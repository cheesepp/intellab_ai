Course Name: Matrix Data Structure Guide
Lesson Name: Program to find transpose of a matrix

Content:

Given a matrix of size n X m, find the transpose of the matrix.

[Transpose of a matrix](
is obtained by changing rows to columns and columns to rows. In other words, transpose of mat[n][m] is obtained by changing mat[i][j] to mat[j][i].


****Example:****

> ![matrix-transpose](


Follow the given steps to solve the problem:


* Run a nested loop using two integer pointers i and j for 0 <= i < n and 0 <= j < m
* Set mat[i][j] equal to mat[j][i]








****Time complexity:****
O(m x n).



****Auxiliary Space:****
O(m x n)


### ****Approach using constant space for Square Matrix****

**This approach works only for square matrices (i.e., – where no. of rows are equal to the number of columns). This algorithm is also known as an “in-place” algorithm as it uses no extra space to solve the problem.**


Follow the given steps to solve the problem:


* Run a nested loop using two integer pointers i and j for 0 <= i < N and i+1 <= j < N
* Swap mat[i][j] with mat[j][i]








****Time complexity:****
O(n

2
).



****Auxiliary Space:****
O(1)


Course Name: Matrix Data Structure Guide
Lesson Name: Search in a Matrix or 2D Array

Content:
Given a matrix

****mat[n][m]****
and an element

****target****
. return true if the target is present in the matrix, else return false.


****Examples:****

> ****Input****
> : mat[][] = { {10, 51, 9},
>
>
>
> {14, 20, 21},
>
>
>
> {30, 24, 43} }
>
>
>
> ****target****
> = 14
>
>
>
> ****Output****
> : Found
>
>
>
>
>
> ****Input****
> : mat[][] = {{31, 5, 9, 11},
>
>
>
> {14, 7, 21, 26},
>
>
>
> {30, 4, 43, 50} }
>
>
>
> ****target****
> = 42
>
>
>
> ****Output****
> : Not Found


We traverse the mat[][] and compare target with every element of the matrix. If matches, then return true If we reach the end we will return false.










****Time Complexity :****
O(n \* m), where n and m are the rows and column of matrix.



****Auxiliary Space :****
O(1)

Course Name: Matrix Data Structure Guide
Lesson Name: Program for subtraction of matrices

Content:
Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].









****Time complexity: O(n****
****2****
****)****


Course Name: Matrix Data Structure Guide
Lesson Name: Traverse a given Matrix using Recursion

Content:
Given a

[matrix](

****mat[][]****
of size

****n x m****
, the task is to traverse this matrix

[using recursion](
.



****Examples:****


> ****Input:****
> mat[][] = [[1, 2, 3],
>
>
>
> [4, 5, 6],
>
>
>
> [7, 8, 9]]
>
>
>
> ****Output:****
> 1 2 3 4 5 6 7 8 9
>
>
>
>
>
> ****Input:****
> mat[][] = [[11, 12, 13],
>
>
>
> [14, 15, 16],
>
>
>
> [17, 18, 19]]
>
>
>
> ****Output:****
> 11 12 13 14 15 16 17 18 19

****Approach:****


* Check If the current position is in the bottom-right corner of the matrix







****Time Complexity:****
O(N \* M)



****Auxiliary Space:****
O(M), because of recursive calling



Course Name: Matrix Data Structure Guide
Lesson Name: Program for addition of two matrices

Content:


Given two

****N****
x

****M matrices****
. Find a

****N****
x

****M****
matrix as the sum of given matrices each value at the sum of values of corresponding elements of the given two matrices.


![](

****Approach:****
Below is the idea to solve the problem.


> Iterate over every cell of matrix (i, j), add the corresponding values of the two matrices and store in a single matrix i.e. the resultant matrix.


Follow the below steps to Implement the idea:


* Initialize a resultant matrix res[N][M].
* Run a for loop for counter

  ****i****
  as each row and in each iteration:
  + Run a for loop for counter

    ****j****
    as each column and in each iteration:
    - Add values of the two matrices for index i, j and store in res[i][j].
* Return res.


Below is the Implementation of above approach.








****Time complexity:****
O(n x m).



****Auxiliary space:****
O(n x m).  since n

2
extra space has been taken for storing results


The program can be extended for rectangular matrices. The following post can be useful for extending this program.

Course Name: Matrix Data Structure Guide
Lesson Name: Print matrix in zig-zag fashion

Content:
****Example:****


> ****Input:****
>
>
> {{1, 2, 3}
>
>
>
> {4, 5, 6}
>
>
>
> {7, 8, 9}}
>
>
>
> ****Output:****
> 1 2 4 7 5 3 6 8 9
>
>
> ****Input :****
> [[1, 2, 3, 4],
>
>
>
> [5, 6, 7, 8],
>
>
>
> [9, 10, 11, 12],
>
>
>
> [13, 14, 15, 16]]
>
>
>
> ****Output::****
> 1 2 5 9 6 3 4 7 10 13 14 11 8 12 15 16


This approach uses a diagonal traversal technique to print the matrix in a zig-zag pattern. It iterates through the matrix diagonally, switching between incrementing the row and column indices based on the current position. This creates a zig-zag path that covers all elements of the matrix.







****Time complexity:****
O(n\*m)



****Auxiliary space:****
O(1), since no extra space has been taken.



Course Name: Matrix Data Structure Guide
Lesson Name: Row-wise vs column-wise traversal of matrix

Content:
Two common ways of traversing a matrix are row-major-order and column-major-order



****Row Major Order:****
When matrix is accessed row by row.



****Column Major Order:****
When matrix is accessed column by column.



****Examples:****

> ****Input :****
> mat[][] = {{1, 2, 3},
>
>
>
> {4, 5, 6},
>
>
>
> {7, 8, 9}}
>
>
> ****Output :****
> Row-wise: 1 2 3 4 5 6 7 8 9
>
>
>
> Col-wise : 1 4 7 2 5 8 3 6 9


In many problems (like

[Search in a Matrix](
), we can use any of the above two, so the question arises which one to use?


If we see according to time complexity, both lead to

****O(n****
****2****
****)****
, but when it comes to cache level one of the orders access will be faster as compare to other one. It depends on the language we are using. Most of the languages including C, C++, Java, Python, C# and JavaScrtipt


store matrix in row major form so while accessing the i+1

th
element after i

th
, most probably it will lead to a hit, which will further reduce the time of program.


The following codes are showing the time difference in row major and column major access.







****Time Complexity:****
O(MAX\*MAX)



****Auxiliary Space:****
O(MAX\*MAX)

Course Name: The Logic Building Problems
Lesson Name: Factorial Coding Problems

Content:

[Factorial](
of a number

****n****
is defined as the product of all the

****positive****
numbers less than n. In other words, Factorial of a number

****n****
can be calculated as:

****n × (n – 1) × (n – 2) × … × 1.****
Factorial of a number n is denoted as

****n!****
. It is widely used in Combinatorics and Algebra to find the number of ways to arrange or select items.


****Examples:****

> ****0!****
> = 1
>
>
> ****1!****
> = 1
>
>
> ****3!****
> = 3 x 2 x 1 = 6


Here is a list of problems based on Factorial.


* [Factorial of a Number](
* [Check Factorial](
* [Factorial of Large number](
* [Count trailing zeroes](
* [Sum of Digits](
* [Double Factorial](
* [Last Non-Zero digit](
* [Check Strong Number](
* [Factorial without Multiplication](
* [Length of factorial](
* [Sum of Factorials till N (1! + 2! + 3! + … + N!)](
* [Smallest number at least n trailing zeroes](
* [Factorial of an Array](
* [K-th Prime Factor](
* [nCr](
* [Ways to go from one point to another](
* [Check Krishnamurthy Number](
* [nCr using Fermat Little Theorem](
* [Ways to arrange K different objects](

> Recommended Links
>
>
> * [Factorial Formula](
> * [Interesting Facts about Factorial](


Course Name: The Logic Building Problems
Lesson Name: Program to find LCM of two numbers

Content:


[****LCM****](
of two numbers is the smallest number which can be divided by both numbers.


> ****Input****
> : a = 12, b = 18
>
>
>
> ****Output****
> : 36
>
>
>
> 36 is the smallest number divisible by both 12 and 18
>
>
> ****Input****
> : a = 5, b = 11
>
>
>
> ****Output****
> : 55
>
>
>
> 55 is the smallest number divisible by both 5 and 11


A

****simple solution****
is to

[find all prime factors](
of both numbers, then find union of all factors present in both

[numbers](
. Finally, return the product of elements in union.


An

****efficient solution****
is based on the below formula for LCM of two numbers ‘a’ and ‘b’.


![relation---------between---------hcf---------and---------lcm_________](
> a x b = LCM(a, b) \* GCD (a, b)
>
>
>
>
>
> LCM(a, b) = (a x b) / GCD(a, b)


We have discussed

[function to find GCD of two numbers](
. Using GCD, we can find LCM.









****Time Complexity:****
O(log(min(a,b))



****Auxiliary Space:****
O(log(min(a,b))







****Time Complexity:****
O(min(a,b))



****Auxiliary Space:****
O(1)


Course Name: The Logic Building Problems
Lesson Name: Prime Number Coding Problems

Content:

[Prime Numbers](
are natural numbers greater than 1 and can be divided by itself and 1 only. For instance, numbers 2, 3, 5, 7, and 11 are the prime numbers since they can only be divided by 1 and themselves, there is no other number that can fully divide them Since it is manually very difficult to check if a number is prime (no direct formula) and find prime factors, problems related to prime become really interesting coding problems.


Here is a list of example problems based on prime.


* [Check for Prime Number](
* [All Prime Factors](
* [Largest Prime Factor](
* [Check for Co-Prime](
* [Primes in an Array](
* [Primes with Given Sum](
* [Pair of Primes with Given Sum and Min Diff](
* [Prime Number Gap](
* [Find the next prime](
* [Check for Strong Prime](
* [Closest Prime](
* [N Digit Numbers with Prime Digits](
* [Sieve of Eratosthenes](
* [Nth Prime Number](
* [Program to print prime numbers from 1 to N.](
* [Segmented Sieve](

Course Name: The Logic Building Problems
Lesson Name: Program to add two fractions

Content:








****Algorithm to add two fractions****





* Find a common denominator by finding the LCM (Least Common Multiple) of the two denominators.
* Change the

  [fractions](
  to have the same denominator and add both terms.
* Reduce the final fraction obtained into its simpler form by dividing both numerator and denominator by their largest common factor.








****Time Complexity:****
O(log(min(a, b)), where a and b are two integers.


****Auxiliary Space:****
O(1), no extra space required so it is a constant.


Course Name: Introduction to DSA II
Lesson Name: Time complexities of different data structures

Content:

[Time Complexity](
is a concept in computer science that deals with the quantification of the amount of time taken by a set of code or

[algorithm](
to process or run as a function of the amount of input. In other words, the time complexity is how long a program takes to process a given input. The efficiency of an algorithm depends on two parameters:


* Time Complexity
* Space Complexity

****Time Complexity:****
It is defined as the number of times a particular instruction set is executed rather than the total time taken. It is because the total time taken also depends on some external factors like the compiler used, the processor’s speed, etc.


****Space Complexity:****
It is the total memory space required by the program for its execution.


### Best case time complexity of different data structures for different operations

### ****Worst Case time complexity of different data structures for different operations****

### ****The average time complexity of different data structures for different operations****

### Related Article on Time and Space Complexity:

* [Time and Space Complexity of Binary Search](
* [Time and Space Complexity of Linear Search](
* [Time and Space Complexity of Ternary Search](
* [Time and Space Complexity of Breadth First Search (BFS)](
* [Time and Space Complexity of Depth First Search (DFS)](
* [Time and Space Complexity of Insertion Sort](
* [Time and Space Complexity of Selection Sort](
* [Time and Space Complexity of Bubble Sort](
* [Time and Space Complexity of Quick Sort](
* [Time and Space Complexity of Merge Sort](
* [Time and Space complexity of Radix Sort Algorithm](
* [Time and Space Complexity of Linked List](
* [Time and Space Complexity of Floyd Warshall Algorithm](
* [Time and Space Complexity of Bellman–Ford Algorithm](
* [Time and Space Complexity of Dijkstra’s Algorithm](
* [Time and Space Complexity Analysis of Prim’s Algorithm](

Course Name: Linked List Data Structure Guide
Lesson Name: Find Length of a Linked List (Iterative and Recursive)

Content:
Given a Singly Linked List, the task is to find the Length of the Linked List.


****Examples:****


> ****Input:****
> LinkedList = 1->3->1->2->1
>
>
>
> ****Output:****
> 5
>
>
> ****Input:****
> LinkedList = 2->4->1->9->5->3->6
>
>
>
> ****Output:****
> 7

Iterative Approach to Find the Length of a Linked List:

> The idea is similar to
>
> [traversal of Linked List](
> with an additional variable
>
>
> to count the number of nodes in the Linked List.


Following is the approach to find the length of the Linked List:


* Initialize count as 0.
* Initialize a node pointer, curr = head.
* Do following while curr is not NULL
  + curr = curr -> next
  + Increment count by 1.
* Return count.








****Time complexity:****
O(N), Where

****N****
is the size of the linked list



****Auxiliary Space:****
O(1), As constant extra space is used.


Recursive Approach to Find the Length of a Linked List:

> The idea is to use
>
> [recursion](
> by maintaining a function, say
>
> ****countNodes(node)****
> which takes a node as an argument and calls itself with the next node until we reach the end of the Linked List. Each of the recursive call returns
>
> ****1 + count of remaining nodes****
> .








****Time Complexity:****
O(N), where

****N****
is the length of Linked List.



****Auxiliary Space:****
O(N), Extra space is used in the recursion call stack.

Course Name: The Logic Building Problems
Lesson Name: Program to print multiplication table of a number

Content:
Given a number

****n****
, we need to print its table.


****Examples :****


> ****Input****
> : 5
>
>
>
> ****Output****
> :
>
>
>
> 5 \* 1 = 5
>
>
>
> 5 \* 2 = 10
>
>
>
> 5 \* 3 = 15
>
>
>
> 5 \* 4 = 20
>
>
>
> 5 \* 5 = 25
>
>
>
> 5 \* 6 = 30
>
>
>
> 5 \* 7 = 35
>
>
>
> 5 \* 8 = 40
>
>
>
> 5 \* 9 = 45
>
>
>
> 5 \* 10 = 50

Table of Content

* [Iterative Approach – O(1) Time and O(1) Space](#using-a-loop-o1-time-and-o1-space)
* [Recursive Approach – O(1) Time and O(1) Space](#using-recursion-o1-space-and-o1-time)
### Iterative Approach – O(1) Time and O(1) Space






### ****Recursive Approach – O(1) Time and O(1) Space****







****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1), since the recursion stack will only go up to 10.



Course Name: Linked List Data Structure Guide
Lesson Name: Program to find size of Doubly Linked List

Content:
Given a

[doubly linked list](
, The task is to find the

****number of nodes in****
the given doubly linked list.


Example:


> ****Input****
> : 1<->2<->3<->4
>
>
>
> ****output****
> : 4
>
>
> ****Input****
> : 1<->2
>
>
>
> ****output****
> : 2

### By Traversing the Doubly linked list – O(n) Time and O(1) Space

> The idea is to traverse the doubly linked list starting from the
>
> ****head****
> node. Increment the
>
> ****size****
> variable until we reaches end.


Algorithm :


* Initialize a variable

  ****size****
  to 0
* Initialize a

  ****curr****
  node to

  ****head****
* Do the following while the

  ****curr node****
  is not NULL
  + ****curr = curr -> next****
  + ****size++;****
* Return

  ****size****
  .








****Time Complexity: O(n),****
where n is the number of nodes in the linked list.



****Auxiliary Space:****

****O(1)****

Course Name: The Logic Building Problems
Lesson Name: Perfect Number

Content:





Recommended Practice

[Perfect Number](


[Try It!](


A

****Simple Solution****
is to go through every number from 1 to n-1 and check if it is a divisor. Maintain sum of all divisors. If sum becomes equal to n, then return true, else return false.



An

****Efficient Solution****
is to go through numbers till square root of n. If a number ‘i’ divides n, then add both ‘i’ and n/i to sum.



Below is the implementation of efficient solution.








****Time Complexity:****
O(log(n))



Course Name: The Logic Building Problems
Lesson Name: Program to find simple interest

Content:
Given Principal

****p****
, Rate

****r****
and Time

****t,****
the task is to calculate Simple Interest.


****Examples :****

> ****Input****
> : p = 10000, r = 5, t = 5
>
>
>
> ****Output****
> :2500
>
>
>
> ****Explanation****
> : We need to find simple interest on Rs. 10,000 at the rate of 5% for 5 units of time.
>
>
> ****Input****
> : p = 3000, r = 7, t = 1
>
>
>
> ****Output****
> :210


The basic idea is to calculate by applying the formula

****SI = (p x t x r)/100****








****Time complexity****
: O(1)



****Auxiliary Space****
: O(1)


Course Name: The Logic Building Problems
Lesson Name: Find the number closest to n and divisible by m

Content:

Given two integers

****n****
and

****m (m != 0)****
. Find the number closest to

****n****
and divisible by

****m****
. If there is more than one such number, then output the one having maximum absolute value.


****Examples:****


> Input: n = 13, m = 4
>
>
>
> Output: 12
>
>
>
> Explanation: 12 is the closest to 13, divisible by 4.
>
>
> Input: n = -15, m = 6
>
>
>
> Output: -18
>
>
>
> Explanation: Both -12 and -18 are closest to -15, but-18 has the maximum absolute value.

Table of Content

* [[Naive Approach] – O(m) Time and O(1) Space](#naive-approach-om-time-and-o1-space)
* [[Expected Approach] By finding Quotient – O(1) Time and O(1) Space](#expected-approach-by-finding-quotient-o1-time-and-o1-space)
### [Naive Approach] – O(m) Time and O(1) Space

> The basic idea is to start checking from n – m to n + m one by one and tack the closest number.







### [Expected Approach] By finding Quotient – O(1) Time and O(1) Space

> We find the value of n/m. Then we find closest of two possibilities. One is q \* m other is (m \* (q + 1)) or (m \* (q – 1)) depending on whether one of the given two numbers is negative or not.








****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1)




Course Name: The Logic Building Problems
Lesson Name: Find Recurring Sequence in a Fraction

Content:

Given a fraction, find a recurring sequence of digits if it exists, otherwise, print “No recurring sequence”.

// C++ program to find repeating
// sequence in a fraction
#include <bits/stdc++.h>
using namespace std;

// This function returns repeating sequence of
// a fraction.  If repeating sequence doesn't
// exist, then returns empty string
string fractionToDecimal( int numr, int denr)
{
string res; // Initialize result

// Create a map to store already
// seen remainders, remainder is used
// as key and its position in
// result is stored as value.
// Note that we need
// position for cases like 1/6.
// In this case,the recurring sequence
// doesn't start from first
// remainder.
map< int , int > mp;
mp.clear();

// Find first remainder
int rem = numr % denr;

// Keep finding remainder until either remainder
// becomes 0 or repeats
while ((rem != 0)
&& (mp.find(rem) == mp.end()))
{
// Store this remainder
mp[rem] = res.length();

// Multiply remainder with 10
rem = rem * 10;

// Append rem / denr to result
int res_part = rem / denr;
res += to_string(res_part);

// Update remainder
rem = rem % denr;
}

return (rem == 0) ? "" : res.substr(mp[rem]);
}

// Driver code
int main()
{
int numr = 50, denr = 22;
string res = fractionToDecimal(numr, denr);
if (res == "" )
cout << "No recurring sequence" ;
else
cout << "Recurring sequence is " << res;
return 0;
}
```






**Time Complexity : O(N)**

**Auxiliary Space : O(N) ,**
                                                                                                                                        as we use map as extra space.
                                                                                                                                        

Course Name: Introduction to DSA II
Lesson Name: Introduction to Pattern Searching – Data Structure and Algorithm Tutorial

Content:
Features of Pattern Searching Algorithm:

* Pattern searching algorithms should recognize familiar patterns quickly and accurately.
* Recognize and classify unfamiliar patterns.
* Identify patterns even when partly hidden.
* Recognize patterns quickly with ease, and with automaticity.

[Naive Pattern Searching algorithm](


Naive pattern searching is the simplest method among other pattern-searching algorithms. It checks for all characters of the main string to the pattern. This algorithm is helpful for smaller texts. It does not need any pre-processing phases. We can find the substring by checking once for the string. It also does not occupy extra space to perform the operation.


![Compare text characters with pattern characters](

Compare text characters with pattern characters


The time complexity of Naive Pattern Search method is O(m\*n). The m is the size of pattern and n is the size of the main string.







****Time Complexity:****
O(N\*M)



****Auxiliary Space:****
O(1)


[KMP algorithm](


KMP algorithm is used to find a “Pattern” in a “Text”. This algorithm compares character by character from left to right. But whenever a mismatch occurs, it uses a preprocessed table called “Prefix Table” to skip characters comparison while matching. Sometimes prefix table is also known as LPS Table. Here LPS stands for “Longest proper Prefix which is also Suffix”.


### How to use LPS Table


We use the LPS table to decide how many characters are to be skipped for comparison when a mismatch has occurred.



When a mismatch occurs, check the LPS value of the previous character of the mismatched character in the pattern. If it is ‘0’ then start comparing the first character of the pattern with the next character to the mismatched character in the text. If it is not ‘0’ then start comparing the character which is at an index value equal to the LPS value of the previous character to the mismatched character in pattern with the mismatched character in the Text.







![Example of KMP algorithm](

Example of KMP algorithm


![Compare first character of pattern with first character of text from left to right](

Compare first character of pattern with first character of text from left to right


![Compare first character of pattern with next character of text](

Compare first character of pattern with next character of text


![Compare pattern[0] and pattern[1] values](

Compare pattern[0] and pattern[1] values


![Compare pattern[0] with next characters in text.](

Compare pattern[0] with next characters in text.


![Compare pattern[2] with mismatched characters in text.](

Compare pattern[2] with mismatched characters in text.

### How the KMP Algorithm Works


Let’s take a look on working example of KMP Algorithm to find a Pattern in a Text.



![LPS table](

LPS table


![Define variables](

Define variables


![Compare A with B](

Compare A with B


![Compare A with C](

Compare A with C


![Compare A with D](

Compare A with D


![Compare A with A](

Compare A with A


![Compare B with B](

Compare B with B


![Compare C with D](

Compare C with D


![Compare A with D](







****Time complexity:****
O(n + m)



****Auxiliary Space:****
O(M)


[Rabin Karp algorithm](
:


Rabin-Karp algorithm is an algorithm used for searching/matching patterns in the text using a hash function. Unlike Naive string-matching algorithm, it does not travel through every character in the initial phase rather it filters the characters that do not match and then perform the comparison.


Rabin-Karp compares a string’s hash values, rather than the strings themselves. For efficiency, the hash value of the next position in the text is easily computed from the hash value of the current position.


### Working of Rabin-Karp algorithm

* Initially calculate the hash value of the pattern P.
* Start iterating from the start of the string:
  + Calculate the hash value of the current substring having length m.
  + If the hash value of the current substring and the pattern are same check if the substring is same as the pattern.
  + If they are same, store the starting index as a valid answer. Otherwise, continue for the next substrings.
* Return the starting indices as the required answer.

![Example of Rabin Karp](

Example of Rabin Karp


Below is the implementation of the Rabin-Karp algorithm.







****Time Complexity:****

* The average and best-case running time of the Rabin-Karp algorithm is O(n+m), but its worst-case time is O(nm).
* The worst case of the Rabin-Karp algorithm occurs when all characters of pattern and text are the same as the hash values of all the substrings of txt[] match with the hash value of pat[].

****Space Complexity :****


The space complexity of the Rabin-Karp algorithm is O(1), which means that it is a constant amount of memory that is required, regardless of the size of the input text and pattern. This is because the algorithm only needs to store a few variables that are updated as the algorithm progresses through the text and pattern. Specifically, the algorithm needs to store the hash value of the pattern, the hash value of the current window in the text, and a few loop counters and temporary variables. Since the size of these variables is fixed, the space complexity is constant.


[Z algorithm](
:


This algorithm finds all occurrences of a pattern in a text in linear time. Let length of text be n and of pattern be m, then total time taken is O(m + n) with linear space complexity. Z algorithm works by maintaining an auxiliary array called the Z array. This Z array stores the length of the longest substring, starting from the current index, that also it’s prefix.


### What is Z Array?


For a string str[0..n-1], Z array is of same length as string. An element Z[i] of Z array stores length of the longest substring starting from str[i] which is also a prefix of str[0..n-1]. The first entry of Z array is meaning less as complete string is always prefix of itself.


****Example:****

> Index            0   1   2   3   4   5   6   7   8   9  10  11
>
>
>
> Text             a   a   b   c   a   a   b   x   a   a   a   z
>
>
>
> Z values         X   1   0   0   3   1   0   0   2   2   1   0

### How to construct Z array?


A Simple Solution is to run two nested loops, the outer loop goes to every index and the inner loop finds length of the longest prefix that matches the substring starting at current index. The time complexity of this solution is O(n2).


We can construct Z array in linear time. The idea is to maintain an interval [L, R] which is the interval with max R



such that [L, R] is prefix substring (substring which is also a prefix.


****Steps for maintaining this interval are as follows –****

> 1. If
>
>    ****i > R****
>    then there is no prefix substring that starts before i and ends after i, so we reset L and R and compute new [L, R] by comparing
>
>    ****str[0..]****
>    to
>
>    ****str[i..]****
>    and get
>
>    ****Z[i] (= R-L+1)****
>    .
> 2. If
>
>    ****i <= R****
>    then let
>
>    ****K = i-L****
>    ,  now
>
>    ****Z[i] >= min(Z[K], R-i+1)****
>    because str[i..] matches with
>
>    ****str[K..]****
>    for atleast
>
>    ****R-i+1****
>    characters (they are in[L, R] interval which we know is a prefix substring).
>
>
>
>    Now two sub cases arise:
>    * If
>
>      ****Z[K] < R-i+1****
>      then there is no prefix substring starting at str[i] (otherwise
>
>      ****Z[K]****
>      would be larger)  so  Z[i] = Z[K]and interval [L, R] remains same.
>    * If
>
>      ****Z[K] >= R-i+1****
>      then it is possible to extend the [L, R] interval thus we will set L as i and start matching from
>
>      ****str[R]****
>      onwards  and get new R then we will update interval [L, R] and calculate
>
>      ****Z[i] (=R-L+1)****
>      .

![Construction of Z array](







****Time Complexity:****
O(m+n), where m is length of pattern and n is length of text.



****Auxiliary Space:****
O(m+n)


[Aho-Corasick algorithm](
:

****Aho-Corasick Algorithm****
finds all words in O(n + m + z) time where z is the total number of occurrences of words in text. The Aho–Corasick string matching algorithm formed the basis of the original Unix command

****“fgrep”****
.


****Preprocessing:****
Build an automaton of all words in arr[] The automaton has mainly three functions:


> ****Go To:****
> This function simply follows edges of Trie of all words in arr[].
>
>
>
> It is represented as 2D array g[][] where we store next state for current state and character.
>
>
> ****Failure:****
> This function stores all edges that are followed when current character doesn’t have edge in Trie.
>
>
>
> It is represented as1D array f[] where we store next state for current state.
>
>
> ****Output:****
> Stores indexes of all words that end at current state.
>
>
>
> It is represented as 1D  array o[] where we store indices of all matching words as a bitmap for current state.

****Matching:****
Traverse the given text over built automaton to find all matching words.



Preprocessing:


### ****Illustration of Aho-Corasick algorithm****

****Preprocessing:****
We first Build a Trie (or Keyword Tree) of all words.


![ Build a Trie (or Keyword Tree) of all words.](

Build a Trie (or Keyword Tree) of all words.

* This part fills entries in goto g[][] and output o[].
* Next, we extend Trie into an automaton to support linear time matching.

![ills entries in goto g[][] and output o[]](

Fills entries in goto g[][] and output o[]

* This part fills entries in failure f[] and output o[].

****Go to:****
We build Trie. And for all characters which don’t have an edge at the root, we add an edge back to root.



****Failure:****
For a state s, we find the longest proper suffix which is a proper prefix of some pattern. This is done using Breadth First Traversal of Trie.



****Output:****
For a state s, indexes of all words ending at s are stored. These indexes are stored as bitwise map (by doing bitwise OR of values). This is also computing using Breadth First Traversal with Failure.


Below is the implementation of the Aho-Corasick Algorithm:






****Time Complexity:****
O(n + l + z), where ‘n’ is the length of the text, ‘l’ is the length of keywords, and ‘z’ is the number of matches.



****Auxiliary Space:****
O(l \* q), where ‘q’ is the length of the alphabet since that is the maximum number of children a node can have.

Course Name: The Logic Building Problems
Lesson Name: Program to find area of a circle

Content:

Given the radius of a circle, find the area of that circle.


![Area-of-circle](
> The area of a circle can simply be evaluated using the following formula.
>
>
> [Tex]Area = \pi r^2[/Tex]
>
>
> where r is radius of circle and it maybe in float because value of pie is 3.14

****Approach****
: Using the given radius, find the area using the above formula: (pi \* r \* r) and print the result in float.









****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1), since no extra space has been taken.


Course Name: The Logic Building Problems
Lesson Name: Check whether a given number is even or odd

Content:
Given a number

****n****
, check whether it is even or odd. Return

****true****
for even and

****false****
for odd.


****Examples:****


> ****Input****
> : 2
>
>
>
> ****Output****
> : true
>
>
> ****Input****
> : 5
>
>
>
> ****Output****
> : false

Table of Content

* [By Finding the Remainder – O(1) Time and O(1) Space](#by-finding-the-reminder-o1-time-and-o1-space)
* [Using Bitwise AND Operator – O(1) Time and O(1) Space](#using-bitwaise-operators-o1-time-and-o1-space)
* [Using Bitwise Shift Operators – O(1) Time and O(1) Space](#using-bitwaise-shift-operators-o1-time-and-o1-space)
### By Finding the Remainder – O(1) Time and O(1) Space


We can check the remainder when divided by 2. If the remainder is 0, the number is even; otherwise, it is odd






### Using Bitwise AND Operator – O(1) Time and O(1) Space

> The last bit of all odd numbers is always 1, while for even numbers it’s 0. So, when performing bitwise AND operation with 1, odd numbers give 1, and even numbers give 0.
>
>
> Ex: 5 (101) -> 101
>
>
>
> & 001
>
>
>
> —-
>
>
>
> 001 , so this we can say it is an odd number.








****Time Complexity: O(1)****


****Auxiliary Space: O(1)****

### Using Bitwise Shift Operators – O(1) Time and O(1) Space

![](
C++








Course Name: Matrix Data Structure Guide
Lesson Name: Program to find Determinant of a Matrix

Content:

****Determinant of 2 x 2 Matrix:****

![](

Determinant of 2 x 2 matrix

****Determinant of 3 x 3 Matrix:****

![](

Determinant of 3 x 3 matrix

****How to calculate?****


The value of the determinant of a matrix can be calculated by the following procedure:


* For each element of the first row or first column get the cofactor of those elements.
* Then multiply the element with the determinant of the corresponding cofactor.
* Finally, add them with alternate signs. As a base case, the value of the determinant of a 1\*1 matrix is the single value itself.


The

****cofactor****
of an element is a matrix that we can get by removing the row and column of that element from that matrix.








****Time Complexity:****
O(n

4
)



****Space Complexity:****
O(n

2
), Auxiliary space used for storing cofactors.


****Note:****
In the above recursive approach when the size of the matrix is large it consumes more stack size.


Determinant of a Matrix using Determinant properties:


We calculates the determinant of an

`N x N`
matrix using Gaussian elimination and a series of transformations that reduce the matrix to upper triangular form.



> * Converting the given matrix into an
>
>   ****upper triangular matrix****
>   using determinant properties
> * The determinant of the upper triangular matrix is the product of all diagonal elements.
> * Iterating every diagonal element and making all the elements down the diagonal as zero using determinant properties
> * If the diagonal element is zero then search for the next non-zero element in the same column.


There exist two cases:


* ****Case 1:****
  If there is no non-zero element. In this case, the determinant of a matrix is zero
* ****Case 2:****
  If there exists a non-zero element there exist two cases
  + ****Case A:****
    If the index is with a respective diagonal row element. Using the determinant properties make all the column elements down to it zero
  + ****Case B:****
    Swap the row with respect to the diagonal element column and continue the

    ****Case A****
    operation.







****Time complexity:****
O(n

3
)



****Auxiliary Space:****
O(n), Space used for storing row.





****Determinant of a Matrix****


There is a built-in function or method in

****linalg****
module of

****NumPy****
package in python. It can be called

****numpy.linalg.det(mat)****
which returns the determinant value of the matrix mat passed in the argument.



****Time Complexity:****
O(n

3
), as the time complexity of np.linalg.det is O(n

3
) for an n x n order matrix.



****Auxiliary Space:****
O(1)


Course Name: The Logic Building Problems
Lesson Name: Check if a number is a power of another number

Content:

Given two positive numbers x and y, check if y is a power of x or not.


**Examples :**

> **Input:**
> x = 10, y = 1
>
>
> **Output:**
> True
>
>
> x^0 = 1
>
> **Input:**
> x = 10, y = 1000
>
>
> **Output:**
> True
>
>
> x^3 = 1
>
> **Input:**
> x = 10, y = 1001
>
>
> **Output:**
> False

Recommended Practice

[Check if a number is power of another number](


[Try It!](


A simple solution is to repeatedly compute the powers of x. If a power becomes equal to y, then y is a power, else not.








**Time complexity:**
O(Log
x
y)


**Auxiliary space:**
O(1)

**Optimization:**


We can optimize above solution to work in O(Log Log y). The idea is to do squaring of power instead of multiplying it with x, i.e., compare y with x^2, x^4, x^8, …etc. If x becomes equal to y, return true. If x becomes more than y, then we do binary search for power of x between previous power and current power, i.e., between x^i and x^(i/2).


Following are detailed step.


**Alternate Solution :**


The idea is to take log of y in base x. If it turns out to be an integer, we return true. Else false.








**Time complexity**
: O(log Y)


**Auxiliary space**
: O(1)

Course Name: Matrix Data Structure Guide
Lesson Name: Adjoint and Inverse of a Matrix

Content:
Given a square matrix, find the adjoint and

[inverse](
of the matrix. We strongly recommend you to refer

[determinant of matrix](
as a prerequisite for this.


****Adjoint****
(or Adjugate) of a matrix is the matrix obtained by taking the transpose of the cofactor matrix of a given square matrix is called its Adjoint or Adjugate matrix. The Adjoint of any square matrix ‘A’ (say) is represented as Adj(A).


****Important properties:****


Product of a square matrix A with its adjoint yields a diagonal matrix, where each diagonal entry is equal to determinant of A.



i.e.



A non-zero square matrix ‘A’ of order n is said to be

****invertible****
if there exists a unique square matrix ‘B’ of order n such that,

Let A[N][N] be input matrix.
1) Create a matrix adj[N][N] store the adjoint matrix.
2) For every entry A[i][j] in input matrix where 0 <= i < N
                                             and 0 <= j < N.
    a) Find cofactor of A[i][j]
    b) Find sign of entry.  Sign is + if (i+j) is even else
    sign is odd.
    c) Place the cofactor at adj[j][i]
    ```

    ****How to find Inverse?****


    Inverse of a matrix exists only if the matrix is non-singular i.e., determinant should not be 0.



    Using determinant and adjoint, we can easily find the inverse of a square matrix using the below formula,


    ```
    If det(A) != 0
    A-1 = adj(A)/det(A)
    Else
    "Inverse doesn't exist"
    ```


    Inverse is used to find the solution to a system of linear equations.


    Below are implementations for finding adjoint and inverse of a matrix.


    C++

    ````
    #include <iostream>
    #include <vector>
    using namespace std;

    // Function to get cofactor of mat[p][q] in cof[][]. n is
    // current dimension of mat[][]
    void getCof(vector<vector<int>>& mat, vector<vector<int>>& cof,
                                            int p, int q, int n) {
        int i = 0, j = 0;
        for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
                if (row != p && col != q) {
                    cof[i][j++] = mat[row][col];
                    if (j == n - 1) {
                        j = 0;
                        i++;
                    }
                }
            }
        }
    }

    // Recursive function for finding determinant
    // of matrix mat of dimension n
    int getDet(vector<vector<int>>& mat, int n) {
        if (n == 1) return mat[0][0];

        int det = 0;

        // To store cofactors
        vector<vector<int>> cof(mat.size(), vector<int>(mat.size()));

        int sign = 1;
        for (int f = 0; f < n; f++) {
            getCof(mat, cof, 0, f, n);
            det += sign * mat[0][f] * getDet(cof, n - 1);
            sign = -sign;
        }
        return det;
    }

    // Function to get adjoint of mat in adj
    void adjoint(vector<vector<int>>& mat, vector<vector<int>>& adj) {
        int n = mat.size();
        if (n == 1) {
            adj[0][0] = 1;
            return;
        }

        int sign = 1;
        vector<vector<int>> cof(n, vector<int>(n));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                getCof(mat, cof, i, j, n);
                sign = ((i + j) % 2 == 0) ? 1 : -1;
                adj[j][i] = sign * getDet(cof, n - 1);
            }
        }
    }

    // Function to calculate and store inverse, returns
    // false if matrix is singular
    bool inverse(vector<vector<int>>& mat, vector<vector<float>>& inv) {
        int n = mat.size();
        int det = getDet(mat, n);
        if (det == 0) {
            cout << "Singular matrix, can't find its inverse";
            return false;
        }

        vector<vector<int>> adj(n, vector<int>(n));
        adjoint(mat, adj);

        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                inv[i][j] = adj[i][j] / float(det);

        return true;
    }

    int main() {
        vector<vector<int>> mat = { { 5, -2, 2, 7 },
                                    { 1, 0, 0, 3 },
                                    { -3, 1, 5, 0 },
                                    { 3, -1, -9, 4 } };

        int n = mat.size();
        vector<vector<int>> adj(n, vector<int>(n)); // To store adjoint
        vector<vector<float>> inv(n, vector<float>(n)); // To store inverse

        // Print the input matrix
        cout << "Input matrix is:\n";
        for (auto& row : mat) {
            for (int val : row) cout << val << " ";
            cout << endl;
        }

        // Print the adjoint matrix
        cout << "\nThe Adjoint is:\n";
        adjoint(mat, adj);
        for (auto& row : adj) {
            for (int val : row) cout << val << " ";
            cout << endl;
        }

        // Print the inverse matrix if it exists
        cout << "\nThe Inverse is:\n";
        if (inverse(mat, inv)) {
            for (auto& row : inv) {
                for (float val : row) cout << val << " ";
                cout << endl;
            }
        }

        return 0;
    }

    ````

    C

    ````
    #include <stdio.h>

    #define N 4

    // Function to get cofactor of mat[p][q] in cof[][]. n is
    // current dimension of mat[][]
    void getCof(int mat[N][N], int cof[N][N], int p, int q, int n) {
        int i = 0, j = 0;
        for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
                if (row != p && col != q) {
                    cof[i][j++] = mat[row][col];
                    if (j == n - 1) {
                        j = 0;
                        i++;
                    }
                }
            }
        }
    }

    // Recursive function for finding determinant of matrix mat of dimension n
    int getDet(int mat[N][N], int n) {
        if (n == 1) return mat[0][0];
        int det = 0;

        int cof[N][N];
        int sign = 1;
        for (int f = 0; f < n; f++) {
            getCof(mat, cof, 0, f, n);
            det += sign * mat[0][f] * getDet(cof, n - 1);
            sign = -sign;
        }
        return det;
    }

    // Function to get adjoint of mat in adj
    void adjoint(int mat[N][N], double adj[N][N]) {
        if (N == 1) {
            adj[0][0] = 1;
            return;
        }

        int sign = 1;
        int cof[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                getCof(mat, cof, i, j, N);
                sign = ((i + j) % 2 == 0) ? 1 : -1;
                adj[j][i] = sign * getDet(cof, N - 1);
            }
        }
    }

    // Function to calculate and store inverse, returns 0 if matrix is singular
    int inverse(int mat[N][N], double inv[N][N]) {
        int det = getDet(mat, N);
        if (det == 0) {
            printf("Singular matrix, can't find its inverse\n");
            return 0;
        }

        double adj[N][N];
        adjoint(mat, adj);

        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
                inv[i][j] = adj[i][j] / det;

        return 1;
    }

    int main() {
        int mat[N][N] = { { 5, -2, 2, 7 },
                          { 1, 0, 0, 3 },
                          { -3, 1, 5, 0 },
                          { 3, -1, -9, 4 } };

        double adj[N][N];
        double inv[N][N];

        // Print the input matrix
        printf("Input matrix is:\n");
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                printf("%d ", mat[i][j]);
            }
            printf("\n");
        }

        // Print the adjoint matrix
        printf("\nThe Adjoint is:\n");
        adjoint(mat, adj);
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                printf("%lf ", adj[i][j]);
            }
            printf("\n");
        }

        // Print the inverse matrix if it exists
        printf("\nThe Inverse is:\n");
        if (inverse(mat, inv)) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    printf("%lf ", inv[i][j]);
                }
                printf("\n");
            }
        }
        return 0;
    }

    ````

    Java

    ````
    // Importing required classes
    import java.util.Arrays;
    import java.util.Scanner;

    public class GfG {

        // Function to get cofactor of mat[p][q] in cof[][]
        static void getCof(int[][] mat, int[][] cof, int p, int q, int n) {
            int i = 0, j = 0;
            for (int row = 0; row < n; row++) {
                for (int col = 0; col < n; col++) {
                    if (row != p && col != q) {
                        cof[i][j++] = mat[row][col];
                        if (j == n - 1) {
                            j = 0;
                            i++;
                        }
                    }
                }
            }
        }

        // Recursive function for finding determinant of
        // matrix mat of dimension n
        static int getDet(int[][] mat, int n) {
            if (n == 1) return mat[0][0];
            int det = 0;
            int[][] cof = new int[n][n];
            int sign = 1;
            for (int f = 0; f < n; f++) {
                getCof(mat, cof, 0, f, n);
                det += sign * mat[0][f] * getDet(cof, n - 1);
                sign = -sign;
            }
            return det;
        }

        // Function to get adjoint of mat in adj
        static void adjoint(int[][] mat, int[][] adj) {
            int n = mat.length;
            if (n == 1) {
                adj[0][0] = 1;
                return;
            }
            int sign;
            int[][] cof = new int[n][n];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    getCof(mat, cof, i, j, n);
                    sign = ((i + j) % 2 == 0) ? 1 : -1;
                    adj[j][i] = sign * getDet(cof, n - 1);
                }
            }
        }

        // Function to calculate and store inverse, returns
        // false if matrix is singular
        static boolean inverse(int[][] mat, float[][] inv) {
            int n = mat.length;
            int det = getDet(mat, n);
            if (det == 0) {
                System.out.println("Singular matrix, can't find its inverse");
                return false;
            }
            int[][] adj = new int[n][n];
            adjoint(mat, adj);
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    inv[i][j] = (float) adj[i][j] / det;
            return true;
        }

        public static void main(String[] args) {
            int[][] mat = { { 5, -2, 2, 7 }, { 1, 0, 0, 3 },
                            { -3, 1, 5, 0 }, { 3, -1, -9, 4 } };
            int n = mat.length;
            int[][] adj = new int[n][n]; // To store adjoint
            float[][] inv = new float[n][n]; // To store inverse

            // Print the input matrix
            System.out.println("Input matrix is:");
            for (int[] row : mat) {
                System.out.println(Arrays.toString(row));
            }

            // Print the adjoint matrix
            System.out.println("\nThe Adjoint is:");
            adjoint(mat, adj);
            for (int[] row : adj) {
                System.out.println(Arrays.toString(row));
            }

            // Print the inverse matrix if it exists
            System.out.println("\nThe Inverse is:");
            if (inverse(mat, inv)) {
                for (float[] row : inv) {
                    System.out.println(Arrays.toString(row));
                }
            }
        }
    }

    ````

    Python

    ````
    # Function to get cofactor of mat[p][q] in cof[][]
    def get_cof(mat, cof, p, q, n):
        i = 0
        j = 0
        for row in range(n):
            for col in range(n):
                if row != p and col != q:
                    cof[i][j] = mat[row][col]
                    j += 1
                    if j == n - 1:
                        j = 0
                        i += 1

    # Recursive function for finding determinant
    # of matrix mat of dimension n
    def get_det(mat, n):
        if n == 1:
            return mat[0][0]
        det = 0
        cof = [[0] * n for _ in range(n)]  # To store cofactors
        sign = 1
        for f in range(n):
            get_cof(mat, cof, 0, f, n)
            det += sign * mat[0][f] * get_det(cof, n - 1)
            sign = -sign
        return det

    # Function to get adjoint of mat in adj
    def adjoint(mat, adj):
        n = len(mat)
        if n == 1:
            adj[0][0] = 1
            return
        sign = 1
        cof = [[0] * n for _ in range(n)]
        for i in range(n):
            for j in range(n):
                get_cof(mat, cof, i, j, n)
                sign = 1 if (i + j) % 2 == 0 else -1
                adj[j][i] = sign * get_det(cof, n - 1)

    # Function to calculate and store inverse, returns
    # false if matrix is singular
    def inverse(mat):
        n = len(mat)
        det = get_det(mat, n)
        if det == 0:
            print("Singular matrix, can't find its inverse")
            return None
        adj = [[0] * n for _ in range(n)]
        adjoint(mat, adj)
        inv = [[adj[i][j] / det for j in range(n)] for i in range(n)]
        return inv

    if __name__ == '__main__':
        mat = [[5, -2, 2, 7], [1, 0, 0, 3], [-3, 1, 5, 0], [3, -1, -9, 4]]
        n = len(mat)
        adj = [[0] * n for _ in range(n)]  # To store adjoint

        # Print the input matrix
        print("Input matrix is:")
        for row in mat:
            print(row)

        # Print the adjoint matrix
        print("\nThe Adjoint is:")
        adjoint(mat, adj)
        for row in adj:
            print(row)

        # Print the inverse matrix if it exists
        print("\nThe Inverse is:")
        inv = inverse(mat)
        if inv:
            for row in inv:
                print(row)

    ````

    C#

    ````
    using System;

    class MatrixOperations {

        // Function to get cofactor of mat[p][q] in cof[][]. n is
        // current dimension of mat[][]
        static void GetCof(int[,] mat, int[,] cof, int p, int q, int n) {
            int i = 0, j = 0;
            for (int row = 0; row < n; row++) {
                for (int col = 0; col < n; col++) {
                    if (row != p && col != q) {
                        cof[i, j++] = mat[row, col];
                        if (j == n - 1) {
                            j = 0;
                            i++;
                        }
                    }
                }
            }
        }

        // Recursive function for finding determinant of matrix mat of dimension n
        static int GetDet(int[,] mat, int n) {
            if (n == 1) return mat[0, 0];
            int det = 0;

            // To store cofactors
            int[,] cof = new int[n, n];

            int sign = 1;
            for (int f = 0; f < n; f++) {
                GetCof(mat, cof, 0, f, n);
                det += sign * mat[0, f] * GetDet(cof, n - 1);
                sign = -sign;
            }
            return det;
        }

        // Function to get adjoint of mat in adj
        static void Adjoint(int[,] mat, double[,] adj) {
            int n = mat.GetLength(0);
            if (n == 1) {
                adj[0, 0] = 1;
                return;
            }

            int sign = 1;
            int[,] cof = new int[n, n];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    GetCof(mat, cof, i, j, n);
                    sign = ((i + j) % 2 == 0) ? 1 : -1;
                    adj[j, i] = sign * GetDet(cof, n - 1);
                }
            }
        }

        // Function to calculate and store inverse, returns false if matrix is singular
        static bool Inverse(int[,] mat, double[,] inv) {
            int n = mat.GetLength(0);
            int det = GetDet(mat, n);
            if (det == 0) {
                Console.WriteLine("Singular matrix, can't find its inverse");
                return false;
            }

            double[,] adj = new double[n, n];
            Adjoint(mat, adj);

            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    inv[i, j] = adj[i, j] / det;

            return true;
        }

        static void Main() {
            int[,] mat = new int[,] { { 5, -2, 2, 7 },
                                       { 1, 0, 0, 3 },
                                       { -3, 1, 5, 0 },
                                       { 3, -1, -9, 4 } };
            int n = mat.GetLength(0);
            double[,] adj = new double[n, n]; // To store adjoint
            double[,] inv = new double[n, n]; // To store inverse

            // Print the input matrix
            Console.WriteLine("Input matrix is:");
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    Console.Write(mat[i, j] + " ");
                }
                Console.WriteLine();
            }

            // Print the adjoint matrix
            Console.WriteLine("\nThe Adjoint is:");
            Adjoint(mat, adj);
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    Console.Write(adj[i, j] + " ");
                }
                Console.WriteLine();
            }

            // Print the inverse matrix if it exists
            Console.WriteLine("\nThe Inverse is:");
            if (Inverse(mat, inv)) {
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        Console.Write(inv[i, j] + " ");
                    }
                    Console.WriteLine();
                }
            }
        }
    }

    ````

    JavaScript

    ````
    // Function to get cofactor of mat[p][q] in cof[][]. n is
    // current dimension of mat[][]
    function getCof(mat, cof, p, q, n) {
        let i = 0, j = 0;
        for (let row = 0; row < n; row++) {
            for (let col = 0; col < n; col++) {
                if (row !== p && col !== q) {
                    cof[i][j++] = mat[row][col];
                    if (j === n - 1) {
                        j = 0;
                        i++;
                    }
                }
            }
        }
    }

    // Recursive function for finding determinant
    // of matrix mat of dimension n
    function getDet(mat, n) {
        if (n === 1) return mat[0][0];
        let det = 0;

        // To store cofactors
        let cof = Array.from({ length: mat.length }, () => Array(mat.length).fill(0));

        let sign = 1;
        for (let f = 0; f < n; f++) {
            getCof(mat, cof, 0, f, n);
            det += sign * mat[0][f] * getDet(cof, n - 1);
            sign = -sign;
        }
        return det;
    }

    // Function to get adjoint of mat in adj
    function adjoint(mat, adj) {
        let n = mat.length;
        if (n === 1) {
            adj[0][0] = 1;
            return;
        }

        let sign = 1;
        let cof = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                getCof(mat, cof, i, j, n);
                sign = ((i + j) % 2 === 0) ? 1 : -1;
                adj[j][i] = sign * getDet(cof, n - 1);
            }
        }
    }

    // Function to calculate and store inverse, returns
    // false if matrix is singular
    function inverse(mat, inv) {
        let n = mat.length;
        let det = getDet(mat, n);
        if (det === 0) {
            console.log("Singular matrix, can't find its inverse");
            return false;
        }

        let adj = Array.from({ length: n }, () => Array(n).fill(0));
        adjoint(mat, adj);

        for (let i = 0; i < n; i++)
            for (let j = 0; j < n; j++)
                inv[i][j] = adj[i][j] / det;

        return true;
    }

    let mat = [ [ 5, -2, 2, 7 ],
                [ 1, 0, 0, 3 ],
                [ -3, 1, 5, 0 ],
                [ 3, -1, -9, 4 ] ];

    let n = mat.length;
    let adj = Array.from({ length: n }, () => Array(n).fill(0)); // To store adjoint
    let inv = Array.from({ length: n }, () => Array(n).fill(0)); // To store inverse

    // Print the input matrix
    console.log("Input matrix is:");
    mat.forEach(row => {
        console.log(row.join(' '));
    });

    // Print the adjoint matrix
    console.log("\nThe Adjoint is:");
    adjoint(mat, adj);
    adj.forEach(row => {
        console.log(row.join(' '));
    });

    // Print the inverse matrix if it exists
    console.log("\nThe Inverse is:");
    if (inverse(mat, inv)) {
        inv.forEach(row => {
            console.log(row.join(' '));
        });
    }

    ````




    **Output**
    ```
    Input matrix is:
    5 -2 2 7
    1 0 0 3
    -3 1 5 0
    3 -1 -9 4

    The Adjoint is:
    -12 76 -60 -36
    -56 208 -82 -58
    4 4 -2 -10
    4 4 20 12

    The Inverse is:
    -0.136364 0.863636 -0.681818 -0.409091
    -0.636364 2.36364 -0.931818 -0.659091
    0.0454545 0.0454545 -0.0227273 -0.113636
    0.0454545 0.0454545 0.227273 0.136364

    ```
    

Course Name: Introduction to DSA II
Lesson Name: Singly Linked List Problems

Content:
****Learn Basics of Singly Linked List:****

1. [Basic Terminologies in Linked List](
2. [Singly Linked List Tutorial](
3. [Linked List vs Array](

****Basic Operations of Singly Linked List:****

1. [Linked List Insertion](
2. [Search an element in a Linked List (Iterative and Recursive)](
3. [Find Length of a Linked List (Iterative and Recursive)](
4. [Reverse a linked list](
5. [Linked List Deletion (Deleting a given key)](
6. [Linked List Deletion (Deleting a key at given position)](
7. [Write a function to delete a Linked List](

****Easy Problems on Singly Linked List:****

* [Identical Linked Lists](
* [Print the middle of a given linked list](
* [Write a function to get Nth node in a Linked List](
* [Nth node from the end of a Linked List](
* [Move last element to front of a given Linked List](
* [Make middle node head in a linked list](
* [Delete alternate nodes of a Linked List](
* [Add 1 to a number represented as linked list](
* [Add two numbers represented by linked lists](
* [Subtract Two Numbers represented as Linked Lists](
* [Find the sum of last n nodes of the given Linked List](
* [Pairwise swap elements of a given linked list](
* [Remove every k-th node of the linked list](
* [Remove duplicates from a sorted linked list](

****Intermediate Problems on Singly Linked List:****

* [Detect loop in a linked list](
* [Find length of loop in linked list](
* [Function to check if a singly linked list is palindrome](
* [Remove duplicates from an unsorted linked list](
* [Remove all occurrences of duplicates from a sorted Linked List](
* [Swap nodes in a linked list without swapping data](
* [Intersection point of two Linked Lists.](
* [Iteratively Reverse a linked list using only 2 pointers (An Interesting Method)](
* [Segregate even and odd nodes in a Linked List](
* [Alternate Odd and Even Nodes in a Singly Linked List](
* [Rearrange a Linked List in Zig-Zag fashion](
* [Adding two polynomials using Linked List](
* [Union and Intersection of two Linked Lists](
* [Sort linked list which is already sorted on absolute values](

****Hard Problems on Singly Linked List:****

* [Reverse a Linked List in groups of given size](
* [Flattening a Linked List](
* [Reverse alternate K nodes in a Singly Linked List](
* [Alternating split of a given Singly Linked List](
* [Delete nodes which have a greater value on right side](
* [Given a linked list of line segments, remove middle points](
* [Clone a linked list with next and random pointer](
* [Rearrange a given linked list in-place.](
* [Select a Random Node from a Singly Linked List](
* [In-place Merge two linked lists without changing links of first list](
* [Length of longest palindrome list in a linked list using O(1) extra space](
* [Rotate Linked List block wise](
* [Count rotations in sorted and rotated linked list](

****Quick Links:****

* ['Practice Problems' on Linked List](
    * ['Videos' on Linked List](
* ['Quizzes' on Linked List](


Course Name: Linked List Data Structure Guide
Lesson Name: Remove every k-th node of the linked list

Content:
Given a

****singly linked list,****
the task is to remove every k

th
node of the linked list. Assume that k is always less than or equal to the length of the Linked List.


****Examples :****


> ****Input:****
> LinkedList: 1 -> 2 -> 3 -> 4 -> 5 -> 6, k = 2
>
>
>
> ****Output:****
> 1 -> 3 -> 5
>
>
>
> ****Explanation:****
> After removing every 2nd node of the linked list, the resultant linked list will be: 1 -> 3 -> 5 .
>
>
> ****Input:****
> LinkedList: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10, k = 3
>
>
>
> ****Output:****
> 1 -> 2 -> 4 -> 5 -> 7 -> 8 -> 10
>
>
>
> ****Explanation:****
> After removing every 3rd node of the linked list, the resultant linked list will be: 1 -> 2 -> 4 -> 5 -> 7 -> 8 -> 10.

### [Expected Approach – 1] Iterative Approach – O(n) Time and O(1) Space

> The idea is to traverse the linked list while maintaining a
>
> ****counter****
> to track node positions. Every time the counter reaches
>
> ****k,****
> update the next pointer of the
>
> ****previous****
> node to
>
> ****skip****
> the current k
>
> th
> node, effectively removing it from the list. Continue this process until reaching the
>
> ****end****
> of the list. This method ensures that the
>
> ****k****
> ****th****
>
> nodes are removed as required while
>
> ****preserving****
> the rest of the list structure.








****Time Complexity :****
O(n),


where

****n****
is the number of nodes.



****Auxiliary Space :****
O(1)

Course Name: Matrix Data Structure Guide
Lesson Name: Search element in a sorted matrix

Content:
Given a

****sorted****
matrix

****mat[][]****
of size

****nxm****
and an


element

****x****
, the task is to find if x is

****present****
in the matrix or not. Matrix is

****sorted****
in a way such that all elements in a

****row are sorted in increasing order****
and for row i, where 1 <= i <= n-1, the

****first element****
of

****row i****
is

****greater than or equal****
to the

****last element****
of

****row i-1.****


****Examples:****

> ****Input:****
> x = 14, mat[][] = [[ 1, 5, 9],
>
>
>
> [14, 20, 21],
>
>
>
> [30, 34, 43]]
>
>
>
> ****Output:****
> true
>
>
> ****Input:****
> x = 42, mat[][] = [[ 1, 5, 9, 11],
>
>
>
> [14, 20, 21, 26],
>
>
>
> [30, 34, 43, 50]]
>
>
>
> ****Output:****
> false

Table of Content

* [[Naive Approach] Comparing with all elements – O(n\*m) Time and O(1) Space](#naive-solution-onm-time-and-o1-space)
* [[Better Approach] Using Binary Search Twice – O(logn + logm) Time and O(1) Space](#using-binary-search-two-times-olog-n-log-m-time-and-o1-space)
* [[Expected Approach] Using Binary Search Once – O(log(n\*m)) and O(1) Space](#using-one-binary-search-olognm-and-o1-space)
### ****[Naive Approach] Comparing with all elements – O(n\*m) Time and O(1) Space****


In this approach, we will iterate through the entire

****matrix mat[][]****
and compare

****each element****
with

****x****
. If an element matches the x, we will

****return true****
. Otherwise, at the end of the traversal, we will

****return false.****
Please refer to

[Searching Algorithms for 2D Arrays (Matrix)](
to know more about the implementation.


### ****[Better Approach] Using Binary Search Twice –**** O(logn + logm) Time and O(1) Space


First, we locate the row where the

****target x****
might be by using

****binary search****
, and then we apply binary search again within that row.



> To find the correct row, we perform
>
> ****binary search****
> on the
>
> ****first****
> elements of the middle row.
>
>
>
> Start with l
>
> ****ow = 0****
> and
>
> ****high = n – 1.****
>
> 1. If
>
>    ****x is smaller****
>    than the
>
>    ****first element****
>    of the middle row
>
>    ****(a[mid][0]),****
>    then x will be smaller than all elements in rows >= mid, so update
>
>    ****high = mid – 1.****
> 2. If
>
>    ****x is greater****
>    than the
>
>    ****first element****
>    of the middle row
>
>    ****(a[mid][0])****
>    , then x will be greater than all elements in rows < mid, so store the current mid row and update
>
>    ****low = mid + 1****
>    .
>
>
> Once we have found the
>
> ****correct row,****
> we can apply
>
> ****binary search****
> within that row to search for the
>
> ****target****
> element
>
> ****x****
> .






### ****[Expected Approach] Using Binary Search Once –**** O(log(n\*m)) and O(1) Space

> The idea is to
>
> ****consider the given matrix as 1D array****
> and
>
> ****apply****
> only one
>
> ****binary search.****
> For example, for a matrix of size
>
> ****n x m a****
> nd we can consider it as a
>
> ****1D array****
> of size n\*m
>
> ****,****
> then the
>
> ****first index****
> would be
>
> ****0****
> and
>
> ****last index****
> would
>
> ****n\*m-1.****
> So
>
> ****,****
> we need to do binary search from low = 0 to high = (n\*m-1)
>
> ****.****
>
> ****How to find the element in 2D matrix corresponding to index = mid?****
>
>
> Since each row of mat[][] will have
>
> ****m****
> elements, so we can find the row of the element as
>
> ****(mid / m)****
> and the column of the element as
>
> ****(mid % m)****
> . Then, we can compare
>
> ****x****
> with
>
> ****arr[mid/m][mid%m]****
> for each mid and complete our binary search.







Course Name: The Logic Building Problems
Lesson Name: Mathematical Algorithms (Difficulty Wise)

Content:

### ****Mathematical Concepts:****

* [Numbers](
* [Prime Numbers](
* [Arithmetic Progression](
* [Geometric Progression](
* [GCD](
  and

  [LCM](
* [Factorial](
* [Permutation](
  and

  [Combination](
* [Catalan Number](
* [Modular Arithmetic](

### ****Basic Problems****

* [Sum of Naturals](
* [Sum of Squares of Naturals](
* [Nth Term of AP](
* [Nth Term of GP](
* [Nth Triangular Number](
* [Sum of Sums of Natural Numbers](
* [Count Digits](
* [Sum of Digits](
* [Reverse Digits](
* [K-th Digit in a^b](
* [Palindrome Number](
* [GCD of Two Numbers](
* [LCM of Two Numbers](
* [Add two fractions](
* [Check for Co-Prime](
* [Factorial of a Number](
* [GCD of more than 2](
* [LCM of more than 2](
* [Padovan Sequence](

### ****Easy Problems****

* [Pair Cube Count](
* [Sum of 2, 22, 222, ………](
* [Sum of 1^2 + 3^2 + 5^2 + . . . + (2\*n – 1)^2](
* [Sum of 0.6, 0.06, 0.006, 0.0006, …to n terms](
* [n-th term of 2, 12, 36, 80, 150….](
* [Digit Root](
* [Fibonacci Numbers](
* [Lucas Number](
* [Check for Power](
* [Three Divisors](
* [Square Root](
* [Binomial Coefficient](
* [Pascal Triangle](
* [nth Row of the Pascal Triangle](
* [Armstrong Numbers](
* [Determinant of a Matrix](
* [Modular Exponentiation](
* [Check for Perfect Squares](
* [Divisibility by 3](
* [Divisibility by 4](
* [Divisibility by 7](
* [Divisibility by 11](
* [Divisibility by 13](
* [Divisibility by 29](

### ****Medium Problems****

* [Linear Diophantine Equations](
* [Euler's Totient Function](
* [Sieve of Eratosthenes](
* [All Divisors](
* [Prime Factorization](
* [Largest Prime Factor](
* [Factorial of a Large Number](
* [Largest Power Divisible in Factorial](
* [Last Non-zero Digit of Factorial](
* [Power Set](
* [Add Two Polynomials](
* [All Permutations of a String](
* [Next Permutation](
* [Check for Carmichael Numbers](
* [Collatz sequence](
* [Grid Unique Paths](
* [Nth Even Fibonacci Number](
* [Last 2 Digits of Nth Fibonacci](

### ****Hard Problems****

* [Josephus Problem](
* [Water Jug Tutorial](
* [Segmented Sieve](
* [k-th prime factor](
* [N-th Root](
* [Sum of Digits in Factorial](
* [Egg Dropping](
* [Next String](

Course Name: Introduction to DSA II
Lesson Name: Hash Table Data Structure

Content:

****What is Hash Table?****


A Hash table is defined as a data structure used to insert, look up, and remove key-value pairs quickly. It operates on the

[hashing concept](
, where each key is translated by a hash function into a distinct index in an array. The index functions as a storage location for the matching value. In simple words, it maps the keys with the value.


![Components-of-Hashing](

Hash Function and Table

What is Load factor?


A hash table’s load factor is determined by how many elements are kept there in relation to how big the table is. The table may be cluttered and have longer search times and collisions if the load factor is high. An ideal load factor can be maintained with the use of a good hash function and proper table resizing.


What is a Hash function?


A Function that translates keys to array indices is known as a hash function. The keys should be evenly distributed across the array via a decent hash function to reduce collisions and ensure quick lookup speeds.


* ****Integer universe assumption:****

  The keys are assumed to be integers within a certain range according to the integer universe assumption. This enables the use of basic hashing operations like division or multiplication hashing.
* ****Hashing by division:****

  This straightforward hashing technique uses the key’s remaining value after dividing it by the array’s size as the index. When an array size is a prime number and the keys are evenly spaced out, it performs well.
* ****Hashing by multiplication:****

  This straightforward hashing operation multiplies the key by a constant between 0 and 1 before taking the fractional portion of the outcome. After that, the index is determined by multiplying the fractional component by the array’s size. Also, it functions effectively when the keys are scattered equally.

### [Choosing a hash function]( :


Selecting a decent hash function is based on the properties of the keys and the intended functionality of the hash table. Using a function that evenly distributes the keys and reduces collisions is crucial.


****Criteria based on which a hash function is chosen:****


* To ensure that the number of collisions is kept to a minimum, a good hash function should distribute the keys throughout the hash table in a uniform manner. This implies that for all pairings of keys, the likelihood of two keys hashing to the same position in the table should be rather constant.
* To enable speedy hashing and key retrieval, the hash function should be computationally efficient.
* It ought to be challenging to deduce the key from its hash value. As a result, attempts to guess the key using the hash value are less likely to succeed.
* A hash function should be flexible enough to adjust as the data being hashed changes. For instance, the hash function needs to continue to perform properly if the keys being hashed change in size or format.

### [Collision resolution techniques]( :


Collisions happen when two or more keys point to the same array index. Chaining, open addressing, and double hashing are a few techniques for resolving collisions.


![collision-in-hashing](




* [****Open addressing****](
  ****:****
  collisions are handled by looking for the following empty space in the table. If the first slot is already taken, the hash function is applied to the subsequent slots until one is left empty. There are various ways to use this approach, including double hashing, linear probing, and quadratic probing.
* [****Separate Chaining****](
  ****:****
  In separate chaining, a linked list of objects that hash to each slot in the hash table is present. Two keys are included in the linked list if they hash to the same slot. This method is rather simple to use and can manage several collisions.
* ****Robin Hood hashing:****
  To reduce the length of the chain, collisions in Robin Hood hashing are addressed by switching off keys. The algorithm compares the distance between the slot and the occupied slot of the two keys if a new key hashes to an already-occupied slot. The existing key gets swapped out with the new one if it is closer to its ideal slot. This brings the existing key closer to its ideal slot. This method has a tendency to cut down on collisions and average chain length.

### Dynamic resizing:


This feature enables the hash table to expand or contract in response to changes in the number of elements contained in the table. This promotes a load factor that is ideal and quick lookup times.


Example Implementation of Hash Table


Python, Java, C++, and Ruby are just a few of the programming languages that support hash tables. They can be used as a customized data structure in addition to frequently being included in the standard library.


****Example: hashIndex = key % noOfBuckets****


****Insert****
: Move to the bucket corresponding to the above-calculated hash index and insert the new node at the end of the list.



****Delete****
: To delete a node from hash table, calculate the hash index for the key, move to the bucket corresponding to the calculated hash index, and search the list in the current bucket to find and remove the node with the given key (if found).


![](


Please refer

[****Hashing | Set 2 (Separate Chaining)****](

for details.







Complexity Analysis of a Hash Table:


For lookup, insertion, and deletion operations, hash tables have an average-case time complexity of O(1). Yet, these operations may, in the worst case, require O(n) time, where n is the number of elements in the table.


Applications of Hash Table:

* Hash tables are frequently used for indexing and searching massive volumes of data. A search engine might use a hash table to store the web pages that it has indexed.
* Data is usually cached in memory via hash tables, enabling rapid access to frequently used information.
* Hash functions are frequently used in cryptography to create digital signatures, validate data, and guarantee data integrity.
* Hash tables can be used for implementing database indexes, enabling fast access to data based on key values.

Course Name: Introduction to DSA I

Lesson Name: Getting Started with Array Data Structure

Content:
Basic terminologies of Array

* ****Array Index:****
  In an array, elements are identified by their indexes. Array index
  starts from 0.
* ****Array element:**** Elements are items stored in an array and can be accessed by their
  index.
* ****Array Length:****
  The length of an array is determined by the number of elements it can
  contain.

Memory representation of Array

In an array, all the elements are stored in contiguous memory
locations. So, if we initialize an array, the elements will be allocated
sequentially in memory. This allows for efficient access and
manipulation of elements.

![Memory-Representation-of-Array-(1)](

Declaration of Array

Arrays can be declared in various ways in different languages. For
better illustration, below are some language-specific array












Initialization of Array

Arrays can be initialized in different ways in different languages.
Below are some language-specific array initializations:










Why do we Need Arrays?

Assume there is a class of five students and if we have to keep records
of their marks in examination then, we can do this by declaring five
variables individual and keeping track of records but what if the number
of students becomes very large, it would be challenging to manipulate
and maintain the data.

What it means is that, we can use normal variables (v1, v2, v3, ..)
when we have a small number of objects. But if we want to store a large
number of instances, it becomes difficult to manage them with normal
variables. ****The idea of an array is to represent many instances in one
variable****.


![Importance-of-Array](

Types of Arrays

Arrays can be classified in two ways:

* On the basis of Size
* On the basis of Dimensions

![Types-of-Arrays](
### Types of Arrays on the basis of Size:

****1. Fixed Sized Arrays:****

We cannot alter or update the size of this array. Here only a fixed
size (i,e. the size that is mentioned in square brackets ****[]****) of memory will be allocated for storage. In case, we don’t know the
size of the array then if we declare a larger size and store a lesser
number of elements will result in a wastage of memory or we declare a
lesser size than the number of elements then we won’t get enough memory
to store all the elements. In such cases, static memory allocation is
not preferred.









****2. Dynamic Sized Arrays:****

The size of the array changes as per user requirements during execution
of code so the coders do not have to worry about sizes. They can add and
removed the elements as per the need. The memory is mostly dynamically
allocated and de-allocated in these arrays.










### Types of Arrays on the basis of Dimensions:

****1. One-dimensional Array(1-D Array):**** You can imagine a 1d array as a row, where elements are stored one
after another.

![One-Dimensional-Array(1-D-Array)](

****2. Multi-dimensional Array:****
A multi-dimensional array is an array with more than one dimension. We
can use multidimensional array to store complex data in the form of
tables, etc. We can have 2-D arrays, 3-D arrays, 4-D arrays and so on.


* [****Two-Dimensional Array(2-D Array or Matrix):****]( Multidimensional arrays can be considered as an array of
  arrays or as a matrix consisting of rows and columns.

![Two-Dimensional-Array(2-D-Array-or-Matrix)](

* ****Three-Dimensional Array(3-D Array):**** A 3-D Multidimensional array contains three dimensions, so
  it can be considered an array of two-dimensional arrays.

![Three-Dimensional-Array(3-D-Array)](

Operations on Array

### 1. Array Traversal:

Array traversal involves visiting all the elements of the array once.







### 2. Insertion in Array:

We can insert one or multiple elements at any position in the array.








### 3. Deletion in Array:

We can delete an element at any index in an array. Below is the












### 4. Searching in Array:

We can traverse over an array and search for an element. Below is the








Complexity Analysis of Operations on Array

### Time Complexity:

| Operation | Best Case | Average Case | Worst Case |
| --- | --- | --- | --- |
| ****Traversal**** | θ(N) | θ(N) | θ((N) |
| ****Insertion**** | θ((1) | θ(N) | θ(N) |
| ****Deletion**** | θ(1) | θ(N) | θ(N) |
| ****Searching**** | θ(1) | θ(N) | θ(N) |

### Auxiliary Space

| Operation | Best Case | Average Case | Worst Case |
| --- | --- | --- | --- |
| ****Traversal**** | θ(1) | θ(1) | θ(1) |
| ****Insertion**** | θ(1) | θ(N) | θ(N) |
| ****Deletion**** | θ(1) | θ(N) | θ(N) |
| ****Searching**** | θ(1) | θ(1) | θ(1) |


Course Name: Introduction to DSA I

Lesson Name: Applications, Advantages and Disadvantages of Array

Content:
Table of Content

* [Applications of Array Data Structure:](#applications-of-array-data-structure)
* [Advantages of Array Data Structure:](#advantages-of-array-data-structure)
* [Disadvantages of Array Data Structure:](#disadvantages-of-array-data-structure)
### ****Applications of Array Data Structure:****

Arrays mainly have advantages like random access and cache friendliness
over other data structures that make them useful.

Below are some applications of arrays.

* ****Storing and accessing data****: Arrays store elements in a specific order and allow constant-time
  O(1) access to any element.
* ****Searching****: If data in array is sorted, we can search an item in O(log n) time.
  We can also find floor(), ceiling(), kth smallest, kth largest, etc
  efficiently.
* ****Matrices****: Two-dimensional arrays are used for matrices in computations like
  graph algorithms and image processing.
* ****Implementing other data structures:****
  Arrays are used as the underlying data structure for implementing
  stacks and queues.
* ****Dynamic programming****: Dynamic programming algorithms often use arrays to store
  intermediate results of subproblems in order to solve a larger
  problem.
* ****Data Buffers:****
  Arrays serve as data buffers and queues, temporarily storing incoming
  data like network packets, file streams, and database results before
  processing.

### ****Advantages of Array Data Structure:****

* ****Efficient and Fast Access:****
  Arrays allow direct and efficient access to any element in the
  collection with constant access time, as the data is stored in
  contiguous memory locations.
* ****Memory Efficiency:****
  Arrays store elements in contiguous memory, allowing efficient
  allocation in a single block and reducing memory fragmentation.
* ****Versatility:****
  Arrays can be used to store a wide range of data types, including
  integers, floating-point numbers, characters, and even complex data
  structures such as objects and pointers.
* ****Compatibility with hardware:**** The array data structure is compatible with most hardware
  architectures, making it a versatile tool for programming in a wide
  range of environments.

### ****Disadvantages of Array Data Structure:****

* ****Fixed Size:****
  Arrays have a fixed size set at creation. Expanding an array requires
  creating a new one and copying elements, which is time-consuming and
  memory-intensive.
* ****Memory Allocation Issues:****
  Allocating large arrays can cause memory exhaustion, leading to
  crashes, especially on systems with limited resources.
* ****Insertion and Deletion Challenges:****
  Adding or removing elements requires shifting subsequent elements,
  making these operations inefficient.
* ****Limited Data Type Support:****
  Arrays support only elements of the same type, limiting their use with
  complex data types.
* ****Lack of Flexibility:****
  Fixed size and limited type support make arrays less adaptable than
  structures like linked lists or trees.

Course Name: Linked List Data Structure Guide
Lesson Name: Search an element in a Linked List (Iterative and Recursive)

Content:
Given a linked list and a

****key****
, the task is to check if

****key****
is present in the linked list or not.


****Examples:****

> ****Input:****
> 14 -> 21 -> 11 -> 30 -> 10, key = 14
>
>
>
> ****Output:****
> Yes
>
>
>
> ****Explanation:****
> 14 is present in the linked list.
>
>
> ****Input:****
> 6 -> 21 -> 17 -> 30 -> 10 -> 8, key = 13
>
>
>
> ****Output:****
> No
>
>
>
> ****Explanation:****
> No node in the linked list has value = 13.

Table of Content

* [Search an element in a Linked List (Iterative Approach) – O(N) Time and O(1) Space](#search-an-element-in-a-linked-list-iterative-approach)
* [Search an element in a Linked List (Recursive Approach) – O(N) Time and O(N) Space](#search-an-element-in-a-linked-list-recursive-approach)

Search an element in a Linked List (Iterative Approach) – O(N) Time and O(1) Space:

> The idea is to traverse all the nodes of the linked list, starting from the
>
> ****head****
> . While traversing, if we find a node whose value is equal to
>
> ****key****
> then print “Yes”, otherwise print “No”.


Follow the below steps to solve the problem:



* Initialize a node pointer,

  ****curr = head****
  .
* Do following while current is not NULL
  + If the current value (i.e.,

    ****curr->key****
    ) is equal to the key being searched return true.
  + Otherwise, move to the next node (

    ****curr = curr->next****
    ).
* If the key is not found, return false


Below is the implementation of the above approach.








****Time Complexity:****
O(N), Where

****N****
is the number of nodes in the Linked List.



****Auxiliary Space:****
O(1)


Search an element in a Linked List (Recursive Approach) – O(N) Time and O(N) Space:

> The idea is to recursively traverse all the nodes starting from the
>
> ****head****
> of linked list. For any node, if the value is equal to
>
> ****key****
> , then return true. Otherwise, recursively search the next node. If at any point the head reaches
>
> ****NULL****
> , it means that we have reached the end of linked list so return
>
> ****false****
> .


Follow the below steps to solve the problem:


* If the head is NULL, return false.
* If the head’s key is the same as

  ****X****
  , return true;
* Else recursively search in the next node.


Below is the recursive implementation of the above algorithm.








****Time Complexity:****
O(N), where

****N****
is the number of nodes in the linked list.



****Auxiliary Space:****
O(N), Stack space used by recursive calls

Course Name: Linked List Data Structure Guide
Lesson Name: Print Linked List

Content:
Given a Singly Linked List, the task is to print all the elements in the list.


****Examples:****

> ****Input:****
> 1->2->3->4->5->null
>
>
>
> ****Output:****
> 1 2 3 4 5
>
>
>
> ****Explanation:****
> Every element of each node from head node to last node is printed.
>
>
> ****Input:****
> 10->20->30->40->50->null
>
>
>
> ****Output:****
> 10 20 30 40 50
>
>
>
> ****Explanation:****
> Every element of each node from head node to last node is printed.

Table of Content

* [Iterative Approach - O(n) Time and O(1) Space](#iterative-approach-on-time-and-o1-space)
* [Recursive Approach - O(n) Time and O(n) Memory Space](#recursive-approach-on-time-and-on-memory-space)
### Iterative Approach - O(n) Time and O(1) Space


The process of printing a

****singly linked list****
involves printing the value of each node and then going on to the next node and print that node's value also and so on, till we reach the last node in the singly linked list, whose next node points towards the null.


****Step-by-Step Algorithm****

> * We will initialize a temporary pointer to the head node of the singly linked list.
> * After that, we will check if that pointer is null or not null, if it is null, then return.
> * While the pointer is not null, we will access and print the data of the current node, then we move the pointer to next node.


Program to Print the Singly Linked List using Iteration.








****Time Complexity:****
O(n), where

****n****
is the number of nodes in the linked list.



****Auxiliary Space:****
O(1)


### Recursive Approach - O(n) Time and O(n) Memory Space


We can also traverse the singly linked list using recursion. We start at the head node of the singly linked list, check if it is null or not and print its value. We then call the traversal function again with the next node passed as pointer.


****Step-by-Step Algorithm****

> * Firstly, we define a recursive method to traverse the singly linked list, which takes a node as a parameter.
> * In this function, the base case is that if the node is null then we will return from the recursive method.
> * We then pass the head node as the parameter to this function.
> * After that, we access and print the data of the current node.
> * At last, we will make a recursive call to this function with the next node as the parameter.


Program to Print the Singly Linked List using Recursion.







****Time Complexity:****
O(n), where

****n****
is number of nodes in the linked list.



****Space complexity:****
O(n) because of recursive stack space.

Course Name: Matrix Data Structure Guide
Lesson Name: Validity of a given Tic-Tac-Toe board configuration

Content:

Recommended Practice

[Tic Tac Toe](


[Try It!](


Basically, to find the validity of an input grid, we can think of the conditions when an input grid is invalid. Let no. of “X”s be countX and no. of “O”s be countO. Since we know that the game starts with X, a given grid of Tic-Tac-Toe game would be definitely invalid if following two conditions meet


1. countX != countO AND
2. countX != countO + 1
   * Since “X” is always the first move, second condition is also required.
   * Now does it mean that all the remaining board positions are valid one? The answer is NO. Think of the cases when input grid is such that both X and O are making straight lines. This is also not
   * valid position because the game ends when one player wins. So we need to check the following condition as well
3. If input grid shows that both the players are in winning situation, it’s an invalid position.
4. If input grid shows that the player with O has put a straight-line (i.e. is in win condition) and countX != countO, it’s an invalid position. The reason is that O plays his move only after X plays his
   * move. Since X has started the game, O would win when both X and O has played equal no. of moves.
5. If input grid shows that X is in winning condition than xCount must be one greater that oCount.
   * Armed with above conditions i.e. a), b), c) and d), we can now easily formulate an algorithm/program to check the validity of a given Tic-Tac-Toe board position.



Another way to find the validity of a given board is using ‘inverse method’ i.e. rule out all the possibilities when a given board is invalid.








****Time complexity:****
O(1)



****Auxiliary Space:****
O(1), since no extra space has been taken.


****Approach 2:****


The algorithm to check if a Tic-Tac-Toe board is valid or not is as follows:


* Initialize a 2D array win of size 8×3, which contains all possible winning combinations in Tic-Tac-Toe. Each row of the win array represents a winning combination, and each element in a row represents a cell index on the board.
* Define a function isCWin(board, c) which takes a board configuration board and a character c (‘X’ or ‘O’) as inputs, and returns true if character c has won on the board.
* Inside the isCWin function, iterate over each row of the win array. Check if the board has the same character c at all three cell indices of the current row. If yes, return true, as the character c has won.
* Define a function isValid(board) which takes a board configuration board as input, and returns true if the board is valid, else returns false.
* Inside the isValid function, count the number of ‘X’ and ‘O’ characters on the board, and store them in xCount and oCount variables, respectively.
* The board can be valid only if either xCount and oCount are the same, or xCount is one more than oCount.
* If ‘O’ is a winner on the board, check if ‘X’ is also a winner. If yes, return false as both ‘X’ and ‘O’ cannot win at the same time. If not, return true if xCount and oCount are the same, else return false.
* If ‘X’ is a winner on the board, then xCount must be one more than oCount. If not, return false.
* If ‘O’ is not a winner, return true as the board is valid.







****Time complexity: O(N^2)****


****Auxiliary Space: O(N)****


Course Name: Introduction to DSA II
Lesson Name: What is Priority Queue | Introduction to Priority Queue

Content:
****Properties of Priority Queue****

*****So, a priority Queue is an extension of the*****
[*****queue*****](
*****with the following properties.*****

* Every item has a priority associated with it.
* An element with high priority is dequeued before an element with low priority.
* If two elements have the same priority, they are served according to their order in the queue.


In the below priority queue, an element with a maximum ASCII value will have the highest priority. The elements with higher priority are served first.


![](

****How is Priority assigned to the elements in a Priority Queue?****


In a priority queue, generally, the value of an element is considered for assigning the priority.


For example, the element with the highest value is assigned the highest priority and the element with the lowest value is assigned the lowest priority. The reverse case can also be used i.e., the element with the lowest value can be assigned the highest priority. Also, the priority can be assigned according to our needs.


****Operations of a Priority Queue:****


A typical priority queue supports the following operations:


### ****1) Insertion in a Priority Queue****


When a new element is inserted in a priority queue, it moves to the empty slot from top to bottom and left to right. However, if the element is not in the correct place then it will be compared with the parent node. If the element is not in the correct order, the elements are swapped. The swapping process continues until all the elements are placed in the correct position.


### ****2) Deletion in a Priority Queue****


As you know that in a max heap, the maximum element is the root node. And it will remove the element which has maximum priority first. Thus, you remove the root node from the queue. This removal creates an empty slot, which will be further filled with new insertion. Then, it compares the newly inserted element with all the elements inside the queue to maintain the heap invariant.


### ****3) Peek in a Priority Queue****


This operation helps to return the maximum element from Max Heap or the minimum element from Min Heap without deleting the node from the priority queue.


Types of Priority Queue:

### ****1) Ascending Order Priority Queue****


As the name suggests, in ascending order priority queue, the element with a lower priority value is given a higher priority in the priority list. For example, if we have the following elements in a priority queue arranged in ascending order like 4,6,8,9,10. Here, 4 is the smallest number, therefore, it will get the highest priority in a priority queue and so when we dequeue from this type of priority queue, 4 will remove from the queue and dequeue returns 4.


### ****2) Descending order Priority Queue****


The root node is the maximum element in a max heap, as you may know. It will also remove the element with the highest priority first. As a result, the root node is removed from the queue. This deletion leaves an empty space, which will be filled with fresh insertions in the future. The heap invariant is then maintained by comparing the newly inserted element to all other entries in the queue.


![Types of Priority Queues](

Types of Priority Queues

****Difference between Priority Queue and Normal Queue?****


There is no priority attached to elements in a queue, the rule of first-in-first-out(FIFO) is implemented whereas, in a priority queue, the elements have a priority. The elements with higher priority are served first.


****How to Implement Priority Queue?****


Priority queue can be implemented using the following data structures:


* Arrays
* Linked list
* Heap data structure
* Binary search tree

****Let’s discuss all these in detail.****

### ****1) Implement Priority Queue Using Array:****


A simple implementation is to use an array of the following structure.


> struct item {
>
>
>
> int item;
>
>
>
> int priority;
>
>
>
> }

* ****enqueue():****
  This function is used to insert new data into the queue.
* ****dequeue():****
  This function removes the element with the highest priority from the queue.
* ****peek()/top():****
  This function is used to get the highest priority element in the queue without removing it from the queue.






> ****Note:****
> Read
>
> [****this article****](
>
> for more details.

### ****2) Implement Priority Queue Using Linked List:****


In a LinkedList implementation, the entries are sorted in descending order based on their priority. The highest priority element is always added to the front of the priority queue, which is formed using linked lists. The functions like

****push()****
,

****pop()****
, and

****peek()****
are used to implement a priority queue using a linked list and are explained as follows:


* ****push():****
  This function is used to insert new data into the queue.
* ****pop():****
  This function removes the element with the highest priority from the queue.
* ****peek() / top():****
  This function is used to get the highest priority element in the queue without removing it from the queue.








Refer to

[this article](
for more details.


> ****Note:****
> We can also use Linked List, time complexity of all operations with linked list remains same as array. The advantage with linked list is
>
>
> deleteHighestPriority()
>
>
> can be more efficient as we don’t have to move items.

### ****3) Implement Priority Queue Using Heaps:****


Binary Heap is generally preferred for priority queue implementation because heaps provide better performance compared to arrays or LinkedList. Considering the properties of a heap, The entry with the largest key is on the top and can be removed immediately. It will, however, take time O(log n) to restore the heap property for the remaining keys. However if another entry is to be inserted immediately, then some of this time may be combined with the O(log n) time needed to insert the new entry. Thus the representation of a priority queue as a heap proves advantageous for large n, since it is represented efficiently in contiguous storage and is guaranteed to require only logarithmic time for both insertions and deletions. Operations on Binary Heap are as follows:


* ****insert(p):****
  Inserts a new element with priority p.
* ****extractMax():****
  Extracts an element with maximum priority.
* ****remove(i):****
  Removes an element pointed by an iterator i.
* ****getMax():****
  Returns an element with maximum priority.
* ****changePriority(i, p):****
  Changes the priority of an element pointed by

  ****i to p****
  .

> Refer to
>
> [this article](
> for code implementation.

### ****4) Implement Priority Queue Using Binary Search Tree:****


A Self-Balancing Binary Search Tree like AVL Tree, Red-Black Tree, etc. can also be used to implement a priority queue. Operations like peek(), insert() and delete() can be performed using BST.


****Applications of Priority Queue:****

* CPU Scheduling
* Graph algorithms like

  [Dijkstra’s shortest path algorithm](
  ,

  [Prim’s Minimum Spanning Tree](
  , etc.
* All

  [queue applications](
  where priority is involved.
* Data compression in Huffman code
* Event-driven simulation such as customers waiting in a queue.
* Finding Kth largest/smallest element.

****Advantages of Priority Queue:****

* It helps to access the elements in a faster way. This is because elements in a priority queue are ordered by priority, one can easily retrieve the highest priority element without having to search through the entire queue.
* The ordering of elements in a Priority Queue is done dynamically. Elements in a priority queue can have their priority values updated, which allows the queue to dynamically reorder itself as priorities change.
* Efficient algorithms can be implemented. Priority queues are used in many algorithms to improve their efficiency, such as Dijkstra’s algorithm for finding the shortest path in a graph and the A\* search algorithm for pathfinding.
* Included in real-time systems. This is because priority queues allow you to quickly retrieve the highest priority element, they are often used in real-time systems where time is of the essence.

****Disadvantages of Priority Queue:****

* High complexity. Priority queues are more complex than simple data structures like arrays and linked lists, and may be more difficult to implement and maintain.
* High consumption of memory. Storing the priority value for each element in a priority queue can take up additional memory, which may be a concern in systems with limited resources.
* It is not always the most efficient data structure. In some cases, other data structures like heaps or binary search trees may be more efficient for certain operations, such as finding the minimum or maximum element in the queue.
* At times it is less predictable:. This is because the order of elements in a priority queue is determined by their priority values, the order in which elements are retrieved may be less predictable than with other data structures like stacks or queues, which follow a first-in, first-out (FIFO) or last-in, first-out (LIFO) order.


Course Name: Introduction to DSA I

Lesson Name: Applications, Advantages and Disadvantages of Linked List

Content:
Advantages of Linked Lists (or Most Common Use Cases):

* Linked Lists are mostly used because of their effective insertion and
  deletion.  We only need to change few pointers (or references) to
  insert (or delete) an item in the middle
* [Insertion and deletion]( at any point in a linked list take O(1) time. Whereas in an [array](
  data structure, insertion / deletion in the middle takes O(n)
  time.
* This data structure is simple and can be also used to implement [a stack]( [queues,]( and other [abstract data structures](
* Implementation of Queue and Deque data structures : Simple array
  implementation is not efficient at all. We must use circular array to
  efficiently implement which is complex. But with linked list, it is
  easy and straightforward. That is why most of the language libraries
  use Linked List internally to implement these data structures..
* Linked List might turn out to be more space efficient compare to
  arrays in cases where we cannot guess the number of elements in
  advance. In case of arrays, the whole memory for items is allocated
  together. Even with dynamic sized arrays like vector in C++ or list in
  Python or ArrayList in Java. the internal working involves
  de-allocation of whole memory and allocation of a bigger chunk when
  insertions happen beyond the current capacity.

Applications of Linked Lists:

* Linked Lists can be used to implement stacks, queue, deque, [sparse matrices]( and adjacency list representation of graphs.
* [Dynamic memory allocation](
  in operating systems and compilers (linked list of free blocks).
* Manipulation of polynomials
* Arithmetic operations on long integers.
* In operating systems, they can be used in Memory management, process
  scheduling (for example circular linked list for round robin
  scheduling) and file system.
* Algorithms that need to frequently insert or delete items from large
  collections of data.
* LRU cache, which uses a doubly linked list to keep track of the most
  recently used items in a cache.

Applications of Linked Lists in real world:

* The list of songs in the music player are linked to the previous and
  next songs.
* In a web browser, previous and next web page URLs can be linked
  through the previous and next buttons (Doubly Linked List)
* In image viewer, the previous and next images can be linked with the
  help of the previous and next buttons (Doubly Linked List)
* Circular Linked Lists can be used to implement things in round manner
  where we go to every element one by one.
* Linked List are preferred over arrays for implementations of Queue
  and Deque data structures because of fast deletions (or insertions)
  from the front of the linked lists.

Disadvantages of Linked Lists:

Linked lists are a popular data structure in computer science, but like
any other data structure, they have certain disadvantages as well. Some
of the key disadvantages of linked lists are:

* ****Slow Access Time:**** Accessing elements in a linked list can be slow, as you need to
  traverse the linked list to find the element you are looking for,
  which is an O(n) operation. This makes linked lists a poor choice for
  situations where you need to access elements quickly.
* ****Pointers or References:****
  Linked lists use pointers or references to access the next node, which
  can make them more complex to understand and use compared to arrays.
  This complexity can make linked lists more difficult to debug and
  maintain.
* ****Higher overhead:**** Linked lists have a higher overhead compared to arrays, as each node
  in a linked list requires extra memory to store the reference to the
  next node.
* ****Cache Inefficiency:**** Linked lists are cache-inefficient because the memory is not
  contiguous. This means that when you traverse a linked list, you are
  not likely to get the data you need in the cache, leading to cache
  misses and slow performance.

In conclusion, linked lists are a powerful and flexible data structure,
but they have certain disadvantages that need to be taken into
consideration when deciding whether to use them or not. For example, if
you need fast access time, arrays might be a better choice, but if you
need to insert or delete elements frequently, linked lists might be the
better choice.


Course Name: Introduction to DSA II
Lesson Name: Recursive Functions

Content:
Need of Recursive Function:


A recursive function is a function that solves a problem by solving smaller instances of the same problem. This technique is often used in programming to solve problems that can be broken down into simpler, similar subproblems.


### 1. ****Solving complex tasks:****


Recursive functions break complex problems into smaller instances of the same problem, resulting in compact and readable code.


### 2. Divide and Conquer:


Recursive functions are suitable for divide-and-conquer algorithms such as merge sort and quicksort, breaking problems into smaller subproblems, solving them recursively, and merging the solutions with the original problem.


### 3. ****Backtracking**** :


Recursive backtracking is ideal for exploring and solving problems like N-Queens and Sudoku.



### 4. Dynamic ****programming:****


Recursive functions efficiently solve dynamic programming problems by solving subproblems and combining their solutions into a complete solution.


### 5. Tree and ****graph structures:****


Recursive functions are great for working with tree and graph structures, simplifying traversal and pattern recognition tasks

****.****

How to write a Recursive Function:

### Components of a recursive function:

****Base case:****
Every recursive function must have a base case. The base case is the simplest scenario that does not require further recursion. This is a termination condition that prevents the function from calling itself indefinitely. Without a proper base case, a recursive function can lead to infinite recursion.


****Recursive case:****
In the recursive case, the function calls itself with the modified arguments. This is the essence of recursion – solving a larger problem by breaking it down into smaller instances of the same problem. The recursive case should move closer to the base case with each iteration.


Let’s consider the example of

[factorial of number](
:


In this example, the base case is when

****n****
is

****0****
, and the function returns

****1****
. The recursive case multiplies

****n****
with the result of the function called with parameter

****n – 1****
. The process continues until the base case is reached.


It’s essential to ensure that the recursive function has a correct base case and that the recursive calls lead to the base case, otherwise, the procedure might run indefinitely, leading to a stack overflow (exceeding the available memory allocated for function calls).







****Time Complexity:****
O(n)



****Auxiliary Space:****
O(n)



Course Name: The Logic Building Problems
Lesson Name: Program to Find GCD or HCF of Two Numbers

Content:
Given two numbers

****a****
and

****b****
, the task is to find the

[GCD](
of the two numbers.


****Note:****
The GCD (Greatest Common Divisor) or HCF (Highest Common Factor) of two numbers is the largest number that divides both of them.



![gcd](




****Examples:****

> ****Input:****
> a = 20, b = 28
>
>
>
> ****Output:****
> 4
>
>
>
> ****Explanation:****
> The factors of 20 are 1, 2, 4, 5, 10 and 20. The factors of 28 are 1, 2, 4, 7, 14 and 28. Among these factors, 1, 2 and 4 are the common factors of both 20 and 28. The greatest among the common factors is 4.
>
>
> ****Input:****
> a = 60, b = 36
>
>
>
> ****Output:****
> 12

Naive Approach for GCD of two numbers:

> The basic idea is to find the minimum of the two numbers and find its highest factor which is also a factor of the other
>
> [number](
> .








****Time Complexity:****
O(min(a,b))



****Auxiliary Space:****
O(1)


[Euclidean algorithm](
for GCD of two numbers:


The idea of this algorithm is, the GCD of two numbers doesn’t change if the smaller number is subtracted from the bigger number. This is the

****Euclidean algorithm by subtraction****
. It is a process of repeat subtraction, carrying the result forward each time until the result is equal to any one number being subtracted.


****Pseudo-code:****

> gcd(a, b):
>
>
>
> if a = b:
>
>
>
> return a
>
>
>
> if a > b:
>
>
>
> return gcd(a – b, b)
>
>
>
> else:
>
>
>
> return gcd(a, b – a)


Below is the implementation of the above approach.









****Time Complexity:****
O(min(a,b))



****Auxiliary Space:****
O(min(a,b)) because it uses internal stack data structure in recursion.


****Optimization by checking divisibility:****


The above method can be optimized based on the following idea:


> If we notice the previous approach, we can see at some point, one number becomes a factor of the other so instead of repeatedly subtracting till both become equal, we can check if it is a factor of the other.

****Illustration:****


See the below illustration for a better understanding:


> Consider a = 98 and b = 56
>
>
> ****a = 98, b = 56:****
>
> * a > b so put a = a-b and b remains same. So  a = 98-56 = 42  & b= 56.
>
> ****a = 42, b = 56:****
>
> * Since b > a, we check if b%a=0. Since answer is no, we proceed further.
> * Now b>a. So b = b-a and a remains same. So b = 56-42 = 14 & a= 42.
>
> ****a = 42, b = 14:****
>
> * Since a>b, we check if a%b=0. Now the answer is yes.
> * So we print smaller among a and b as H.C.F . i.e. 42 is  3 times of 14.
>
>
> So
>
> ****HCF****
> is 14.







****Time Complexity:****
O(min(a, b))



****Auxiliary Space:****
O(1)


****Optimization using division:****

> Instead of the Euclidean algorithm by subtraction, a better approach can be used. We don’t perform subtraction here. we continuously divide the bigger number by the smaller number. More can be learned about this
>
> ****efficient solution****
> by using the modulo operator in
>
> [Euclidean algorithm](
> .


Below is the implementation of the above approach.









****Complexity Analysis:****

****Time Complexity:****
O(log(min(a,b)))


* The derivation for this is obtained from the analysis of the worst-case scenario.
* What we do is we ask what are the 2 least numbers that take 1 step, those would be (1,1). If we want to increase the number of steps to 2 while keeping the numbers as low as possible as we can take the numbers to be (1,2). Similarly, for 3 steps, the numbers would be (2,3), 4 would be (3,5), 5 would be (5,8).
* So we can notice a pattern here, for the nth step the numbers would be (fib(n), fib(n+1)). So the worst-case time complexity would be O(n) where

  ****a ? fib(n)****
  and

  ****b ? fib(n+1)****
  .
* Now Fibonacci series is an exponentially growing series where the ratio of n

  th
  /(n-1)

  th
  term approaches (sqrt(5)+1)/2 which is also called the golden ratio. So we can see that the time complexity of the algorithm increases linearly as the terms grow exponentially hence the time complexity would be

  ****log(min(a,b))****
  .

****Auxiliary Space:****
O(log(min(a,b))


****Iterative implementation for GCD of two numbers using Euclidean Algorithm:****


Below is the iterative way to find the GCD of two numbers using Euclidean algorithm.








****Time Complexity:****
O(log(min(a,b)))



****Auxiliary Space:****
O(1)


### GCD of two numbers using inbuilt function:


Languages like C++ have inbuilt functions to calculate GCD of two numbers.


Below is the implementation using inbuilt functions.







****Time Complexity:****
O(log(min(a, b)))



****Auxiliary Space:****
O(1)



Course Name: Introduction to DSA I

Lesson Name: Singly Linked List Tutorial

Content:
Understanding Node Structure

In a singly linked list, each node consists of two parts: data and a
pointer to the next node. This structure allows nodes to be dynamically
linked together, forming a chain-like sequence.


![Singly-Linked-List](








In this example, the Node class contains an integer data field (****data****) to store the information and a pointer to another Node (****next****) to establish the link to the next node in the list.

Operations on Singly Linked List

* ****Traversal****
* ****Searching****
* ****Length****
* ****Insertion:****
  + Insert at the beginning
  + Insert at the end
  + Insert at a specific position
* ****Deletion:****
  + Delete from the beginning
  + Delete from the end
  + Delete a specific node

Let's go through each of the operations mentioned above, one by
one.

[****Traversal**** of Singly Linked List](

Traversal involves visiting each node in the linked list and performing
some operation on the data. A simple traversal function would print or
process the data of each node.

Step-by-step approach:

* Initialize a pointer current to the head of the list.
* Use a while loop to iterate through the list until the current
  pointer reaches NULL.
* Inside the loop, print the data of the current node and move the
  current pointer to the next node.







[Searching in Singly Linked List](

Searching in a Singly Linked List refers to the process of looking for
a specific element or value within the elements of the linked list.


Step-by-step approach:

1. Traverse the Linked List starting from the head.
2. Check if the current node's data matches the target value.
   * If a match is found, return ****true****.
3. Otherwise, Move to the next node and repeat steps 2.
4. If the end of the list is reached without finding a match, return ****false****.








[Length of Singly Linked List](

Finding Length in Singly Linked List refers to the process of
determining the total number of nodes in a singly linked list.

Step-by-step approach:

* Initialize a counter ****length**** to 0.
* Start from the head of the list, assign it to current.
* Traverse the list:
  + Increment ****length**** for each node.
  + Move to the next node (****current = current->next****).
* Return the final value of ****length****.









[Insertion in Singly Linked List](

Insertion is a fundamental operation in linked lists that involves
adding a new node to the list. There are several scenarios for
insertion:

### a. [Insertion at the Beginning of Singly Linked List](

![Insertion-at-the-Beginning-of-Singly-Linked-List](


Insert a Node at the Front/Beginning of Linked List



Step-by-step approach:

* Create a new node with the given value.
* Set the ****next**** pointer of the new node to the current head.
* Move the head to point to the new node.
* Return the new head of the linked list.







### b. [Insertion at the End of Singly Linked List:](

To insert a node at the end of the list, traverse the list until the
last node is reached, and then link the new node to the current last
node-

![Insertion-at-the-End-of-Singly-Linked-List](

Insertion at end of Linked List


Step-by-step approach:

* Create a new node with the given value.
* Check if the list is empty:
  + If it is, make the new node the head and return.
* Traverse the list until the last node is reached.
* Link the new node to the current last node by setting the last node's
  next pointer to the new node.










### c. [Insertion at a Specific Position of the Singly Linked List:](

To insert a node at a specific position, traverse the list to the
desired position, link the new node to the next node, and update the
links accordingly.

![Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy](




We mainly find the node after which we need to insert the new node. If
we encounter a NULL before reaching that node, it means that the given
position is invalid.













[Deletion in Singly Linked List](

Deletion involves removing a node from the linked list. Similar to
insertion, there are different scenarios for deletion:

### a. [****Deletion at the Beginning of**** Singly Linked List****:****](

To delete the first node, update the head to point to the second node
in the list.

![Deletion-at-beginning-](

Deletion at beginning in a Linked List


Steps-by-step approach:

* Check if the head is ****NULL****.
  + If it is, return ****NULL**** (the list is empty).
* Store the current head node in a temporary variable ****temp****.
* Move the head pointer to the next node.
* Delete the temporary node.
* Return the new head of the linked list.







### b. [Deletion at the End of Singly Linked List:](

To delete the last node, traverse the list until the second-to-last
node and update its next field to None.

![Deletion-At-End](

Deletion at the end of linked list


Step-by-step approach:

* Check if the head is ****NULL****.
  + If it is, return NULL (the list is empty).
* Check if the head's ****next**** is ****NULL**** (only one node in the list).
  + If true, delete the head and return ****NULL****.
* Traverse the list to find the second last node (****second\_last****).
* Delete the last node (the node after ****second\_last****).
* Set the ****next**** pointer of the second last node to ****NULL****.
* Return the head of the linked list.









### c. [Deletion at a Specific Position of Singly Linked List:](

To delete a node at a specific position, traverse the list to the
desired position, update the links to bypass the node to be
deleted.

![Deletion-specific-At-End--](

Delete a Linked List node at a given position


Step-by-step approach:

* Check if the list is empty or the position is invalid, return if
  so.
* If the head needs to be deleted, update the head and delete the
  node.
* Traverse to the node before the position to be deleted.
* If the position is out of range, return.
* Store the node to be deleted.
* Update the links to bypass the node.
* Delete the stored node.









Course Name: Linked List Data Structure Guide
Lesson Name: Singly Linked List Tutorial

Content:
Understanding Node Structure

In a singly linked list, each node consists of two parts: data and a
pointer to the next node. This structure allows nodes to be dynamically
linked together, forming a chain-like sequence.


![Singly-Linked-List](








In this example, the Node class contains an integer data field (****data****) to store the information and a pointer to another Node (****next****) to establish the link to the next node in the list.

Operations on Singly Linked List

* ****Traversal****
* ****Searching****
* ****Length****
* ****Insertion:****
  + Insert at the beginning
  + Insert at the end
  + Insert at a specific position
* ****Deletion:****
  + Delete from the beginning
  + Delete from the end
  + Delete a specific node

Let's go through each of the operations mentioned above, one by
one.

[****Traversal**** of Singly Linked List](

Traversal involves visiting each node in the linked list and performing
some operation on the data. A simple traversal function would print or
process the data of each node.

Step-by-step approach:

* Initialize a pointer current to the head of the list.
* Use a while loop to iterate through the list until the current
  pointer reaches NULL.
* Inside the loop, print the data of the current node and move the
  current pointer to the next node.







[Searching in Singly Linked List](

Searching in a Singly Linked List refers to the process of looking for
a specific element or value within the elements of the linked list.


Step-by-step approach:

1. Traverse the Linked List starting from the head.
2. Check if the current node's data matches the target value.
   * If a match is found, return ****true****.
3. Otherwise, Move to the next node and repeat steps 2.
4. If the end of the list is reached without finding a match, return ****false****.








[Length of Singly Linked List](

Finding Length in Singly Linked List refers to the process of
determining the total number of nodes in a singly linked list.

Step-by-step approach:

* Initialize a counter ****length**** to 0.
* Start from the head of the list, assign it to current.
* Traverse the list:
  + Increment ****length**** for each node.
  + Move to the next node (****current = current->next****).
* Return the final value of ****length****.









[Insertion in Singly Linked List](

Insertion is a fundamental operation in linked lists that involves
adding a new node to the list. There are several scenarios for
insertion:

### a. [Insertion at the Beginning of Singly Linked List](

![Insertion-at-the-Beginning-of-Singly-Linked-List](


Insert a Node at the Front/Beginning of Linked List



Step-by-step approach:

* Create a new node with the given value.
* Set the ****next**** pointer of the new node to the current head.
* Move the head to point to the new node.
* Return the new head of the linked list.







### b. [Insertion at the End of Singly Linked List:](

To insert a node at the end of the list, traverse the list until the
last node is reached, and then link the new node to the current last
node-

![Insertion-at-the-End-of-Singly-Linked-List](

Insertion at end of Linked List


Step-by-step approach:

* Create a new node with the given value.
* Check if the list is empty:
  + If it is, make the new node the head and return.
* Traverse the list until the last node is reached.
* Link the new node to the current last node by setting the last node's
  next pointer to the new node.










### c. [Insertion at a Specific Position of the Singly Linked List:](

To insert a node at a specific position, traverse the list to the
desired position, link the new node to the next node, and update the
links accordingly.

![Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy](




We mainly find the node after which we need to insert the new node. If
we encounter a NULL before reaching that node, it means that the given
position is invalid.













[Deletion in Singly Linked List](

Deletion involves removing a node from the linked list. Similar to
insertion, there are different scenarios for deletion:

### a. [****Deletion at the Beginning of**** Singly Linked List****:****](

To delete the first node, update the head to point to the second node
in the list.

![Deletion-at-beginning-](

Deletion at beginning in a Linked List


Steps-by-step approach:

* Check if the head is ****NULL****.
  + If it is, return ****NULL**** (the list is empty).
* Store the current head node in a temporary variable ****temp****.
* Move the head pointer to the next node.
* Delete the temporary node.
* Return the new head of the linked list.







### b. [Deletion at the End of Singly Linked List:](

To delete the last node, traverse the list until the second-to-last
node and update its next field to None.

![Deletion-At-End](

Deletion at the end of linked list


Step-by-step approach:

* Check if the head is ****NULL****.
  + If it is, return NULL (the list is empty).
* Check if the head's ****next**** is ****NULL**** (only one node in the list).
  + If true, delete the head and return ****NULL****.
* Traverse the list to find the second last node (****second\_last****).
* Delete the last node (the node after ****second\_last****).
* Set the ****next**** pointer of the second last node to ****NULL****.
* Return the head of the linked list.









### c. [Deletion at a Specific Position of Singly Linked List:](

To delete a node at a specific position, traverse the list to the
desired position, update the links to bypass the node to be
deleted.

![Deletion-specific-At-End--](

Delete a Linked List node at a given position


Step-by-step approach:

* Check if the list is empty or the position is invalid, return if
  so.
* If the head needs to be deleted, update the head and delete the
  node.
* Traverse to the node before the position to be deleted.
* If the position is out of range, return.
* Store the node to be deleted.
* Update the links to bypass the node.
* Delete the stored node.









Course Name: The Logic Building Problems
Lesson Name: Program for Sum of the digits of a given number

Content:
Given a number

****n****
, find the sum of its digits.


****Examples :****

> ****Input:****
> n = 687
>
>
>
> ****Output:****
> 21
>
>
>
> ****Explanation:****
> **The sum of its digits are: 6 + 8 + 7 = 21**
>
> ****Input:****
> n = 12
>
>
>
> ****Output:****
> 3
>
>
>
> ****Explanation:****
> **The sum of its digits are: 1 + 2 = 3**

Table of Content

* [[Expected Approach] Sum of the digits of a given number using recursion](#expected-approach-sum-of-the-digits-of-a-given-number-using-recursion)
* [[Alternate Approach] Sum of the digits of a given number using tail recursion](#alternate-approach-sum-of-the-digits-of-a-given-number-using-tail-recursion)
* [[Alternate Approach] Converting Number to String](#sum-of-the-digits-of-a-given-number-with-input-as-string)
### ****[Expected Approach] Sum of the digits using recursion****

> **The idea is to count the digits by removing the digits from the input number starting from**
> ****right(least significant digit)****
> **to**
> ****left(most significant digit)****
> **till the number is reduced to 0 because the rightmost digit can be removed simply by performing**
> ****integer division by 10****
> **. For eg: n = 1567, then 1567 / 10 = 156.7 = 156(Integer Division).**








****Time Complexity:****
O(log n)



****Auxiliary Space:****
O(log n)


### ****[Alternate Approach] Using tail recursion****

> This approach ensures that the recursive call is the last operation, allowing for better memory efficiency and preventing stack overflow.








****Time Complexity:****
O(log n)



****Auxiliary Space:****
O(log n)


### ****[Alternate Approach]**** Converting Number to String

> When the number of digits of that number exceeds 10
>
> 19
> , we can’t take that number as an integer since the range of long long int doesn’t satisfy the given number. So take input as a string, run a loop from start to the length of the string and increase the sum with that character(in this case it is numeric)







****Time Complexity:****
O(n)



****Auxiliary Space:****
O(1)



Course Name: Linked List Data Structure Guide
Lesson Name: Applications, Advantages and Disadvantages of Linked List

Content:
Advantages of Linked Lists (or Most Common Use Cases):

* Linked Lists are mostly used because of their effective insertion and deletion.  We only need to change few pointers (or references) to insert (or delete) an item in the middle
* [Insertion and deletion](
  at any point in a linked list take O(1) time. Whereas in an

  [array](
  data structure, insertion / deletion in the middle takes O(n) time.
* This data structure is simple and can be also used to implement

  [a stack](
  ,

  [queues,](
  and other

  [abstract data structures](
  .
* Implementation of Queue and Deque data structures : Simple array implementation is not efficient at all. We must use circular array to efficiently implement which is complex. But with linked list, it is easy and straightforward. That is why most of the language libraries use Linked List internally to implement these data structures..
* Linked List might turn out to be more space efficient compare to arrays in cases where we cannot guess the number of elements in advance. In case of arrays, the whole memory for items is allocated together. Even with dynamic sized arrays like vector in C++ or list in Python or ArrayList in Java. the internal working involves de-allocation of whole memory and allocation of a bigger chunk when insertions happen beyond the current capacity.

Applications of Linked Lists:

* Linked Lists can be used to implement stacks, queue, deque,

  [sparse matrices](
  and adjacency list representation of graphs.
* [Dynamic memory allocation](
  in operating systems and compilers (linked list of free blocks).
* Manipulation of polynomials
* Arithmetic operations on long integers.
* In operating systems, they can be used in Memory management, process scheduling (for example circular linked list for round robin scheduling) and file system.
* Algorithms that need to frequently insert or delete items from large collections of data.
* LRU cache, which uses a doubly linked list to keep track of the most recently used items in a cache.

Applications of Linked Lists in real world:

* The list of songs in the music player are linked to the previous and next songs.
* In a web browser, previous and next web page URLs can be linked through the previous and next buttons (Doubly Linked List)
* In image viewer, the previous and next images can be linked with the help of the previous and next buttons (Doubly Linked List)
* Circular Linked Lists can be used to implement things in round manner where we go to every element one by one.
* Linked List are preferred over arrays for implementations of Queue and Deque data structures because of fast deletions (or insertions) from the front of the linked lists.

Disadvantages of Linked Lists:


Linked lists are a popular data structure in computer science, but like any other data structure, they have certain disadvantages as well. Some of the key disadvantages of linked lists are:


* ****Slow Access Time:****
  Accessing elements in a linked list can be slow, as you need to traverse the linked list to find the element you are looking for, which is an O(n) operation. This makes linked lists a poor choice for situations where you need to access elements quickly.
* ****Pointers or References:****
  Linked lists use pointers or references to access the next node, which can make them more complex to understand and use compared to arrays. This complexity can make linked lists more difficult to debug and maintain.
* ****Higher overhead:****
  Linked lists have a higher overhead compared to arrays, as each node in a linked list requires extra memory to store the reference to the next node.
* ****Cache Inefficiency:****
  Linked lists are cache-inefficient because the memory is not contiguous. This means that when you traverse a linked list, you are not likely to get the data you need in the cache, leading to cache misses and slow performance.


In conclusion, linked lists are a powerful and flexible data structure, but they have certain disadvantages that need to be taken into consideration when deciding whether to use them or not. For example, if you need fast access time, arrays might be a better choice, but if you need to insert or delete elements frequently, linked lists might be the better choice.


Course Name: Introduction to DSA I

Lesson Name: C Arrays

Content:
Let’s take a look a simple example to demonstrate the use of vector



Table of Content

* [Syntax of Vector](#create-a-vector)
* [Declaration and Initialization](#initialize-a-vector)
* [Basic Vector Operations](#basic-vector-operations)

+ [Accessing Elements](#accessing-elements)
+ [Updating Elements](#updating-elements)
+ [Traversing Vector](#traversal)
+ [Inserting Elements](#insert)
+ [Deleting Elements](#delete)

* [Other Common Operations on Vector](#common-examples-of-vector-in-c)
* [Passing Vector to Functions](#passing-vector-to-functions)
* [Internal Working of Vector](#internal-working-of-vector)
* [2D Vectors](#2d-vectors)
* [All Member Functions of Vector](#all-member-functions-of-stdvector)

Syntax of Vector

Vector is defined as the ****std::vector****
class template which contains its implementation and some useful member
functions. It is defined inside the ****<vector>**** header file.

> ****vector****<**T**> vec\_name;

where,

* ****T:**** Type of elements in the vector.
* ****vec\_name:**** Name assigned to the vector.

To master vectors and other STL components, check out our [****Complete C++ Course****]( which covers the ins and outs of C++ STL with real-world examples and
hands-on projects.


Declaration and Initialization

Declaration and initialization are the process of creating an instance
of std::vector class and assigning it some initial value. In C++,
vectors can be declared and initialized in multiple ways as shown
below:

****1. Default Initialization****

An empty vector can be created using the below declaration. This vector
can be filled later on in the program.

> ****vector****<T> vec\_name;

****2. Initialization with Size and Default Value****

A vector of a specific size can also be declared and initialized to the
given value as default value.

> ****vector****<T> vec\_name(size, value);

****3. Initialization Using Initializer List****

Vector can also be initialized using a list of values enclosed in ****{} braces**** separated by comma.

> ****vector****<T> vec\_name = { v1, v2, v3….};
> ****vector****<T> vec\_name ({ v1, v2, v3….});

Let’s take a look at an example that shows implements the above



More ways to declare and initialize vectors are discussed in this
article – [8 Ways to Initialize Vector in C++](

Basic Vector Operations

The basic operations of vector are shown below:

### 1. Accessing Elements

Just like arrays, vector elements can be accessed using their index
inside the [****[] subscript operator****]( This method is fast but doesn’t check whether the given index exists
in the vector or not. So, there is another member method [****vector at()****]( for safely accessing elements:



To know more about accessing vector elements, refer to the article – [How to Access an Element in a Vector in C++?](

### 2. Updating Elements

Updating elements is very similar to the accessing except that we use
an additional assignment operator to assign a new value to a particular
element. It uses the same methods: [] subscript operator and vector
at().



More methods to update vector elements are discussed in this article – [How to Update Vector Elements in C++?](

### 3. Traversing Vector

Vector in C++ can be traversed using indexes in a loop. The indexes
start from 0 and go up to vector size – 1. To iterate through this
range, we can use a loop and determine the size of the vector using the [vector size()]( method.



More ways to traverse vectors are discussed in this article – [How to Iterate Through a Vector in C++?](

### 4. Inserting Elements

An element can be inserted into a vector using [****vector insert()****](
method which takes linear time. But for the insertion at the end, the [****vector push\_back()****](
method can be used. It is much faster, taking only constant time.


More ways to insert an element in the vector are discussed in this
article – [How to Add Elements in a Vector in C++?](

### 5. Deleting Elements

An element can be deleted from a vector using [****vector erase()****](
but this method needs iterator to the element to be deleted. If only the
value of the element is known, then find() function is used to find the
position of this element.

For the deletion at the end, the [****vector pop\_back()****](
method can be used, and it is much faster, taking only constant
time.



To know more about the deletion of an element in the vector, refer to
this article – [How to Remove an Element from Vector in C++?](

Other Common Operations on Vector

Vector is one of the most frequently used containers in C++. It is used
in many situations for different purposes. The following examples aim to
help you master vector operations beyond the basics.

Course Name: Introduction to DSA II
Lesson Name: Hash Functions and Types of Hash functions

Content:
What is a Hash Function?


A

****hash function****
is a function that takes an input (or ‘message’) and returns a fixed-size string of bytes. The output, typically a number, is called the

****hash code****
or

****hash value****
. The main purpose of a hash function is to efficiently map data of arbitrary size to fixed-size values, which are often used as indexes in hash tables.


### Key Properties of Hash Functions

* ****Deterministic****
  : A hash function must consistently produce the same output for the same input.
* ****Fixed Output Size****
  : The output of a hash function should have a fixed size, regardless of the size of the input.
* ****Efficiency****
  : The hash function should be able to process input quickly.
* ****Uniformity****
  : The hash function should distribute the hash values uniformly across the output space to avoid clustering.
* ****Pre-image Resistance****
  : It should be computationally infeasible to reverse the hash function, i.e., to find the original input given a hash value.
* ****Collision Resistance****
  : It should be difficult to find two different inputs that produce the same hash value.
* ****Avalanche Effect****
  : A small change in the input should produce a significantly different hash value.

Applications of Hash Functions

* ****Hash Tables****
  : The most common use of hash functions in DSA is in hash tables, which provide an efficient way to store and retrieve data.
* ****Data Integrity****
  : Hash functions are used to ensure the integrity of data by generating checksums.
* ****Cryptography****
  : In cryptographic applications, hash functions are used to create secure hash algorithms like SHA-256.
* ****Data Structures****
  : Hash functions are utilized in various data structures such as Bloom filters and hash sets.

Types of Hash Functions


There are many hash functions that use numeric or alphanumeric keys. This article focuses on discussing different hash functions:


1. Division Method.
2. Multiplication Method
3. Mid-Square Method
4. Folding Method
5. Cryptographic Hash Functions
6. Universal Hashing
7. Perfect Hashing


Let’s begin discussing these methods in detail.


1. Division Method


The division method involves dividing the key by a prime number and using the remainder as the hash value.


> **h**
> (
>
> **k**
> )=
>
> **k**
> mod
>
> **m**
>
>
> Where
>
> **k**
> is the key and 𝑚
>
> **m**
> is a prime number.

****Advantages****
:


* Simple to implement.
* Works well when 𝑚

  **m**
  is a prime number.

****Disadvantages****
:


* Poor distribution if 𝑚

  **m**
  is not chosen wisely.

2. Multiplication Method


In the multiplication method, a constant 𝐴

**A**
(0 < A < 1) is used to multiply the key. The fractional part of the product is then multiplied by 𝑚

**m**
to get the hash value.


> **h**
> (
>
> **k**
> )=⌊
>
> **m**
> (
>
> **kA**
> mod1)⌋
>
>
> Where ⌊ ⌋ denotes the floor function.

****Advantages****
:


* Less sensitive to the choice of 𝑚

  **m**
  .

****Disadvantages****
:


* More complex than the division method.

3. Mid-Square Method


In the mid-square method, the key is squared, and the middle digits of the result are taken as the hash value.


****Steps****
:


1. Square the key.
2. Extract the middle digits of the squared value.

****Advantages****
:


* Produces a good distribution of hash values.

****Disadvantages****
:


* May require more computational effort.

4. Folding Method


The folding method involves dividing the key into equal parts, summing the parts, and then taking the modulo with respect to 𝑚

**m**
.


****Steps****
:


1. Divide the key into parts.
2. Sum the parts.
3. Take the modulo 𝑚

   **m**
   of the sum.

****Advantages****
:


* Simple and easy to implement.

****Disadvantages****
:


* Depends on the choice of partitioning scheme.

5. Cryptographic Hash Functions


Cryptographic hash functions are designed to be secure and are used in cryptography. Examples include MD5, SHA-1, and SHA-256.


****Characteristics****
:


* Pre-image resistance.
* Second pre-image resistance.
* Collision resistance.

****Advantages****
:


* High security.

****Disadvantages****
:


* Computationally intensive.

6. Universal Hashing


Universal hashing uses a family of hash functions to minimize the chance of collision for any given set of inputs.


> **h**
> (
>
> **k**
> )=((
>
> **a**
> ⋅
>
> **k**
> +
>
> **b**
> )mod
>
> **p**
> )mod
>
> **m**
>
>
> Where
>
> **a**
> and
>
> **b**
> are randomly chosen constants,
>
> **p**
> is a prime number greater than
>
> **m**
> , and
>
> **k**
> is the key.

****Advantages****
:


* Reduces the probability of collisions.

****Disadvantages****
:


* Requires more computation and storage.

7. Perfect Hashing


Perfect hashing aims to create a collision-free hash function for a static set of keys. It guarantees that no two keys will hash to the same value.


****Types****
:


* Minimal Perfect Hashing: Ensures that the range of the hash function is equal to the number of keys.
* Non-minimal Perfect Hashing: The range may be larger than the number of keys.

****Advantages****
:


* No collisions.

****Disadvantages****
:


* Complex to construct.

Conclusion


In conclusion, hash functions are very important tools that help store and find data quickly. Knowing the different types of hash functions and how to use them correctly is key to making software work better and more securely. By choosing the right hash function for the job, developers can greatly improve the efficiency and reliability of their systems.


Course Name: Linked List Data Structure Guide
Lesson Name: Write a function to get Nth node in a Linked List

Content:
Given a

****LinkedList****
and an

****index****
(1-based). The task is to find the

****data value****
stored in the node at that

****kth****
position. If no such node exists whose index is

****k****
then

****return -1.****

****Example:****


> ****Input****
> : 1->10->30->14, index = 2
>
>
>
> ****Output****
> : 10
>
>
>
> ****Explanation****
> : The node value at index 2 is 10
>
>
> ![Maximum-of-all-subarrays-of-size-K](
>
>
>
> ****Input****
> : 1->32->12->10->30->14->100, index = 8
>
>
>
> ****Output****
> : -1
>
>
>
> ****Explanation****
> : No such node exists at index = 8.

Table of Content

* [[Naive Approach] Recursive Method – O(n) Time and O(n) Space](#approach-1-using-recursion-on-time-and-on-space)
* [[Expected Approach-2] Iterative Method – O(n) Time and O(1) Space](#approach-2-using-iterative-method-on-time-and-o1-space)
### ****[Naive Approach] Recursive Method – O(n) Time and O(n) Space****

> The idea is to use the
>
> [****recursive****](
> ****method****
> to find the value of
>
> ****index****
> node
>
> ****(1- based)****
> . Call the function
>
> ****GetNth(head,index)****
> recusively, where
>
> ****head****
> will represent the
>
> ****current head****
> node . Decrement the index
>
> ****value by 1****
> on every recursion call. When the
>
> ****n reaches 1****
> ,we will return the
>
> ****data****
> of current node.








****Time Complexity :****
O(n)

****,****
where n is the nth node of linked list.



****Auxiliary Space:****
O(n), for recursive call stack


### ****[Expected Approach-2] Iterative Method – O(n) Time and O(1) Space****

> The idea is similar to recursive
>
> ****approach to find****
> the value at
>
> ****index****
> node
>
> ****(1- based)****
> .We will use a variable say,
>
> ****count = 1****
> to track the node
>
> ****s.****
> Traverse the list until
>
> ****curr != NULL****
> . Increment the
>
>
> count
>
>
> if count is
>
> ****not equal****
> to
>
> ****index****
> node
>
> ****(1- based) ,****
> else if count equals to the
>
> ****index****
> node, return data at
>
> ****current****
> node.








****Time Complexity :****
O(n)

****,****
where n is the nth node of linked list.



****Auxiliary Space:****
O(1)

Course Name: Introduction to DSA II
Lesson Name: Collision Resolution Techniques

Content:
Collision Resolution Techniques


There are mainly two methods to handle collision:


1. Separate Chaining
2. Open Addressing

![Collision-Resolution-Techniques](

### 1) Separate Chaining


The idea behind

[Separate Chaining](
is to make each cell of the hash table point to a linked list of records that have the same hash function value. Chaining is simple but requires additional memory outside the table.


****Example****
: We have given a hash function and we have to insert some elements in the hash table using a separate chaining method for collision resolution technique.


> Hash function = key % 5,
>
>
>
> Elements = 12, 15, 22, 25 and 37.


Let’s see step by step approach to how to solve the above problem:









Hence In this way, the separate chaining method is used as the collision resolution technique.


### 2) Open Addressing


In

[open addressing](
, all elements are stored in the hash table itself. Each table entry contains either a record or NIL. When searching for an element, we examine the table slots one by one until the desired element is found or it is clear that the element is not in the table.


#### 2.a) Linear Probing


In linear probing, the hash table is searched sequentially that starts from the original location of the hash. If in case the location that we get is already occupied, then we check for the next location.


****Example:****
Let us consider a simple hash function as “key mod 5” and a sequence of keys that are to be inserted are 50, 70, 76, 85, 93.










#### 2.b) Quadratic Probing


Quadratic probing is an open addressing scheme in computer programming for resolving hash collisions in hash tables. Quadratic probing operates by taking the original hash index and adding successive values of an arbitrary quadratic polynomial until an open slot is found.


This method is also known as the mid-square method because in this method we look for i

2
th probe (slot) in i-th iteration and the value of i = 0, 1, . . . n – 1. We always start from the original hash location. If only the location is occupied then we check the other slots.



Example: Let us consider table Size = 7, hash function as Hash(x) = x % 7 and collision resolution strategy to be f(i) = i

2
. Insert = 22, 30, and 50








#### 2.c) Double Hashing


Double hashing is a collision resolving technique in

[Open Addressed](
Hash tables. Double hashing make use of two hash function,


* The first hash function is

  ****h1(k)****
  which takes the key and gives out a location on the hash table. But if the new location is not occupied or empty then we can easily place our key.
* But in case the location is occupied (collision) we will use secondary hash-function

  ****h2(k)****
  in combination with the first hash-function

  ****h1(k)****
  to find the new location on the hash table.


This combination of hash functions is of the form


> ****h(k, i) = (h1(k) + i \* h2(k)) % n****


where


* i is a non-negative integer that indicates a collision number,
* k = element/key which is being hashed
* n = hash table size.

****Complexity of the Double hashing algorithm:****

> Time complexity: O(n)

****Example:****
Insert the keys 27, 43, 692, 72 into the Hash Table of size 7. where first hash-function is

****h1​(k) = k mod 7****
and second hash-function is

****h2(k) = 1 + (k mod 5)****



Course Name: Introduction to DSA II
Lesson Name: Introduction to Divide and Conquer Algorithm

Content:
Table of Content

                                                                                                                                        * [Divide and Conquer Algorithm Definition](#divide-and-conquer-algorithm-definition)
                                                                                                                                        * [Working of Divide and Conquer Algorithm](#working-of-divide-and-conquer-algorithm)
                                                                                                                                        * [Characteristics of Divide and Conquer Algorithm](#characteristics-of-divide-and-conquer-algorithm)
                                                                                                                                        * [Examples of Divide and Conquer Algorithm](#examples-of-divide-and-conquer-algorithm)
                                                                                                                                        * [Complexity Analysis of Divide and Conquer Algorithm](#complexity-analysis-of-divide-and-conquer-algorithm)
                                                                                                                                        * [Applications of Divide and Conquer Algorithm](#applications-of-divide-and-conquer-algorithm)
                                                                                                                                        * [Advantages of Divide and Conquer Algorithm](#advantages-of-divide-and-conquer-algorithm)
                                                                                                                                        * [Disadvantages of Divide and Conquer Algorithm](#disadvantages-of-divide-and-conquer-algorithm)

                                                                                                                                        ****Divide and Conquer****

                                                                                                                                        Algorithm Definition:

                                                                                                                                        > ****Divide and Conquer Algorithm****
                                                                                                                                        > involves breaking a larger problem into smaller subproblems, solving them independently, and then combining their solutions to solve the original problem. The basic idea is to recursively divide the problem into smaller subproblems until they become simple enough to be solved directly. Once the solutions to the subproblems are obtained, they are then combined to produce the overall solution.

Working of Divide and Conquer Algorithm:


Divide and Conquer Algorithm can be divided into three steps:

****Divide****
                                                                                                                                       ,

                                                                                                                                    ****Conquer****
                                                                                                                                        and

                                                                                                                                    ****Merge****
                                                                                                                                        .


![Working-of-Divide-and-Conquer-Algorithm](

### ****1. Divide:****

* Break down the original problem into smaller subproblems.
* Each subproblem should represent a part of the overall problem.
* The goal is to divide the problem until no further division is possible.

### ****2. Conquer:****

* Solve each of the smaller subproblems individually.
* If a subproblem is small enough (often referred to as the “base case”), we solve it directly without further recursion.
* The goal is to find solutions for these subproblems independently.

### 3. Merge:

* Combine the sub-problems to get the final solution of the whole problem.
* Once the smaller subproblems are solved, we recursively combine their solutions to get the solution of larger problem.
* The goal is to formulate a solution for the original problem by merging the results from the subproblems.

Characteristics of Divide and Conquer Algorithm:


Divide and Conquer Algorithm involves breaking down a problem into smaller, more manageable parts, solving each part individually, and then combining the solutions to solve the original problem. The characteristics of Divide and Conquer Algorithm are:



                                                                                                                                    * ****Dividing the Problem****
                                                                                                                                    : The first step is to break the problem into smaller, more manageable subproblems. This division can be done recursively until the subproblems become simple enough to solve directly.
* ****Independence of Subproblems****
  : Each subproblem should be independent of the others, meaning that solving one subproblem does not depend on the solution of another. This allows for parallel processing or concurrent execution of subproblems, which can lead to efficiency gains.
* ****Conquering Each Subproblem****
  : Once divided, the subproblems are solved individually. This may involve applying the same divide and conquer approach recursively until the subproblems become simple enough to solve directly, or it may involve applying a different algorithm or technique.
                                                                                                                                    * ****Combining Solutions****
                                                                                                                                    : After solving the subproblems, their solutions are combined to obtain the solution to the original problem. This combination step should be relatively efficient and straightforward, as the solutions to the subproblems should be designed to fit together seamlessly.

                                                                                                                                    ****Examples of Divide and Conquer Algorithm:****

                                                                                                                                    ### ****1. Finding the maximum element in the array:****


                                                                                                                                    We can use Divide and Conquer Algorithm to find the maximum element in the array by dividing the array into two equal sized subarrays, finding the maximum of those two individual halves by again dividing them into two smaller halves. This is done till we reach subarrays of size 1. After reaching the elements, we return the maximum element and combine the subarrays by returning the maximum in each subarray.






### ****2. Finding the minimum element in the array:****


Similarly, we can use Divide and Conquer Algorithm to find the minimum element in the array by dividing the array into two equal sized subarrays, finding the minimum of those two individual halves by again dividing them into two smaller halves. This is done till we reach subarrays of size 1. After reaching the elements, we return the minimum element and combine the subarrays by returning the minimum in each subarray.


### 3. [Merge Sort:](


We can use Divide and Conquer Algorithm to sort the array in ascending or descending order by dividing the array into smaller subarrays, sorting the smaller subarrays and then merging the sorted arrays to sort the original array.


Complexity Analysis of Divide and Conquer Algorithm:

> T(n) = aT(n/b) + f(n), where
> n = size of input
> a = number of subproblems in the recursion
> n/b = size of each subproblem. All subproblems are assumed to have the same size.
> f(n) = cost of the work done outside the recursive call, which includes the cost of dividing the problem and cost of merging the solutions

Applications of Divide and Conquer Algorithm:


The following are some standard algorithms that follow Divide and Conquer algorithm:


* [****Quicksort****](
  is a sorting algorithm that picks a pivot element and rearranges the array elements so that all elements smaller than the picked pivot element move to the left side of the pivot, and all greater elements move to the right side. Finally, the algorithm recursively sorts the subarrays on the left and right of the pivot element.
* [****Merge Sort****](
  is also a sorting algorithm. The algorithm divides the array into two halves, recursively sorts them, and finally merges the two sorted halves.
* [****Closest Pair of Points****](
  The problem is to find the closest pair of points in a set of points in the x-y plane. The problem can be solved in O(n^2) time by calculating the distances of every pair of points and comparing the distances to find the minimum. The Divide and Conquer algorithm solves the problem in O(N log N) time.
* [****Strassen’s Algorithm****](
  is an efficient algorithm to multiply two matrices. A simple method to multiply two matrices needs 3 nested loops and is O(n^3). Strassen’s algorithm multiplies two matrices in O(n^2.8974) time.
* [****Cooley–Tukey Fast Fourier Transform (FFT) algorithm****](
  is the most common algorithm for FFT. It is a divide and conquer algorithm which works in O(N log N) time.
* [****Karatsuba algorithm for fast multiplication****](
  does the multiplication of two binary strings in O(n

  1.59
  ) where n is the length of binary string.

****Advantages of Divide and Conquer Algorithm:****

* ****Solving difficult problems:****
  Divide and conquer technique is a tool for solving difficult problems conceptually. e.g. Tower of Hanoi puzzle. It requires a way of breaking the problem into sub-problems, and solving all of them as an individual cases and then combining sub- problems to the original problem.
* ****Algorithm efficiency:****
  The divide-and-conquer algorithm often helps in the discovery of efficient algorithms. It is the key to algorithms like Quick Sort and Merge Sort, and fast Fourier transforms.
* ****Parallelism:****
  Normally Divide and Conquer algorithms are used in multi-processor machines having shared-memory systems where the communication of data between processors does not need to be planned in advance, because distinct sub-problems can be executed on different processors.
* ****Memory access:****
  These algorithms naturally make an efficient use of memory caches. Since the subproblems are small enough to be solved in cache without using the main memory that is slower one. Any algorithm that uses cache efficiently is called cache oblivious.

****Disadvantages of Divide and Conquer Algorithm:****

* ****Overhead:****
  The process of dividing the problem into subproblems and then combining the solutions can require additional time and resources. This overhead can be significant for problems that are already relatively small or that have a simple solution.
* ****Complexity:****
  Dividing a problem into smaller subproblems can increase the complexity of the overall solution. This is particularly true when the subproblems are interdependent and must be solved in a specific order.
* ****Difficulty of implementation:****
  Some problems are difficult to divide into smaller subproblems or require a complex algorithm to do so. In these cases, it can be challenging to implement a divide and conquer solution.
* ****Memory limitations:****
  When working with large data sets, the memory requirements for storing the intermediate results of the subproblems can become a limiting factor.

Frequently Asked Questions (FAQs) on Divide and Conquer Algorithm:

### ****1. What is the Divide and Conquer algorithm?****

> Divide and Conquer is a problem-solving technique where a problem is divided into smaller, more manageable subproblems. These subproblems are solved recursively, and then their solutions are combined to solve the original problem.

### ****2. What are the key steps involved in the Divide and Conquer algorithm?****

> The main steps are:
>
>
> ****Divide****
> : Break the problem into smaller subproblems.
>
>
> ****Conquer****
> : Solve the subproblems recursively.
>
>
> ****Combine****
> : Merge or combine the solutions of the subproblems to obtain the solution to the original problem.

### ****3. What are some examples of problems solved using Divide and Conquer?****

> Divide and Conquer Algorithm is used in sorting algorithms like Merge Sort and Quick Sort, finding closest pair of points, Strassen’s Algorithm, etc.

### ****4. How does Merge Sort use the Divide and Conquer approach?****

> Merge Sort divides the array into two halves, recursively sorts each half, and then merges the sorted halves to produce the final sorted array.

### ****5. What is the time complexity of Divide and Conquer algorithms?****

> The time complexity varies depending on the specific problem and how it’s implemented. Generally, many Divide and Conquer algorithms have a time complexity of O(n log n) or better.

### ****6. Can Divide and Conquer algorithms be parallelized?****

> Yes, Divide and Conquer algorithms are often naturally parallelizable because independent subproblems can be solved concurrently. This makes them suitable for parallel computing environments.

### ****7. What are some strategies for choosing the base case in Divide and Conquer algorithms?****

> The base case should be simple enough to solve directly, without further division. It’s often chosen based on the smallest input size where the problem can be solved trivially.

### ****8. Are there any drawbacks or limitations to using Divide and Conquer?****

> While Divide and Conquer can lead to efficient solutions for many problems, it may not be suitable for all problem types. Overhead from recursion and combining solutions can also be a concern for very large problem sizes.

### ****9. How do you analyze the space complexity of Divide and Conquer algorithms?****

> Space complexity depends on factors like the recursion depth and auxiliary space required for combining solutions. Analyzing space complexity typically involves considering the space used by each recursive call.

### ****10. What are some common advantages of Divide and Conquer Algorithm?****

> Divide and Conquer Algorithm has numerous advantages. Some of them include:
>
>
> * Solving difficult problems
> * Algorithm efficiency
> * Parallelism
> * Memory access


Divide and Conquer is a popular algorithmic technique in computer science that involves breaking down a problem into smaller sub-problems, solving each sub-problem independently, and then combining the solutions to the sub-problems to solve the original problem. The basic idea behind this technique is to divide a problem into smaller, more manageable sub-problems that can be solved more easily.



Course Name: Introduction to DSA II
Lesson Name: What is Stack Data Structure? A Complete Tutorial

Content:
Representation of Stack Data Structure:


Stack follows LIFO (Last In First Out) Principle so the element which is pushed last is popped first.


![Stack-representation-in-Data-Structures-(1)](

****Types of Stack:****

* ****Fixed Size Stack****
  : As the name suggests, a fixed size stack has a fixed size and cannot grow or shrink dynamically. If the stack is full and an attempt is made to add an element to it, an overflow error occurs. If the stack is empty and an attempt is made to remove an element from it, an underflow error occurs.
* ****Dynamic Size Stack****
  : A dynamic size stack can grow or shrink dynamically. When the stack is full, it automatically increases its size to accommodate the new element, and when the stack is empty, it decreases its size. This type of stack is implemented using a linked list, as it allows for easy resizing of the stack.

Basic Operations on Stack:


In order to make manipulations in a stack, there are certain operations provided to us.


* ****push()****
  to insert an element into the stack
* ****pop()****
  to remove an element from the stack
* ****top()****
  Returns the top element of the stack.
* ****isEmpty()****
  returns true if stack is empty else false.
* ****isFull()****
  returns true if the stack is full else false.


To implement stack, we need to maintain reference to the top item.


### ****Push Operation on Stack****


Adds an item to the stack. If the stack is full, then it is said to be an

****Overflow condition.****

****Algorithm for Push Operation:****


* Before pushing the element to the stack, we check if the stack is

  ****full****
  .
* If the stack is full

  ****(top == capacity-1)****
  , then

  ****Stack Overflows****
  and we cannot insert the element to the stack.
* Otherwise, we increment the value of top by 1

  ****(top = top + 1)****
  and the new value is inserted at

  ****top position****
  .
* The elements can be pushed into the stack till we reach the

  ****capacity****
  of the stack.

![Push-Operation-in-Stack-(1)](
### ****Pop Operation in Stack****


Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an

****Underflow condition.****

****Algorithm for Pop Operation:****

* Before popping the element from the stack, we check if the stack is

  ****empty****
  .
* If the stack is empty (top == -1), then

  ****Stack Underflows****
  and we cannot remove any element from the stack.
* Otherwise, we store the value at top, decrement the value of top by 1

  ****(top = top – 1)****
  and return the stored top value.

![Pop-Operation-in-Stack-(1)](
### ****Top or Peek Operation on Stack****


Returns the top element of the stack.


****Algorithm for Top Operation:****

* Before returning the top element from the stack, we check if the stack is empty.
* If the stack is empty (top == -1), we simply print “Stack is empty”.
* Otherwise, we return the element stored at

  ****index = top****
  .

![Top-or-Peek-Operation-in-Stack-(1)](
### ****isEmpty Operation in Stack Data Structure:****


Returns true if the stack is empty, else false.


****Algorithm for isEmpty Operation****
:


* Check for the value of

  ****top****
  in stack.
* If

  ****(top == -1)****
  , then the stack is

  ****empty****
  so return

  ****true****
  .
* Otherwise, the stack is not empty so return

  ****false****
  .

![isEmpty-Operation-in-Stack-(1)](
### isFull ****Operation in Stack**** ****Data Structure**** :


Returns true if the stack is full, else false.


****Algorithm for isFull Operation:****

* Check for the value of

  ****top****
  in stack.
* If

  ****(top == capacity-1),****
  then the stack is

  ****full****
  so return

  ****true****
  .
* Otherwise, the stack is not full so return

  ****false****
  .

![isFull-Operation-in-Stack-(1)](

Implementation of Stack


The basic operations that can be performed on a stack include push, pop, and peek. There are two ways to implement a stack –


* [****Implementation of Stack using Array****](
* [****Implementation of Stack using Linked List****](



Course Name: The Logic Building Problems
Lesson Name: The Logic Building Problems

Content:

You are given a

****cubic dice****
with

****6****
faces. All the individual faces have a number printed on them. The numbers are in the range of

****1 to 6****
, like any ordinary dice. You will be provided with a face of this cube, your task is to guess the number on the opposite face of the cube.


****Examples:****

> ****Input:****
> n = 2
>
>
>
> ****Output:****
> 5
>
>
>
> ****Explanation:****
> For dice facing number 5 opposite face will have the number 2.
>
>
> ****Input:****
> 6 = 6
>
>
>
> ****Output:****
> 1

Table of Content

* [[Naive Approach] Using if-else – O(1) Time and O(1) Space](#naive-approach-using-ifelse-o1-time-and-o1-space)
* [[Expected Approach] Using Sum of two sides – O(1) Time and O(1) Space](#expected-approach-using-sum-of-two-sides-o1-time-and-o1-space)
### ****[Naive Approach] Using if-else – O(1) Time and O(1) Space****

> In a normal 6-faced dice, 1 is opposite to 6, 2 is opposite to 5, and 3 is opposite to 4. Hence a normal if-else-if block can be placed






### [Expected Approach] Using Sum of two sides – O(1) Time and O(1) Space

> The idea is based on the observation that the sum of two opposite sides of a cubical dice is equal to
>
> ****7****
> . So, just subtract the given
>
> ****n****
> from
>
> ****7****
> and print the answer.







*****Time Complexity:*****
**O(1)**


*****Auxiliary Space:*****
**O(1)**


Course Name: Linked List Data Structure Guide
Lesson Name: Delete a Linked List node at a given position

Content:
Given a singly linked list and a position (1-based indexing), the task is to delete a linked list node at the given position.


****Note:****
Position will be valid (i.e, 1 <= position <= linked list length)


****Example:****


> ****Input:****
> position = 2, Linked List = 8->2->3->1->7
>
>
>
> ****Output:****
> Linked List =  8->3->1->7
>
>
> ****Input:****
> position = 1, Linked List = 8->2->3->1->7
>
>
>
> ****Output:****
> Linked List = 2->3->1->7

****Approach:****


Deletion at a specified position in a linked list involves removing a node from a specific index/position, which can be the first, middle, or last node.


> To perform the deletion, If the position is 1, we update the
>
> ****head****
> to point to the
>
> ****next node****
> and delete the current head. For other positions, we traverse the list to reach the node just before the specified
>
> ****position****
> . If the target node exists, we adjust the next of this previous node to point to next of
>
> ****next nodes****
> , which will result in skipping the target node.

![Deletion-specific-At-End--](

Delete a Linked List node at a given position


Step-by-step approach:


* If list is empty (

  ****head****
  ==

  ****NULL)****
  , returns the

  ****head****
  .
* If the

  ****position****
  to delete is

  ****1****
  (the head node):
  + Update

    ****head = temp->next****
* Traverse the list until reaching the desired position:
  + Initialize

    ****prev****
    to keep track of the previous node.
  + Move

    ****temp****
    through the list until the position is reached.
* Check for Valid Position:
  + If

    ****temp****
    becomes

    ****NULL****
    , it means the position exceeds the number of nodes in the list. Print a message and return the

    ****head****
    .
* If the node to delete is found:
  + Set

    ****prev->next****
    to

    ****temp->next****
    , effectively skipping over the node to be deleted.







****Time Complexity****
: O(n), where n is the number of nodes in the list



****Auxiliary Space:****
O(1)


Course Name: The Logic Building Problems
Lesson Name: Program to find sum of first n natural numbers

Content:

Given a number n, find the sum of the first natural numbers.


****Examples :****


> ****Input:****
> n = 3
>
>
>
> ****Output:****
> 6
>
>
>
> ****Explanation****
> : Note that 1 + 2 + 3 = 6
>
>
>
>
>
> ****Input****
> : 5
>
>
>
> ****Output****
> : 15
>
>
>
> ****Explanation****
> : Note that 1 + 2 + 3 + 4 + 5 = 15

### Naive Solution – O(n) Time and O(1) Space


Calculate the sum of all integers from 1 to

`n`
by iterating through a loop.








### Expected Approach – O(1) Time and O(1) Space


An

****efficient solution****
is to use the below formula.


> ****Sum of first n natural numbers = (n \* (n+1)) / 2****
>
>
> For example: n = 5
>
>
>
> Sum = (5 \* (5 + 1)) / 2 = (5 \* 6) / 2 = 30 / 2 = 15

****How does this work?****

> ****We can prove this formula using induction.****
>
>
>
>
> It is true for n = 1 and n = 2
>
>
>
> For n = 1, sum = 1 \* (1 + 1)/2 = 1
>
>
>
> For n = 2, sum = 2 \* (2 + 1)/2 = 3
>
>
>
>
>
> Let it be true for k = n-1.
>
>
>
>
>
> Sum of k numbers = (k \* (k+1))/2
>
>
>
> Putting k = n-1, we get
>
>
>
> Sum of k numbers = ((n-1) \* (n-1+1))/2
>
>
>
> = (n – 1) \* n / 2
>
>
>
>
>
> If we add n, we get,
>
>
>
> Sum of n numbers = n + (n – 1) \* n / 2
>
>
>
> = (2n + n
>
> 2
> – n)/2
>
>
>
> = n \* (n + 1)/2









****Note:****
The above program causes

****overflow,****
even if the

****result****
is not beyond the

****integer limit****
. We can avoid overflow up to some extent by

****dividing first****
.










Course Name: Linked List Data Structure Guide
Lesson Name: Write a function to delete a Linked List

Content:
Given a

****linked list****
, the task is to

****delete****
the linked list completely.


****Examples:****

> ****Input:****
> head: 1 -> 2 -> 3 -> 4 -> 5 -> NULL
>
>
>
> ****Output:****
> NULL
>
>
>
> ****Explanation:****
> Linked List is Deleted.
>
>
>
>
>
> ****Input:****
> head: 1 -> 12 -> 1 -> 4 -> 1 -> NULL
>
>
>
> ****Output:****
> NULL
>
>
>
> ****Explanation:****
> Linked List is Deleted.

Table of Content

* [[Expected Approach – 1] Using Recursion – O(n) Time and O(n) Space](#expected-approach-1-using-recursion-on-time-and-on-space)
* [[Expected Approach – 2] Using Iteration – O(n) Time and O(1) Space](#expected-approach-2-using-iteration-on-time-and-o1-space)
### [Expected Approach – 1] Using Recursion – O(n) Time and O(n) Space:

> The idea is to use
>
> [****recursion****](
> to delete the entire linked list. Traverse from the
>
> ****head****
> to the
>
> ****end****
> of the list recursively. While backtracking, delete the
>
> ****currrent****
> node. This ensures that each node is processed after its subsequent nodes.








****Time Complexity:****
O(n), where

****n****
is the number of nodes in the given linked list.



****Auxiliary Space:****
O(n)


### [Expected Approach – 2] Using Iteration – O(n) Time and O(1) Space:

> The idea is to
>
> ****iteratively****
> delete the list by starting from the
>
> ****head****
> and moving towards the
>
> ****end****
> . At each step, the function stores a
>
> ****reference****
> to the
>
> ****next****
> node, deletes the
>
> ****current****
> node, and
>
> ****moves****
> to the next node. This continues until all nodes are deleted.








****Time Complexity:****
O(n), where

****n****
is the number of nodes in the given linked list.



****Auxiliary Space:****
O(1)

Course Name: The Logic Building Problems
Lesson Name: Print all Jumping Numbers smaller than or equal to a given value

Content:
A number is called as a

****Jumping Number****
if all adjacent digits in it differ by

****1****
. The difference between

****‘9****
’ and

****‘0’****
is not considered as 1.



All single digit numbers are considered as Jumping Numbers. For example 7, 8987 and 4343456 are

****Jumping numbers****
but 796 and 89098 are not.



Given a positive number

****x****
, print all

****Jumping Numbers****
smaller than or equal to

****x****
. The numbers can be printed in any order.



One

****Simple Solution****
is to traverse all

[numbers](
from

****0****
to

****x****
. For every traversed number, check if it is a Jumping number. If

****yes****
, then print it. Otherwise ignore it.







*****Time Complexity:*****
O(x)



*****Auxiliary Space:*****
O(1)


An

****Efficient Solution****
can solve this problem in

****O(k)****
time where

****k****
is number of Jumping Numbers smaller than or equal to

****x****
. The idea is use

[BFS](
or

[DFS](
.



Assume that we have a graph where the starting node is

****0****
and we need to traverse it from the start node to all the reachable nodes.


With the restrictions given in the graph about the jumping numbers, what do you think should be the restrictions defining the next transitions in the graph.



Below is BFS based implementation of above idea.







*****Time Complexity:*****
O(k) time where

****k****
is number of Jumping Numbers smaller than or equal to

****x****


*****Auxiliary Space:*****
O(1)


Thanks to Gaurav Ahirwar for above solution.


****Exercise:****


1. Change the above solution to use DFS instead of BFS.
2. Extend your solution to print all numbers in sorted order instead of any order.
3. Further extend the solution to print all numbers in a given range.

****DFS based solution:****


In the

[DFS](
based approach we start building our numbers from single digits , i.e. from 1 – 9. Then we check for next possible digit and if possible we call the dfs for those numbers, increasing the number of digits with each call.








****Time Complexity:****
O(k)


Here k is the total number of jumping numbers.


****Auxiliary Space:****
O(len(N))


Here len(N) is the maximum length from all the jumping numbers, the extra space is used due to recursive function call stack.



Course Name: The Logic Building Problems
Lesson Name: Fraction to Recurring Decimal

Content:
Given two integers ****a**** and ****b**** (b != 0), the task is to return the fraction ****a/b**** in string format. If the fractional part is repeating, enclose the repeating part in parentheses.****Examples:****


> ****Input****
> : a = 1, b = 2
>
>
>
> ****Output****
> : “0.5”
>
>
>
> ****Explanation:****
> 1/2 = 0.5 with no repeating part.
>
>
>
>
>
> ****Input****
> : a = 50, b = 22
>
>
>
> ****Output****
> : “2.(27)”
>
>
>
> ****Explanation:****
> 50/22 = 2.27272727… Since fractional part (27) is repeating, it is enclosed in parentheses.

****Approach****
:


> The idea is to first calculate the integral quotient (absolute part before decimal point) and then calculate the fractional part. To check if the fractional part is repeating, insert the remainder (a % b) in a
>
> [hash map](
> with key as remainder and value as the index position at which this remainder occurs. If at any point of time, the remainder becomes zero, then there doesn’t exist a repeating fraction otherwise if the remainder is already found in the map, then there exists a repeating fraction.







****Time Complexity****
: O(max(log10(a), log10(b))), we can make any number of recurring digits in the fraction. For example:


* 2/9 = 0.22222..
* 21/99 = 0.212121…
* 213/999 = 0.213213…
* 2134/9999 = 0.21342134…
* 21345/99999 = 0.2134521345… and so on.

****Auxiliary Space****
: O(max(log10(a), log10(b))), to store the result.



Course Name: Queue
Lesson Name: Different Types of Queues and its Applications

Content:
**Types of Queues:**

There are **five different types of queues** that are used in
different scenarios. They are:

1. Input Restricted Queue (this is a Simple Queue)
2. Output Restricted Queue (this is also a Simple Queue)
3. Circular Queue
4. Double Ended Queue (Deque)
5. Priority Queue
   * Ascending Priority Queue
   * Descending Priority Queue

![Types of Queues](

Types of Queues

**1.** [**Circular Queue**]( Circular Queue is a linear data structure in which the
operations are performed based on FIFO (First In First Out) principle and
the last position is connected back to the first position to make a
circle. It is also called **‘Ring Buffer’**. This queue is
primarily used in the following cases:

1. **Memory Management:** The unused memory locations in the
   case of ordinary queues can be utilized in circular queues.
2. **Traffic system:** In a computer-controlled traffic
   system, circular queues are used to switch on the traffic lights one by
   one repeatedly as per the time set.
3. **CPU Scheduling:** Operating systems often maintain a
   queue of processes that are ready to execute or that are waiting for a
   particular event to occur.

The time complexity for the circular Queue is O(1).

**2. Input restricted Queue:** In this type of Queue, the
input can be taken from one side only(rear) and deletion of elements can
be done from both sides(front and rear). This kind of Queue does not
follow FIFO(first in first out).  This queue is used in cases where
the consumption of the data needs to be in FIFO order but if there is a
need to remove the recently inserted data for some reason and one such
case can be irrelevant data, performance issue, etc.



![Input Restricted Queue](

Input Restricted Queue

**Advantages of Input restricted Queue:**

* Prevents overflow and overloading of the queue by limiting the number of
  items added
* Helps maintain stability and predictable performance of the system

**Disadvantages of Input restricted Queue:**

* May lead to resource wastage if the restriction is set too low and items
  are frequently discarded
* May lead to waiting or blocking if the restriction is set too high and
  the queue is full, preventing new items from being added.

**3. Output restricted Queue:** In this type of Queue, the
input can be taken from both sides(rear and front) and the deletion of the
element can be done from only one side(front).  This queue is used in
the case where the inputs have some priority order to be executed and the
input can be placed even in the first place so that it is executed
first.

![Output Restricted Queue](

Output Restricted Queue

**4.** [**Double ended Queue**]( Double Ended Queue is also a Queue data structure in
which the insertion and deletion operations are performed at both the ends
(front and rear). That means, we can insert at both front and rear
positions and can delete from both front and rear positions.  Since
Deque supports both stack and queue operations, it can be used as both.
The Deque data structure supports clockwise and anticlockwise rotations in
O(1) time which can be useful in certain applications. Also, the problems
where elements need to be removed and or added both ends can be
efficiently solved using Deque.

![Double Ended Queue](

Double Ended Queue

**5.** [**Priority Queue**]( A priority queue is a special type of queue in which
each element is associated with a priority and is served according to its
priority. There are two types of Priority Queues. They are:

1. **Ascending Priority Queue:** Element can be inserted
   arbitrarily but only smallest element can be removed. For example,
   suppose there is an array having elements 4, 2, 8 in the same order. So,
   while inserting the elements, the insertion will be in the same sequence
   but while deleting, the order will be 2, 4, 8.
2. **Descending priority Queue:** Element can be inserted
   arbitrarily but only the largest element can be removed first from the
   given Queue. For example, suppose there is an array having elements 4,
   2, 8 in the same order. So, while inserting the elements, the insertion
   will be in the same sequence but while deleting, the order will be 8, 4,
   2.

The time complexity of the Priority Queue is O(logn).

[**Applications of a Queue:**](

The
[queue](
is used when things don’t have to be processed immediately, but have to be
processed in First In First Out order like
[Breadth First Search]( This property of Queue makes it also useful in the following kind of
scenarios.

1. When a resource is shared among multiple consumers. Examples include
   [CPU scheduling](
   [Disk Scheduling](
2. When data is transferred asynchronously (data not necessarily received
   at the same rate as sent) between two processes. Examples include IO
   Buffers,
   [pipes]( file IO, etc.
3. Linear Queue: A linear queue is a type of queue where data elements are
   added to the end of the queue and removed from the front of the queue.
   Linear queues are used in applications where data elements need to be
   processed in the order in which they are received. Examples include
   printer queues and message queues.
4. Circular Queue: A circular queue is similar to a linear queue, but the
   end of the queue is connected to the front of the queue. This allows for
   efficient use of space in memory and can improve performance. Circular
   queues are used in applications where the data elements need to be
   processed in a circular fashion. Examples include CPU scheduling and
   memory management.
5. Priority Queue: A priority queue is a type of queue where each element
   is assigned a priority level. Elements with higher priority levels are
   processed before elements with lower priority levels. Priority queues
   are used in applications where certain tasks or data elements need to be
   processed with higher priority. Examples include operating system task
   scheduling and network packet scheduling.
6. Double-ended Queue: A double-ended queue, also known as a deque, is a
   type of queue where elements can be added or removed from either end of
   the queue. This allows for more flexibility in data processing and can
   be used in applications where elements need to be processed in multiple
   directions. Examples include job scheduling and searching algorithms.
7. Concurrent Queue: A concurrent queue is a type of queue that is designed
   to handle multiple threads accessing the queue simultaneously.
   Concurrent queues are used in multi-threaded applications where data
   needs to be shared between threads in a thread-safe manner. Examples
   include database transactions and web server requests.

**Issues of Queue :**

Some common issues that can arise when using queues:

1. Queue overflow: Queue overflow occurs when the queue reaches its maximum
   capacity and is unable to accept any more elements. This can cause data
   loss and can lead to application crashes.
2. Queue underflow: Queue underflow occurs when an attempt is made to
   remove an element from an empty queue. This can cause errors and
   application crashes.
3. Priority inversion: Priority inversion occurs in priority queues when a
   low-priority task holds a resource that a high-priority task needs. This
   can cause delays in processing and can impact system performance.
4. Deadlocks: Deadlocks occur when multiple threads or processes are
   waiting for each other to release resources, resulting in a situation
   where none of the threads can proceed. This can happen when using
   concurrent queues and can lead to system crashes.
5. Performance issues: Queue performance can be impacted by various
   factors, such as the size of the queue, the frequency of access, and the
   type of operations performed on the queue. Poor queue performance can
   lead to slower system performance and reduced user experience.
6. Synchronization issues: Synchronization issues can arise when multiple
   threads are accessing the same queue simultaneously. This can result in
   data corruption, race conditions, and other errors.
7. Memory management issues: Queues can use up significant amounts of
   memory, especially when processing large data sets. Memory leaks and
   other memory management issues can occur, leading to system crashes and
   other errors.

**Reference :**

Some references for further reading on queues:

1. “Data Structures and Algorithms in Java” by Robert Lafore – This book
   provides an in-depth explanation of different types of queues and their
   implementations in Java.
2. “Introduction to Algorithms” by Thomas H. Cormen et al. – This textbook
   covers the basic concepts of data structures and algorithms, including
   queues and their various applications.
3. “Concurrency in C# Cookbook” by Stephen Cleary – This book provides
   practical examples of how to use concurrent queues in C# programming.
4. “Queue (abstract data type)” on Wikipedia – This article provides an
   overview of queues and their properties, as well as examples of their
   applications.
5. “The Art of Computer Programming, Volume 1: Fundamental Algorithms” by
   Donald E. Knuth – This book includes a detailed analysis of different
   queue algorithms and their performance.
6. “Queues and the Producer-Consumer Problem” by Douglas C. Schmidt – This
   paper discusses how queues can be used to solve the producer-consumer
   problem in concurrent programming.

Course Name: Queue
Lesson Name: Different Types of Queues and its Applications

Content:
**Types of Queues:**

There are **five different types of queues** that are used in
different scenarios. They are:

1. Input Restricted Queue (this is a Simple Queue)
2. Output Restricted Queue (this is also a Simple Queue)
3. Circular Queue
4. Double Ended Queue (Deque)
5. Priority Queue
   * Ascending Priority Queue
   * Descending Priority Queue

![Types of Queues](

Types of Queues

**1.** [**Circular Queue**]( Circular Queue is a linear data structure in which the
operations are performed based on FIFO (First In First Out) principle and
the last position is connected back to the first position to make a
circle. It is also called **‘Ring Buffer’**. This queue is
primarily used in the following cases:

1. **Memory Management:** The unused memory locations in the
   case of ordinary queues can be utilized in circular queues.
2. **Traffic system:** In a computer-controlled traffic
   system, circular queues are used to switch on the traffic lights one by
   one repeatedly as per the time set.
3. **CPU Scheduling:** Operating systems often maintain a
   queue of processes that are ready to execute or that are waiting for a
   particular event to occur.

The time complexity for the circular Queue is O(1).

**2. Input restricted Queue:** In this type of Queue, the
input can be taken from one side only(rear) and deletion of elements can
be done from both sides(front and rear). This kind of Queue does not
follow FIFO(first in first out).  This queue is used in cases where
the consumption of the data needs to be in FIFO order but if there is a
need to remove the recently inserted data for some reason and one such
case can be irrelevant data, performance issue, etc.



![Input Restricted Queue](

Input Restricted Queue

**Advantages of Input restricted Queue:**

* Prevents overflow and overloading of the queue by limiting the number of
  items added
* Helps maintain stability and predictable performance of the system

**Disadvantages of Input restricted Queue:**

* May lead to resource wastage if the restriction is set too low and items
  are frequently discarded
* May lead to waiting or blocking if the restriction is set too high and
  the queue is full, preventing new items from being added.

**3. Output restricted Queue:** In this type of Queue, the
input can be taken from both sides(rear and front) and the deletion of the
element can be done from only one side(front).  This queue is used in
the case where the inputs have some priority order to be executed and the
input can be placed even in the first place so that it is executed
first.

![Output Restricted Queue](

Output Restricted Queue

**4.** [**Double ended Queue**]( Double Ended Queue is also a Queue data structure in
which the insertion and deletion operations are performed at both the ends
(front and rear). That means, we can insert at both front and rear
positions and can delete from both front and rear positions.  Since
Deque supports both stack and queue operations, it can be used as both.
The Deque data structure supports clockwise and anticlockwise rotations in
O(1) time which can be useful in certain applications. Also, the problems
where elements need to be removed and or added both ends can be
efficiently solved using Deque.

![Double Ended Queue](

Double Ended Queue

**5.** [**Priority Queue**]( A priority queue is a special type of queue in which
each element is associated with a priority and is served according to its
priority. There are two types of Priority Queues. They are:

1. **Ascending Priority Queue:** Element can be inserted
   arbitrarily but only smallest element can be removed. For example,
   suppose there is an array having elements 4, 2, 8 in the same order. So,
   while inserting the elements, the insertion will be in the same sequence
   but while deleting, the order will be 2, 4, 8.
2. **Descending priority Queue:** Element can be inserted
   arbitrarily but only the largest element can be removed first from the
   given Queue. For example, suppose there is an array having elements 4,
   2, 8 in the same order. So, while inserting the elements, the insertion
   will be in the same sequence but while deleting, the order will be 8, 4,
   2.

The time complexity of the Priority Queue is O(logn).

[**Applications of a Queue:**](

The
[queue](
is used when things don’t have to be processed immediately, but have to be
processed in First In First Out order like
[Breadth First Search]( This property of Queue makes it also useful in the following kind of
scenarios.

1. When a resource is shared among multiple consumers. Examples include
   [CPU scheduling](
   [Disk Scheduling](
2. When data is transferred asynchronously (data not necessarily received
   at the same rate as sent) between two processes. Examples include IO
   Buffers,
   [pipes]( file IO, etc.
3. Linear Queue: A linear queue is a type of queue where data elements are
   added to the end of the queue and removed from the front of the queue.
   Linear queues are used in applications where data elements need to be
   processed in the order in which they are received. Examples include
   printer queues and message queues.
4. Circular Queue: A circular queue is similar to a linear queue, but the
   end of the queue is connected to the front of the queue. This allows for
   efficient use of space in memory and can improve performance. Circular
   queues are used in applications where the data elements need to be
   processed in a circular fashion. Examples include CPU scheduling and
   memory management.
5. Priority Queue: A priority queue is a type of queue where each element
   is assigned a priority level. Elements with higher priority levels are
   processed before elements with lower priority levels. Priority queues
   are used in applications where certain tasks or data elements need to be
   processed with higher priority. Examples include operating system task
   scheduling and network packet scheduling.
6. Double-ended Queue: A double-ended queue, also known as a deque, is a
   type of queue where elements can be added or removed from either end of
   the queue. This allows for more flexibility in data processing and can
   be used in applications where elements need to be processed in multiple
   directions. Examples include job scheduling and searching algorithms.
7. Concurrent Queue: A concurrent queue is a type of queue that is designed
   to handle multiple threads accessing the queue simultaneously.
   Concurrent queues are used in multi-threaded applications where data
   needs to be shared between threads in a thread-safe manner. Examples
   include database transactions and web server requests.

**Issues of Queue :**

Some common issues that can arise when using queues:

1. Queue overflow: Queue overflow occurs when the queue reaches its maximum
   capacity and is unable to accept any more elements. This can cause data
   loss and can lead to application crashes.
2. Queue underflow: Queue underflow occurs when an attempt is made to
   remove an element from an empty queue. This can cause errors and
   application crashes.
3. Priority inversion: Priority inversion occurs in priority queues when a
   low-priority task holds a resource that a high-priority task needs. This
   can cause delays in processing and can impact system performance.
4. Deadlocks: Deadlocks occur when multiple threads or processes are
   waiting for each other to release resources, resulting in a situation
   where none of the threads can proceed. This can happen when using
   concurrent queues and can lead to system crashes.
5. Performance issues: Queue performance can be impacted by various
   factors, such as the size of the queue, the frequency of access, and the
   type of operations performed on the queue. Poor queue performance can
   lead to slower system performance and reduced user experience.
6. Synchronization issues: Synchronization issues can arise when multiple
   threads are accessing the same queue simultaneously. This can result in
   data corruption, race conditions, and other errors.
7. Memory management issues: Queues can use up significant amounts of
   memory, especially when processing large data sets. Memory leaks and
   other memory management issues can occur, leading to system crashes and
   other errors.

**Reference :**

Some references for further reading on queues:

1. “Data Structures and Algorithms in Java” by Robert Lafore – This book
   provides an in-depth explanation of different types of queues and their
   implementations in Java.
2. “Introduction to Algorithms” by Thomas H. Cormen et al. – This textbook
   covers the basic concepts of data structures and algorithms, including
   queues and their various applications.
3. “Concurrency in C# Cookbook” by Stephen Cleary – This book provides
   practical examples of how to use concurrent queues in C# programming.
4. “Queue (abstract data type)” on Wikipedia – This article provides an
   overview of queues and their properties, as well as examples of their
   applications.
5. “The Art of Computer Programming, Volume 1: Fundamental Algorithms” by
   Donald E. Knuth – This book includes a detailed analysis of different
   queue algorithms and their performance.
6. “Queues and the Producer-Consumer Problem” by Douglas C. Schmidt – This
   paper discusses how queues can be used to solve the producer-consumer
   problem in concurrent programming.

Course Name: Introduction to DSA II
Lesson Name: Introduction to Backtracking

Content:
Table of Content

* [What is Backtracking?](#what-is-backtracking)
* [Types of Backtracking Problems](#types-of-backtracking-problems)
* [How does Backtracking works?](#how-does-backtracking-works)
* [Determining Backtracking Problems](#determining-backtracking-problems)
* [Pseudocode for Backtracking](#pseudocode-for-backtracking)
* [Complexity Analysis of Backtracking](#complexity-analysis-of-backtracking)
* [How Backtracking is different from Recursion?](#how-backtracking-is-different-from-recursion)
* [Applications of Backtracking](#applications-of-backtracking)
* [Must Do Backtracking Problems](#must-do-backtracking-problems)

What is Backtracking?


Backtracking is a problem-solving algorithmic technique that involves finding a solution incrementally by trying

****different options****
and

****undoing****
them if they lead to a

****dead end****
. It is commonly used in situations where you need to explore multiple possibilities to solve a problem, like searching for a path in a maze or solving puzzles like Sudoku. When a dead end is reached, the algorithm backtracks to the previous decision point and explores a different path until a solution is found or all possibilities have been exhausted.


> Backtracking can be defined as a general algorithmic technique that considers searching every possible combination in order to solve a computational problem.

![backtracking-banner-(1)](

Introduction to Backtracking

### Basic Terminologies

* ****Candidate:****
  A candidate is a potential choice or element that can be added to the current solution.
* ****Solution:****
  The solution is a valid and complete configuration that satisfies all problem constraints.
* ****Partial Solution:****
  A partial solution is an intermediate or incomplete configuration being constructed during the backtracking process.
* ****Decision Space:****
  The decision space is the set of all possible candidates or choices at each decision point.
* ****Decision Point:****
  A decision point is a specific step in the algorithm where a candidate is chosen and added to the partial solution.
* ****Feasible Solution:****
  A feasible solution is a partial or complete solution that adheres to all constraints.
* ****Dead End:****
  A dead end occurs when a partial solution cannot be extended without violating constraints.
* ****Backtrack:****
  Backtracking involves undoing previous decisions and returning to a prior decision point.
* ****Search Space:****
  The search space includes all possible combinations of candidates and choices.
* ****Optimal Solution:****
  In optimization problems, the optimal solution is the best possible solution.

Types of Backtracking Problems


Problems associated with backtracking can be categorized into 3 categories:


* ****Decision Problems:****
  Here, we search for a feasible solution.
* ****Optimization Problems:****
  For this type, we search for the best solution.
* ****Enumeration Problems:****
  We find set of all possible feasible solutions to the problems of this type.

How does Backtracking works?

> As we know backtracking algorithm explores each and every possible path in order to find a valid solution, this exploration of path can be easily understood via given images:
>
>
> ![backtracking](
>
>
> As shown in the image, “
>
> ****IS”****
> represents the
>
> ****Initial State****
> where the recursion call starts to find a valid solution.
>
>
>
> ****C :****
> it represents different
>
> ****Checkpoints****
> for recursive calls
>
>
> ****TN****
> : it represents the
>
> ****Terminal Nodes****
> where no further recursive calls can be made, these nodes act as base case of recursion and we determine whether the current solution is valid or not at this state.
>
>
> At each Checkpoint, our program makes some decisions and move to other checkpoints untill it reaches a terminal Node, after determining whether a solution is valid or not, the program starts to revert back to the checkpoints and try to explore other paths. For example in the above image
>
> ****TN1…TN5****
> are the terminal node where the solution is not acceptable, while
>
> ****TN6****
> is the state where we found a valid solution.
>
>
> The back arrows in the images shows backtracking in actions, where we revert the changes made by some checkpoint.

Determining Backtracking Problems:


Generally every constraint satisfaction problem can be solved using backtracking but, Is it optimal to use backtracking every time? Turns out

****NO****
, there are a vast number of problem that can be solved using

[Greedy](
or

[Dynamic programming](
in logarithmic or polynomial time complexity which is far better than exponential complexity of Backtracking. However many problems still exists that can only be solved using Backtracking.


> To understand whether a problem is Backtracking based or not, let us take a simple problem:
>
>
>
> ****Problem:****
>
> Imagine you have 3 closed boxes, among which 2 are empty and 1 has a gold coin. Your task is to get the gold coin.
>
>
> ****Why dynamic programming fails to solve this question:****
>
> ****D****
> oes opening or closing one box has any effect on the other box? Turns out NO, each and every box is independent of each other and opening/closing state of one box can not determine the transition for other boxes. Hence DP fails.
>
>
> ****Why greedy fails to solve this question:****
>
>
> Greedy algorithm chooses a local maxima in order to get global maxima, but in this problem each and every box has equal probability of having a gold coin i.e 1/3 hence there is no criteria to make a greedy choice.
>
>
> ****Why Backtracking works:****
>
> As discussed already, backtracking algorithm is simply brute forcing each and every choice, hence we can one by one choose every box to find the gold coin, If a box is found empty we can close it back which acts as a Backtracking step.
>
>
> Technically, for backtracking problems:
>
>
> * The algorithm builds a solution by exploring all possible paths created by the choices in the problem, this solution begins with an empty set
>
>   ****S={}****
> * Each choice creates a new sub-tree ‘
>
>   ****s’****
>   which we add into are set.
> * Now there exist two cases:
>   + ****S+s is valid set****
>   + ****S+s is not valid set****
> * In case the set is valid then we further make choices and repeat the process until a solution is found, otherwise we backtrack our decision of including ‘
>
>   ****s’****
>   and explore other paths until a solution is found or all the possible paths are exhausted.

Pseudocode for Backtracking


The best way to implement backtracking is through recursion, and all backtracking code can be summarised as per the given Pseudocode:


> void
>
> ****FIND\_SOLUTIONS****
> ( parameters):
>
>
> if (valid
>
> ****solution****
> ):
>
>
> store the
>
> ****solution****
>
>
> Return
>
>
> for (all
>
> ****choice****
> ):
>
>
> if (valid
>
> ****choice****
> ):
>
>
> ****APPLY****
> (
>
> ****choice****
> )
>
>
> ****FIND\_SOLUTIONS****
> (parameters)
>
>
> ****BACKTRACK****
> (remove
>
> ****choice****
> )
>
>
> Return

Complexity Analysis of Backtracking


Since backtracking algorithm is purely brute force therefore in terms of time complexity, it performs very poorly. Generally backtracking can be seen having below mentioned time complexities:


* Exponential (O(K^N))
* Factorial (O(N!))


These complexities are due to the fact that at each state we have multiple choices due to which the number of paths increases and sub-trees expand rapidly.


How Backtracking is different from Recursion?


Recursion and Backtracking are related concepts in computer science and programming, but they are not the same thing. Let’s explore the key differences between them:


Applications of Backtracking

* Creating smart bots to play Board Games such as Chess.
* Solving mazes and puzzles such as N-Queen problem.
* Network Routing and Congestion Control.
* Decryption
* Text Justification

Course Name: Linked List Data Structure Guide
Lesson Name: Program for Nth node from the end of a Linked List

Content:
Given a Linked List of

****M****
nodes and a number

****N****
, find the value at the Nth node from the end of the Linked List. If there is no Nth node from the end, print -1.


****Examples:****

> ****Input:****
> 1 -> 2 -> 3 -> 4, N = 3
>
>
>
> ****Output:****
> 2
>
>
>
> ****Explanation:****
> Node 2 is the third node from the end of the linked list.
>
>
> ****Input:****
> 35 -> 15 -> 4 -> 20, N = 4
>
>
>
> ****Output:****
> 35
>
>
>
> ****Explanation:****
> Node 35 is the fourth node from the end of the linked list.

Table of Content

* [[Naive Approach] By Finding the length of list – Two Pass – O(M) Time and O(1) Space](#naive-approach-finding-the-length-of-list-and-return-the-node-two-pass-om-time-and-o1-space)
* [[Expected Approach] Using Two Pointers – One Pass – O(M) Time and O(1) Space](#expected-approach-using-two-pointers-one-pass-om-time-and-o1-space)
### ****[Naive Approach]**** Finding the length of list – Two Pass – O(M) Time and O(1) Space

> The idea is to count the number of nodes in linked list in the first pass, say
>
> ****len****
> . In the second pass, return the
>
> ****(len – n + 1)th****
> nodes from beginning of the Linked List.








****Time complexity:****
O(M) where

****M****
is the size of the linked list



****Auxiliary Space:****
O(1)


### [Expected Approach] Using Two Pointers – One Pass – O(M) Time and O(1) Space

> The idea is to maintain two pointers, say
>
> ****main\_ptr****
> and
>
> ****ref\_ptr****
> point to the head of Linked List and move
>
> ****ref\_ptr****
> to the Nth node from the head to ensure that the distance between main\_ptr and ref\_ptr is
>
> ****(N – 1)****
> . Now, move both the pointers simultaneously until ref\_ptr reaches the last node. Since the distance between main\_ptr and ref\_ptr is (N – 1), so when ref\_ptr will reach the
>
> ****last node****
> , main\_ptr will reach
>
> ****Nth****
> node from the end of Linked List. Return the value of node pointed by main\_ptr.


Below image is a dry run of the above approach:








Follow the given steps to solve the problem:


* Maintain two pointers

  ****main\_ptr****
  and

  ****ref\_ptr****
* Move ref\_ptr to the Nth node from the start
* Now move both main\_ptr and ref\_ptr, until the ref\_ptr reaches the last node
* Now return the data of the main\_ptr, as it is at the Nth node from the end








****Time Complexity:****
O(M) where

****M****
is the length of the linked list



****Auxiliary Space:****
O(1)

Course Name: Matrix Data Structure Guide
Lesson Name: Program to multiply two matrices

Content:


Given two

[matrices](
, the task is to multiply them. Matrices can either be square or rectangular:


****Examples:****


> ****(Square Matrix Multiplication)****
>
> ****Input:****
> m1[m][n] = { {1, 1}, {2, 2} }
>
>
>
> m2[n][p] = { {1, 1}, {2, 2} }
>
>
>
> ****Output:****
> res[m][p] = { {3, 3}, {6, 6} }
>
>
> ****(Rectangular Matrix Multiplication)****
>
> ****Input:****
> m1[3][2] = { {1, 1}, {2, 2}, {3, 3} }
>
>
>
> m2[2][3] = { {1, 1, 1}, {2, 2, 2} }
>
>
>
> ****Output:****
> res[3][3] = { {3, 3, 3}, {6, 6, 6}, {9, 9, 9} }
>
>
> ![](

****Multiplication of two Square or Rectangular Matrices****

> * The number of columns in Matrix-1 must be equal to the number of rows in Matrix-2.
> * Output of multiplication of Matrix-1 and Matrix-2, results with equal to the number of rows of Matrix-1 and  the number of columns of Matrix-2 i.e. rslt[R1][C2]


Below is the implementation of the multiplication of two

[matrices](








****Time complexity:****
O(R1 \* C2 \* R2) for given matrices mat1[R1][C1] and mat2[R2][C2]



****Auxiliary space:****
O(R1 \* C2)


****Multiplication of Rectangular Matrices using Pointers in C/C++:****


To solve the problem follow the below idea:


> We use pointers in C/C++ to multiply matrices

****Prerequisite:****

[How to pass a 2D array as a parameter in C?](



  

Course Name: Stack
Lesson Name: Implement a stack using singly linked list

Content:
****Stack Operations:****

* [****push()****](
  Insert a new element into the stack i.e just insert a new element at
  the beginning of the linked list.
* [****pop()****](
  Return the top element of the Stack i.e simply delete the first
  element from the linked list.
* [****peek()****]( Return the top element.
* ****display():**** Print all elements in Stack.

Push Operation:

> * Initialise a node
> * Update the value of that node by data i.e. ****node->data = data****
> * Now link this node to the top of the linked list
> * And update top pointer to the current node

Pop Operation:

> * First Check whether there is any node present in the linked list or
>   not, if not then return
> * Otherwise make pointer let say ****temp**** to the top node and move forward the top node by 1 step
> * Now free this temp node

Peek Operation:

> * Check if there is any node present or not, if not then
>   return.
> * Otherwise return the value of top node of the linked list

Display Operation:

> * Take a ****temp**** node and initialize it with top pointer
> * Now start traversing temp till it encounters NULL
> * Simultaneously print the value of the temp node








****Time Complexity:****
O(1), for all push(), pop(), and peek(), as we are not performing any
kind of traversal over the list. We perform all the operations through
the current pointer only.  
****Auxiliary Space:**** O(N), where N is the size of the stack


In this implementation, we define a Node class that represents a node
in the linked list, and a Stack class that uses this node class to
implement the stack. The head attribute of the Stack class points to the
top of the stack (i.e., the first node in the linked list).

To push an item onto the stack, we create a new node with the given
item and set its next pointer to the current head of the stack. We then
set the head of the stack to the new node, effectively making it the new
top of the stack.

To pop an item from the stack, we simply remove the first node from the
linked list by setting the head of the stack to the next node in the
list (i.e., the node pointed to by the next pointer of the current
head). We return the data stored in the original head node, which is the
item that was removed from the top of the stack.

### Benefits of implementing a stack using a singly linked list include:

****Dynamic memory allocation****: The size of the stack can be increased or decreased dynamically by
adding or removing nodes from the linked list, without the need to
allocate a fixed amount of memory for the stack upfront.

****Efficient memory usage:**** Since nodes in a singly linked list only have a next pointer and not a
prev pointer, they use less memory than nodes in a doubly linked
list.

****Easy implementation****: Implementing a stack using a singly linked list is straightforward
and can be done using just a few lines of code.

****Versatile****: Singly linked lists can be used to implement other data structures
such as queues, linked lists, and trees.

In summary, implementing a stack using a singly linked list is a simple
and efficient way to create a dynamic stack data structure in
Python.

### Real time examples of stack:

Stacks are used in various real-world scenarios where a last-in,
first-out (LIFO) data structure is required. Here are some examples of
real-time applications of stacks:

****Function call stack****: When a function is called in a program, the return address and all
the function parameters are pushed onto the function call stack. The
stack allows the function to execute and return to the caller function
in the reverse order in which they were called.

****Undo/Redo operations:****
In many applications, such as text editors, image editors, or web
browsers, the undo and redo functionalities are implemented using a
stack. Every time an action is performed, it is pushed onto the stack.
When the user wants to undo the last action, the top element of the
stack is popped and the action is reversed.

****Browser history:**** Web browsers use stacks to keep track of the pages visited by the user.
Every time a new page is visited, its URL is pushed onto the stack. When
the user clicks the “Back” button, the last visited URL is popped from
the stack and the user is directed to the previous page.

****Expression evaluation****: Stacks are used in compilers and interpreters to evaluate
expressions. When an expression is parsed, it is converted into postfix
notation and pushed onto a stack. The postfix expression is then
evaluated using the stack.

****Call stack in recursion:****
When a recursive function is called, its call is pushed onto the stack.
The function executes and calls itself, and each subsequent call is
pushed onto the stack. When the recursion ends, the stack is popped, and
the program returns to the previous function call.

In summary, stacks are widely used in many applications where LIFO
functionality is required, such as function calls, undo/redo operations,
browser history, expression evaluation, and recursive function
calls.


Course Name: Introduction to DSA I

Lesson Name: Different Types of Queues and its Applications

Content:
**Types of Queues:**

There are **five different types of queues** that are used in
different scenarios. They are:

1. Input Restricted Queue (this is a Simple Queue)
2. Output Restricted Queue (this is also a Simple Queue)
3. Circular Queue
4. Double Ended Queue (Deque)
5. Priority Queue
   * Ascending Priority Queue
   * Descending Priority Queue

![Types of Queues](

Types of Queues

**1.** [**Circular Queue**]( Circular Queue is a linear data structure in which the
operations are performed based on FIFO (First In First Out) principle and
the last position is connected back to the first position to make a
circle. It is also called **‘Ring Buffer’**. This queue is
primarily used in the following cases:

1. **Memory Management:** The unused memory locations in the
   case of ordinary queues can be utilized in circular queues.
2. **Traffic system:** In a computer-controlled traffic
   system, circular queues are used to switch on the traffic lights one by
   one repeatedly as per the time set.
3. **CPU Scheduling:** Operating systems often maintain a
   queue of processes that are ready to execute or that are waiting for a
   particular event to occur.

The time complexity for the circular Queue is O(1).

**2. Input restricted Queue:** In this type of Queue, the
input can be taken from one side only(rear) and deletion of elements can
be done from both sides(front and rear). This kind of Queue does not
follow FIFO(first in first out).  This queue is used in cases where
the consumption of the data needs to be in FIFO order but if there is a
need to remove the recently inserted data for some reason and one such
case can be irrelevant data, performance issue, etc.



![Input Restricted Queue](

Input Restricted Queue

**Advantages of Input restricted Queue:**

* Prevents overflow and overloading of the queue by limiting the number of
  items added
* Helps maintain stability and predictable performance of the system

**Disadvantages of Input restricted Queue:**

* May lead to resource wastage if the restriction is set too low and items
  are frequently discarded
* May lead to waiting or blocking if the restriction is set too high and
  the queue is full, preventing new items from being added.

**3. Output restricted Queue:** In this type of Queue, the
input can be taken from both sides(rear and front) and the deletion of the
element can be done from only one side(front).  This queue is used in
the case where the inputs have some priority order to be executed and the
input can be placed even in the first place so that it is executed
first.

![Output Restricted Queue](

Output Restricted Queue

**4.** [**Double ended Queue**]( Double Ended Queue is also a Queue data structure in
which the insertion and deletion operations are performed at both the ends
(front and rear). That means, we can insert at both front and rear
positions and can delete from both front and rear positions.  Since
Deque supports both stack and queue operations, it can be used as both.
The Deque data structure supports clockwise and anticlockwise rotations in
O(1) time which can be useful in certain applications. Also, the problems
where elements need to be removed and or added both ends can be
efficiently solved using Deque.

![Double Ended Queue](

Double Ended Queue

**5.** [**Priority Queue**]( A priority queue is a special type of queue in which
each element is associated with a priority and is served according to its
priority. There are two types of Priority Queues. They are:

1. **Ascending Priority Queue:** Element can be inserted
   arbitrarily but only smallest element can be removed. For example,
   suppose there is an array having elements 4, 2, 8 in the same order. So,
   while inserting the elements, the insertion will be in the same sequence
   but while deleting, the order will be 2, 4, 8.
2. **Descending priority Queue:** Element can be inserted
   arbitrarily but only the largest element can be removed first from the
   given Queue. For example, suppose there is an array having elements 4,
   2, 8 in the same order. So, while inserting the elements, the insertion
   will be in the same sequence but while deleting, the order will be 8, 4, 2.

The time complexity of the Priority Queue is O(logn).

[**Applications of a Queue:**](

The [queue]( is used when things don’t have to be processed immediately, but have to be processed in First In First Out order like [Breadth First Search]( This property of Queue makes it also useful in the following kind of scenarios.

1. When a resource is shared among multiple consumers. Examples include   [CPU scheduling](   [Disk Scheduling](
2. When data is transferred asynchronously (data not necessarily received
   at the same rate as sent) between two processes. Examples include IO
   Buffers, [pipes]( file IO, etc.
3. Linear Queue: A linear queue is a type of queue where data elements are
   added to the end of the queue and removed from the front of the queue.
   Linear queues are used in applications where data elements need to be
   processed in the order in which they are received. Examples include
   printer queues and message queues.
4. Circular Queue: A circular queue is similar to a linear queue, but the
   end of the queue is connected to the front of the queue. This allows for
   efficient use of space in memory and can improve performance. Circular
   queues are used in applications where the data elements need to be
   processed in a circular fashion. Examples include CPU scheduling and
   memory management.
5. Priority Queue: A priority queue is a type of queue where each element
   is assigned a priority level. Elements with higher priority levels are
   processed before elements with lower priority levels. Priority queues
   are used in applications where certain tasks or data elements need to be
   processed with higher priority. Examples include operating system task
   scheduling and network packet scheduling.
6. Double-ended Queue: A double-ended queue, also known as a deque, is a
   type of queue where elements can be added or removed from either end of
   the queue. This allows for more flexibility in data processing and can
   be used in applications where elements need to be processed in multiple
   directions. Examples include job scheduling and searching algorithms.
7. Concurrent Queue: A concurrent queue is a type of queue that is designed
   to handle multiple threads accessing the queue simultaneously.
   Concurrent queues are used in multi-threaded applications where data
   needs to be shared between threads in a thread-safe manner. Examples
   include database transactions and web server requests.

**Issues of Queue :**

Some common issues that can arise when using queues:

1. Queue overflow: Queue overflow occurs when the queue reaches its maximum
   capacity and is unable to accept any more elements. This can cause data
   loss and can lead to application crashes.
2. Queue underflow: Queue underflow occurs when an attempt is made to
   remove an element from an empty queue. This can cause errors and
   application crashes.
3. Priority inversion: Priority inversion occurs in priority queues when a
   low-priority task holds a resource that a high-priority task needs. This
   can cause delays in processing and can impact system performance.
4. Deadlocks: Deadlocks occur when multiple threads or processes are
   waiting for each other to release resources, resulting in a situation
   where none of the threads can proceed. This can happen when using
   concurrent queues and can lead to system crashes.
5. Performance issues: Queue performance can be impacted by various
   factors, such as the size of the queue, the frequency of access, and the
   type of operations performed on the queue. Poor queue performance can
   lead to slower system performance and reduced user experience.
6. Synchronization issues: Synchronization issues can arise when multiple
   threads are accessing the same queue simultaneously. This can result in
   data corruption, race conditions, and other errors.
7. Memory management issues: Queues can use up significant amounts of
   memory, especially when processing large data sets. Memory leaks and
   other memory management issues can occur, leading to system crashes and
   other errors.

**Reference :**

Some references for further reading on queues:

1. “Data Structures and Algorithms in Java” by Robert Lafore – This book
   provides an in-depth explanation of different types of queues and their
   implementations in Java.
2. “Introduction to Algorithms” by Thomas H. Cormen et al. – This textbook
   covers the basic concepts of data structures and algorithms, including
   queues and their various applications.
3. “Concurrency in C# Cookbook” by Stephen Cleary – This book provides
   practical examples of how to use concurrent queues in C# programming.
4. “Queue (abstract data type)” on Wikipedia – This article provides an
   overview of queues and their properties, as well as examples of their
   applications.
5. “The Art of Computer Programming, Volume 1: Fundamental Algorithms” by
   Donald E. Knuth – This book includes a detailed analysis of different
   queue algorithms and their performance.
6. “Queues and the Producer-Consumer Problem” by Douglas C. Schmidt – This
   paper discusses how queues can be used to solve the producer-consumer
   problem in concurrent programming.

Course Name: Introduction to DSA I

Lesson Name: Applications, Advantages and Disadvantages of Stack

Content:
Applications of Stacks:

* ****Function calls:****
  Stacks are used to keep track of the return addresses of function
  calls, allowing the program to return to the correct location after a
  function has finished executing.
* ****Recursion:**** Stacks are used to store the local variables and return addresses of
  recursive function calls, allowing the program to keep track of the
  current state of the recursion.
* ****Expression evaluation:**** Stacks are used to evaluate expressions in postfix notation (Reverse
  Polish Notation).
* ****Syntax parsing:**** Stacks are used to check the validity of syntax in programming
  languages and other formal languages.
* ****Memory management:**** Stacks are used to allocate and manage memory in some operating
  systems and programming languages.
* Used to solve popular problems like [Next Greater]( [Previous Greater]( [Next Smaller]( [Previous Smaller]( [Largest Area in a Histogram]( and [Stock Span Problems](

Advantages of Stacks:

* ****Simplicity:**** Stacks are a simple and easy-to-understand data structure, making
  them suitable for a wide range of applications.
* ****Efficiency:**** Push and pop operations on a stack can be performed in constant time ****(O(1))****, providing efficient access to data.
* ****Last-in, First-out (LIFO):****
  Stacks follow the LIFO principle, ensuring that the last element added
  to the stack is the first one removed. This behavior is useful in many
  scenarios, such as function calls and expression evaluation.
* ****Limited memory usage:**** Stacks only need to store the elements that have been pushed onto
  them, making them memory-efficient compared to other data
  structures.

Disadvantages of Stacks:

* ****Limited access:****
  Elements in a stack can only be accessed from the top, making it
  difficult to retrieve or modify elements in the middle of the
  stack.
* ****Potential for overflow:**** If more elements are pushed onto a stack than it can hold, an
  overflow error will occur, resulting in a loss of data.
* ****Not suitable for random access:**** Stacks do not allow for random access to elements, making them
  unsuitable for applications where elements need to be accessed in a
  specific order.
* ****Limited capacity:****
  Stacks have a fixed capacity, which can be a limitation if the number
  of elements that need to be stored is unknown or highly
  variable.


Course Name: Introduction to DSA II
Lesson Name: Introduction to Linked List – Data Structure and Algorithm Tutorials

Content:
Basic Terminologies of Linked List

* ****Head:****
  The Head of a linked list is a pointer to the first node or reference of the first node of linked list. This pointer marks the beginning of the linked list.
* ****Node:****
  Linked List consists of a series of nodes where each node has two parts:

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ****data****
                                              and

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ****next pointer****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Data:****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Data is the part of node which stores the information in the linked list.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Next pointer:****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Next pointer is the part of the node which points to the next node of the linked list.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Importance of Linked List


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Here are a few advantages of a linked list that is listed below, it will help you understand why it is necessary to know.


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Dynamic Data structure:****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The size of memory can be allocated or de-allocated at run time based on the operation insertion or deletion.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Ease of Insertion/Deletion:****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The insertion and deletion of elements are simpler than arrays since no elements need to be shifted after insertion and deletion, Just the address needed to be updated.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Efficient Memory Utilization:****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           As we know Linked List is a dynamic data structure the size increases or decreases as per the requirement so this avoids the wastage of memory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Implementation:****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Various advanced data structures can be implemented using a linked list like a stack, queue, graph, hash maps, etc.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Implementations of Basic Operations on Different Types of List

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * [Singly Linked List](
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * [Doubly Linked List](
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * [Circular Linked List](

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ### Basic Operations on Singly Linked List


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The following are some basic operations performed on a Single Linked List:


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Insertion:****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The insertion operation can be performed in three ways. They are as follows:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           + [Inserting At the Beginning of the list](
        + [Inserting At End of the list](
  + [Inserting At Specific location in the list](
* ****Deletion:****
  The deletion operation can be performed in three ways. They are as follows:
  + [Deleting from the Beginning of the list](
  + [Deleting from the End of the list](
  + [Deleting a Specific Node](
* [****Traverse****](
  ****:****
  This process displays the elements of a Single-linked list.
* [****Search:****](

  It is a process of determining and retrieving a specific node either from the front, the end or anywhere in the list.

### ****Operations on Doubly Linked List:****


In a doubly linked list, we perform the following operations…


* ****Insertion:****
  The insertion operation can be performed in three ways as follows:
  + [Inserting At the Beginning of the list](
  + [Inserting after a given node.](
  + [Inserting at the end](
    .
  + [Inserting before a given node](
* ****Deletion:****
  The deletion operation can be performed in three ways as follows…
  + [Deleting from the Beginning of the list](
  + [Deleting from the End of the list](
  + Deleting a Specific Node
* ****Display:****
  This process displays the elements of a double-linked list.

### ****Commonly used operations on Circular Linked List:****


The following operations are performed on a Circular Linked List



* ****Insertion:****
  The insertion operation can be performed in three ways:
  + [Insertion in an empty list](
  + [Insertion at the beginning of the list](
  + [Insertion at the end of the list](
  + [Insertion in between the nodes](
* ****Deletion:****
  The deletion operation can be performed in three ways:
  + [Deleting from the Beginning of the list](
  + [Deleting from the End of the list](
  + [Deleting a Specific Node](
* ****Display:****
  This process displays the elements of a Circular linked list.

[Linked List vs. Array:](

Time Complexity Analysis of Linked List and Array:


Please refer

[Applications, Advantages and Disadvantages of Linked List](
for more details


Frequently Asked Questions (FAQs) about Linked List:

### 1. What is linked list data structure?

> Linked list are most commonly used to handle dynamic data elements. Linked list consists of nodes and a node consists of two fields one for storing data and other for keeping the reference of next node.

### 2. What is linked list example?

> A linked list can be assumed as a garland that is made up of flowers. Similarly, a linked list is made up of nodes. Every flower in this particular garland is referred to as a node. In addition, each node points to the next node in this list, and it contains data (in this case, the type of flower).

### 3. Why do we need linked list data structure??

> There are some important advantages to using linked lists over other linear data structures. This is unlike arrays, as they are resizable at runtime. Additionally, they can be easily inserted and deleted.

### 4. What are linked lists used for?

> The linked list is a linear data structure that stores data in nodes. these nodes hold both the data and a reference to the next node in the list. Linked are very efficient at adding and removing nodes because of their simple structure.

### 5. What is the difference between array and linked list?

> There are some following differences between them:
>
>
> * Arrays are data structures containing similar data elements, whereas linked lists are non-primitive data structures containing unordered linked elements.
> * In an array, elements are indexed, but in a linked list nodes are not indexed.
> * Accessing an element array is fast if we know the position of an element in the array, while in the Linked list it takes linear time so, the Linked list is quite bit slower.
> * Operations like insertion and deletion in arrays take a lot of time. Whereas, the performance of these operations is faster in Linked lists.
> * Arrays are of fixed size and their size is static but Linked lists are dynamic and flexible and can expand and shrink their size.

### 6. Why is a linked list preferred over an array?

> Following are the reason that linked lists are preferred over array
>
>
> * Nodes in a linked array, insertions, and deletions can be done at any point in the list at a constant time.
> * Arrays are of fixed size and their size is static but Linked lists are dynamic and flexible and can expand and shrink their size.
> * Linked lists provide an efficient way of storing related data and performing basic operations such as insertion, deletion, and updating of information at the cost of extra space required for storing the address.
> * Insertion and deletion operations in the linked list are faster as compared to the array.

### 7. Which is the best array or linked list?

> There are some advantages and disadvantages to both arrays and linked lists when it comes to storing linear data of similar types.
>
>
> #### Advantages of linked list over arrays:
>
> * ****Dynamic size:****
>   Linked lists are dynamic and flexible and can expand and shrink their size
> * ****Ease of Insertion/Deletion:****
>   Insertion and deletion operations in linked list are faster as compared to the array
>
> #### ****Disadvantages of linked list over arrays:****
>
> * If the array is sorted we can apply binary search to search any element which takes
>
>   ****O(log(n))****
>   time. But even if the linked list is sorted we cannot apply binary search and the complexity of searching elements in the linked list is
>
>   ****O(n)****
>   .
> * A linked list takes more memory as compared to the array because extra memory space is required for the pointer with each element in the linked list.

### 8. What are the limitations of linked list?

> Following are some limitations of the linked list:
>
>
> * The use of pointers is more in linked lists hence, complex and requires more memory.
> * Random access is not possible due to dynamic memory allocation.
> * Traversing is more time-consuming and reverse traversing is not possible in singly linked lists.
> * Searching for an element is costly and requires
>
>   ****O(n)****
>   time complexity.

### 9. Why insertion/deletion are faster in a linked list?

> If any element is inserted/ deleted from the array, all the other elements after it will be shifted in memory this takes a lot of time whereas manipulation in Linked List is faster because we just need to manipulate the addresses of nodes, so no bit shifting is required in memory, and it will not take that much of time.

### 10. What is the difference between a singly and doubly linked list?


Following are some

[difference between single and double linked list.](

Conclusion:


There are many advantages of the linked list compared to array, despite the fact that they solve the similar problem to arrays, we have also discussed the advantage, disadvantages, and its application, and we concluded the fact that we can use a linked list if we need the dynamic size of storage and list are good for adding and removing items quickly or for tasks that require sequence but are not suitable for querying or search elements in a large collection of data.


So, it becomes important that we should always keep in mind the

****positive****
and

****negative****
aspects of a

****data structure****
and how they relate to the problem you are trying to solve.

Course Name: Introduction to DSA I

Lesson Name: Implement Stack using Array

Content:
Implement Stack using Array:

> To implement a stack using an array, initialize an array and treat
> its end as the stack’s top. Implement ****push**** (add to end), ****pop**** (remove from end), and ****peek**** (check end) operations, handling cases for an ****empty**** or f****ull stack****.

****Step-by-step approach:****

1. ****Initialize an array**** to represent the stack.
2. Use the ****end of the array**** to represent the ****top of the stack****.
3. Implement ****push**** (add to end), ****pop**** (remove from the end), and ****peek**** (check end) operations, ensuring to handle empty and full stack
   conditions.

Implement Stack Operations using Array:


Here are the following operations of implement stack using array:

### ****Push Operation in Stack:****

Adds an item to the stack. If the stack is full, then it is said to be
an ****Overflow condition.****

****Algorithm for Push Operation:****

> * Before pushing the element to the stack, we check if the stack
>   is ****full****.
> * If the stack is full ****(top == capacity-1)**** , then ****Stack Overflows****and we cannot insert the element to the stack.
> * Otherwise, we increment the value of top by 1 ****(top = top + 1)**** and the new value is inserted at ****top position****.
> * The elements can be pushed into the stack till we reach
>   the ****capacity**** of the stack.

![push-operation-in-stack-1.webp](


![push-operation-in-stack-2.webp](


![push-operation-in-stack-3.webp](


![push-operation-in-stack-4.webp](


![push-operation-in-stack-5.webp](


![push-operation-in-stack-6.webp](



Previous





Pause

Next





5 / 6

### ****Pop Operation in Stack:****

Removes an item from the stack. The items are popped in the reversed
order in which they are pushed. If the stack is empty, then it is said
to be an ****Underflow condition.****

****Algorithm for Pop Operation:****

> * Before popping the element from the stack, we check if the stack
>   is ****empty****.
> * If the stack is empty (top == -1), then ****Stack Underflows**** and we cannot remove any element from the stack.
> * Otherwise, we store the value at top, decrement the value of top by
>   1 ****(top = top – 1)**** and return the stored top value.

![pop-operation-in-stack-1.webp](


![pop-operation-in-stack-2.webp](


![pop-operation-in-stack-3.webp](


![pop-operation-in-stack-4.webp](


![pop-operation-in-stack-5.webp](


![pop-operation-in-stack-6.webp](



Previous





Play

Next





1 / 6




### ****Top or Peek Operation in Stack:****

Returns the top element of the stack.

****Algorithm for Top Operation:****

> * Before returning the top element from the stack, we check if the
>   stack is empty.
> * If the stack is empty (top == -1), we simply print “Stack is
>   empty”.
> * Otherwise, we return the element stored at ****index = top****.

### ****isEmpty Operation in Stack:****

Returns true if the stack is empty, else false.

****Algorithm for isEmpty Operation****:

> * Check for the value of ****top**** in stack.
> * If ****(top == -1)**** , then the stack is ****empty****so return ****true****.
> * Otherwise, the stack is not empty so return ****false****.

### isFull ****Operation in Stack****:

Returns true if the stack is full, else false.

****Algorithm for isFull Operation:****

> * Check for the value of ****top**** in stack.
> * If ****(top == capacity-1),**** then the stack is ****full**** so return ****true****.
> * Otherwise, the stack is not full so return ****false.****







### Complexity Analysis:

* ****Time Complexity****:
  + `push`: O(1)
  + `pop`: O(1)
  + `peek`: O(1)
  + `is_empty`: O(1)
  + is\_full: O(1)
* ****Auxiliary Space****: O(n), where n is the number of items in the stack.

Advantages of Array Implementation:

* Easy to implement.
* Memory is saved as pointers are not involved.

Disadvantages of Array Implementation:

* It is not dynamic i.e., it doesn’t grow and shrink depending on needs
  at runtime. [But in case of dynamic sized arrays like vector in C++,
  list in Python, ArrayList in Java, stacks can grow and shrink with
  array implementation as well].
* The total size of the stack must be defined beforehand.


Course Name: Introduction to DSA I

Lesson Name: Implement a stack using singly linked list

Content:
****Stack Operations:****

* [****push()****](
  Insert a new element into the stack i.e just insert a new element at
  the beginning of the linked list.
* [****pop()****](
  Return the top element of the Stack i.e simply delete the first
  element from the linked list.
* [****peek()****]( Return the top element.
* ****display():**** Print all elements in Stack.

Push Operation:

> * Initialise a node
> * Update the value of that node by data i.e. ****node->data = data****
> * Now link this node to the top of the linked list
> * And update top pointer to the current node

Pop Operation:

> * First Check whether there is any node present in the linked list or
>   not, if not then return
> * Otherwise make pointer let say ****temp**** to the top node and move forward the top node by 1 step
> * Now free this temp node

Peek Operation:

> * Check if there is any node present or not, if not then
>   return.
> * Otherwise return the value of top node of the linked list

Display Operation:

> * Take a ****temp**** node and initialize it with top pointer
> * Now start traversing temp till it encounters NULL
> * Simultaneously print the value of the temp node








****Time Complexity:****
O(1), for all push(), pop(), and peek(), as we are not performing any
kind of traversal over the list. We perform all the operations through
the current pointer only.
****Auxiliary Space:**** O(N), where N is the size of the stack


In this implementation, we define a Node class that represents a node
in the linked list, and a Stack class that uses this node class to
implement the stack. The head attribute of the Stack class points to the
top of the stack (i.e., the first node in the linked list).

To push an item onto the stack, we create a new node with the given
item and set its next pointer to the current head of the stack. We then
set the head of the stack to the new node, effectively making it the new
top of the stack.

To pop an item from the stack, we simply remove the first node from the
linked list by setting the head of the stack to the next node in the
list (i.e., the node pointed to by the next pointer of the current
head). We return the data stored in the original head node, which is the
item that was removed from the top of the stack.

### Benefits of implementing a stack using a singly linked list include:

****Dynamic memory allocation****: The size of the stack can be increased or decreased dynamically by
adding or removing nodes from the linked list, without the need to
allocate a fixed amount of memory for the stack upfront.

****Efficient memory usage:**** Since nodes in a singly linked list only have a next pointer and not a
prev pointer, they use less memory than nodes in a doubly linked
list.

****Easy implementation****: Implementing a stack using a singly linked list is straightforward
and can be done using just a few lines of code.

****Versatile****: Singly linked lists can be used to implement other data structures
such as queues, linked lists, and trees.

In summary, implementing a stack using a singly linked list is a simple
and efficient way to create a dynamic stack data structure in
Python.

### Real time examples of stack:

Stacks are used in various real-world scenarios where a last-in,
first-out (LIFO) data structure is required. Here are some examples of
real-time applications of stacks:

****Function call stack****: When a function is called in a program, the return address and all
the function parameters are pushed onto the function call stack. The
stack allows the function to execute and return to the caller function
in the reverse order in which they were called.

****Undo/Redo operations:****
In many applications, such as text editors, image editors, or web
browsers, the undo and redo functionalities are implemented using a
stack. Every time an action is performed, it is pushed onto the stack.
When the user wants to undo the last action, the top element of the
stack is popped and the action is reversed.

****Browser history:**** Web browsers use stacks to keep track of the pages visited by the user.
Every time a new page is visited, its URL is pushed onto the stack. When
the user clicks the “Back” button, the last visited URL is popped from
the stack and the user is directed to the previous page.

****Expression evaluation****: Stacks are used in compilers and interpreters to evaluate
expressions. When an expression is parsed, it is converted into postfix
notation and pushed onto a stack. The postfix expression is then
evaluated using the stack.

****Call stack in recursion:****
When a recursive function is called, its call is pushed onto the stack.
The function executes and calls itself, and each subsequent call is
pushed onto the stack. When the recursion ends, the stack is popped, and
the program returns to the previous function call.

In summary, stacks are widely used in many applications where LIFO
functionality is required, such as function calls, undo/redo operations,
browser history, expression evaluation, and recursive function
calls.


Course Name: Stack
Lesson Name: Implement Stack using Array

Content:
Implement Stack using Array:

> To implement a stack using an array, initialize an array and treat
> its end as the stack’s top. Implement ****push**** (add to end), ****pop**** (remove from end), and ****peek**** (check end) operations, handling cases for an ****empty**** or f****ull stack****.

****Step-by-step approach:****

1. ****Initialize an array**** to represent the stack.
2. Use the ****end of the array**** to represent the ****top of the stack****.
3. Implement ****push**** (add to end), ****pop**** (remove from the end), and ****peek**** (check end) operations, ensuring to handle empty and full stack
   conditions.

Implement Stack Operations using Array:


Here are the following operations of implement stack using array:

### ****Push Operation in Stack:****

Adds an item to the stack. If the stack is full, then it is said to be
an ****Overflow condition.****

****Algorithm for Push Operation:****

> * Before pushing the element to the stack, we check if the stack
>   is ****full****.
> * If the stack is full ****(top == capacity-1)****, then ****Stack Overflows****and we cannot insert the element to the stack.
> * Otherwise, we increment the value of top by 1 ****(top = top + 1)****and the new value is inserted at ****top position****.
> * The elements can be pushed into the stack till we reach
>   the ****capacity****of the stack.

![push-operation-in-stack-1.webp](


![push-operation-in-stack-2.webp](


![push-operation-in-stack-3.webp](


![push-operation-in-stack-4.webp](


![push-operation-in-stack-5.webp](


![push-operation-in-stack-6.webp](



Previous





Pause

Next





5 / 6

### ****Pop Operation in Stack:****

Removes an item from the stack. The items are popped in the reversed
order in which they are pushed. If the stack is empty, then it is said
to be an ****Underflow condition.****

****Algorithm for Pop Operation:****

> * Before popping the element from the stack, we check if the stack
>   is ****empty****.
> * If the stack is empty (top == -1), then ****Stack Underflows****and we cannot remove any element from the stack.
> * Otherwise, we store the value at top, decrement the value of top by
>   1 ****(top = top – 1)****and return the stored top value.

![pop-operation-in-stack-1.webp](


![pop-operation-in-stack-2.webp](


![pop-operation-in-stack-3.webp](


![pop-operation-in-stack-4.webp](


![pop-operation-in-stack-5.webp](


![pop-operation-in-stack-6.webp](



Previous





Play

Next





1 / 6

  


### ****Top or Peek Operation in Stack:****

Returns the top element of the stack.

****Algorithm for Top Operation:****

> * Before returning the top element from the stack, we check if the
>   stack is empty.
> * If the stack is empty (top == -1), we simply print “Stack is
>   empty”.
> * Otherwise, we return the element stored at ****index = top****.

### ****isEmpty Operation in Stack:****

Returns true if the stack is empty, else false.

****Algorithm for isEmpty Operation****:

> * Check for the value of ****top****in stack.
> * If ****(top == -1)****, then the stack is ****empty****so return ****true****.
> * Otherwise, the stack is not empty so return ****false****.

### isFull ****Operation in Stack****:

Returns true if the stack is full, else false.

****Algorithm for isFull Operation:****

> * Check for the value of ****top****in stack.
> * If ****(top == capacity-1),****then the stack is ****full****so return ****true****.
> * Otherwise, the stack is not full so return ****false.****

































































### Complexity Analysis:

* ****Time Complexity****:
  + `push`: O(1)
  + `pop`: O(1)
  + `peek`: O(1)
  + `is_empty`: O(1)
  + is\_full: O(1)
* ****Auxiliary Space****: O(n), where n is the number of items in the stack.

Advantages of Array Implementation:

* Easy to implement.
* Memory is saved as pointers are not involved.

Disadvantages of Array Implementation:

* It is not dynamic i.e., it doesn’t grow and shrink depending on needs
  at runtime. [But in case of dynamic sized arrays like vector in C++,
  list in Python, ArrayList in Java, stacks can grow and shrink with
  array implementation as well].
* The total size of the stack must be defined beforehand.

Course Name: Stack
Lesson Name: Applications, Advantages and Disadvantages of Stack

Content:
Applications of Stacks:

* ****Function calls:****
  Stacks are used to keep track of the return addresses of function
  calls, allowing the program to return to the correct location after a
  function has finished executing.
* ****Recursion:**** Stacks are used to store the local variables and return addresses of
  recursive function calls, allowing the program to keep track of the
  current state of the recursion.
* ****Expression evaluation:**** Stacks are used to evaluate expressions in postfix notation (Reverse
  Polish Notation).
* ****Syntax parsing:**** Stacks are used to check the validity of syntax in programming
  languages and other formal languages.
* ****Memory management:**** Stacks are used to allocate and manage memory in some operating
  systems and programming languages.
* Used to solve popular problems like [Next Greater]( [Previous Greater]( [Next Smaller]( [Previous Smaller]( [Largest Area in a Histogram]( and [Stock Span Problems](

Advantages of Stacks:

* ****Simplicity:**** Stacks are a simple and easy-to-understand data structure, making
  them suitable for a wide range of applications.
* ****Efficiency:**** Push and pop operations on a stack can be performed in constant time ****(O(1))****, providing efficient access to data.
* ****Last-in, First-out (LIFO):****
  Stacks follow the LIFO principle, ensuring that the last element added
  to the stack is the first one removed. This behavior is useful in many
  scenarios, such as function calls and expression evaluation.
* ****Limited memory usage:**** Stacks only need to store the elements that have been pushed onto
  them, making them memory-efficient compared to other data
  structures.

Disadvantages of Stacks:

* ****Limited access:****
  Elements in a stack can only be accessed from the top, making it
  difficult to retrieve or modify elements in the middle of the
  stack.
* ****Potential for overflow:**** If more elements are pushed onto a stack than it can hold, an
  overflow error will occur, resulting in a loss of data.
* ****Not suitable for random access:**** Stacks do not allow for random access to elements, making them
  unsuitable for applications where elements need to be accessed in a
  specific order.
* ****Limited capacity:****
  Stacks have a fixed capacity, which can be a limitation if the number
  of elements that need to be stored is unknown or highly
  variable.


Course Name: Introduction to DSA I

Lesson Name: Introduction to Circular Linked List

Content:
What is a Circular Linked List?

A ****circular linked list****
is a special type of linked list where all the nodes are connected to
form a circle. Unlike a regular linked list, which ends with a node
pointing to ****NULL****, the last node in a circular linked list points back to the first
node. This means that you can keep traversing the list without ever
reaching a ****NULL**** value.

Types of Circular Linked Lists

We can create a circular linked list from both [singly linked lists]( and [doubly linked lists]( So, circular linked list are basically of two types:

### 1. Circular Singly Linked List

In ****Circular Singly Linked List****, each node has just one pointer called the “****next****” pointer. The next pointer of ****last node**** points back to the ****first node**** and this results in forming a circle. In this type of Linked list we
can only move through the list in one direction.

![Representation-of-circular-linked-list](

Representation of Circular Singly Linked List

### 2. Circular Doubly Linked List:

In ****circular doubly linked**** ****list,**** each node has two pointers ****prev**** and ****next,**** similar to doubly linked list. The ****prev**** pointer points to the previous node and the ****next**** points to the next node. Here, in addition to the ****last**** node storing the address of the first node, the ****first node**** will also store the address of the ****last node****.

![Representation-of-circular-doubly-linked-list](

Representation of Circular Doubly Linked List

****Note:**** In this article, we will use the circular singly linked list to explain
the working of circular linked lists.

Representation of a Circular Singly Linked List

Let’s take a look on the structure of a circular linked list.



![Node-structure-of-circular-linked-list](

Representation of a Circular Singly Linked List

### Create/Declare a Node of Circular Linked List













In the code above, each node has ****data**** and a ****pointer**** to the next node. When we create multiple nodes for a circular linked
list, we only need to connect the last node back to the first one.

Example of Creating a Circular Linked List

Here’s an example of creating a circular linked list with three nodes
(2, 3, 4):

![Circular-Linked-List](











In the above code, we have created three nodes ****first, second,**** and ****last**** having values ****2, 3,**** and ****4**** respectively.

* After creating three nodes, we have connected these node in a
  series.
* Connect the first node “****first”**** to “****second”**** node by ****s****toring the address of “****second”**** nodeinto ****first’s**** next
* Connect the second node “****second”**** to “****second”**** node by ****s****toring the address of “****third****” node into ****second’s**** next
* After connecting all the nodes, we reach the key characteristic of a
  circular linked list: linking the last node back to the first node. Therefore, we store the address of the “****first****” node in the “****last****” node.

### Why have we taken a pointer that points to the last node instead of the first node?

For the insertion of a node at the beginning, we need to traverse the
whole list. Also, for insertion at the end, the whole list has to be
traversed. If instead of the start pointer, we take a pointer to the
last node, then in both cases there won’t be any need to traverse the
whole list. So insertion at the beginning or at the end takes constant
time, irrespective of the length of the list.

Operations on the Circular Linked list:

We can do some operations on the circular linked list similar to the
singly and doubly linked list which are:

* ****Insertion****
  + Insertion at the empty list
  + Insertion at the beginning
  + Insertion at the end
  + Insertion at the given position
* ****Deletion****
  + Delete the first node
  + Delete the last node
  + Delete the node from any position
* ****Searching****

****Note:**** We will be using the circular singly linked list to represent the
working of the circular linked list.

[Insertion in the circular linked list:](

Insertion is a fundamental operation in linked lists that involves
adding a new node to the list. The only extra step is connecting the
last node to the first one. In the circular linked list mentioned below,
we can insert nodes in four ways:

### 1. Insertion in an empty List in the circular linked list

> To insert a node in empty circular linked list, creates a ****new node**** with the given data, sets its next pointer to point to itself, and
> updates the ****last**** pointer to reference this ****new node****.

![Insertion-in-an-empty-list-in-circular-linked-list](






### 2. Insertion at the beginning in circular linked list

> To insert a new node at the beginning of a circular linked list, we
> first create the ****new node****
> and allocate memory for it. If the list is empty (indicated by the
> last pointer being ****NULL****), we make the ****new node****
> point to itself. If the list already contains nodes then we set the ****new node’s**** next pointer to point to the ****current head**** of the list (which is ****last->next****), and then update the last node’s next pointer to point to the ****new node****. This maintains the circular structure of the list.

![Insertion-at-the-beginning-of-circular-linked-list](







### 3. Insertion at the end in circular linked list

> To insert a new node at the end of a circular linked list, we first
> create the new node and allocate memory for it. If the list is empty
> (mean, ****last**** or ****tail**** pointer being ****NULL****), we initialize the list with the ****new node**** and making it point to itself to form a circular structure. If the
> list already contains nodes then we set the ****new node’s**** next pointer to point to the ****current head**** (which is ****tail->next****), then update the ****current tail’s**** next pointer to point to the ****new node****. Finally, we update the ****tail pointer**** to the ****new node.**** This will ensure that the ****new node**** is now the ****last node**** in the list while maintaining the circular linkage.

![Insertion-at-the-end-of-circular-linked-list](






### 4. Insertion at specific position in circular linked list

> To insert a new node at a specific position in a circular linked
> list, we first check if the list is empty. If it is and the ****position**** is not ****1****
> then we print an error message because the position doesn’t exist in
> the list. If the ****position**** is ****1**** then we create the ****new node**** and make it point to itself. If the list is not empty, we create the ****new node**** and traverse the list to find the correct insertion point. If the ****position**** is ****1****, we insert the ****new node****
> at the beginning by adjusting the pointers accordingly. For other
> positions, we traverse through the list until we reach the desired
> position and inserting the ****new node****
> by updating the pointers. If the new node is inserted at the end, we
> also update the ****last****
> pointer to reference the new node, maintaining the circular structure
> of the list.

![Insertion-at-specific-position-of-circular-linked-list](







[Deletion from a Circular Linked List](

Deletion involves removing a node from the linked list. The main
difference is that we need to ensure the list remains circular after the
deletion. We can delete a node in a circular linked list in three
ways:

### 1. Delete the first node in circular linked list

> To delete the first node of a circular linked list, we first check if
> the list is empty. If it is then we print a message and return ****NULL****. If the list contains only one node (the ****head**** is the same as the ****last****) then we delete that node and set the ****last**** pointer to ****NULL****. If there are multiple nodes then we update the ****last->next**** pointer to skip the ****head**** node and effectively removing it from the list. We then delete the ****head**** node to free the allocated memory. Finally, we return the updated ****last**** pointer, which still points to the ****last**** node in the list.

![Deletion-from-the-beginning-of-circular-linked-list](






### 2. Delete a specific node in circular linked list

> To delete a specific node from a circular linked list, we first check
> if the list is empty. If it is then we print a message and return ****nullptr****. If the list contains only one node and it matches the ****key**** then we delete that node and set ****last**** to ****nullptr****. If the node to be deleted is the first node then we update
> the ****next**** pointer of the ****last**** node to skip the ****head**** node and delete the ****head****. For other nodes, we traverse the list using two pointers: ****curr**** (to find the node) and ****prev****
> (to keep track of the previous node). If we find the node with the
> matching key then we update the next pointer of ****prev**** to skip the ****curr****
> node and delete it. If the node is found and it is the last node, we
> update the ****last****
> pointer accordingly. If the node is not found then do nothing and ****tail**** or ****last**** as it is. Finally, we return the updated ****last**** pointer.

![Delete-a-specific-node-in-circular-linked-list](






### 3. Deletion at the end of Circular linked list

> To delete the last node in a circular linked list, we first check if
> the list is empty. If it is, we print a message and return ****nullptr****. If the list contains only one node (where the ****head**** is the same as the ****last****), we delete that node and set ****last**** to ****nullptr****. For lists with multiple nodes, we need to traverse the list to find
> the ****second last node****. We do this by starting from the ****head**** and moving through the list until we reach the node whose next
> pointer points to ****last****. Once we find the ****second last**** node then we update its next pointer to point back to the ****head,****
> this effectively removing the last node from the list. We then delete
> the last node to free up memory and return the updated ****last**** pointer, which now points to the last node.

![Deletion-at-the-end-of-circular-linked-list](








[Searching in Circular Linked list](

Searching in a circular linked list is similar to searching in a
regular linked list. We start at a given node and traverse the list
until you either find the target value or return to the starting node.
Since the list is circular, make sure to keep track of where you started
to avoid an infinite loop.

> To search for a specific value in a circular linked list, we first
> check if the list is empty. If it is then we return ****false****. If the list contains nodes then we start from the ****head**** node (which is the ****last->next****) and traverse the list. We use a pointer ****curr**** to iterate through the nodes until we reach back to the ****head****. During traversal, if we find a node whose ****data**** matches the given ****key**** then we return ****true**** to indicating that the value was found. After the loop, we also check
> the last node to ensure we don’t miss it. If the ****key**** is not found after traversing the entire list then we return ****false****.








Advantages of Circular Linked Lists

* In circular linked list, the last node points to the first node.
  There are no null references, making traversal easier and reducing the
  chances of encountering null pointer exceptions.
* We can traverse the list from any node and return to it without
  needing to restart from the head, which is useful in applications
  requiring a circular iteration.
* Circular linked lists can easily implement circular queues, where the
  last element connects back to the first, allowing for efficient
  resource management.
* In a circular linked list, each node has a reference to the next node
  in the sequence. Although it doesn’t have a direct reference to the
  previous node like a doubly linked list, we can still find the
  previous node by traversing the list.

Disadvantages of Circular Linked Lists

* Circular linked lists are more complex to implement than singly
  linked lists.
* Traversing a circular linked list without a clear stopping condition
  can lead to infinite loops if not handled carefully.
* Debugging can be more challenging due to the circular nature, as
  traditional methods of traversing linked lists may not apply.

Applications of Circular Linked Lists

* It is used for time-sharing among different users, typically through
  a ****Round-Robin scheduling mechanism.****
* In multiplayer games, a circular linked list can be used to switch
  between players. After the last player’s turn, the list cycles back to
  the first player.
* Circular linked lists are often used in buffering applications, such
  as streaming data, where data is continuously produced and
  consumed.
* In media players, circular linked lists can manage playlists, this
  allowing users to loop through songs continuously.
* Browsers use circular linked lists to manage the cache. This allows
  you to navigate back through your browsing history efficiently by
  pressing the BACK button.

Course Name: Stack
Lesson Name: What is Stack Data Structure? A Complete Tutorial

Content:
Representation of Stack Data Structure:

Stack follows LIFO (Last In First Out) Principle so the element which
is pushed last is popped first.


![Stack-representation-in-Data-Structures-(1)](

****Types of Stack:****

* ****Fixed Size Stack**** 
  : As the name suggests, a fixed size stack has a fixed size and cannot
  grow or shrink dynamically. If the stack is full and an attempt is
  made to add an element to it, an overflow error occurs. If the stack
  is empty and an attempt is made to remove an element from it, an
  underflow error occurs.
* ****Dynamic Size Stack**** 
  : A dynamic size stack can grow or shrink dynamically. When the stack
  is full, it automatically increases its size to accommodate the new
  element, and when the stack is empty, it decreases its size. This type
  of stack is implemented using a linked list, as it allows for easy
  resizing of the stack.

Basic Operations on Stack:

In order to make manipulations in a stack, there are certain operations
provided to us.


* ****push()****  to insert an element into the stack
* ****pop()****  to remove an element from the stack
* ****top()****  Returns the top element of the stack.
* ****isEmpty()****  returns true if stack is empty else false.
* ****isFull()****  returns true if the stack is full else false.

To implement stack, we need to maintain reference to the top
item.

### ****Push Operation on Stack****

Adds an item to the stack. If the stack is full, then it is said to be
an  ****Overflow condition.**** 

 ****Algorithm for Push Operation:**** 

* Before pushing the element to the stack, we check if the stack is  ****full****  .
* If the stack is full  ****(top == capacity-1)****  , then  ****Stack Overflows****  and we cannot insert the element to the stack.
* Otherwise, we increment the value of top by 1  ****(top = top + 1)****  and the new value is inserted at  ****top position****  .
* The elements can be pushed into the stack till we reach the  ****capacity****  of the stack.

![Push-Operation-in-Stack-(1)](
### ****Pop Operation in Stack****

Removes an item from the stack. The items are popped in the reversed
order in which they are pushed. If the stack is empty, then it is said
to be an  ****Underflow condition.**** 

****Algorithm for Pop Operation:**** 

* Before popping the element from the stack, we check if the stack is  ****empty****  .
* If the stack is empty (top == -1), then  ****Stack Underflows****  and we cannot remove any element from the stack.
* Otherwise, we store the value at top, decrement the value of top by 1  ****(top = top – 1)****  and return the stored top value.

![Pop-Operation-in-Stack-(1)](
### ****Top or Peek Operation on Stack****

Returns the top element of the stack. 

****Algorithm for Top Operation:**** 

* Before returning the top element from the stack, we check if the
  stack is empty.
* If the stack is empty (top == -1), we simply print “Stack is empty”.
* Otherwise, we return the element stored at  ****index = top****  .

![Top-or-Peek-Operation-in-Stack-(1)](
### ****isEmpty Operation in Stack Data Structure:****

Returns true if the stack is empty, else false. 

****Algorithm for isEmpty Operation****: 

* Check for the value of  ****top****  in stack.
* If  ****(top == -1)****, then the stack is  ****empty****  so return  ****true****  .
* Otherwise, the stack is not empty so return  ****false****  .

![isEmpty-Operation-in-Stack-(1)](
### isFull ****Operation in Stack**** ****Data Structure****:

Returns true if the stack is full, else false. 

****Algorithm for isFull Operation:**** 

* Check for the value of  ****top****  in stack.
* If  ****(top == capacity-1),****  then the stack is  ****full****  so return  ****true****.
* Otherwise, the stack is not full so return  ****false****.

![isFull-Operation-in-Stack-(1)](

Implementation of Stack


The basic operations that can be performed on a stack include push, pop,
and peek. There are two ways to implement a stack –


* [****Implementation of Stack using Array****](
* [****Implementation of Stack using Linked List****](

****Complexity Analysis of Operations on Stack Data Structure:****

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****push()**** | O(1) | O(1) |
| ****pop()**** | O(1) | O(1) |
| top() or  ****pee****k() | O(1) | O(1) |
| isEmpty() | O(1) | O(1) |
| isFull() | O(1) | O(1) |

Course Name: The Logic Building Problems
Lesson Name: Find numbers from 1 to N with exactly 3 divisors

Content:

Given a number

****N****
, print all numbers in the range from 1 to N having exactly 3 divisors.


****Examples:****


> ****Input:****
> N = 16
>
>
>
> ****Output:****
> 4 9
>
>
>
> ****Explanation****
> : 4 and 9 have exactly three divisors.
>
>
> ****Input:****
> N = 49
>
>
>
> ****Output:****
> 4 9 25 49
>
>
>
> ****Explanation:****
> 4, 9, 25 and 49 have exactly three divisors.

Recommended Practice

[3 Divisors](


[Try It!](


****Mathematical approach to find Numbers with exactly 3 divisors:****


To solve the problem follow the below idea:


> ****Idea:****
> After having a close look at the examples mentioned above, you have noticed that all the required numbers are perfect squares and that too of only prime numbers.
>
>
> ****Proof:****
> Suppose the number is N, and it is a perfect square with square root X such that X is prime.
>
>
> Now if we find the factors of N, it will always have following combinations:
>
>
> * 1\*N
> * X\*X
>
>
> Therefore the required numbers will have only three numbers as their divisors:
>
>
> * 1,
> * that number itself, and
> * just a single divisor in between 1 and the number.

****Algorithm:****
We can generate all primes within a set using any sieve method efficiently and then we should take all primes i, such that

****i\*i <=N****
.


Follow the below steps to solve the problem:


* Generate the prime numbers from 1 to N using any sieve method efficiently
* Print all the prime numbers(X) between 1 to N, such as X








****Time Complexity:****
O(N\*log(log(N)))



****Auxiliary Space:****
O(N)


****Numbers with exactly 3 divisors using constant space:****

> Run a loop from 2 to sqrt(N) and check if the current element is prime or not, if it is so then print that number, but this method will increase the time complexity of the solution


Follow the below steps to solve the problem:


* Start a loop for integer

  ****i****
  from

  ****2****
  to

  ****N.****
* Check if

  ****i****
  is prime or not, which can be done easily using the

  [****isPrime(n)****](

  method.
* If

  ****i****
  is prime, check if its square is less than or equal to the given number. This will be reviewed only for squares of prime numbers, therefore reducing the number of checks.
* If the above condition is satisfied, the number will be printed and the loop will continue till

  ****i <= n.****







****Time Complexity:****
O(sqrt N

2
)



****Auxiliary Space:****
O(1)




Course Name: Introduction to DSA I

Lesson Name: What is Stack Data Structure? A Complete Tutorial

Content:
Representation of Stack Data Structure:

Stack follows LIFO (Last In First Out) Principle so the element which
is pushed last is popped first.


![Stack-representation-in-Data-Structures-(1)](

****Types of Stack:****

* ****Fixed Size Stack****
  : As the name suggests, a fixed size stack has a fixed size and cannot
  grow or shrink dynamically. If the stack is full and an attempt is
  made to add an element to it, an overflow error occurs. If the stack
  is empty and an attempt is made to remove an element from it, an
  underflow error occurs.
* ****Dynamic Size Stack****
  : A dynamic size stack can grow or shrink dynamically. When the stack
  is full, it automatically increases its size to accommodate the new
  element, and when the stack is empty, it decreases its size. This type
  of stack is implemented using a linked list, as it allows for easy
  resizing of the stack.

Basic Operations on Stack:

In order to make manipulations in a stack, there are certain operations
provided to us.


* ****push()****  to insert an element into the stack
* ****pop()****  to remove an element from the stack
* ****top()****  Returns the top element of the stack.
* ****isEmpty()****  returns true if stack is empty else false.
* ****isFull()****  returns true if the stack is full else false.

To implement stack, we need to maintain reference to the top
item.

### ****Push Operation on Stack****

Adds an item to the stack. If the stack is full, then it is said to be
an  ****Overflow condition.****

 ****Algorithm for Push Operation:****

* Before pushing the element to the stack, we check if the stack is  ****full****  .
* If the stack is full  ****(top == capacity-1)****  , then  ****Stack Overflows****  and we cannot insert the element to the stack.
* Otherwise, we increment the value of top by 1  ****(top = top + 1)****  and the new value is inserted at  ****top position****  .
* The elements can be pushed into the stack till we reach the  ****capacity****  of the stack.

![Push-Operation-in-Stack-(1)](
### ****Pop Operation in Stack****

Removes an item from the stack. The items are popped in the reversed
order in which they are pushed. If the stack is empty, then it is said
to be an  ****Underflow condition.****

****Algorithm for Pop Operation:****

* Before popping the element from the stack, we check if the stack is  ****empty****  .
* If the stack is empty (top == -1), then  ****Stack Underflows****  and we cannot remove any element from the stack.
* Otherwise, we store the value at top, decrement the value of top by 1  ****(top = top – 1)****  and return the stored top value.

![Pop-Operation-in-Stack-(1)](
### ****Top or Peek Operation on Stack****

Returns the top element of the stack.

****Algorithm for Top Operation:****

* Before returning the top element from the stack, we check if the
  stack is empty.
* If the stack is empty (top == -1), we simply print “Stack is empty”.
* Otherwise, we return the element stored at  ****index = top****  .

![Top-or-Peek-Operation-in-Stack-(1)](
### ****isEmpty Operation in Stack Data Structure:****

Returns true if the stack is empty, else false.

****Algorithm for isEmpty Operation****:

* Check for the value of  ****top****  in stack.
* If  ****(top == -1)****, then the stack is  ****empty****  so return  ****true****  .
* Otherwise, the stack is not empty so return  ****false****  .

![isEmpty-Operation-in-Stack-(1)](
### isFull ****Operation in Stack**** ****Data Structure****:

Returns true if the stack is full, else false.

****Algorithm for isFull Operation:****

* Check for the value of  ****top****  in stack.
* If  ****(top == capacity-1),****  then the stack is  ****full****  so return  ****true****.
* Otherwise, the stack is not full so return  ****false****.

![isFull-Operation-in-Stack-(1)](

Implementation of Stack


The basic operations that can be performed on a stack include push, pop,
and peek. There are two ways to implement a stack –


* [****Implementation of Stack using Array****](
* [****Implementation of Stack using Linked List****](

****Complexity Analysis of Operations on Stack Data Structure:****

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****push()**** | O(1) | O(1) |
| ****pop()**** | O(1) | O(1) |
| top() or  ****pee****k() | O(1) | O(1) |
| isEmpty() | O(1) | O(1) |
| isFull() | O(1) | O(1) |

Course Name: The Logic Building Problems
Lesson Name: Square root of an integer

Content:
Given a positive integer

****n****
, find its square root. If

****n****
is not a perfect square, then return

****floor****
of

****√n****
.


****Examples :****


> ****Input:****
> n = 4
>
>
>
> ****Output:****
> 2
>
>
>
> ****Explanation:****
> The square root of 4 is 2.
>
>
> ****Input:****
> n = 11
>
>
>
> ****Output:****
> 3
>
>
>
> ****Explanation:****
> The square root of 11 lies in between 3 and 4 so floor of the square root is 3.

Table of Content

* [[Naive Approach] Using a loop – O(sqrt(n)) Time and O(1) Space](#approach-1-using-a-loop-on-time-and-o1-space)
* [[Expected Approach] Using Binary Search – O(logn) Time and O(1) Space](#approach-2-using-binary-search-ologn-time-and-o1-space)
* [[Alternate Approach] Using Built In functions – O(logn) Time and O(1) Space](#approach-3-using-built-in-functions-ologn-time-and-o1-space)
* [[Alternate Approach] Using Formula Used by Pocket Calculators – O(1) Time and O(1) Space](#approach-4-using-formula-used-by-pocket-calculators-o1-time-and-o1-space)
### [Naive Approach] Using a loop – O(sqrt(n)) Time and O(1) Space


As, we know that square root of a positive integer is always

****greater****
than or

****equal****
to one. So we start iterating from

****1****
and calculate the square of each number. We continue the iteration until we reach to an

****integer****
whose square is

****greater****
than the given integer, then the integer just

****before****
it will be our answer.







### [Expected Approach] Using Binary Search – O(logn) Time and O(1) Space

> The square root of an integer follows a
>
> ****monotonic****
> pattern, because as we
>
> ****increase****
> any number, it’s square also
>
> ****increases****
> . If the square of a number is
>
> ****greater****
> than given integer, then square root will definitely exist
>
> ****before****
> this number. Conversely, if the square of a number is
>
> ****less****
> than or
>
> ****equal****
> to
>
> ****n****
> , then either this number is the square root or it lies after this number.
>
>
>
> Therefore, we can use
>
> [binary search](
> to find the square root of n. I
>
> ****nitial search****
> space will be 1 to the given integer itself, because square root of any positive integer always exists within this range.







### [Alternate Approach] Using Built In functions – O(logn) Time and O(1) Space


We can directly use built in functions to find square root of an integer.







### [Alternate Approach] Using Formula Used by Pocket Calculators – O(1) Time and O(1) Space

[Pocket calculator](
uses the mathematical formula

****√n = e****
****1/2 \* ln(n)****
to compute the square root of an integer n. Below is mathematical proof of this formula:


> Let’s say square root of n is x:
>
>
>
> ****x = √n****
>
>
> Squaring both the sides:
>
>
>
> x
>
> 2 =
> n
>
>
>
> Taking log on both the sides:
>
>
>
> => ln(x
>
> 2
> ) = ln(n)
>
>
>
> => 2\*ln(x) = ln(n)
>
>
>
> => ln(x) = 1/2 \* ln(n)
>
>
>
> To isolate x, exponentiate both sides with base e:
>
>
>
> => x = e
>
> 1/2 \* ln(n)
>
>
> x is the square root of n:
>
>
>
> ****√n****
> = e
>
> 1/2 \* ln(n)


Because of the way computations are done in computers in case of decimals, the result from the expression may be slightly less than the actual square root. Therefore, we will also consider the

****next integer****
after the calculated result as a potential answer.








Course Name: The Logic Building Problems
Lesson Name: Factorial of a Number

Content:
Given the number

****n****
(n >=0), find its

[factorial](
. Factorial of n is defined as 1 x 2 x … x n. For n = 0, factorial is 1. We are going to discuss iterative and recursive programs in this post.


****Examples:****

> ****Input****
> : n = 5
>
>
>
> ****Output****
> : 120
>
>
>
> ****Explanation****
> : 5! = 5 \* 4 \* 3 \* 2 \* 1 = 120
>
>
> ****Input****
> : n = 4
>
>
>
> ****Output****
> : 24
>
>
>
> ****Explanation****
> : 4! = 4 \* 3 \* 2 \* 1 = 24
>
>
> ****Input****
> : n = 0
>
>
>
> ****Output****
> : 1
>
>
> ****Input****
> : n = 1
>
>
>
> ****Output****
> : 1

### ****Iterative Solution****


The idea is simple, we initialize result as 1. Then run a loop from 1 to n and multiply every number with n.



> ****Illustration for n = 4****
>
>
> Initialize res = 1
>
>
>
> Run a loop for i = 2 to 4
>
>
>
> i = 2 : res = res \* 2 = 2
>
>
>
> i = 3 : res = res \* 3 = 6
>
>
>
> i = 4 : res = res \* 4 = 24









****Time Complexity:****
O(n), since we are running a loop from 1 to n.



****Auxiliary Space:****
O(1)


### ****Recursive Solution****


Let us first see how we can break factorial(n) into smaller problem and then define recurrance.


> * ****n!****
>   = n \* (n – 1) \* (n – 2) …. 2 \* 1
> * ****(n – 1)!****
>   = (n – 1) \* (n – 2) … 2 \* 1
>
>
> From the above two equations, we can say that n
>
> ****! = n \* (n – 1)!****
>
>
>
>
> Since the problem can be broken down into The idea is to define a recursive function, say
>
> ****factorial(n)****
> to calculate the
>
> [factorial](
> of number
>
> ****n****
> . According to the value of n, we can have two cases:
>
>
> ****if****
> n
>
> ****= 0 or n = 1 :****
>
>
>
> factorial(n) = 1
>
>
>
> ****Else****
> :
>
>
>
> factorial(n) = n \* factorial(n – 1).

****Illustration:****

![factorial](









****Time Complexity:****
O(n), since the function is being called n times



****Auxiliary Space:****
O(n), In the worst case, the recursion stack space would be full with all the function calls waiting to get completed and that would make it an O(n) recursion stack space.


****Which approach is better – iterative or recursive?****


Iterative approach is better as the recursive approach requires extra space for recursion call stack and overhead of recursion calls. However writing a recursive code is always a fun exercise.


****How do we handle large numbers?****


One simple improvement that we can do is use long long in C/C++ and long in Java/C#, but that does not help much as factorials are really large numbers and causes overflow for small values. Please refer


Course Name: Introduction to DSA I

Lesson Name: Introduction to Queue Data Structure

Content:
Basic Terminologies of Queue

* ****Front:**** Position of the entry in a queue ready to be served, that is, the
  first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.
* ****Rear:****
  Position of the last entry in the queue, that is, the one most
  recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.
* ****Size:**** Size refers to the ****current**** number of elements in the queue.
* ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.

****Representation of Queue****

![Representation-of-Queue-Data-Structure](

Operations on Queue

### ****1. Enqueue:****

Enqueue operation ****adds (or stores) an element to the end of the queue****.

****Steps:****

1. Check if the ****queue is full****. If so, return an ****overflow**** error and exit.
2. If the queue is ****not full****, increment the ****rear**** pointer to the next available position.
3. Insert the element at the rear.


![Enqueue-Operation-in-Queue-01.webp](


![Enqueue-Operation-in-Queue-02.webp](


![Enqueue-Operation-in-Queue-03.webp](


![Enqueue-Operation-in-Queue-04.webp](


![Enqueue-Operation-in-Queue-05.webp](


![Enqueue-Operation-in-Queue-06.webp](



Previous





Pause

Next





3 / 6



### ****2. Dequeue:****

Dequeue operation removes the element at the front of the queue. The
following steps are taken to perform the dequeue operation:


1. Check if the ****queue is empty****. If so, return an ****underflow**** error.
2. Remove the element at the ****front****.
3. ****Increment**** the ****front**** pointer to the next element.


![Dequeue-Operation-in-Queue-01-.webp](


![Dequeue-Operation-in-Queue-02-.webp](


![Dequeue-Operation-in-Queue-03.webp](


![Dequeue-Operation-in-Queue-04.webp](


![Dequeue-Operation-in-Queue-05.webp](


![Dequeue-Operation-in-Queue-06.webp](



Previous





Play

Next





1 / 6



### ****3. Peek or Front Operation:****

This operation returns the element at the front end without removing
it.

### 4. Size Operation:

This operation returns the numbers of elements present in the
queue.

### ****5. isEmpty Operation:****

This operation returns a boolean value that indicates whether the queue
is empty or not.

### ****6. isFull Operation:****

This operation returns a boolean value that indicates whether the queue
is full or not.

Implementation of Queue Data Structure

Queue can be implemented using following data structures:

* [Implementation of Queue using Arrays](
* [Implementation of Queue using Linked List](

Complexity Analysis of Operations on Queue

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****enqueue**** | O(1) | O(1) |
| ****dequeue**** | O(1) | O(1) |
| front | O(1) | O(1) |
| size | O(1) | O(1) |
| isEmpty | O(1) | O(1) |
| isFull | O(1) | O(1) |

****Types of Queues****

Queue data structure can be classified into 4 types:

1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the
   element from the front of the queue.
2. [****Double-Ended Queue (Deque)****](
   In a double-ended queue the insertion and deletion operations, both
   can be performed from both ends. They are of two types:
   * ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be
     taken from only one end but deletion can be done from any of the
     ends.
   * ****Output Restricted Queue:****
     This is also a simple queue. In this type of queue, the input can
     be taken from both ends but deletion can be done from only one
     end.
3. [****Circular Queue:****]( This is a special type of queue where the last position is connected
   back to the first position. Here also the operations are performed in
   FIFO order.
4. [****Priority Queue****](
   A priority queue is a special queue where the elements are accessed
   based on the priority assigned to them. They are of two types:
   * ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in
     increasing order of their priority values. Element with smallest
     priority value is popped first.
   * ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in
     decreasing order of their priority values. Element with largest
     priority is popped first.

![Types-of-Queue](

****Applications of Queue Data Structure****

Application of queue is common. In a computer system, there may be
queues of tasks waiting for the printer, for access to disk storage, or
even in a time-sharing system, for use of the CPU. Within a single
program, there may be multiple requests to be kept in a queue, or one
task may create other tasks, which must be done in turn by keeping them
in a queue.

* A Queue is always used as a buffer when we have a speed mismatch
  between a producer and consumer. For example keyboard and CPU.
* Queue can be used where we have a single resource and multiple
  consumers like a single CPU and multiple processes.
* In a network, a queue is used in devices such as a router/switch and
  mail queue.
* Queue can be used in various algorithm techniques like Breadth First
  Search, Topological Sort, etc.

Course Name: Queue
Lesson Name: Introduction to Queue Data Structure

Content:
Basic Terminologies of Queue

* ****Front:**** Position of the entry in a queue ready to be served, that is, the
  first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.
* ****Rear:****
  Position of the last entry in the queue, that is, the one most
  recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.
* ****Size:**** Size refers to the ****current**** number of elements in the queue.
* ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.

****Representation of Queue****

![Representation-of-Queue-Data-Structure](

Operations on Queue

### ****1. Enqueue:****

Enqueue operation ****adds (or stores) an element to the end of the queue****. 

****Steps:****

1. Check if the ****queue is full****. If so, return an ****overflow**** error and exit.
2. If the queue is ****not full****, increment the ****rear**** pointer to the next available position.
3. Insert the element at the rear.


![Enqueue-Operation-in-Queue-01.webp](


![Enqueue-Operation-in-Queue-02.webp](


![Enqueue-Operation-in-Queue-03.webp](


![Enqueue-Operation-in-Queue-04.webp](


![Enqueue-Operation-in-Queue-05.webp](


![Enqueue-Operation-in-Queue-06.webp](



Previous





Pause

Next





3 / 6



### ****2. Dequeue:****

Dequeue operation removes the element at the front of the queue. The
following steps are taken to perform the dequeue operation:


1. Check if the ****queue is empty****. If so, return an ****underflow**** error.
2. Remove the element at the ****front****.
3. ****Increment**** the ****front**** pointer to the next element.


![Dequeue-Operation-in-Queue-01-.webp](


![Dequeue-Operation-in-Queue-02-.webp](


![Dequeue-Operation-in-Queue-03.webp](


![Dequeue-Operation-in-Queue-04.webp](


![Dequeue-Operation-in-Queue-05.webp](


![Dequeue-Operation-in-Queue-06.webp](



Previous





Play

Next





1 / 6



### ****3. Peek or Front Operation:****

This operation returns the element at the front end without removing
it.

### 4. Size Operation:

This operation returns the numbers of elements present in the
queue.

### ****5. isEmpty Operation:****

This operation returns a boolean value that indicates whether the queue
is empty or not.

### ****6. isFull Operation:****

This operation returns a boolean value that indicates whether the queue
is full or not.

Implementation of Queue Data Structure

Queue can be implemented using following data structures:

* [Implementation of Queue using Arrays](
* [Implementation of Queue using Linked List](

Complexity Analysis of Operations on Queue

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****enqueue**** | O(1) | O(1) |
| ****dequeue**** | O(1) | O(1) |
| front | O(1) | O(1) |
| size | O(1) | O(1) |
| isEmpty | O(1) | O(1) |
| isFull | O(1) | O(1) |

****Types of Queues****

Queue data structure can be classified into 4 types:

1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the
   element from the front of the queue.
2. [****Double-Ended Queue (Deque)****](
   In a double-ended queue the insertion and deletion operations, both
   can be performed from both ends. They are of two types:
   * ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be
     taken from only one end but deletion can be done from any of the
     ends.
   * ****Output Restricted Queue:****
     This is also a simple queue. In this type of queue, the input can
     be taken from both ends but deletion can be done from only one
     end.
3. [****Circular Queue:****]( This is a special type of queue where the last position is connected
   back to the first position. Here also the operations are performed in
   FIFO order.
4. [****Priority Queue****](
   A priority queue is a special queue where the elements are accessed
   based on the priority assigned to them. They are of two types:
   * ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in
     increasing order of their priority values. Element with smallest
     priority value is popped first.
   * ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in
     decreasing order of their priority values. Element with largest
     priority is popped first.

![Types-of-Queue](

****Applications of Queue Data Structure****

Application of queue is common. In a computer system, there may be
queues of tasks waiting for the printer, for access to disk storage, or
even in a time-sharing system, for use of the CPU. Within a single
program, there may be multiple requests to be kept in a queue, or one
task may create other tasks, which must be done in turn by keeping them
in a queue.

* A Queue is always used as a buffer when we have a speed mismatch
  between a producer and consumer. For example keyboard and CPU.
* Queue can be used where we have a single resource and multiple
  consumers like a single CPU and multiple processes.
* In a network, a queue is used in devices such as a router/switch and
  mail queue.
* Queue can be used in various algorithm techniques like Breadth First
  Search, Topological Sort, etc.

Course Name: Queue
Lesson Name: Introduction to Queue Data Structure

Content:
Basic Terminologies of Queue

* ****Front:**** Position of the entry in a queue ready to be served, that is, the
  first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.
* ****Rear:****
  Position of the last entry in the queue, that is, the one most
  recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.
* ****Size:**** Size refers to the ****current**** number of elements in the queue.
* ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.

****Representation of Queue****

![Representation-of-Queue-Data-Structure](

Operations on Queue

### ****1. Enqueue:****

Enqueue operation ****adds (or stores) an element to the end of the queue****. 

****Steps:****

1. Check if the ****queue is full****. If so, return an ****overflow**** error and exit.
2. If the queue is ****not full****, increment the ****rear**** pointer to the next available position.
3. Insert the element at the rear.


![Enqueue-Operation-in-Queue-01.webp](


![Enqueue-Operation-in-Queue-02.webp](


![Enqueue-Operation-in-Queue-03.webp](


![Enqueue-Operation-in-Queue-04.webp](


![Enqueue-Operation-in-Queue-05.webp](


![Enqueue-Operation-in-Queue-06.webp](



Previous





Pause

Next





3 / 6



### ****2. Dequeue:****

Dequeue operation removes the element at the front of the queue. The
following steps are taken to perform the dequeue operation:


1. Check if the ****queue is empty****. If so, return an ****underflow**** error.
2. Remove the element at the ****front****.
3. ****Increment**** the ****front**** pointer to the next element.


![Dequeue-Operation-in-Queue-01-.webp](


![Dequeue-Operation-in-Queue-02-.webp](


![Dequeue-Operation-in-Queue-03.webp](


![Dequeue-Operation-in-Queue-04.webp](


![Dequeue-Operation-in-Queue-05.webp](


![Dequeue-Operation-in-Queue-06.webp](



Previous





Play

Next





1 / 6



### ****3. Peek or Front Operation:****

This operation returns the element at the front end without removing
it.

### 4. Size Operation:

This operation returns the numbers of elements present in the
queue.

### ****5. isEmpty Operation:****

This operation returns a boolean value that indicates whether the queue
is empty or not.

### ****6. isFull Operation:****

This operation returns a boolean value that indicates whether the queue
is full or not.

Implementation of Queue Data Structure

Queue can be implemented using following data structures:

* [Implementation of Queue using Arrays](
* [Implementation of Queue using Linked List](

Complexity Analysis of Operations on Queue

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****enqueue**** | O(1) | O(1) |
| ****dequeue**** | O(1) | O(1) |
| front | O(1) | O(1) |
| size | O(1) | O(1) |
| isEmpty | O(1) | O(1) |
| isFull | O(1) | O(1) |

****Types of Queues****

Queue data structure can be classified into 4 types:

1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the
   element from the front of the queue.
2. [****Double-Ended Queue (Deque)****](
   In a double-ended queue the insertion and deletion operations, both
   can be performed from both ends. They are of two types:
   * ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be
     taken from only one end but deletion can be done from any of the
     ends.
   * ****Output Restricted Queue:****
     This is also a simple queue. In this type of queue, the input can
     be taken from both ends but deletion can be done from only one
     end.
3. [****Circular Queue:****]( This is a special type of queue where the last position is connected
   back to the first position. Here also the operations are performed in
   FIFO order.
4. [****Priority Queue****](
   A priority queue is a special queue where the elements are accessed
   based on the priority assigned to them. They are of two types:
   * ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in
     increasing order of their priority values. Element with smallest
     priority value is popped first.
   * ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in
     decreasing order of their priority values. Element with largest
     priority is popped first.

![Types-of-Queue](

****Applications of Queue Data Structure****

Application of queue is common. In a computer system, there may be
queues of tasks waiting for the printer, for access to disk storage, or
even in a time-sharing system, for use of the CPU. Within a single
program, there may be multiple requests to be kept in a queue, or one
task may create other tasks, which must be done in turn by keeping them
in a queue.

* A Queue is always used as a buffer when we have a speed mismatch
  between a producer and consumer. For example keyboard and CPU.
* Queue can be used where we have a single resource and multiple
  consumers like a single CPU and multiple processes.
* In a network, a queue is used in devices such as a router/switch and
  mail queue.
* Queue can be used in various algorithm techniques like Breadth First
  Search, Topological Sort, etc.

Course Name: Queue
Lesson Name: Basic Operations for Queue in Data Structure

Content:
**Basic Operations on Queue:**

Some of the basic operations for Queue in Data Structure are:

* **enqueue() –** Insertion of elements to the queue.
* **dequeue() –** Removal of elements from the queue.
* **peek() or front()-** Acquires the data element available
  at the front node of the queue without deleting it.
* **rear() –** This operation returns the element at the rear
  end without removing it.
* **isFull() –** Validates if the queue is full.
* **isEmpty() –** Checks if the queue is empty.
* **size():** This operation returns the size of the queue
  i.e. the total number of elements it contains.

![](

Queue Data Structure

### **Operation 1: enqueue()**

Inserts an element at the end of the queue i.e. at the rear end.

The following steps should be taken to enqueue (insert) data into a queue:

* Check if the queue is full.
* If the queue is full, return overflow error and exit.
* If the queue is not full, increment the rear pointer to point to the
  next empty space.
* Add the data element to the queue location, where the rear is pointing.
* return success.

![Enqueue representation](

Enqueue representation

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++

  



  

  




| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `printf``(``"\nQueue is full\n"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}` |
| --- |





Java

  



  

  




| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `System.out.println(``"\nQueue is full\n"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `void` `enqueue(``struct` `Queue* queue,` `int` `item)`  `{`  `if` `(isFull(queue))`  `return``;`  `queue->rear = (queue->rear + 1) % queue->capacity;`  `queue->array[queue->rear] = item;`  `queue->size = queue->size + 1;`  `printf``(``"%d enqueued to queue\n"``, item);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3

  



  

  




| `# Function to add an item to the queue.`  `# It changes rear and size`  `def` `EnQueue(``self``, item):`  `if` `self``.isFull():`  `print``(``"Full"``)`  `return`  `self``.rear` `=` `(``self``.rear` `+` `1``)` `%` `(``self``.capacity)`  `self``.Q[``self``.rear]` `=` `item`  `self``.size` `=` `self``.size` `+` `1`  `print``(``"% s enqueued to queue"` `%` `str``(item))`  `# This code is contributed by Susobhan Akhuli` |
| --- |





C#

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `void` `enqueue(``int` `item)`  `{`  `if` `(rear == max - 1) {`  `Console.WriteLine(``"Queue Overflow"``);`  `return``;`  `}`  `else` `{`  `ele[++rear] = item;`  `}`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Javascript

  



  

  




| `<script>`  `enqueue(element){`  `// adding element to the queue`  `this``.items.push(element);`  `}`    `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 2: dequeue()**

This operation removes and returns an element that is at the front end of
the queue.

The following steps are taken to perform the dequeue operation:

* Check if the queue is empty.
* If the queue is empty, return the underflow error and exit.
* If the queue is not empty, access the data where the front is pointing.
* Increment the front pointer to point to the next available data element.
* The Return success.

![Dequeue operation](

Dequeue operation

Below is the Implementation of above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++

  



  

  




| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `printf``(``"\nQueue is empty\n"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i = 0; i < rear - 1; i++) {`  `queue[i] = queue[i + 1];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}` |
| --- |





Java

  



  

  




| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `System.out.println(``"\nQueue is empty\n"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i =` `0``; i < rear -` `1``; i++) {`  `queue[i] = queue[i +` `1``];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C

  



  

  




| `// Function to remove an item from queue.`  `// It changes front and size`  `int` `dequeue(``struct` `Queue* queue)`  `{`  `if` `(isEmpty(queue)) {`  `printf``(``"\nQueue is empty\n"``);`  `return``;`  `}`  `int` `item = queue->array[queue->front];`  `queue->front = (queue->front + 1) % queue->capacity;`  `queue->size = queue->size - 1;`  `return` `item;`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3

  



  

  




| `# Function to remove an item from queue.`  `# It changes front and size`      `def` `DeQueue(``self``):`  `if` `self``.isEmpty():`  `print``(``"Queue is empty"``)`  `return`    `print``(``"% s dequeued from queue"` `%` `str``(``self``.Q[``self``.front]))`  `self``.front` `=` `(``self``.front` `+` `1``)` `%` `(``self``.capacity)`  `self``.size` `=` `self``.size` `-` `1`  `# This code is contributed by Susobhan Akhuli` |
| --- |





C#

  



  

  




| `// Function to remove an item from queue.`  `// It changes front and size`  `public` `int` `dequeue()`  `{`  `if` `(front == rear + 1) {`  `Console.WriteLine(``"Queue is Empty"``);`  `return` `-1;`  `}`  `else` `{`  `int` `p = ele[front++];`  `return` `p;`  `}`  `}`  `// This code is contributed by Susobhan Akhuli` |
| --- |





Javascript

  



  

  




| `<script>`  `dequeue(){`  `// removing element from the queue`  `// returns underflow when called`  `// on empty queue`  `if``(``this``.isEmpty()){`  `document.write(``"<br>Queue is empty<br>"``);`  `return` `-1;`  `}`  `return` `this``.items.shift();`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 3: front()**

This operation returns the element at the front end without removing it.

The following steps are taken to perform the front operation:

* If the queue is empty return the most minimum value.
* otherwise, return the front value.

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++

  



  

  




| `// Function to get front of queue`  `int` `front(Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}` |
| --- |





Java

  



  

  




| `// Function to get front of queue`  `int` `front(Queue queue)`  `{`  `if` `(isempty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.front];`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C

  



  

  




| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3

  



  

  




| `# Function to get front of queue`  `def` `que_front(``self``):`  `if` `self``.isempty():`  `return` `"Queue is empty"`  `return` `self``.Q[``self``.front]`    `# This code is contributed By Susobhan Akhuli` |
| --- |





C#

  



  

  




| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[front];`  `}`    `// This code is contributed By Susobhan Akhuli` |
| --- |





Javascript

  



  

  




| `<script>`  `// Function to get front of queue`  `front(){`  `// returns the Front element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `"No elements in Queue<br>"``;`  `return` `this``.items[0];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### Operation 4 : rear()

This operation returns the element at the rear end without removing it.

The following steps are taken to perform the rear operation:

* If the queue is empty return the most minimum value.
* otherwise, return the rear value.

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++

  



  

  




| `// Function to get rear of queue`  `int` `rear(Queue* queue)`  `{`  `if` `(isEmpty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}` |
| --- |





Java

  



  

  




| `// Function to get rear of queue`  `int` `rear(Queue queue)`  `{`  `if` `(isEmpty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.rear];`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C

  



  

  




| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3

  



  

  




| `# Function to get rear of queue`  `def` `que_rear(``self``):`  `if` `self``.isEmpty():`  `return` `"Queue is empty"`  `return` `self``.Q[``self``.rear]`    `# This code is contributed By Susobhan Akhuli` |
| --- |





C#

  



  

  




| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[rear];`  `}`    `// This code is contributed By Susobhan Akhuli` |
| --- |





Javascript

  



  

  




| `<script>`  `rear(){`  `// returns the Rear element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `"No elements in Queue<br>"``;`  `return` `this``.items[``this``.items.length-1];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 5: isEmpty():**

This operation returns a boolean value that indicates whether the queue is
empty or not.

The following steps are taken to perform the Empty operation:

* check if front value is equal to -1 or not, if yes then return true
  means queue is empty.
* Otherwise return false, means queue is not empty

Below is the implementation of the above approach:

* C++
* Java
* C#
* C
* Python3
* Javascript

C++

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}` |
| --- |





Java

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `boolean` `isEmpty()`  `{`  `if` `(front == -``1``)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C#

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by lokeshmvs21.` |
| --- |





C

  



  

  




| `// Queue is empty when size is 0`  `bool` `isEmpty(``struct` `Queue* queue)`  `{`  `return` `(queue->size == 0);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3

  



  

  




| `# Queue is empty when size is 0`  `def` `isEmpty(``self``):`  `return` `self``.size` `=``=` `0`  `# This code is contributed by Susobhan Akhuli` |
| --- |





Javascript

  



  

  




| `</script>`  `isEmpty(){`  `// return true if the queue is empty.`  `return` `this``.items.length == 0;`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 6 : isFull()**

This operation returns a boolean value that indicates whether the queue is
full or not.

The following steps are taken to perform the isFull() operation:

* Check if front value is equal to zero and rear is equal to the capacity
  of queue if yes then return true.
* otherwise return false

Below is the Implementation of the above approach:

* C++
* Java
* C
* C#
* Python3
* Javascript

C++

  



  

  




| `// This function will check`  `// whether the queue is full or not.`  `bool` `isFull()`  `{`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}` |
| --- |





Java

  



  

  




| `// This function will check`  `// whether the queue is full or not.`  `boolean` `isFull()`  `{`  `if` `(front ==` `0` `&& rear == MAX_SIZE -` `1``) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C

  



  

  




| `// Queue is full when size becomes`  `// equal to the capacity`  `bool` `isFull(``struct` `Queue* queue)`  `{`  `return` `(queue->size == queue->capacity);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





C#

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `bool` `isFull(``int` `item) {` `return` `(rear == max - 1); }`  `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3

  



  

  




| `# Queue is full when size becomes`  `# equal to the capacity`      `def` `isFull(``self``):`  `return` `self``.size` `=``=` `self``.capacity`    `# This code is contributed by Susobhan Akhuli` |
| --- |





Javascript

  



  

  




| `function` `isFull() {`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityamaharshi21.` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### Operation 7: size()

This operation returns the size of the queue i.e. the total number of
elements it contains.


* C++
* Java
* Python
* C#
* Javascript

C++

  



  

  




| `// CPP program to illustrate`  `// Implementation of size() function`  `#include <iostream>`  `#include <queue>`  `using` `namespace` `std;`    `int` `main()`  `{`  `int` `sum = 0;`  `queue<``int``> myqueue;`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `cout << myqueue.size();`    `return` `0;`  `}` |
| --- |





Java

  



  

  




| `// Java program to illustrate implementation of size()`  `// function`    `import` `java.util.*;`    `public` `class` `Main {`  `public` `static` `void` `main(String[] args)`  `{`  `int` `sum =` `0``;`  `Queue<Integer> myqueue =` `new` `LinkedList<>();`  `myqueue.add(``1``);`  `myqueue.add(``8``);`  `myqueue.add(``3``);`  `myqueue.add(``6``);`  `myqueue.add(``2``);`    `// Queue becomes 1, 8, 3, 6, 2`    `System.out.println(myqueue.size());`  `}`  `}`    `// This code is contributed by lokesh.` |
| --- |





Python

  



  

  




| `from` `collections` `import` `deque`    `def` `main():`  `sum` `=` `0`  `myqueue` `=` `deque()`  `myqueue.append(``1``)`  `myqueue.append(``8``)`  `myqueue.append(``3``)`  `myqueue.append(``6``)`  `myqueue.append(``2``)`    `# Queue becomes 1, 8, 3, 6, 2`    `print``(``len``(myqueue))`    `main()`    `# This code is contributed by aadityamaharshi21.` |
| --- |





C#

  



  

  




| `using` `System;`  `using` `System.Collections.Generic;`    `namespace` `ConsoleApp1 {`  `class` `MainClass {`  `public` `static` `void` `Main(``string``[] args)`  `{`  `int` `sum = 0;`  `Queue<``int``> myqueue =` `new` `Queue<``int``>();`  `myqueue.Enqueue(1);`  `myqueue.Enqueue(8);`  `myqueue.Enqueue(3);`  `myqueue.Enqueue(6);`  `myqueue.Enqueue(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `Console.WriteLine(myqueue.Count);`  `}`  `}`  `}`    `// This code is contributed by adityamaharshi21.` |
| --- |





Javascript

  



  

  




| `// Javascript code`  `let sum = 0;`  `let myqueue=[];`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `console.log(myqueue.length);` |
| --- |







**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)



Course Name: Queue
Lesson Name: Basic Operations for Queue in Data Structure

Content:
**Basic Operations on Queue:**

Some of the basic operations for Queue in Data Structure are:

* **enqueue() –** Insertion of elements to the queue.
* **dequeue() –** Removal of elements from the queue.
* **peek() or front()-** Acquires the data element available
  at the front node of the queue without deleting it.
* **rear() –** This operation returns the element at the rear
  end without removing it.
* **isFull() –** Validates if the queue is full.
* **isEmpty() –** Checks if the queue is empty.
* **size():** This operation returns the size of the queue
  i.e. the total number of elements it contains.

![](

Queue Data Structure

### **Operation 1: enqueue()**

Inserts an element at the end of the queue i.e. at the rear end.

The following steps should be taken to enqueue (insert) data into a queue:

* Check if the queue is full.
* If the queue is full, return overflow error and exit.
* If the queue is not full, increment the rear pointer to point to the
  next empty space.
* Add the data element to the queue location, where the rear is pointing.
* return success.

![Enqueue representation](

Enqueue representation

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++

  



  

  




| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `printf``(``"\nQueue is full\n"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}` |
| --- |





Java

  



  

  




| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `System.out.println(``"\nQueue is full\n"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `void` `enqueue(``struct` `Queue* queue,` `int` `item)`  `{`  `if` `(isFull(queue))`  `return``;`  `queue->rear = (queue->rear + 1) % queue->capacity;`  `queue->array[queue->rear] = item;`  `queue->size = queue->size + 1;`  `printf``(``"%d enqueued to queue\n"``, item);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3

  



  

  




| `# Function to add an item to the queue.`  `# It changes rear and size`  `def` `EnQueue(``self``, item):`  `if` `self``.isFull():`  `print``(``"Full"``)`  `return`  `self``.rear` `=` `(``self``.rear` `+` `1``)` `%` `(``self``.capacity)`  `self``.Q[``self``.rear]` `=` `item`  `self``.size` `=` `self``.size` `+` `1`  `print``(``"% s enqueued to queue"` `%` `str``(item))`  `# This code is contributed by Susobhan Akhuli` |
| --- |





C#

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `void` `enqueue(``int` `item)`  `{`  `if` `(rear == max - 1) {`  `Console.WriteLine(``"Queue Overflow"``);`  `return``;`  `}`  `else` `{`  `ele[++rear] = item;`  `}`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Javascript

  



  

  




| `<script>`  `enqueue(element){`  `// adding element to the queue`  `this``.items.push(element);`  `}`    `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 2: dequeue()**

This operation removes and returns an element that is at the front end of
the queue.

The following steps are taken to perform the dequeue operation:

* Check if the queue is empty.
* If the queue is empty, return the underflow error and exit.
* If the queue is not empty, access the data where the front is pointing.
* Increment the front pointer to point to the next available data element.
* The Return success.

![Dequeue operation](

Dequeue operation

Below is the Implementation of above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++

  



  

  




| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `printf``(``"\nQueue is empty\n"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i = 0; i < rear - 1; i++) {`  `queue[i] = queue[i + 1];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}` |
| --- |





Java

  



  

  




| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `System.out.println(``"\nQueue is empty\n"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i =` `0``; i < rear -` `1``; i++) {`  `queue[i] = queue[i +` `1``];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C

  



  

  




| `// Function to remove an item from queue.`  `// It changes front and size`  `int` `dequeue(``struct` `Queue* queue)`  `{`  `if` `(isEmpty(queue)) {`  `printf``(``"\nQueue is empty\n"``);`  `return``;`  `}`  `int` `item = queue->array[queue->front];`  `queue->front = (queue->front + 1) % queue->capacity;`  `queue->size = queue->size - 1;`  `return` `item;`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3

  



  

  




| `# Function to remove an item from queue.`  `# It changes front and size`      `def` `DeQueue(``self``):`  `if` `self``.isEmpty():`  `print``(``"Queue is empty"``)`  `return`    `print``(``"% s dequeued from queue"` `%` `str``(``self``.Q[``self``.front]))`  `self``.front` `=` `(``self``.front` `+` `1``)` `%` `(``self``.capacity)`  `self``.size` `=` `self``.size` `-` `1`  `# This code is contributed by Susobhan Akhuli` |
| --- |





C#

  



  

  




| `// Function to remove an item from queue.`  `// It changes front and size`  `public` `int` `dequeue()`  `{`  `if` `(front == rear + 1) {`  `Console.WriteLine(``"Queue is Empty"``);`  `return` `-1;`  `}`  `else` `{`  `int` `p = ele[front++];`  `return` `p;`  `}`  `}`  `// This code is contributed by Susobhan Akhuli` |
| --- |





Javascript

  



  

  




| `<script>`  `dequeue(){`  `// removing element from the queue`  `// returns underflow when called`  `// on empty queue`  `if``(``this``.isEmpty()){`  `document.write(``"<br>Queue is empty<br>"``);`  `return` `-1;`  `}`  `return` `this``.items.shift();`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 3: front()**

This operation returns the element at the front end without removing it.

The following steps are taken to perform the front operation:

* If the queue is empty return the most minimum value.
* otherwise, return the front value.

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++

  



  

  




| `// Function to get front of queue`  `int` `front(Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}` |
| --- |





Java

  



  

  




| `// Function to get front of queue`  `int` `front(Queue queue)`  `{`  `if` `(isempty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.front];`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C

  



  

  




| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3

  



  

  




| `# Function to get front of queue`  `def` `que_front(``self``):`  `if` `self``.isempty():`  `return` `"Queue is empty"`  `return` `self``.Q[``self``.front]`    `# This code is contributed By Susobhan Akhuli` |
| --- |





C#

  



  

  




| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[front];`  `}`    `// This code is contributed By Susobhan Akhuli` |
| --- |





Javascript

  



  

  




| `<script>`  `// Function to get front of queue`  `front(){`  `// returns the Front element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `"No elements in Queue<br>"``;`  `return` `this``.items[0];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### Operation 4 : rear()

This operation returns the element at the rear end without removing it.

The following steps are taken to perform the rear operation:

* If the queue is empty return the most minimum value.
* otherwise, return the rear value.

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++

  



  

  




| `// Function to get rear of queue`  `int` `rear(Queue* queue)`  `{`  `if` `(isEmpty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}` |
| --- |





Java

  



  

  




| `// Function to get rear of queue`  `int` `rear(Queue queue)`  `{`  `if` `(isEmpty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.rear];`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C

  



  

  




| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3

  



  

  




| `# Function to get rear of queue`  `def` `que_rear(``self``):`  `if` `self``.isEmpty():`  `return` `"Queue is empty"`  `return` `self``.Q[``self``.rear]`    `# This code is contributed By Susobhan Akhuli` |
| --- |





C#

  



  

  




| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[rear];`  `}`    `// This code is contributed By Susobhan Akhuli` |
| --- |





Javascript

  



  

  




| `<script>`  `rear(){`  `// returns the Rear element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `"No elements in Queue<br>"``;`  `return` `this``.items[``this``.items.length-1];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 5: isEmpty():**

This operation returns a boolean value that indicates whether the queue is
empty or not.

The following steps are taken to perform the Empty operation:

* check if front value is equal to -1 or not, if yes then return true
  means queue is empty.
* Otherwise return false, means queue is not empty

Below is the implementation of the above approach:

* C++
* Java
* C#
* C
* Python3
* Javascript

C++

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}` |
| --- |





Java

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `boolean` `isEmpty()`  `{`  `if` `(front == -``1``)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C#

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by lokeshmvs21.` |
| --- |





C

  



  

  




| `// Queue is empty when size is 0`  `bool` `isEmpty(``struct` `Queue* queue)`  `{`  `return` `(queue->size == 0);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3

  



  

  




| `# Queue is empty when size is 0`  `def` `isEmpty(``self``):`  `return` `self``.size` `=``=` `0`  `# This code is contributed by Susobhan Akhuli` |
| --- |





Javascript

  



  

  




| `</script>`  `isEmpty(){`  `// return true if the queue is empty.`  `return` `this``.items.length == 0;`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 6 : isFull()**

This operation returns a boolean value that indicates whether the queue is
full or not.

The following steps are taken to perform the isFull() operation:

* Check if front value is equal to zero and rear is equal to the capacity
  of queue if yes then return true.
* otherwise return false

Below is the Implementation of the above approach:

* C++
* Java
* C
* C#
* Python3
* Javascript

C++

  



  

  




| `// This function will check`  `// whether the queue is full or not.`  `bool` `isFull()`  `{`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}` |
| --- |





Java

  



  

  




| `// This function will check`  `// whether the queue is full or not.`  `boolean` `isFull()`  `{`  `if` `(front ==` `0` `&& rear == MAX_SIZE -` `1``) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C

  



  

  




| `// Queue is full when size becomes`  `// equal to the capacity`  `bool` `isFull(``struct` `Queue* queue)`  `{`  `return` `(queue->size == queue->capacity);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





C#

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `bool` `isFull(``int` `item) {` `return` `(rear == max - 1); }`  `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3

  



  

  




| `# Queue is full when size becomes`  `# equal to the capacity`      `def` `isFull(``self``):`  `return` `self``.size` `=``=` `self``.capacity`    `# This code is contributed by Susobhan Akhuli` |
| --- |





Javascript

  



  

  




| `function` `isFull() {`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityamaharshi21.` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### Operation 7: size()

This operation returns the size of the queue i.e. the total number of
elements it contains.


* C++
* Java
* Python
* C#
* Javascript

C++

  



  

  




| `// CPP program to illustrate`  `// Implementation of size() function`  `#include <iostream>`  `#include <queue>`  `using` `namespace` `std;`    `int` `main()`  `{`  `int` `sum = 0;`  `queue<``int``> myqueue;`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `cout << myqueue.size();`    `return` `0;`  `}` |
| --- |





Java

  



  

  




| `// Java program to illustrate implementation of size()`  `// function`    `import` `java.util.*;`    `public` `class` `Main {`  `public` `static` `void` `main(String[] args)`  `{`  `int` `sum =` `0``;`  `Queue<Integer> myqueue =` `new` `LinkedList<>();`  `myqueue.add(``1``);`  `myqueue.add(``8``);`  `myqueue.add(``3``);`  `myqueue.add(``6``);`  `myqueue.add(``2``);`    `// Queue becomes 1, 8, 3, 6, 2`    `System.out.println(myqueue.size());`  `}`  `}`    `// This code is contributed by lokesh.` |
| --- |





Python

  



  

  




| `from` `collections` `import` `deque`    `def` `main():`  `sum` `=` `0`  `myqueue` `=` `deque()`  `myqueue.append(``1``)`  `myqueue.append(``8``)`  `myqueue.append(``3``)`  `myqueue.append(``6``)`  `myqueue.append(``2``)`    `# Queue becomes 1, 8, 3, 6, 2`    `print``(``len``(myqueue))`    `main()`    `# This code is contributed by aadityamaharshi21.` |
| --- |





C#

  



  

  




| `using` `System;`  `using` `System.Collections.Generic;`    `namespace` `ConsoleApp1 {`  `class` `MainClass {`  `public` `static` `void` `Main(``string``[] args)`  `{`  `int` `sum = 0;`  `Queue<``int``> myqueue =` `new` `Queue<``int``>();`  `myqueue.Enqueue(1);`  `myqueue.Enqueue(8);`  `myqueue.Enqueue(3);`  `myqueue.Enqueue(6);`  `myqueue.Enqueue(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `Console.WriteLine(myqueue.Count);`  `}`  `}`  `}`    `// This code is contributed by adityamaharshi21.` |
| --- |





Javascript

  



  

  




| `// Javascript code`  `let sum = 0;`  `let myqueue=[];`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `console.log(myqueue.length);` |
| --- |







**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)



Course Name: Linked List Data Structure Guide
Lesson Name: Introduction to Circular Linked List

Content:
What is a Circular Linked List?


A

****circular linked list****
is a special type of linked list where all the nodes are connected to form a circle. Unlike a regular linked list, which ends with a node pointing to

****NULL****
, the last node in a circular linked list points back to the first node. This means that you can keep traversing the list without ever reaching a

****NULL****
value.


Types of Circular Linked Lists


We can create a circular linked list from both

[singly linked lists](
and

[doubly linked lists](
. So, circular linked list are basically of two types:


### 1. Circular Singly Linked List


In

****Circular Singly Linked List****
, each node has just one pointer called the “

****next****
” pointer. The next pointer of

****last node****
points back to the

****first node****
and this results in forming a circle. In this type of Linked list we can only move through the list in one direction.


![Representation-of-circular-linked-list](

Representation of Circular Singly Linked List

### 2. Circular Doubly Linked List:


In

****circular doubly linked****

****list,****
each node has two pointers

****prev****
and

****next,****
similar to doubly linked list. The

****prev****
pointer points to the previous node and the

****next****
points to the next node. Here, in addition to the

****last****
node storing the address of the first node, the

****first node****
will also store the address of the

****last node****
.


![Representation-of-circular-doubly-linked-list](

Representation of Circular Doubly Linked List

****Note:****
In this article, we will use the circular singly linked list to explain the working of circular linked lists.


Representation of a Circular Singly Linked List


Let’s take a look on the structure of a circular linked list.




![Node-structure-of-circular-linked-list](

Representation of a Circular Singly Linked List

### Create/Declare a Node of Circular Linked List








In the code above, each node has

****data****
and a

****pointer****
to the next node. When we create multiple nodes for a circular linked list, we only need to connect the last node back to the first one.


Example of Creating a Circular Linked List


Here’s an example of creating a circular linked list with three nodes (2, 3, 4):


![Circular-Linked-List](









In the above code, we have created three nodes

****first, second,****
and

****last****
having values

****2, 3,****
and

****4****
respectively.


* After creating three nodes, we have connected these node in a series.
* Connect the first node “

  ****first”****
  to “

  ****second”****
  node by

  ****s****
  toring the address of “

  ****second”****
  node


  into

  ****first’s****
  next
* Connect the second node “

  ****second”****
  to “

  ****second”****
  node by

  ****s****
  toring the address of “

  ****third****
  ” node into

  ****second’s****
  next
* After connecting all the nodes, we reach the key characteristic of a circular linked list:

  linking the last node back to the first node


  . Therefore, we store the address of the “

  ****first****
  ” node in the “

  ****last****
  ” node.

### Why have we taken a pointer that points to the last node instead of the first node?


For the insertion of a node at the beginning, we need to traverse the whole list. Also, for insertion at the end, the whole list has to be traversed. If instead of the start pointer, we take a pointer to the last node, then in both cases there won’t be any need to traverse the whole list. So insertion at the beginning or at the end takes constant time, irrespective of the length of the list.


Operations on the Circular Linked list:


We can do some operations on the circular linked list similar to the singly and doubly linked list which are:


* ****Insertion****
  + Insertion at the empty list
  + Insertion at the beginning
  + Insertion at the end
  + Insertion at the given position
* ****Deletion****
  + Delete the first node
  + Delete the last node
  + Delete the node from any position
* ****Searching****

****Note:****
We will be using the circular singly linked list to represent the working of the circular linked list.


[Insertion in the circular linked list:](


Insertion is a fundamental operation in linked lists that involves adding a new node to the list. The only extra step is connecting the last node to the first one. In the circular linked list mentioned below, we can insert nodes in four ways:


### 1. Insertion in an empty List in the circular linked list

> To insert a node in empty circular linked list, creates a
>
> ****new node****
> with the given data, sets its next pointer to point to itself, and updates the
>
> ****last****
> pointer to reference this
>
> ****new node****
> .

![Insertion-in-an-empty-list-in-circular-linked-list](






### 2. Insertion at the beginning in circular linked list

> To insert a new node at the beginning of a circular linked list, we first create the
>
> ****new node****
> and allocate memory for it. If the list is empty (indicated by the last pointer being
>
> ****NULL****
> ), we make the
>
> ****new node****
> point to itself. If the list already contains nodes then we set the
>
> ****new node’s****
> next pointer to point to the
>
> ****current head****
> of the list (which is
>
> ****last->next****
> ), and then update the last node’s next pointer to point to the
>
> ****new node****
> . This maintains the circular structure of the list.

![Insertion-at-the-beginning-of-circular-linked-list](







### 3. Insertion at the end in circular linked list

> To insert a new node at the end of a circular linked list, we first create the new node and allocate memory for it. If the list is empty (mean,
>
> ****last****
> or
>
> ****tail****
> pointer being
>
> ****NULL****
> ), we initialize the list with the
>
> ****new node****
> and making it point to itself to form a circular structure. If the list already contains nodes then we set the
>
> ****new node’s****
> next pointer to point to the
>
> ****current head****
> (which is
>
> ****tail->next****
> ), then update the
>
> ****current tail’s****
> next pointer to point to the
>
> ****new node****
> . Finally, we update the
>
> ****tail pointer****
> to the
>
> ****new node.****
> This will ensure that the
>
> ****new node****
> is now the
>
> ****last node****
> in the list while maintaining the circular linkage.

![Insertion-at-the-end-of-circular-linked-list](






### 4. Insertion at specific position in circular linked list

> To insert a new node at a specific position in a circular linked list, we first check if the list is empty. If it is and the
>
> ****position****
> is not
>
> ****1****
> then we print an error message because the position doesn’t exist in the list. If the
>
> ****position****
> is
>
> ****1****
> then we create the
>
> ****new node****
> and make it point to itself. If the list is not empty, we create the
>
> ****new node****
> and traverse the list to find the correct insertion point. If the
>
> ****position****
> is
>
> ****1****
> , we insert the
>
> ****new node****
> at the beginning by adjusting the pointers accordingly. For other positions, we traverse through the list until we reach the desired position and inserting the
>
> ****new node****
> by updating the pointers. If the new node is inserted at the end, we also update the
>
> ****last****
> pointer to reference the new node, maintaining the circular structure of the list.

![Insertion-at-specific-position-of-circular-linked-list](







[Deletion from a Circular Linked List](


Deletion involves removing a node from the linked list. The main difference is that we need to ensure the list remains circular after the deletion. We can delete a node in a circular linked list in three ways:


### 1. Delete the first node in circular linked list

> To delete the first node of a circular linked list, we first check if the list is empty. If it is then we print a message and return
>
> ****NULL****
> . If the list contains only one node (the
>
> ****head****
> is the same as the
>
> ****last****
> ) then we delete that node and set the
>
> ****last****
> pointer to
>
> ****NULL****
> . If there are multiple nodes then we update the
>
> ****last->next****
> pointer to skip the
>
> ****head****
> node and effectively removing it from the list. We then delete the
>
> ****head****
> node to free the allocated memory. Finally, we return the updated
>
> ****last****
> pointer, which still points to the
>
> ****last****
> node in the list.

![Deletion-from-the-beginning-of-circular-linked-list](






### 2. Delete a specific node in circular linked list

> To delete a specific node from a circular linked list, we first check if the list is empty. If it is then we print a message and return
>
> ****nullptr****
> . If the list contains only one node and it matches the
>
> ****key****
> then we delete that node and set
>
> ****last****
> to
>
> ****nullptr****
> . If the node to be deleted is the first node then we update the
>
> ****next****
> pointer of the
>
> ****last****
> node to skip the
>
> ****head****
> node and delete the
>
> ****head****
> . For other nodes, we traverse the list using two pointers:
>
> ****curr****
> (to find the node) and
>
> ****prev****
> (to keep track of the previous node). If we find the node with the matching key then we update the next pointer of
>
> ****prev****
> to skip the
>
> ****curr****
> node and delete it. If the node is found and it is the last node, we update the
>
> ****last****
> pointer accordingly. If the node is not found then do nothing and
>
> ****tail****
> or
>
> ****last****
> as it is. Finally, we return the updated
>
> ****last****
> pointer.

![Delete-a-specific-node-in-circular-linked-list](






### 3. Deletion at the end of Circular linked list

> To delete the last node in a circular linked list, we first check if the list is empty. If it is, we print a message and return
>
> ****nullptr****
> . If the list contains only one node (where the
>
> ****head****
> is the same as the
>
> ****last****
> ), we delete that node and set
>
> ****last****
> to
>
> ****nullptr****
> . For lists with multiple nodes, we need to traverse the list to find the
>
> ****second last node****
> . We do this by starting from the
>
> ****head****
> and moving through the list until we reach the node whose next pointer points to
>
> ****last****
> . Once we find the
>
> ****second last****
> node then we update its next pointer to point back to the
>
> ****head,****
> this effectively removing the last node from the list. We then delete the last node to free up memory and return the updated
>
> ****last****
> pointer, which now points to the last node.

![Deletion-at-the-end-of-circular-linked-list](








[Searching in Circular Linked list](


Searching in a circular linked list is similar to searching in a regular linked list. We start at a given node and traverse the list until you either find the target value or return to the starting node. Since the list is circular, make sure to keep track of where you started to avoid an infinite loop.


> To search for a specific value in a circular linked list, we first check if the list is empty. If it is then we return
>
> ****false****
> . If the list contains nodes then we start from the
>
> ****head****
> node (which is the
>
> ****last->next****
> ) and traverse the list. We use a pointer
>
> ****curr****
> to iterate through the nodes until we reach back to the
>
> ****head****
> . During traversal, if we find a node whose
>
> ****data****
> matches the given
>
> ****key****
> then we return
>
> ****true****
> to indicating that the value was found. After the loop, we also check the last node to ensure we don’t miss it. If the
>
> ****key****
> is not found after traversing the entire list then we return
>
> ****false****
> .








Advantages of Circular Linked Lists

* In circular linked list, the last node points to the first node. There are no null references, making traversal easier and reducing the chances of encountering null pointer exceptions.
* We can traverse the list from any node and return to it without needing to restart from the head, which is useful in applications requiring a circular iteration.
* Circular linked lists can easily implement circular queues, where the last element connects back to the first, allowing for efficient resource management.
* In a circular linked list, each node has a reference to the next node in the sequence. Although it doesn’t have a direct reference to the previous node like a doubly linked list, we can still find the previous node by traversing the list.

Disadvantages of Circular Linked Lists

* Circular linked lists are more complex to implement than singly linked lists.
* Traversing a circular linked list without a clear stopping condition can lead to infinite loops if not handled carefully.
* Debugging can be more challenging due to the circular nature, as traditional methods of traversing linked lists may not apply.

Applications of Circular Linked Lists

* It is used for time-sharing among different users, typically through a

  ****Round-Robin scheduling mechanism.****
* In multiplayer games, a circular linked list can be used to switch between players. After the last player’s turn, the list cycles back to the first player.
* Circular linked lists are often used in buffering applications, such as streaming data, where data is continuously produced and consumed.
* In media players, circular linked lists can manage playlists, this allowing users to loop through songs continuously.
* Browsers use circular linked lists to manage the cache. This allows you to navigate back through your browsing history efficiently by pressing the BACK button.


Course Name: The Logic Building Problems
Lesson Name: How to swap two numbers without using a temporary variable?

Content:


Given two variables, x, and y, swap two variables without using a third variable.


![](



****Method 1 (Using Addition and subtraction)****


The idea is to get a sum in one of the two given

[numbers](
. The numbers can then be swapped using the sum and subtraction from the sum.









****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


****Method 2: (Using Multiplication and division)****


Multiplication and division can also be used for swapping.








****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


****Method 3: (Using Bitwise XOR)****



The bitwise XOR operator can be used to swap two variables. The XOR of two numbers x and y returns a number that has all the bits as 1 wherever bits of x and y differ. For example, XOR of 10 (In Binary 1010) and 5 (In Binary 0101) is 1111, and XOR of 7 (0111) and 5 (0101) is (0010).









****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


****Problems with the above methods****



****1)****
The multiplication and division-based approach doesn’t work if one of the numbers is 0 as the product becomes 0 irrespective of the other number.



****2)****
Both Arithmetic solutions may cause an arithmetic overflow. If x and y are too large, addition and multiplication may go out of the integer range.



****3)****
When we use pointers to variable and make a function swap, all the above methods fail when both pointers point to the same variable. Let’s take a look at what will happen in this case if both are pointing to the same variable.


// Bitwise XOR based method



x = x ^ x; // x becomes 0



x = x ^ x; // x remains 0



x = x ^ x; // x remains 0



// Arithmetic based method



x = x + x; // x becomes 2x



x = x – x; // x becomes 0



x = x – x; // x remains 0


Let us see the following program.









****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


Swapping a variable with itself may be needed in many standard algorithms. The above problem can be avoided by putting a condition before swapping.









****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


****Method 4 (A mixture of bitwise operators and arithmetic operators)****



The idea is the same as discussed in

****Method 1****
but uses Bitwise addition and subtraction for swapping.


Below is the implementation of the above approach.









****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1), since no extra space has been taken.


****Method 5 (One Line Expression)****


We can write only one line to swap two numbers.


* x = x ^ y ^ (y = x);
* x = x + y – (y = x);
* x = (x \* y) / (y = x);
* x , y = y, x (In Python)








****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1)


Course Name: Introduction to DSA II
Lesson Name: Introduction to Heap – Data Structure and Algorithm Tutorials

Content:
Properties of Heap:

* The minimum or maximum element is always at the root of the heap, allowing constant-time access.
* The relationship between a parent node at index

  ****‘i’****
  and its children is given by the formulas: left child at index

  ****2i+1****
  and right child at index

  ****2i+2****
  for 0-based indexing of node numbers.
* As the tree is complete binary, all levels are filled except possibly the last level. And the last level is filled from left to right.
* When we insert an item, we insert it at the last available slot and then rearrange the nodes so that the heap property is maintained.
* When we remove an item, we swap root with the last node to make sure either the max or min item is removed. Then we rearrange the remaining nodes to ensure heap property (max or min)

Operations Supported by Heap:


Operations supported by

****min – heap****
and

****max – heap****
are same. The difference is just that min-heap contains minimum element at root of the tree and max – heap contains maximum element at the root of the tree.


****Heapify:****
It is the process to rearrange the elements to maintain the property of heap data structure. It is done when root is removed (we replace root with the last node and then call heapify to ensure that heap property is maintained) or heap is built (we call heapify from the last internal node to root) to make sure that the heap property is maintained. This operation also takes

****O(log n)****
time.


* For

  ****max-heap,****
  it


  makes sure the maximum element is the root of that binary tree and all descendants also follow the same property.
* For

  ****min-heap,****
  it balances in such a way that the minimum element is the root and all descendants also follow the same property.

****Insertion****
: When a new element is inserted into the heap, it can disrupt the heap’s properties. To restore and maintain the heap structure, a heapify operation is performed. This operation ensures the heap properties are preserved and has a time complexity of

****O(log n)****
.



****Examples:****

> Assume initially heap(taking
>
> ****max-heap****
> ) is as follows
>
>
> 8
>
>
>
> /   \
>
>
>
> 4     5
>
>
>
> / \
>
>
>
> 1   2
>
>
> Now if we insert 10 into the heap
>
>
>
> 8
>
>
>
> /      \
>
>
>
> 4       5
>
>
>
> /  \      /
>
>
>
> 1     2  10
>
>
> After repeatedly comparing with the parent nodes and swapping if required, the final heap will be look like this
>
>
>
> 10
>
>
>
> /    \
>
>
>
> 4      8
>
>
>
> /  \     /
>
>
>
> 1     2 5

### Deletion:

* If we delete the element from the heap it always deletes the root element of the tree and replaces it with the last element of the tree.
* Since we delete the root element from the heap it will distort the properties of the heap so we need to perform heapify operations so that it maintains the property of the heap.


It takes

****O(log n)****
time.


****Example:****

> Assume initially heap(taking max-heap) is as follows
>
>
>
> 15
>
>
>
> /   \
>
>
>
> 5     7
>
>
>
> /  \
>
>
>
> 2     3
>
>
> Now if we delete 15 into the heap it will be replaced by leaf node of the tree for temporary.
>
>
>
> 3
>
>
>
> /   \
>
>
>
> 5     7
>
>
>
> /
>
>
>
> 2
>
>
> After heapify operation final heap will be look like this
>
>
>
> 7
>
>
>
> /   \
>
>
>
> 5     3
>
>
>
> /
>
>
>
> 2

### getMax (For max-heap) or getMin (For min-heap):


It finds the maximum element or minimum element for

****max-heap****
and

****min-heap****
respectively and as we know minimum and maximum elements will always be the root node itself for min-heap and max-heap respectively. It takes

****O(1)****
time.


### removeMin or removeMax:


This operation returns and deletes the maximum element and minimum element from the max-heap and min-heap respectively. In short, it deletes the root element of the heap binary tree.


Implementation of Heap Data Structure:-


The following code shows the implementation of a

****max-heap****
.


Let’s understand the

****maxHeapify****
function in detail:-


****maxHeapify****
is the function responsible for restoring the property of the Max Heap. It arranges the node

****i****
, and its subtrees accordingly so that the heap property is maintained.


1. Suppose we are given an array,

   ****arr[]****
   representing the complete binary tree. The left and the right child of

   ****i****
   ****th****
   node are in indices

   ****2\*i+1****
   and

   ****2\*i+2****
   .
2. We set the index of the current element,

   ****i****
   , as the ‘MAXIMUM’.
3. If

   ****arr[2 \* i + 1] > arr[i]****
   , i.e., the left child is larger than the current value, it is set as ‘MAXIMUM’.
4. Similarly if

   ****arr[2 \* i + 2] > arr[i]****
   , i.e., the right child is larger than the current value, it is set as ‘MAXIMUM’.
5. Swap the ‘MAXIMUM’ with the current element.
6. Repeat steps

   ****2 to 5****
   till the property of the heap is restored.







Course Name: Introduction to DSA I

Lesson Name: Basic Operations for Queue in Data Structure

Content:
**Basic Operations on Queue:**

Some of the basic operations for Queue in Data Structure are:

* **enqueue() –** Insertion of elements to the queue.
* **dequeue() –** Removal of elements from the queue.
* **peek() or front()-** Acquires the data element available
  at the front node of the queue without deleting it.
* **rear() –** This operation returns the element at the rear
  end without removing it.
* **isFull() –** Validates if the queue is full.
* **isEmpty() –** Checks if the queue is empty.
* **size():** This operation returns the size of the queue
  i.e. the total number of elements it contains.

![](

Queue Data Structure

### **Operation 1: enqueue()**

Inserts an element at the end of the queue i.e. at the rear end.

The following steps should be taken to enqueue (insert) data into a queue:

* Check if the queue is full.
* If the queue is full, return overflow error and exit.
* If the queue is not full, increment the rear pointer to point to the
  next empty space.
* Add the data element to the queue location, where the rear is pointing.
* return success.

![Enqueue representation](









**Complexity Analysis:**
**Time Complexity:** O(1)
**Space Complexity:** O(N)

### **Operation 2: dequeue()**

This operation removes and returns an element that is at the front end of
the queue.

The following steps are taken to perform the dequeue operation:

* Check if the queue is empty.
* If the queue is empty, return the underflow error and exit.
* If the queue is not empty, access the data where the front is pointing.
* Increment the front pointer to point to the next available data element.
* The Return success.

![Dequeue operation](


**Complexity Analysis:**
**Time Complexity:** O(1)
**Space Complexity:** O(N)

### Operation 4 : rear()

This operation returns the element at the rear end without removing it.

The following steps are taken to perform the rear operation:

* If the queue is empty return the most minimum value.
* otherwise, return the rear value.




**Complexity Analysis:**
**Time Complexity:** O(1)
**Space Complexity:** O(N)

### **Operation 5: isEmpty():**

This operation returns a boolean value that indicates whether the queue is
empty or not.

The following steps are taken to perform the Empty operation:

* check if front value is equal to -1 or not, if yes then return true
  means queue is empty.
* Otherwise return false, means queue is not empty




**Complexity Analysis:**
**Time Complexity:** O(1)
**Space Complexity:** O(N)

### **Operation 6 : isFull()**

This operation returns a boolean value that indicates whether the queue is
full or not.

The following steps are taken to perform the isFull() operation:

* Check if front value is equal to zero and rear is equal to the capacity
  of queue if yes then return true.


**Complexity Analysis:**
**Time Complexity:** O(1)
**Space Complexity:** O(N)

### Operation 7: size()

This operation returns the size of the queue i.e. the total number of
elements it contains.



**Complexity Analysis:**
**Time Complexity:** O(1)
**Space Complexity:** O(N)



Course Name: Queue
Lesson Name: Applications, Advantages and Disadvantages of Queue

Content:
****Enqueue**** and when an element is deleted from the queue, then the operation is
known as ****Dequeue.****It is important to know that we cannot insert an element if the size of
the queue is full and cannot delete an element when the queue itself is
empty. If we try to insert an element even after the queue is full, then
such a condition is known as overflow whereas, if we try to delete an
element even after the queue is empty then such a condition is known as
underflow.

****Primary Queue Operations:****

* ****void enqueue(int Element):**** When this operation is performed, an element is inserted in the queue
  at the end i.e. at the rear end. (Where T is Generic i.e we can define
  Queue of any type of data structure.) This operation take ****constant time i.e O(1).****
* ****int dequeue():****
  When this operation is performed, an element is removed from the front
  end and is returned. This operation take ****constant time i.e O(1).****

****Auxiliary Queue Operations:****

* ****int front():**** This operation will return the element at the front without removing
  it and it take O(1) time.
* ****int rear():**** This operation will return the element at the rear without removing
  it, Its Time Complexity is O(1).
* ****int isEmpty():**** This operation indicates whether the queue is empty or not. This
  Operation also done in O(1).
* ****int size():**** This operation will return the size of the queue i.e. the total
  number of elements present in the queue and it’s time complexity is
  O(1).

****Types of Queues:****

* ****Simple Queue:**** Simple queue also known as a linear queue is the most basic version
  of a queue. Here, insertion of an element i.e. the Enqueue operation
  takes place at the rear end and removal of an element i.e. the Dequeue
  operation takes place at the front end.
* ****Circular Queue:****This is mainly an efficient array implementation of Simple Queue. In
  a circular queue, the element of the queue act as a circular ring. The
  working of a circular queue is similar to the linear queue except for
  the fact that the last element is connected to the first element. Its
  advantage is that the memory is utilized in a better way. This is
  because if there is an empty space i.e. if no element is present at a
  certain position in the queue, then an element can be easily added at
  that position.
* ****Priority Queue:**** This queue is a special type of queue. Its specialty is that it
  arranges the elements in a queue based on some priority. The priority
  can be something where the element with the highest value has the
  priority so it creates a queue with decreasing order of values. The
  priority can also be such that the element with the lowest value gets
  the highest priority so in turn it creates a queue with increasing
  order of values.
* ****Dequeue:**** Dequeue is also known as Double Ended Queue. As the name suggests
  double ended, it means that an element can be inserted or removed from
  both the ends of the queue unlike the other queues in which it can be
  done only from one end. Because of this property it may not obey the
  First In First Out property.

****Implementation of Queue:****

* ****Sequential allocation:**** A queue can be implemented using an array. It can organize a limited
  number of elements.
* ****Linked list allocation:****
  A queue can be implemented using a linked list. It can organize an
  unlimited number of elements.

****Applications of Queue:****

* ****Multi programming:**** Multi programming means when multiple programs are running in the
  main memory. It is essential to organize these multiple programs and
  these multiple programs are organized as queues.
* ****Network:**** In a network, a queue is used in devices such as a router or a
  switch. another application of a queue is a mail queue which is a
  directory that stores data and controls files for mail messages.
* ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that
  are scheduled to be executed one after another. These jobs are
  assigned to the processor one by one which is organized using a
  queue.
* ****Shared resources:**** Queues are used as waiting lists for a single shared resource.

****Real-time application of Queue:****

* Working as a buffer between a slow and a fast device. For example
  keyboard and CPU, and two devices on network.
* ATM Booth Line
* Ticket Counter Line
* CPU task scheduling
* Waiting time of each customer at call centers.

****Advantages of Queue:****

* A large amount of data can be managed efficiently with ease.
* Operations such as insertion and deletion can be performed with ease
  as it follows the first in first out rule.
* Queues are useful when a particular service is used by multiple
  consumers.
* Queues are fast in speed for data inter-process communication.
* Queues can be used in the implementation of other data
  structures.

****Disadvantages of Queue:****

* The operations such as insertion and deletion of elements from the
  middle are time consuming.
* In a classical queue, a new element can only be inserted when the
  existing elements are deleted from the queue.
* Searching an element takes O(N) time.
* Maximum size of a queue must be defined prior in case of array
  implementation.

Course Name: Queue
Lesson Name: Applications, Advantages and Disadvantages of Queue

Content:
****Enqueue**** and when an element is deleted from the queue, then the operation is
known as ****Dequeue.****It is important to know that we cannot insert an element if the size of
the queue is full and cannot delete an element when the queue itself is
empty. If we try to insert an element even after the queue is full, then
such a condition is known as overflow whereas, if we try to delete an
element even after the queue is empty then such a condition is known as
underflow.

****Primary Queue Operations:****

* ****void enqueue(int Element):**** When this operation is performed, an element is inserted in the queue
  at the end i.e. at the rear end. (Where T is Generic i.e we can define
  Queue of any type of data structure.) This operation take ****constant time i.e O(1).****
* ****int dequeue():****
  When this operation is performed, an element is removed from the front
  end and is returned. This operation take ****constant time i.e O(1).****

****Auxiliary Queue Operations:****

* ****int front():**** This operation will return the element at the front without removing
  it and it take O(1) time.
* ****int rear():**** This operation will return the element at the rear without removing
  it, Its Time Complexity is O(1).
* ****int isEmpty():**** This operation indicates whether the queue is empty or not. This
  Operation also done in O(1).
* ****int size():**** This operation will return the size of the queue i.e. the total
  number of elements present in the queue and it’s time complexity is
  O(1).

****Types of Queues:****

* ****Simple Queue:**** Simple queue also known as a linear queue is the most basic version
  of a queue. Here, insertion of an element i.e. the Enqueue operation
  takes place at the rear end and removal of an element i.e. the Dequeue
  operation takes place at the front end.
* ****Circular Queue:****This is mainly an efficient array implementation of Simple Queue. In
  a circular queue, the element of the queue act as a circular ring. The
  working of a circular queue is similar to the linear queue except for
  the fact that the last element is connected to the first element. Its
  advantage is that the memory is utilized in a better way. This is
  because if there is an empty space i.e. if no element is present at a
  certain position in the queue, then an element can be easily added at
  that position.
* ****Priority Queue:**** This queue is a special type of queue. Its specialty is that it
  arranges the elements in a queue based on some priority. The priority
  can be something where the element with the highest value has the
  priority so it creates a queue with decreasing order of values. The
  priority can also be such that the element with the lowest value gets
  the highest priority so in turn it creates a queue with increasing
  order of values.
* ****Dequeue:**** Dequeue is also known as Double Ended Queue. As the name suggests
  double ended, it means that an element can be inserted or removed from
  both the ends of the queue unlike the other queues in which it can be
  done only from one end. Because of this property it may not obey the
  First In First Out property.

****Implementation of Queue:****

* ****Sequential allocation:**** A queue can be implemented using an array. It can organize a limited
  number of elements.
* ****Linked list allocation:****
  A queue can be implemented using a linked list. It can organize an
  unlimited number of elements.

****Applications of Queue:****

* ****Multi programming:**** Multi programming means when multiple programs are running in the
  main memory. It is essential to organize these multiple programs and
  these multiple programs are organized as queues.
* ****Network:**** In a network, a queue is used in devices such as a router or a
  switch. another application of a queue is a mail queue which is a
  directory that stores data and controls files for mail messages.
* ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that
  are scheduled to be executed one after another. These jobs are
  assigned to the processor one by one which is organized using a
  queue.
* ****Shared resources:**** Queues are used as waiting lists for a single shared resource.

****Real-time application of Queue:****

* Working as a buffer between a slow and a fast device. For example
  keyboard and CPU, and two devices on network.
* ATM Booth Line
* Ticket Counter Line
* CPU task scheduling
* Waiting time of each customer at call centers.

****Advantages of Queue:****

* A large amount of data can be managed efficiently with ease.
* Operations such as insertion and deletion can be performed with ease
  as it follows the first in first out rule.
* Queues are useful when a particular service is used by multiple
  consumers.
* Queues are fast in speed for data inter-process communication.
* Queues can be used in the implementation of other data
  structures.

****Disadvantages of Queue:****

* The operations such as insertion and deletion of elements from the
  middle are time consuming.
* In a classical queue, a new element can only be inserted when the
  existing elements are deleted from the queue.
* Searching an element takes O(N) time.
* Maximum size of a queue must be defined prior in case of array
  implementation.

Course Name: Introduction to DSA I

Lesson Name: Applications, Advantages and Disadvantages of Queue

Content:

****Enqueue**** and when an element is deleted from the queue, then the operation is known as ****Dequeue.**** It is important to know that we cannot insert an element if the size of the queue is full and cannot delete an element when the queue itself is empty. If we try to insert an element even after the queue is full, then such a condition is known as overflow whereas, if we try to delete an element even after the queue is empty then such a condition is known as underflow.

****Primary Queue Operations:****

* ****void enqueue(int Element):**** When this operation is performed, an element is inserted in the queue
  at the end i.e. at the rear end. (Where T is Generic i.e we can define
  Queue of any type of data structure.) This operation take ****constant time i.e O(1).****
* ****int dequeue():****
  When this operation is performed, an element is removed from the front
  end and is returned. This operation take ****constant time i.e O(1).****

****Auxiliary Queue Operations:****

* ****int front():**** This operation will return the element at the front without removing
  it and it take O(1) time.
* ****int rear():**** This operation will return the element at the rear without removing
  it, Its Time Complexity is O(1).
* ****int isEmpty():**** This operation indicates whether the queue is empty or not. This
  Operation also done in O(1).
* ****int size():**** This operation will return the size of the queue i.e. the total
  number of elements present in the queue and it’s time complexity is
  O(1).

****Types of Queues:****

* ****Simple Queue:**** Simple queue also known as a linear queue is the most basic version
  of a queue. Here, insertion of an element i.e. the Enqueue operation
  takes place at the rear end and removal of an element i.e. the Dequeue
  operation takes place at the front end.
* ****Circular Queue:****This is mainly an efficient array implementation of Simple Queue. In
  a circular queue, the element of the queue act as a circular ring. The
  working of a circular queue is similar to the linear queue except for
  the fact that the last element is connected to the first element. Its
  advantage is that the memory is utilized in a better way. This is
  because if there is an empty space i.e. if no element is present at a
  certain position in the queue, then an element can be easily added at
  that position.
* ****Priority Queue:**** This queue is a special type of queue. Its specialty is that it
  arranges the elements in a queue based on some priority. The priority
  can be something where the element with the highest value has the
  priority so it creates a queue with decreasing order of values. The
  priority can also be such that the element with the lowest value gets
  the highest priority so in turn it creates a queue with increasing
  order of values.
* ****Dequeue:**** Dequeue is also known as Double Ended Queue. As the name suggests
  double ended, it means that an element can be inserted or removed from
  both the ends of the queue unlike the other queues in which it can be
  done only from one end. Because of this property it may not obey the
  First In First Out property.

****Implementation of Queue:****

* ****Sequential allocation:**** A queue can be implemented using an array. It can organize a limited
  number of elements.
* ****Linked list allocation:****
  A queue can be implemented using a linked list. It can organize an
  unlimited number of elements.

****Applications of Queue:****

* ****Multi programming:**** Multi programming means when multiple programs are running in the
  main memory. It is essential to organize these multiple programs and
  these multiple programs are organized as queues.
* ****Network:**** In a network, a queue is used in devices such as a router or a
  switch. another application of a queue is a mail queue which is a
  directory that stores data and controls files for mail messages.
* ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that
  are scheduled to be executed one after another. These jobs are
  assigned to the processor one by one which is organized using a
  queue.
* ****Shared resources:**** Queues are used as waiting lists for a single shared resource.

****Real-time application of Queue:****

* Working as a buffer between a slow and a fast device. For example
  keyboard and CPU, and two devices on network.
* ATM Booth Line
* Ticket Counter Line
* CPU task scheduling
* Waiting time of each customer at call centers.

****Advantages of Queue:****

* A large amount of data can be managed efficiently with ease.
* Operations such as insertion and deletion can be performed with ease
  as it follows the first in first out rule.
* Queues are useful when a particular service is used by multiple
  consumers.
* Queues are fast in speed for data inter-process communication.
* Queues can be used in the implementation of other data
  structures.

****Disadvantages of Queue:****

* The operations such as insertion and deletion of elements from the
  middle are time consuming.
* In a classical queue, a new element can only be inserted when the
  existing elements are deleted from the queue.
* Searching an element takes O(N) time.
* Maximum size of a queue must be defined prior in case of array
  implementation.



Course Name: Introduction to DSA II
Lesson Name: Introduction to Circular Queue

Content:

Table of Content

* [Operations on Circular Queue](#operations-on-circular-queue)
* [Implement Circular Queue using Array](#implement-circular-queue-using-array)
* [Complexity Analysis of Circular Queue Operations](#complexity-analysis-of-circular-queue-operations)
### Operations on Circular Queue

* ****getFront:****
  Get the front item from the queue.
* ****getRear:****
  Get the last item from the queue.
* ****enqueue(value):****
  To

  ****insert****
  an element into the circular queue. In a circular queue, the new element is always inserted at the rear position.
* ****dequeue()****
  : To

  ****delete****
  an element from the circular queue. In a circular queue, the element is always deleted from the front position.

### Implement Circular Queue using Array

1. Initialize an

   ****array****
   of

   ****size n****
   , where

   ****n is the maximum number of element****
   s that the queue can hold.
2. Initialize

   ****three variables (size, capacity, and front.)****
3. ****Enqueue:****
   To enqueue an

   ****element x****
   into the queue, do the following:
   1. Check if

      ****size == capacity****
      (queue is full), display

      ****“Queue is full”.****
   2. If not full: calculate

      ****rear = (front + size) % capacity****
      and

      ****Insert****
      value at the rear index.

      ****Increment****
      size by 1.
4. ****Dequeue:****
   To dequeue an element from the queue, do the following:
   1. Check if

      ****size == 0 (****
      queue is empty), display

      ****“Queue is empty”.****
   2. If not empty:

      ****retrieve****
      the element at the

      ****front index****
      and

      ****move front = (front + 1) % capacity****
      . Also,

      ****decrement****
      size by 1 and

      ****return the removed element.****






### Complexity Analysis of Circular Queue Operations

****Time Complexity:****

****Auxiliary Space:****
O(size), where

****size****
is the number of elements in the circular queue.


Course Name: Linked List Data Structure Guide
Lesson Name: Doubly Linked List Tutorial

Content:
What is a Doubly Linked List?

A ****doubly linked list****
is a data structure that consists of a set of nodes, each of which
contains a ****value**** and ****two pointers****, one pointing to the ****previous node**** in the list and one pointing to the ****next node****
in the list. This allows for efficient traversal of the list in ****both directions****, making it suitable for applications where frequent ****insertions**** and ****deletions**** are required.

![Insertion-at-the-End-in-Doubly-Linked-List-copy](

Doubly Linked List


Representation of Doubly Linked List in Data Structure

In a data structure, a doubly linked list is represented using nodes
that have three fields:

1. Data
2. A pointer to the next node (****next****)
3. A pointer to the previous node (****prev****)

![Node-Structure-of-Doubly-Linked-List](

Node Structure of Doubly Linked List


Node Definition

Here is how a node in a Doubly Linked List is typically
represented:

[Try it on GfG Practice
![redirect icon](
C++
````
struct Node {

    // To store the Value or data.
    int data;

    // Pointer to point the Previous Element
    Node* prev;

    // Pointer to point the Next Element
    Node* next;

    // Constructor
    Node(int d) {
       data = d;
       prev = next = nullptr;
    }
};

struct Node {

    // To store the Value or data.
    int data;

    // Pointer to point the Previous Element
    Node* prev;

    // Pointer to point the Next Element
    Node* next;
};

// Function to create a new node
struct Node *createNode(int new_data) {
    struct Node *new_node = (struct Node *)
    malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    new_node->prev = NULL;
    return new_node;
}

class Node {

    // To store the Value or data.
    int data;

    // Reference to the Previous Node
    Node prev;

    // Reference to the next Node
    Node next;

    // Constructor
    Node(int d) {
       data = d;
       prev = next = null;
    }
};

class Node:

    def __init__(self, data):
        # To store the value or data.
        self.data = data

        # Reference to the previous node
        self.prev = None

        # Reference to the next node
        self.next = None

class Node
{
  	// To store the value or data
    public int Data;

  	// Pointer to the next node
    public Node Next;

  	// Pointer to the previous node
    public Node Prev;

    // Constructor
    public Node(int d)
    {
        Data = d;
        Prev = Next = null;
    }
}

class Node {
    constructor(data)
    {
        // To store the value or data.
        this.data = data;

        // Reference to the previous node
        this.prev = null;

        // Reference to the next node
        this.next = null;
    }
}

#include <iostream>
using namespace std;

// Define the Node structure
struct Node {
    int data;
    Node* next;
    Node* prev;

// Constructor to initialize Node with data
    Node(int data) : data(data), next(nullptr),
  	prev(nullptr) {}
};

// Function to traverse the doubly linked list
// in forward direction
void forwardTraversal(Node* head) {

    // Start traversal from the head of the list
    Node* curr = head;

// Continue until current node is not null
    // (end of list)
    while (curr != nullptr) {

        // Output data of the current node
        cout << curr->data << " ";

// Move to the next node
        curr = curr->next;
}

    // Print newline after traversal
    cout << endl;
}

// Function to traverse the doubly linked list
// in backward direction
void backwardTraversal(Node* tail) {

    // Start traversal from the tail of the list
    Node* curr = tail;

// Continue until current node is not null
    // (end of list)
    while (curr != nullptr) {

        // Output data of the current node
        cout << curr->data << " ";

// Move to the previous node
        curr = curr->prev;
}

    // Print newline after traversal
    cout << endl;
}

int main() {

    // Sample usage of the doubly linked list and
    // traversal functions
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    cout << "Forward Traversal:" << endl;
    forwardTraversal(head);

    cout << "Backward Traversal:" << endl;
    backwardTraversal(third);

return 0;
}

#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node {
    int data; // Data stored in the node
    struct Node* next; // Pointer to the next node
    struct Node* prev; // Pointer to the previous node
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode =
      (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
return newNode;
}

// Function to traverse the doubly linked list
// in forward direction
void forwardTraversal(struct Node* head) {

    // Start traversal from the head of the list
    struct Node* curr = head;

// Continue until the current node is not
    // null (end of list)
    while (curr != NULL) {

        // Output data of the current node
        printf("%d ", curr->data);

// Move to the next node
        curr = curr->next;
}

    // Print newline after traversal
    printf("\n");
}

// Function to traverse the doubly linked list
// in backward direction
void backwardTraversal(struct Node* tail) {

    // Start traversal from the tail of the list
    struct Node* curr = tail;

// Continue until the current node is not
    // null (end of list)
    while (curr != NULL) {

        // Output data of the current node
        printf("%d ", curr->data);

// Move to the previous node
        curr = curr->prev;
}

    // Print newline after traversal
    printf("\n");
}

int main() {

    // Sample usage of the doubly linked list and
    // traversal functions
    struct Node* head = createNode(1);
    struct Node* second = createNode(2);
    struct Node* third = createNode(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    printf("Forward Traversal:\n");
    forwardTraversal(head);

    printf("Backward Traversal:\n");
    backwardTraversal(third);

// Free memory allocated for nodes
    free(head);
    free(second);
    free(third);

return 0;
}

// Define the Node class
class Node {
    int data; // Data stored in the node
    Node next; // Pointer to the next node
    Node prev; // Pointer to the previous node

    // Constructor to initialize the node with data
    public Node(int data) {
        this.data = data;
        this.next = null;
        this.prev = null;
}
}

// Class to manage the doubly linked list
class GfG {

    // Function to traverse the doubly linked list
    // in forward direction
    static void forwardTraversal(Node head) {

        // Start traversal from the head of the list
        Node curr = head;

// Continue until the current node is
        // null (end of the list)
        while (curr != null) {

            // Output data of the current node
            System.out.print(curr.data + " ");

// Move to the next node
            curr = curr.next;
}

        // Print newline after traversal
        System.out.println();
}

    // Function to traverse the doubly linked list
  	//in backward direction
    static void backwardTraversal(Node tail) {

        // Start traversal from the tail of the list
        Node curr = tail;

// Continue until the current node is
        // null (end of the list)
        while (curr != null) {

            // Output data of the current node
            System.out.print(curr.data + " ");

// Move to the previous node
            curr = curr.prev;
}

        // Print newline after traversal
        System.out.println();
}

    public static void main(String[] args) {

        // Sample usage of the doubly linked
        // list and traversal functions
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        System.out.println("Forward Traversal:");
        forwardTraversal(head);

        System.out.println("Backward Traversal:");
        backwardTraversal(third);
}
}

# Define the Node class
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# Function to traverse the doubly linked list
# in forward direction
def forward_traversal(head):

    # Start traversal from the head of the list
    curr = head

    # Continue until the current node is
    # null (end of the list)
    while curr is not None:

        # Output data of the current node
        print(curr.data, end=" ")

        # Move to the next node
        curr = curr.next

    # Print newline after traversal
    print()

# Function to traverse the doubly linked
# list in backward direction
def backward_traversal(tail):

    # Start traversal from the tail of the list
    curr = tail

    # Continue until the current node
    # is null (end of the list)
    while curr is not None:

        # Output data of the current node
        print(curr.data, end=" ")

        # Move to the previous node
        curr = curr.prev

    # Print newline after traversal
    print()

# Sample usage of the doubly linked list
# and traversal functions
if __name__ == "__main__":

    # Create a doubly linked list with 3 nodes
    head = Node(1)
    second = Node(2)
    third = Node(3)

    head.next = second
    second.prev = head
    second.next = third
    third.prev = second

    print("Forward Traversal:")
    forward_traversal(head)

    print("Backward Traversal:")
    backward_traversal(third)

using System;

// Define the Node class
class Node
{
    public int Data; // Data stored in the node
    public Node Next; // Pointer to the next node
    public Node Prev; // Pointer to the previous node

    // Constructor to initialize the node with data
    public Node(int data)
    {
        Data = data;
Next = null;
        Prev = null;
}
}

// Class to manage the doubly linked list
class GfG
{
    // Function to traverse the doubly linked list
  	//in forward direction
    static void ForwardTraversal(Node head)
    {
        // Start traversal from the head of the list
        Node curr = head;

// Continue until the current node is null
      	//(end of the list)
        while (curr != null)
        {
            // Output data of the current node
            Console.Write(curr.Data + " ");

// Move to the next node
            curr = curr.Next;
}

        // Print newline after traversal
        Console.WriteLine();
}

    // Function to traverse the doubly linked list
  	//in backward direction
    static void BackwardTraversal(Node tail)
    {
        // Start traversal from the tail of the list
        Node curr = tail;

// Continue until the current node is null
      	//(end of the list)
        while (curr != null)
        {
            // Output data of the current node
            Console.Write(curr.Data + " ");

// Move to the previous node
            curr = curr.Prev;
}

        // Print newline after traversal
        Console.WriteLine();
}

    public static void Main()
    {
        // Sample usage of the doubly linked list
      	//and traversal functions
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.Next = second;
second.Prev = head;
second.Next = third;
        third.Prev = second;

        Console.WriteLine("Forward Traversal:");
        ForwardTraversal(head);

        Console.WriteLine("Backward Traversal:");
        BackwardTraversal(third);
}
}

// Define the Node class
class Node {
    constructor(data) {
        this.data = data;
        this.prev = null;
        this.next = null;
}
}

// Function to traverse the doubly linked list
// in forward direction
function forwardTraversal(head) {

    // Start traversal from the head of the list
    let curr = head;

// Continue until the current node is null
    // (end of the list)
    while (curr !== null) {

        // Output data of the current node
        console.log(curr.data + " ");

// Move to the next node
        curr = curr.next;
}

    // Print newline after traversal
    console.log();
}

// Function to traverse the doubly linked list
// in backward direction
function backwardTraversal(tail) {

    // Start traversal from the tail of the list
    let curr = tail;

// Continue until the current node is null
    // (end of the list)
    while (curr !== null) {

        // Output data of the current node
        console.log(curr.data + " ");

// Move to the previous node
        curr = curr.prev;
}

    // Print newline after traversal
    console.log();
}

// Sample usage of the doubly linked list
//and traversal functions
// Create a doubly linked list with 3 nodes
const head = new Node(1);
const second = new Node(2);
const third = new Node(3);

head.next = second;
second.prev = head;
second.next = third;
third.prev = second;

console.log("Forward Traversal:");
forwardTraversal(head);

console.log("Backward Traversal:");
backwardTraversal(third);


#include <iostream>

using namespace std;

// Node structure for doubly linked list
struct Node {
    int data;
    Node * prev;
    Node * next;

    Node(int val) {
        data = val;
        prev = next = nullptr;
}
};

// Function to find the length of a doubly
//linked list
int findLength(Node * head) {
    int count = 0;
for (Node * cur = head; cur != nullptr; cur = cur -> next)
        count++;
return count;
}

int main() {

    // Create a DLL with 3 nodes
    Node * head = new Node(1);
    Node * second = new Node(2);
    Node * third = new Node(3);
    head -> next = second;
second -> prev = head;
second -> next = third;
    third -> prev = second;

    cout << "Length of the doubly linked list: " <<
        findLength(head) << endl;

return 0;
}

#include <stdio.h>
#include <stdlib.h>

// Node structure for doubly linked list
struct Node {
    int data; // Data stored in the node
    struct Node* prev; // Pointer to the previous node
    struct Node* next; // Pointer to the next node
};

// Constructor function to create a new node
struct Node* createNode(int val) {
    struct Node* newNode =
         (struct Node*)malloc(sizeof(struct Node));
    newNode->data = val;
    newNode->prev = NULL;
    newNode->next = NULL;
return newNode;
}

// Function to find the length of a doubly linked list
int findLength(struct Node* head) {
    int count = 0;
for (struct Node* cur = head; cur != NULL; cur = cur->next)
        count++;
return count;
}

int main() {
    // Create a DLL with 3 nodes
    struct Node* head = createNode(1);
    struct Node* second = createNode(2);
    struct Node* third = createNode(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    printf("Length of the doubly linked list: %d\n",
           findLength(head));

return 0;
}

class Node {
    int data;
    Node prev;
    Node next;

// Constructor
    public Node(int val) {
        data = val;
        prev = null;
next = null;
}
}

class GfG {

    // Function to find the length of
    // a doubly linked list
    static int FindLength(Node head) {
        int count = 0;
for (Node cur = head; cur != null; cur = cur.next)
            count++;
return count;
}

    // Driver code
    public static void main(String[] args) {

        // Create a doubly linked list
        // with 3 nodes
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        System.out.println("Length of doubly linked list: "
                           + FindLength(head));
}
}

class Node:
    def __init__(self, val):
        self.data = val
        self.prev = None
        self.next = None

# Function to find the length of
# a doubly linked list
def find_length(head):
    count = 0
    cur = head
    while cur is not None:
        count += 1
        cur = cur.next
    return count

# Driver code
if __name__ == "__main__":

    # Create a doubly linked list
    # with 3 nodes
    head = Node(1)
    second = Node(2)
    third = Node(3)

    head.next = second
    second.prev = head
    second.next = third
    third.prev = second

    print("Length of the doubly linked list: " +
          str(find_length(head)))

using System;

class Node {
    public int data;
public Node prev;
public Node next;

// Constructor
    public Node(int val) {
        data = val;
        prev = null;
next = null;
}
}

public class GfG {

    // Function to find the length of
    // a doubly linked list
    static int FindLength(Node head) {
        int count = 0;
for (Node cur = head; cur != null; cur = cur.next)
            count++;
return count;
}

    // Driver code
    public static void Main(string[] args) {

        // Create a doubly linked list
        // with 3 nodes
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        Console.WriteLine("Length of doubly linked list: "
                                 + FindLength(head));
}
}

class Node {
    constructor(val) {
        this.data = val;
        this.prev = null;
        this.next = null;
}
}

// Function to find the length of
// a doubly linked list
function findLength(head) {
    let count = 0;
    let cur = head;
    while (cur !== null) {
        count++;
        cur = cur.next;
}
    return count;
}

// Create a doubly linked list with 3 nodes
const head = new Node(1);
const second = new Node(2);
const third = new Node(3);

head.next = second;
second.prev = head;
second.next = third;
third.prev = second;

console.log("Length of the doubly linked list: " +
            findLength(head));









[Insertion at the End of Doubly Linked List](

![Insertion-at-the-End-in-Doubly-Linked-List](

Insertion at the End in the Doubly Linked List


To insert a new node at the end of the doubly linked list, we can use
the following steps:

* Allocate memory for a new node and assign the provided value to its
  data field.
* Initialize the next pointer of the new node to nullptr.
* If the list is empty:
  + Set the previous pointer of the new node to nullptr.
  + Update the head pointer to point to the new node.
                                                                                          * If the list is not empty:
                                                                                          + Traverse the list starting from the head to reach the last
                                                                                          node.
                                                                                          + Set the next pointer of the last node to point to the new
                                                                                          node.
                                                                                          + Set the previous pointer of the new node to point to the last
                                                                                          node.








[Insertion at a Specific Position in Doubly Linked List](

To insert a node at a specific Position in doubly linked list, we can
use the following steps:

![Insertion-at-a-Specific-Position-in-Doubly-Linked-List](


Insertion at a Specific Position in Doubly Linked List



To insert a new node at a specific position,

* If position = 1, create a new node and make it the head of the linked
  list and return it.
* Otherwise, traverse the list to reach the node at position – 1,
  say ****curr****.
* If the position is valid, create a new node with given data,
  say ****new\_node****.
* Update the next pointer of new node to the next
                                                                                                                                             of current node and prev pointer of new node to current
                                                                                                                                             node, ****new\_node->next = curr->next****and ****new\_node->prev = curr.****
                                                                                                                                             * Similarly, update next pointer of current node to
                                                                                                                                                              thenew node, ****curr->next = new\_node****.
                                                                                                                                                              * If the new node is not the last node, update prev pointer of new
                                                                                                                                                                                                          node’s next to the new node, ****new\_node->next->prev = new\_node.****








[Deletion at the Beginning of Doubly Linked List](

![Deletion-at-the-Beginning-of-Doubly-Linked-List](

Deletion at the Beginning of Doubly Linked List


To delete a node at the beginning in doubly linked list, we can use the
following steps:

* Check if the list is empty, there is nothing to delete. Return.
* Store the head pointer in a variable, say ****temp****.
* Update the head of linked list to the node next to the current head, ****head = head->next****.
                                                                        * If the new head is not NULL, update the previous pointer of new head
                                                                                                           to NULL, ****head->prev = NULL****.








[Deletion at the End of Doubly Linked List](

![Deletion-at-the-End-in-Doubly-Linked-List](

Deletion at the End in Doubly Linked List


To delete a node at the end in doubly linked list, we can use the
following steps:

* Check if the doubly linked list is empty. If it is empty, then there
  is nothing to delete.
* If the list is not empty, then move to the last node of the doubly
  linked list, say ****curr****.
* Update the second-to-last node's next pointer to NULL, ****curr->prev->next = NULL****.
* Free the memory allocated for the node that was deleted.








[Deletion at a Specific Position in Doubly Linked List](

![Deletion-at-a-Specific-Position-in-Doubly-Linked-List](


Deletion at a Specific Position in Doubly Linked List



To delete a node at a specific position in doubly linked list, we can
use the following steps:

* Traverse to the node at the specified position, say ****curr****.
* If the position is valid, adjust the pointers to skip the node to be
  deleted.
  + If curr is not the head of the linked list, update the next
    pointer of the node before curr to point to the node after curr, ****curr->prev->next = curr-next****.
  + If curr is not the last node of the linked list, update the
    previous pointer of the node after curr to the node before curr, ****curr->next->prev = curr->prev****.
* Free the memory allocated for the deleted node.








Advantages of Doubly Linked List

* ****Efficient traversal in both directions:**** Doubly linked lists allow for efficient traversal of the list in both
  directions, making it suitable for applications where frequent
  insertions and deletions are required.
* ****Easy insertion and deletion of nodes:**** The presence of pointers to both the previous and next nodes makes it
  easy to insert or delete nodes from the list, without having to
  traverse the entire list.
* ****Can be used to implement a stack or queue:**** Doubly linked lists can be used to implement both stacks and queues,
  which are common data structures used in programming.

Disadvantages of Doubly Linked List

* ****More complex than singly linked lists:****
  Doubly linked lists are more complex than singly linked lists, as they
  require additional pointers for each node.
* ****More memory overhead:**** Doubly linked lists require more memory overhead than singly linked
  lists, as each node stores two pointers instead of one.

Course Name: Introduction to DSA I

Lesson Name: Doubly Linked List Tutorial

Content:
What is a Doubly Linked List?

A ****doubly linked list****
is a data structure that consists of a set of nodes, each of which
contains a ****value**** and ****two pointers****, one pointing to the ****previous node**** in the list and one pointing to the ****next node****
in the list. This allows for efficient traversal of the list in ****both directions****, making it suitable for applications where frequent ****insertions**** and ****deletions**** are required.

![Insertion-at-the-End-in-Doubly-Linked-List-copy](

Doubly Linked List


Representation of Doubly Linked List in Data Structure

In a data structure, a doubly linked list is represented using nodes
that have three fields:

1. Data
2. A pointer to the next node (****next****)
3. A pointer to the previous node (****prev****)

![Node-Structure-of-Doubly-Linked-List](

Node Structure of Doubly Linked List


Node Definition

Here is how a node in a Doubly Linked List is typically
represented:

[Try it on GfG Practice
![redirect icon](
C++
````
struct Node {

    // To store the Value or data.
    int data;

    // Pointer to point the Previous Element
    Node* prev;

    // Pointer to point the Next Element
    Node* next;

    // Constructor
    Node(int d) {
       data = d;
       prev = next = nullptr;
    }
};

struct Node {

    // To store the Value or data.
    int data;

    // Pointer to point the Previous Element
    Node* prev;

    // Pointer to point the Next Element
    Node* next;
};

// Function to create a new node
struct Node *createNode(int new_data) {
    struct Node *new_node = (struct Node *)
    malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    new_node->prev = NULL;
    return new_node;
}

class Node {

    // To store the Value or data.
    int data;

    // Reference to the Previous Node
    Node prev;

    // Reference to the next Node
    Node next;

    // Constructor
    Node(int d) {
       data = d;
       prev = next = null;
    }
};

class Node:

    def __init__(self, data):
        # To store the value or data.
        self.data = data

        # Reference to the previous node
        self.prev = None

        # Reference to the next node
        self.next = None

class Node
{
  	// To store the value or data
    public int Data;

  	// Pointer to the next node
    public Node Next;

  	// Pointer to the previous node
    public Node Prev;

    // Constructor
    public Node(int d)
    {
        Data = d;
        Prev = Next = null;
    }
}

class Node {
    constructor(data)
    {
        // To store the value or data.
        this.data = data;

        // Reference to the previous node
        this.prev = null;

        // Reference to the next node
        this.next = null;
    }
}

#include <iostream>
using namespace std;

// Define the Node structure
struct Node {
    int data;
    Node* next;
    Node* prev;

// Constructor to initialize Node with data
    Node(int data) : data(data), next(nullptr),
  	prev(nullptr) {}
};

// Function to traverse the doubly linked list
// in forward direction
void forwardTraversal(Node* head) {

    // Start traversal from the head of the list
    Node* curr = head;

// Continue until current node is not null
    // (end of list)
    while (curr != nullptr) {

        // Output data of the current node
        cout << curr->data << " ";

// Move to the next node
        curr = curr->next;
}

    // Print newline after traversal
    cout << endl;
}

// Function to traverse the doubly linked list
// in backward direction
void backwardTraversal(Node* tail) {

    // Start traversal from the tail of the list
    Node* curr = tail;

// Continue until current node is not null
    // (end of list)
    while (curr != nullptr) {

        // Output data of the current node
        cout << curr->data << " ";

// Move to the previous node
        curr = curr->prev;
}

    // Print newline after traversal
    cout << endl;
}

int main() {

    // Sample usage of the doubly linked list and
    // traversal functions
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    cout << "Forward Traversal:" << endl;
    forwardTraversal(head);

    cout << "Backward Traversal:" << endl;
    backwardTraversal(third);

return 0;
}

#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node {
    int data; // Data stored in the node
    struct Node* next; // Pointer to the next node
    struct Node* prev; // Pointer to the previous node
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode =
      (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
return newNode;
}

// Function to traverse the doubly linked list
// in forward direction
void forwardTraversal(struct Node* head) {

    // Start traversal from the head of the list
    struct Node* curr = head;

// Continue until the current node is not
    // null (end of list)
    while (curr != NULL) {

        // Output data of the current node
        printf("%d ", curr->data);

// Move to the next node
        curr = curr->next;
}

    // Print newline after traversal
    printf("\n");
}

// Function to traverse the doubly linked list
// in backward direction
void backwardTraversal(struct Node* tail) {

    // Start traversal from the tail of the list
    struct Node* curr = tail;

// Continue until the current node is not
    // null (end of list)
    while (curr != NULL) {

        // Output data of the current node
        printf("%d ", curr->data);

// Move to the previous node
        curr = curr->prev;
}

    // Print newline after traversal
    printf("\n");
}

int main() {

    // Sample usage of the doubly linked list and
    // traversal functions
    struct Node* head = createNode(1);
    struct Node* second = createNode(2);
    struct Node* third = createNode(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    printf("Forward Traversal:\n");
    forwardTraversal(head);

    printf("Backward Traversal:\n");
    backwardTraversal(third);

// Free memory allocated for nodes
    free(head);
    free(second);
    free(third);

return 0;
}

// Define the Node class
class Node {
    int data; // Data stored in the node
    Node next; // Pointer to the next node
    Node prev; // Pointer to the previous node

    // Constructor to initialize the node with data
    public Node(int data) {
        this.data = data;
        this.next = null;
        this.prev = null;
}
}

// Class to manage the doubly linked list
class GfG {

    // Function to traverse the doubly linked list
    // in forward direction
    static void forwardTraversal(Node head) {

        // Start traversal from the head of the list
        Node curr = head;

// Continue until the current node is
        // null (end of the list)
        while (curr != null) {

            // Output data of the current node
            System.out.print(curr.data + " ");

// Move to the next node
            curr = curr.next;
}

        // Print newline after traversal
        System.out.println();
}

    // Function to traverse the doubly linked list
  	//in backward direction
    static void backwardTraversal(Node tail) {

        // Start traversal from the tail of the list
        Node curr = tail;

// Continue until the current node is
        // null (end of the list)
        while (curr != null) {

            // Output data of the current node
            System.out.print(curr.data + " ");

// Move to the previous node
            curr = curr.prev;
}

        // Print newline after traversal
        System.out.println();
}

    public static void main(String[] args) {

        // Sample usage of the doubly linked
        // list and traversal functions
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        System.out.println("Forward Traversal:");
        forwardTraversal(head);

        System.out.println("Backward Traversal:");
        backwardTraversal(third);
}
}

# Define the Node class
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# Function to traverse the doubly linked list
# in forward direction
def forward_traversal(head):

    # Start traversal from the head of the list
    curr = head

    # Continue until the current node is
    # null (end of the list)
    while curr is not None:

        # Output data of the current node
        print(curr.data, end=" ")

        # Move to the next node
        curr = curr.next

    # Print newline after traversal
    print()

# Function to traverse the doubly linked
# list in backward direction
def backward_traversal(tail):

    # Start traversal from the tail of the list
    curr = tail

    # Continue until the current node
    # is null (end of the list)
    while curr is not None:

        # Output data of the current node
        print(curr.data, end=" ")

        # Move to the previous node
        curr = curr.prev

    # Print newline after traversal
    print()

# Sample usage of the doubly linked list
# and traversal functions
if __name__ == "__main__":

    # Create a doubly linked list with 3 nodes
    head = Node(1)
    second = Node(2)
    third = Node(3)

    head.next = second
    second.prev = head
    second.next = third
    third.prev = second

    print("Forward Traversal:")
    forward_traversal(head)

    print("Backward Traversal:")
    backward_traversal(third)

using System;

// Define the Node class
class Node
{
    public int Data; // Data stored in the node
    public Node Next; // Pointer to the next node
    public Node Prev; // Pointer to the previous node

    // Constructor to initialize the node with data
    public Node(int data)
    {
        Data = data;
Next = null;
        Prev = null;
}
}

// Class to manage the doubly linked list
class GfG
{
    // Function to traverse the doubly linked list
  	//in forward direction
    static void ForwardTraversal(Node head)
    {
        // Start traversal from the head of the list
        Node curr = head;

// Continue until the current node is null
      	//(end of the list)
        while (curr != null)
        {
            // Output data of the current node
            Console.Write(curr.Data + " ");

// Move to the next node
            curr = curr.Next;
}

        // Print newline after traversal
        Console.WriteLine();
}

    // Function to traverse the doubly linked list
  	//in backward direction
    static void BackwardTraversal(Node tail)
    {
        // Start traversal from the tail of the list
        Node curr = tail;

// Continue until the current node is null
      	//(end of the list)
        while (curr != null)
        {
            // Output data of the current node
            Console.Write(curr.Data + " ");

// Move to the previous node
            curr = curr.Prev;
}

        // Print newline after traversal
        Console.WriteLine();
}

    public static void Main()
    {
        // Sample usage of the doubly linked list
      	//and traversal functions
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.Next = second;
second.Prev = head;
second.Next = third;
        third.Prev = second;

        Console.WriteLine("Forward Traversal:");
        ForwardTraversal(head);

        Console.WriteLine("Backward Traversal:");
        BackwardTraversal(third);
}
}

// Define the Node class
class Node {
    constructor(data) {
        this.data = data;
        this.prev = null;
        this.next = null;
}
}

// Function to traverse the doubly linked list
// in forward direction
function forwardTraversal(head) {

    // Start traversal from the head of the list
    let curr = head;

// Continue until the current node is null
    // (end of the list)
    while (curr !== null) {

        // Output data of the current node
        console.log(curr.data + " ");

// Move to the next node
        curr = curr.next;
}

    // Print newline after traversal
    console.log();
}

// Function to traverse the doubly linked list
// in backward direction
function backwardTraversal(tail) {

    // Start traversal from the tail of the list
    let curr = tail;

// Continue until the current node is null
    // (end of the list)
    while (curr !== null) {

        // Output data of the current node
        console.log(curr.data + " ");

// Move to the previous node
        curr = curr.prev;
}

    // Print newline after traversal
    console.log();
}

// Sample usage of the doubly linked list
//and traversal functions
// Create a doubly linked list with 3 nodes
const head = new Node(1);
const second = new Node(2);
const third = new Node(3);

head.next = second;
second.prev = head;
second.next = third;
third.prev = second;

console.log("Forward Traversal:");
forwardTraversal(head);

console.log("Backward Traversal:");
backwardTraversal(third);


#include <iostream>

using namespace std;

// Node structure for doubly linked list
struct Node {
    int data;
    Node * prev;
    Node * next;

    Node(int val) {
        data = val;
        prev = next = nullptr;
}
};

// Function to find the length of a doubly
//linked list
int findLength(Node * head) {
    int count = 0;
for (Node * cur = head; cur != nullptr; cur = cur -> next)
        count++;
return count;
}

int main() {

    // Create a DLL with 3 nodes
    Node * head = new Node(1);
    Node * second = new Node(2);
    Node * third = new Node(3);
    head -> next = second;
second -> prev = head;
second -> next = third;
    third -> prev = second;

    cout << "Length of the doubly linked list: " <<
        findLength(head) << endl;

return 0;
}

#include <stdio.h>
#include <stdlib.h>

// Node structure for doubly linked list
struct Node {
    int data; // Data stored in the node
    struct Node* prev; // Pointer to the previous node
    struct Node* next; // Pointer to the next node
};

// Constructor function to create a new node
struct Node* createNode(int val) {
    struct Node* newNode =
         (struct Node*)malloc(sizeof(struct Node));
    newNode->data = val;
    newNode->prev = NULL;
    newNode->next = NULL;
return newNode;
}

// Function to find the length of a doubly linked list
int findLength(struct Node* head) {
    int count = 0;
for (struct Node* cur = head; cur != NULL; cur = cur->next)
        count++;
return count;
}

int main() {
    // Create a DLL with 3 nodes
    struct Node* head = createNode(1);
    struct Node* second = createNode(2);
    struct Node* third = createNode(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    printf("Length of the doubly linked list: %d\n",
           findLength(head));

return 0;
}

class Node {
    int data;
    Node prev;
    Node next;

// Constructor
    public Node(int val) {
        data = val;
        prev = null;
next = null;
}
}

class GfG {

    // Function to find the length of
    // a doubly linked list
    static int FindLength(Node head) {
        int count = 0;
for (Node cur = head; cur != null; cur = cur.next)
            count++;
return count;
}

    // Driver code
    public static void main(String[] args) {

        // Create a doubly linked list
        // with 3 nodes
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        System.out.println("Length of doubly linked list: "
                           + FindLength(head));
}
}

class Node:
    def __init__(self, val):
        self.data = val
        self.prev = None
        self.next = None

# Function to find the length of
# a doubly linked list
def find_length(head):
    count = 0
    cur = head
    while cur is not None:
        count += 1
        cur = cur.next
    return count

# Driver code
if __name__ == "__main__":

    # Create a doubly linked list
    # with 3 nodes
    head = Node(1)
    second = Node(2)
    third = Node(3)

    head.next = second
    second.prev = head
    second.next = third
    third.prev = second

    print("Length of the doubly linked list: " +
          str(find_length(head)))

using System;

class Node {
    public int data;
public Node prev;
public Node next;

// Constructor
    public Node(int val) {
        data = val;
        prev = null;
next = null;
}
}

public class GfG {

    // Function to find the length of
    // a doubly linked list
    static int FindLength(Node head) {
        int count = 0;
for (Node cur = head; cur != null; cur = cur.next)
            count++;
return count;
}

    // Driver code
    public static void Main(string[] args) {

        // Create a doubly linked list
        // with 3 nodes
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        Console.WriteLine("Length of doubly linked list: "
                                 + FindLength(head));
}
}

class Node {
    constructor(val) {
        this.data = val;
        this.prev = null;
        this.next = null;
}
}

// Function to find the length of
// a doubly linked list
function findLength(head) {
    let count = 0;
    let cur = head;
    while (cur !== null) {
        count++;
        cur = cur.next;
}
    return count;
}

// Create a doubly linked list with 3 nodes
const head = new Node(1);
const second = new Node(2);
const third = new Node(3);

head.next = second;
second.prev = head;
second.next = third;
third.prev = second;

console.log("Length of the doubly linked list: " +
            findLength(head));









[Insertion at the End of Doubly Linked List](

![Insertion-at-the-End-in-Doubly-Linked-List](

Insertion at the End in the Doubly Linked List


To insert a new node at the end of the doubly linked list, we can use
the following steps:

* Allocate memory for a new node and assign the provided value to its
  data field.
* Initialize the next pointer of the new node to nullptr.
* If the list is empty:
  + Set the previous pointer of the new node to nullptr.
  + Update the head pointer to point to the new node.
                                                                                          * If the list is not empty:
                                                                                          + Traverse the list starting from the head to reach the last
                                                                                          node.
                                                                                          + Set the next pointer of the last node to point to the new
                                                                                          node.
                                                                                          + Set the previous pointer of the new node to point to the last
                                                                                          node.








[Insertion at a Specific Position in Doubly Linked List](

To insert a node at a specific Position in doubly linked list, we can
use the following steps:

![Insertion-at-a-Specific-Position-in-Doubly-Linked-List](


Insertion at a Specific Position in Doubly Linked List



To insert a new node at a specific position,

* If position = 1, create a new node and make it the head of the linked
  list and return it.
* Otherwise, traverse the list to reach the node at position – 1,
  say ****curr****.
* If the position is valid, create a new node with given data,
  say ****new\_node****.
* Update the next pointer of new node to the next
                                                                                                                                             of current node and prev pointer of new node to current
                                                                                                                                             node, ****new\_node->next = curr->next****and ****new\_node->prev = curr.****
                                                                                                                                             * Similarly, update next pointer of current node to
                                                                                                                                                              thenew node, ****curr->next = new\_node****.
                                                                                                                                                              * If the new node is not the last node, update prev pointer of new
                                                                                                                                                                                                          node’s next to the new node, ****new\_node->next->prev = new\_node.****








[Deletion at the Beginning of Doubly Linked List](

![Deletion-at-the-Beginning-of-Doubly-Linked-List](

Deletion at the Beginning of Doubly Linked List


To delete a node at the beginning in doubly linked list, we can use the
following steps:

* Check if the list is empty, there is nothing to delete. Return.
* Store the head pointer in a variable, say ****temp****.
* Update the head of linked list to the node next to the current head, ****head = head->next****.
                                                                        * If the new head is not NULL, update the previous pointer of new head
                                                                                                           to NULL, ****head->prev = NULL****.








[Deletion at the End of Doubly Linked List](

![Deletion-at-the-End-in-Doubly-Linked-List](

Deletion at the End in Doubly Linked List


To delete a node at the end in doubly linked list, we can use the
following steps:

* Check if the doubly linked list is empty. If it is empty, then there
  is nothing to delete.
* If the list is not empty, then move to the last node of the doubly
  linked list, say ****curr****.
* Update the second-to-last node's next pointer to NULL, ****curr->prev->next = NULL****.
* Free the memory allocated for the node that was deleted.








[Deletion at a Specific Position in Doubly Linked List](

![Deletion-at-a-Specific-Position-in-Doubly-Linked-List](


Deletion at a Specific Position in Doubly Linked List



To delete a node at a specific position in doubly linked list, we can
use the following steps:

* Traverse to the node at the specified position, say ****curr****.
* If the position is valid, adjust the pointers to skip the node to be
  deleted.
  + If curr is not the head of the linked list, update the next
    pointer of the node before curr to point to the node after curr, ****curr->prev->next = curr-next****.
  + If curr is not the last node of the linked list, update the
    previous pointer of the node after curr to the node before curr, ****curr->next->prev = curr->prev****.
* Free the memory allocated for the deleted node.








Advantages of Doubly Linked List

* ****Efficient traversal in both directions:**** Doubly linked lists allow for efficient traversal of the list in both
  directions, making it suitable for applications where frequent
  insertions and deletions are required.
* ****Easy insertion and deletion of nodes:**** The presence of pointers to both the previous and next nodes makes it
  easy to insert or delete nodes from the list, without having to
  traverse the entire list.
* ****Can be used to implement a stack or queue:**** Doubly linked lists can be used to implement both stacks and queues,
  which are common data structures used in programming.

Disadvantages of Doubly Linked List

* ****More complex than singly linked lists:****
  Doubly linked lists are more complex than singly linked lists, as they
  require additional pointers for each node.
* ****More memory overhead:**** Doubly linked lists require more memory overhead than singly linked
  lists, as each node stores two pointers instead of one.

Course Name: The Logic Building Problems
Lesson Name: Check for Prime Number

Content:

A

[****prime number****](
is a natural number greater than 1 that has exactly two factors:

****1****
and

****itself****
. This article explores the properties of prime numbers, various methods to check for primality, and related problems.


> ****Input****
> : n = 10
>
>
>
> ****Output****
> : False
>
>
>
> 10 is divisible by 2 and 5
>
>
> ****Input****
> : n = 11
>
>
>
> ****Output****
> : True
>
>
>
> 11 is divisible by 1 and 11 only
>
>
> ****Input****
> : n = 1
>
>
>
> ****Output****
> : False
>
>
>
> [1 is neither composite nor prime](
>
> ****Input****
> : n = 0
>
>
>
> ****Output****
> : False
>
>
>
> [0 is neither composite nor prime](

Table of Content

* [Different Methods to Check for Prime Number](#what-is-prime-number)

+ [[Naive Approach] Basic Trial Division Method – O(n) time and O(1) space](#naive-approach-basic-trial-division-method)
+ [[Efficient Approach – 1] Trial Division Method – O(√n) time and O(1) space](#efficient-approach-1-trial-division-method)
+ [[Expected Approach – 2] Optimized Trial Division Method – O(√n) time and O(1) space](#expected-approach-2-optimized-trial-division-method)

* [Primality Testing Methods](#primality-testing-methods)
* [Sieve Algorithms for Prime Number Generation](#sieve-algorithms-for-prime-number-generation)
* [Prime Number Algorithms and Related Problems](#prime-number-algorithms-and-related-problems)

Different Methods to Check for Prime Number


To check if a number is prime, we can use the key property of prime numbers that is, a prime number has exactly two factors, 1 and itself. If a number has more than two factors, it is not considered prime. There are several approaches to check if a number is prime, each varying in complexity and efficiency. Lets explore these approaches one by one.



### [Naive Approach] Basic Trial Division Method – O(n) time and O(1) space

> The simplest method to check if a number
>
> ****n****
> is prime by checking every number from
>
> ****2****
> to
>
> ****n-1.****
> If the number
>
> ****n****
> is divisible by any of these, it’s not prime.


Step-by-step approach:


* If

  ****n****
  is less than 2, return

  ****false****
  (0 and 1 are not prime).
* Loop through numbers from

  ****2****
  to

  ****n-1.****
  + If

    ****n****
    is divisible by any of these numbers, return

    ****false****
    .
* If no divisors are found, return

  ****true****
  .








****Time Complexity:****
O(n)



****Auxiliary Space:****
O(1)


### [Efficient Approach – 1] Trial Division Method – O(√n) time and O(1) space

> There is an observation that if we take any number
>
> ****n****
> and find its divisors then divisors would appear in pairs. For example, if
>
> ****4****
> is a divisor of
>
> ****28****
> , then
>
> ****28/4=7****
> is also a divisor. So we have the pair (4,7).
>
>
> This means that for any divisor
>
> ****d****
> of
>
> ****n****
> , there is a corresponding divisor
>
> ****n/d****
> . If
>
> ****d****
> is less than or equal to the
>
> ****√n****
> , then
>
> ****n/d****
> will be greater than or equal to the
>
> ****√n****
> . Therefore, we only need to check for divisors up to the
>
> ****√n****
> . If
>
> ****n****
> has a divisor larger than its square root, the paired divisor must be smaller than the square root, which we would have already checked.


For example, if

****n = 36****
, its square root is

****6****
. The divisors are

****1,2,3,4,6,9,12,18,36****
. We only need to check

****1,2,3,4,6****
because any larger divisor will have a smaller paired divisor that we’ve already checked.








****Time Complexity:****
O(sqrt(n))



****Auxiliary Space:****
O(1)


### [Expected Approach – 2] Optimized Trial Division Method – O(√n) time and O(1) space

> We know that any integer number can be written in the form of
>
> ****6k+i,****
> where
>
> ****k****
> is a nonnegative integer (like 0, 1, 2, 3,…) and
>
> ****i****
> is a number between 0 and 5 (so i can be 0, 1, 2, 3, 4, or 5). If we look closely, we’ll notice that when
>
> ****i****
> is 0, 2, 3, or 4, the numbers
>
> ****6k, 6k+2, 6k+3,****
> and
>
> ****6k+4****
> are all divisible by either 2 or 3. But prime numbers greater than
>
> ****3****
> can’t be divisible by
>
> ****2****
> or
>
> ****3****
> . Therefore, the only forms left that a prime number can have are
>
> ****6k+1****
> or
>
> ****6k+5****
> (since these forms are not divisible by 2 or 3).
>
>
> Instead of checking every number up to the √n to see if it divides
>
> ****n****
> , we only check numbers of the form
>
> ****6k+1****
> and
>
> ****6k+5.****
> This reduces the number of checks needed.


Step-by-step approach:


* Check if

  ****n == 1****
  or

  ****n == 0****
  then return

  ****false****
  .
* Check if

  ****n****
  is

  ****2****
  or

  ****3****
  and return

  ****true****
  .
* Check if

  ****n****
  is divisible by

  ****2****
  or

  ****3****
  and return

  ****false****
  .
* Loop from

  ****5****
  to

  ****√n****
  ​, incrementing by

  ****6****
  .
  + Checks if

    ****n****
    is divisible by

    ****i****
    (which corresponds to

    ****6k+1****
    ) or by

    ****i+2****
    (which corresponds to

    ****6k+5****
    ).
* If no divisors are found, return

  ****true****
  .








****Time Complexity:****
O(sqrt(n))



****Auxiliary Space:****
O(1)


****Primality Testing Methods****

* [Primality Test | Set 1 (Introduction and School Method)](
* [Primality Test | Set 2 (Fermat Method)](
* [Primality Test | Set 3 (Miller–Rabin)](
* [Primality Test | Set 4 (Solovay-Strassen)](
* [Lucas Primality Test](

Sieve Algorithms for Prime Number Generation

* [Sieve of Eratosthenes](
* [Sieve of Eratosthenes in O(n) time complexity](
* [Segmented Sieve](
* [Sieve of Sundaram](
* [Bitwise Sieve](


For more related article on Sieve algorithms , please refer to

[Recent Articles on Sieve](


****Prime Number Algorithms and Related Problems****

* [Find two distinct prime numbers with](
  a

  [given product](
* [Print all prime numbers less than or equal to N](
* [Recursive program for prime number](
* [Find two prime numbers with](
  a

  [given sum](
* [Find the highest occurring digit in prime numbers in a range](
* [Prime Factorization using Sieve O(log n) for multiple queries](
* [Program to print all prime factors of a given number](
* [Least prime factor of numbers till n](
* [Prime factors of LCM of array elements](
* [Program for Goldbach’s Conjecture](
* [Prime numbers and Fibonacci](
* [Composite Number](


For more related problems on prime number, please refer to


[Recent Articles on Prime Numbers](

  