[
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Program to add two fractions\n\nContent:\n\n\n\n\n\n\n\n\n****Algorithm to add two fractions****\n\n\n\n\n\n* Find a common denominator by finding the LCM (Least Common Multiple) of the two denominators.\n* Change the\n\n  [fractions](\n  to have the same denominator and add both terms.\n* Reduce the final fraction obtained into its simpler form by dividing both numerator and denominator by their largest common factor.\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(log(min(a, b)), where a and b are two integers.\n\n\n****Auxiliary Space:****\nO(1), no extra space required so it is a constant.\n",
        "metadata": {
            "lesson_name": "Program to add two fractions",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Perfect Number\n\nContent:\n\n\n\n\n\nRecommended Practice\n\n[Perfect Number](\n\n\n[Try It!](\n\n\nA\n\n****Simple Solution****\nis to go through every number from 1 to n-1 and check if it is a divisor. Maintain sum of all divisors. If sum becomes equal to n, then return true, else return false.\n\n\n\nAn\n\n****Efficient Solution****\nis to go through numbers till square root of n. If a number \u2018i\u2019 divides n, then add both \u2018i\u2019 and n/i to sum.\n\n\n\nBelow is the implementation of efficient solution.\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(log(n))\n\n",
        "metadata": {
            "lesson_name": "Perfect Number",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Print all Jumping Numbers smaller than or equal to a given value\n\nContent:\nA number is called as a\n\n****Jumping Number****\nif all adjacent digits in it differ by\n\n****1****\n. The difference between\n\n****\u20189****\n\u2019 and\n\n****\u20180\u2019****\nis not considered as 1.\n\n\n\nAll single digit numbers are considered as Jumping Numbers. For example 7, 8987 and 4343456 are\n\n****Jumping numbers****\nbut 796 and 89098 are not.\n\n\n\nGiven a positive number\n\n****x****\n, print all\n\n****Jumping Numbers****\nsmaller than or equal to\n\n****x****\n. The numbers can be printed in any order.\n\n\n\nOne\n\n****Simple Solution****\nis to traverse all\n\n[numbers](\nfrom\n\n****0****\nto\n\n****x****\n. For every traversed number, check if it is a Jumping number. If\n\n****yes****\n, then print it. Otherwise ignore it.\n\n\n\n\n\n\n\n*****Time Complexity:*****\nO(x)\n\n\n\n*****Auxiliary Space:*****\nO(1)\n\n\nAn\n\n****Efficient Solution****\ncan solve this problem in\n\n****O(k)****\ntime where\n\n****k****\nis number of Jumping Numbers smaller than or equal to\n\n****x****\n. The idea is use\n\n[BFS](\nor\n\n[DFS](\n.\n\n\n\nAssume that we have a graph where the starting node is\n\n****0****\nand we need to traverse it from the start node to all the reachable nodes.\n\n\nWith the restrictions given in the graph about the jumping numbers, what do you think should be the restrictions defining the next transitions in the graph.\n\n\n\nBelow is BFS based implementation of above idea.\n\n\n\n\n\n\n\n*****Time Complexity:*****\nO(k) time where\n\n****k****\nis number of Jumping Numbers smaller than or equal to\n\n****x****\n\n\n*****Auxiliary Space:*****\nO(1)\n\n\nThanks to Gaurav Ahirwar for above solution.\n\n\n****Exercise:****\n\n\n1. Change the above solution to use DFS instead of BFS.\n2. Extend your solution to print all numbers in sorted order instead of any order.\n3. Further extend the solution to print all numbers in a given range.\n\n****DFS based solution:****\n\n\nIn the\n\n[DFS](\nbased approach we start building our numbers from single digits , i.e. from 1 \u2013 9. Then we check for next possible digit and if possible we call the dfs for those numbers, increasing the number of digits with each call.\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(k)\n\n\nHere k is the total number of jumping numbers.\n\n\n****Auxiliary Space:****\nO(len(N))\n\n\nHere len(N) is the maximum length from all the jumping numbers, the extra space is used due to recursive function call stack.\n\n",
        "metadata": {
            "lesson_name": "Print all Jumping Numbers smaller than or equal to a given value",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Program to find LCM of two numbers\n\nContent:\n\n\n[****LCM****](\nof two numbers is the smallest number which can be divided by both numbers.\n\n\n> ****Input****\n> : a = 12, b = 18\n>\n>\n>\n> ****Output****\n> : 36\n>\n>\n>\n> 36 is the smallest number divisible by both 12 and 18\n>\n>\n> ****Input****\n> : a = 5, b = 11\n>\n>\n>\n> ****Output****\n> : 55\n>\n>\n>\n> 55 is the smallest number divisible by both 5 and 11\n\n\nA\n\n****simple solution****\nis to\n\n[find all prime factors](\nof both numbers, then find union of all factors present in both\n\n[numbers](\n. Finally, return the product of elements in union.\n\n\nAn\n\n****efficient solution****\nis based on the below formula for LCM of two numbers \u2018a\u2019 and \u2018b\u2019.\n\n\n![relation---------between---------hcf---------and---------lcm_________](\n> a x b = LCM(a, b) \\* GCD (a, b)\n>\n>\n>\n>\n>\n> LCM(a, b) = (a x b) / GCD(a, b)\n\n\nWe have discussed\n\n[function to find GCD of two numbers](\n. Using GCD, we can find LCM.\n\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(log(min(a,b))\n\n\n\n****Auxiliary Space:****\nO(log(min(a,b))\n\n\n\n\n\n\n\n****Time Complexity:****\nO(min(a,b))\n\n\n\n****Auxiliary Space:****\nO(1)\n",
        "metadata": {
            "lesson_name": "Program to find LCM of two numbers",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Program to Find GCD or HCF of Two Numbers\n\nContent:\nGiven two numbers\n\n****a****\nand\n\n****b****\n, the task is to find the\n\n[GCD](\nof the two numbers.\n\n\n****Note:****\nThe GCD (Greatest Common Divisor) or HCF (Highest Common Factor) of two numbers is the largest number that divides both of them.\n\n\n\n![gcd](\n\n\n\n\n****Examples:****\n\n> ****Input:****\n> a = 20, b = 28\n>\n>\n>\n> ****Output:****\n> 4\n>\n>\n>\n> ****Explanation:****\n> The factors of 20 are 1, 2, 4, 5, 10 and 20. The factors of 28 are 1, 2, 4, 7, 14 and 28. Among these factors, 1, 2 and 4 are the common factors of both 20 and 28. The greatest among the common factors is 4.\n>\n>\n> ****Input:****\n> a = 60, b = 36\n>\n>\n>\n> ****Output:****\n> 12\n\nNaive Approach for GCD of two numbers:\n\n> The basic idea is to find the minimum of the two numbers and find its highest factor which is also a factor of the other\n>\n> [number](\n> .\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(min(a,b))\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n[Euclidean algorithm](\nfor GCD of two numbers:\n\n\nThe idea of this algorithm is, the GCD of two numbers doesn\u2019t change if the smaller number is subtracted from the bigger number. This is the\n\n****Euclidean algorithm by subtraction****\n. It is a process of repeat subtraction, carrying the result forward each time until the result is equal to any one number being subtracted.\n\n\n****Pseudo-code:****\n\n> gcd(a, b):\n>\n>\n>\n> if a = b:\n>\n>\n>\n> return a\n>\n>\n>\n> if a > b:\n>\n>\n>\n> return gcd(a \u2013 b, b)\n>\n>\n>\n> else:\n>\n>\n>\n> return gcd(a, b \u2013 a)\n\n\nBelow is the implementation of the above approach.\n\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(min(a,b))\n\n\n\n****Auxiliary Space:****\nO(min(a,b)) because it uses internal stack data structure in recursion.\n\n\n****Optimization by checking divisibility:****\n\n\nThe above method can be optimized based on the following idea:\n\n\n> If we notice the previous approach, we can see at some point, one number becomes a factor of the other so instead of repeatedly subtracting till both become equal, we can check if it is a factor of the other.\n\n****Illustration:****\n\n\nSee the below illustration for a better understanding:\n\n\n> Consider a = 98 and b = 56\n>\n>\n> ****a = 98, b = 56:****\n>\n> * a > b so put a = a-b and b remains same. So  a = 98-56 = 42  & b= 56.\n>\n> ****a = 42, b = 56:****\n>\n> * Since b > a, we check if b%a=0. Since answer is no, we proceed further.\n> * Now b>a. So b = b-a and a remains same. So b = 56-42 = 14 & a= 42.\n>\n> ****a = 42, b = 14:****\n>\n> * Since a>b, we check if a%b=0. Now the answer is yes.\n> * So we print smaller among a and b as H.C.F . i.e. 42 is  3 times of 14.\n>\n>\n> So\n>\n> ****HCF****\n> is 14.\n\n\n\n\n\n\n\n****Time Complexity:****\nO(min(a, b))\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n****Optimization using division:****\n\n> Instead of the Euclidean algorithm by subtraction, a better approach can be used. We don\u2019t perform subtraction here. we continuously divide the bigger number by the smaller number. More can be learned about this\n>\n> ****efficient solution****\n> by using the modulo operator in\n>\n> [Euclidean algorithm](\n> .\n\n\nBelow is the implementation of the above approach.\n\n\n\n\n\n\n\n\n\n****Complexity Analysis:****\n\n****Time Complexity:****\nO(log(min(a,b)))\n\n\n* The derivation for this is obtained from the analysis of the worst-case scenario.\n* What we do is we ask what are the 2 least numbers that take 1 step, those would be (1,1). If we want to increase the number of steps to 2 while keeping the numbers as low as possible as we can take the numbers to be (1,2). Similarly, for 3 steps, the numbers would be (2,3), 4 would be (3,5), 5 would be (5,8).\n* So we can notice a pattern here, for the nth step the numbers would be (fib(n), fib(n+1)). So the worst-case time complexity would be O(n) where\n\n  ****a ? fib(n)****\n  and\n\n  ****b ? fib(n+1)****\n  .\n* Now Fibonacci series is an exponentially growing series where the ratio of n\n\n  th\n  /(n-1)\n\n  th\n  term approaches (sqrt(5)+1)/2 which is also called the golden ratio. So we can see that the time complexity of the algorithm increases linearly as the terms grow exponentially hence the time complexity would be\n\n  ****log(min(a,b))****\n  .\n\n****Auxiliary Space:****\nO(log(min(a,b))\n\n\n****Iterative implementation for GCD of two numbers using Euclidean Algorithm:****\n\n\nBelow is the iterative way to find the GCD of two numbers using Euclidean algorithm.\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(log(min(a,b)))\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n### GCD of two numbers using inbuilt function:\n\n\nLanguages like C++ have inbuilt functions to calculate GCD of two numbers.\n\n\nBelow is the implementation using inbuilt functions.\n\n\n\n\n\n\n\n****Time Complexity:****\nO(log(min(a, b)))\n\n\n\n****Auxiliary Space:****\nO(1)\n\n",
        "metadata": {
            "lesson_name": "Program to Find GCD or HCF of Two Numbers",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Square root of an integer\n\nContent:\nGiven a positive integer\n\n****n****\n, find its square root. If\n\n****n****\nis not a perfect square, then return\n\n****floor****\nof\n\n****\u221an****\n.\n\n\n****Examples :****\n\n\n> ****Input:****\n> n = 4\n>\n>\n>\n> ****Output:****\n> 2\n>\n>\n>\n> ****Explanation:****\n> The square root of 4 is 2.\n>\n>\n> ****Input:****\n> n = 11\n>\n>\n>\n> ****Output:****\n> 3\n>\n>\n>\n> ****Explanation:****\n> The square root of 11 lies in between 3 and 4 so floor of the square root is 3.\n\nTable of Content\n\n* [[Naive Approach] Using a loop \u2013 O(sqrt(n)) Time and O(1) Space](#approach-1-using-a-loop-on-time-and-o1-space)\n* [[Expected Approach] Using Binary Search \u2013 O(logn) Time and O(1) Space](#approach-2-using-binary-search-ologn-time-and-o1-space)\n* [[Alternate Approach] Using Built In functions \u2013 O(logn) Time and O(1) Space](#approach-3-using-built-in-functions-ologn-time-and-o1-space)\n* [[Alternate Approach] Using Formula Used by Pocket Calculators \u2013 O(1) Time and O(1) Space](#approach-4-using-formula-used-by-pocket-calculators-o1-time-and-o1-space)\n### [Naive Approach] Using a loop \u2013 O(sqrt(n)) Time and O(1) Space\n\n\nAs, we know that square root of a positive integer is always\n\n****greater****\nthan or\n\n****equal****\nto one. So we start iterating from\n\n****1****\nand calculate the square of each number. We continue the iteration until we reach to an\n\n****integer****\nwhose square is\n\n****greater****\nthan the given integer, then the integer just\n\n****before****\nit will be our answer.\n\n\n\n\n\n\n\n### [Expected Approach] Using Binary Search \u2013 O(logn) Time and O(1) Space\n\n> The square root of an integer follows a\n>\n> ****monotonic****\n> pattern, because as we\n>\n> ****increase****\n> any number, it\u2019s square also\n>\n> ****increases****\n> . If the square of a number is\n>\n> ****greater****\n> than given integer, then square root will definitely exist\n>\n> ****before****\n> this number. Conversely, if the square of a number is\n>\n> ****less****\n> than or\n>\n> ****equal****\n> to\n>\n> ****n****\n> , then either this number is the square root or it lies after this number.\n>\n>\n>\n> Therefore, we can use\n>\n> [binary search](\n> to find the square root of n. I\n>\n> ****nitial search****\n> space will be 1 to the given integer itself, because square root of any positive integer always exists within this range.\n\n\n\n\n\n\n\n### [Alternate Approach] Using Built In functions \u2013 O(logn) Time and O(1) Space\n\n\nWe can directly use built in functions to find square root of an integer.\n\n\n\n\n\n\n\n### [Alternate Approach] Using Formula Used by Pocket Calculators \u2013 O(1) Time and O(1) Space\n\n[Pocket calculator](\nuses the mathematical formula\n\n****\u221an = e****\n****1/2 \\* ln(n)****\nto compute the square root of an integer n. Below is mathematical proof of this formula:\n\n\n> Let\u2019s say square root of n is x:\n>\n>\n>\n> ****x = \u221an****\n>\n>\n> Squaring both the sides:\n>\n>\n>\n> x\n>\n> 2 =\n> n\n>\n>\n>\n> Taking log on both the sides:\n>\n>\n>\n> => ln(x\n>\n> 2\n> ) = ln(n)\n>\n>\n>\n> => 2\\*ln(x) = ln(n)\n>\n>\n>\n> => ln(x) = 1/2 \\* ln(n)\n>\n>\n>\n> To isolate x, exponentiate both sides with base e:\n>\n>\n>\n> => x = e\n>\n> 1/2 \\* ln(n)\n>\n>\n> x is the square root of n:\n>\n>\n>\n> ****\u221an****\n> = e\n>\n> 1/2 \\* ln(n)\n\n\nBecause of the way computations are done in computers in case of decimals, the result from the expression may be slightly less than the actual square root. Therefore, we will also consider the\n\n****next integer****\nafter the calculated result as a potential answer.\n\n\n\n\n\n\n",
        "metadata": {
            "lesson_name": "Square root of an integer",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Factorial of a Number\n\nContent:\nGiven the number\n\n****n****\n(n >=0), find its\n\n[factorial](\n. Factorial of n is defined as 1 x 2 x \u2026 x n. For n = 0, factorial is 1. We are going to discuss iterative and recursive programs in this post.\n\n\n****Examples:****\n\n> ****Input****\n> : n = 5\n>\n>\n>\n> ****Output****\n> : 120\n>\n>\n>\n> ****Explanation****\n> : 5! = 5 \\* 4 \\* 3 \\* 2 \\* 1 = 120\n>\n>\n> ****Input****\n> : n = 4\n>\n>\n>\n> ****Output****\n> : 24\n>\n>\n>\n> ****Explanation****\n> : 4! = 4 \\* 3 \\* 2 \\* 1 = 24\n>\n>\n> ****Input****\n> : n = 0\n>\n>\n>\n> ****Output****\n> : 1\n>\n>\n> ****Input****\n> : n = 1\n>\n>\n>\n> ****Output****\n> : 1\n\n### ****Iterative Solution****\n\n\nThe idea is simple, we initialize result as 1. Then run a loop from 1 to n and multiply every number with n.\n\n\n\n> ****Illustration for n = 4****\n>\n>\n> Initialize res = 1\n>\n>\n>\n> Run a loop for i = 2 to 4\n>\n>\n>\n> i = 2 : res = res \\* 2 = 2\n>\n>\n>\n> i = 3 : res = res \\* 3 = 6\n>\n>\n>\n> i = 4 : res = res \\* 4 = 24\n\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(n), since we are running a loop from 1 to n.\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n### ****Recursive Solution****\n\n\nLet us first see how we can break factorial(n) into smaller problem and then define recurrance.\n\n\n> * ****n!****\n>   = n \\* (n \u2013 1) \\* (n \u2013 2) \u2026. 2 \\* 1\n> * ****(n \u2013 1)!****\n>   = (n \u2013 1) \\* (n \u2013 2) \u2026 2 \\* 1\n>\n>\n> From the above two equations, we can say that n\n>\n> ****! = n \\* (n \u2013 1)!****\n>\n>\n>\n>\n> Since the problem can be broken down into The idea is to define a recursive function, say\n>\n> ****factorial(n)****\n> to calculate the\n>\n> [factorial](\n> of number\n>\n> ****n****\n> . According to the value of n, we can have two cases:\n>\n>\n> ****if****\n> n\n>\n> ****= 0 or n = 1 :****\n>\n>\n>\n> factorial(n) = 1\n>\n>\n>\n> ****Else****\n> :\n>\n>\n>\n> factorial(n) = n \\* factorial(n \u2013 1).\n\n****Illustration:****\n\n![factorial](\n\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(n), since the function is being called n times\n\n\n\n****Auxiliary Space:****\nO(n), In the worst case, the recursion stack space would be full with all the function calls waiting to get completed and that would make it an O(n) recursion stack space.\n\n\n****Which approach is better \u2013 iterative or recursive?****\n\n\nIterative approach is better as the recursive approach requires extra space for recursion call stack and overhead of recursion calls. However writing a recursive code is always a fun exercise.\n\n\n****How do we handle large numbers?****\n\n\nOne simple improvement that we can do is use long long in C/C++ and long in Java/C#, but that does not help much as factorials are really large numbers and causes overflow for small values. Please refer\n",
        "metadata": {
            "lesson_name": "Factorial of a Number",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Check if a number is a power of another number\n\nContent:\n\nGiven two positive numbers x and y, check if y is a power of x or not.\n\n\n**Examples :**\n\n> **Input:**\n> x = 10, y = 1\n>\n>\n> **Output:**\n> True\n>\n>\n> x^0 = 1\n>\n> **Input:**\n> x = 10, y = 1000\n>\n>\n> **Output:**\n> True\n>\n>\n> x^3 = 1\n>\n> **Input:**\n> x = 10, y = 1001\n>\n>\n> **Output:**\n> False\n\nRecommended Practice\n\n[Check if a number is power of another number](\n\n\n[Try It!](\n\n\nA simple solution is to repeatedly compute the powers of x. If a power becomes equal to y, then y is a power, else not.\n\n\n\n\n\n\n\n\n**Time complexity:**\nO(Log\nx\ny)\n\n\n**Auxiliary space:**\nO(1)\n\n**Optimization:**\n\n\nWe can optimize above solution to work in O(Log Log y). The idea is to do squaring of power instead of multiplying it with x, i.e., compare y with x^2, x^4, x^8, \u2026etc. If x becomes equal to y, return true. If x becomes more than y, then we do binary search for power of x between previous power and current power, i.e., between x^i and x^(i/2).\n\n\nFollowing are detailed step.\n\n\n**Alternate Solution :**\n\n\nThe idea is to take log of y in base x. If it turns out to be an integer, we return true. Else false.\n\n\n\n\n\n\n\n\n**Time complexity**\n: O(log Y)\n\n\n**Auxiliary space**\n: O(1)",
        "metadata": {
            "lesson_name": "Check if a number is a power of another number",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Find numbers from 1 to N with exactly 3 divisors\n\nContent:\n\nGiven a number\n\n****N****\n, print all numbers in the range from 1 to N having exactly 3 divisors.\n\n\n****Examples:****\n\n\n> ****Input:****\n> N = 16\n>\n>\n>\n> ****Output:****\n> 4 9\n>\n>\n>\n> ****Explanation****\n> : 4 and 9 have exactly three divisors.\n>\n>\n> ****Input:****\n> N = 49\n>\n>\n>\n> ****Output:****\n> 4 9 25 49\n>\n>\n>\n> ****Explanation:****\n> 4, 9, 25 and 49 have exactly three divisors.\n\nRecommended Practice\n\n[3 Divisors](\n\n\n[Try It!](\n\n\n****Mathematical approach to find Numbers with exactly 3 divisors:****\n\n\nTo solve the problem follow the below idea:\n\n\n> ****Idea:****\n> After having a close look at the examples mentioned above, you have noticed that all the required numbers are perfect squares and that too of only prime numbers.\n>\n>\n> ****Proof:****\n> Suppose the number is N, and it is a perfect square with square root X such that X is prime.\n>\n>\n> Now if we find the factors of N, it will always have following combinations:\n>\n>\n> * 1\\*N\n> * X\\*X\n>\n>\n> Therefore the required numbers will have only three numbers as their divisors:\n>\n>\n> * 1,\n> * that number itself, and\n> * just a single divisor in between 1 and the number.\n\n****Algorithm:****\nWe can generate all primes within a set using any sieve method efficiently and then we should take all primes i, such that\n\n****i\\*i <=N****\n.\n\n\nFollow the below steps to solve the problem:\n\n\n* Generate the prime numbers from 1 to N using any sieve method efficiently\n* Print all the prime numbers(X) between 1 to N, such as X\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(N\\*log(log(N)))\n\n\n\n****Auxiliary Space:****\nO(N)\n\n\n****Numbers with exactly 3 divisors using constant space:****\n\n> Run a loop from 2 to sqrt(N) and check if the current element is prime or not, if it is so then print that number, but this method will increase the time complexity of the solution\n\n\nFollow the below steps to solve the problem:\n\n\n* Start a loop for integer\n\n  ****i****\n  from\n\n  ****2****\n  to\n\n  ****N.****\n* Check if\n\n  ****i****\n  is prime or not, which can be done easily using the\n\n  [****isPrime(n)****](\n\n  method.\n* If\n\n  ****i****\n  is prime, check if its square is less than or equal to the given number. This will be reviewed only for squares of prime numbers, therefore reducing the number of checks.\n* If the above condition is satisfied, the number will be printed and the loop will continue till\n\n  ****i <= n.****\n\n\n\n\n\n\n\n****Time Complexity:****\nO(sqrt N\n\n2\n)\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n",
        "metadata": {
            "lesson_name": "Find numbers from 1 to N with exactly 3 divisors",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Check for Prime Number\n\nContent:\n\nA\n\n[****prime number****](\nis a natural number greater than 1 that has exactly two factors:\n\n****1****\nand\n\n****itself****\n. This article explores the properties of prime numbers, various methods to check for primality, and related problems.\n\n\n> ****Input****\n> : n = 10\n>\n>\n>\n> ****Output****\n> : False\n>\n>\n>\n> 10 is divisible by 2 and 5\n>\n>\n> ****Input****\n> : n = 11\n>\n>\n>\n> ****Output****\n> : True\n>\n>\n>\n> 11 is divisible by 1 and 11 only\n>\n>\n> ****Input****\n> : n = 1\n>\n>\n>\n> ****Output****\n> : False\n>\n>\n>\n> [1 is neither composite nor prime](\n>\n> ****Input****\n> : n = 0\n>\n>\n>\n> ****Output****\n> : False\n>\n>\n>\n> [0 is neither composite nor prime](\n\nTable of Content\n\n* [Different Methods to Check for Prime Number](#what-is-prime-number)\n\n+ [[Naive Approach] Basic Trial Division Method \u2013 O(n) time and O(1) space](#naive-approach-basic-trial-division-method)\n+ [[Efficient Approach \u2013 1] Trial Division Method \u2013 O(\u221an) time and O(1) space](#efficient-approach-1-trial-division-method)\n+ [[Expected Approach \u2013 2] Optimized Trial Division Method \u2013 O(\u221an) time and O(1) space](#expected-approach-2-optimized-trial-division-method)\n\n* [Primality Testing Methods](#primality-testing-methods)\n* [Sieve Algorithms for Prime Number Generation](#sieve-algorithms-for-prime-number-generation)\n* [Prime Number Algorithms and Related Problems](#prime-number-algorithms-and-related-problems)\n\nDifferent Methods to Check for Prime Number\n\n\nTo check if a number is prime, we can use the key property of prime numbers that is, a prime number has exactly two factors, 1 and itself. If a number has more than two factors, it is not considered prime. There are several approaches to check if a number is prime, each varying in complexity and efficiency. Lets explore these approaches one by one.\n\n\n\n### [Naive Approach] Basic Trial Division Method \u2013 O(n) time and O(1) space\n\n> The simplest method to check if a number\n>\n> ****n****\n> is prime by checking every number from\n>\n> ****2****\n> to\n>\n> ****n-1.****\n> If the number\n>\n> ****n****\n> is divisible by any of these, it\u2019s not prime.\n\n\nStep-by-step approach:\n\n\n* If\n\n  ****n****\n  is less than 2, return\n\n  ****false****\n  (0 and 1 are not prime).\n* Loop through numbers from\n\n  ****2****\n  to\n\n  ****n-1.****\n  + If\n\n    ****n****\n    is divisible by any of these numbers, return\n\n    ****false****\n    .\n* If no divisors are found, return\n\n  ****true****\n  .\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(n)\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n### [Efficient Approach \u2013 1] Trial Division Method \u2013 O(\u221an) time and O(1) space\n\n> There is an observation that if we take any number\n>\n> ****n****\n> and find its divisors then divisors would appear in pairs. For example, if\n>\n> ****4****\n> is a divisor of\n>\n> ****28****\n> , then\n>\n> ****28/4=7****\n> is also a divisor. So we have the pair (4,7).\n>\n>\n> This means that for any divisor\n>\n> ****d****\n> of\n>\n> ****n****\n> , there is a corresponding divisor\n>\n> ****n/d****\n> . If\n>\n> ****d****\n> is less than or equal to the\n>\n> ****\u221an****\n> , then\n>\n> ****n/d****\n> will be greater than or equal to the\n>\n> ****\u221an****\n> . Therefore, we only need to check for divisors up to the\n>\n> ****\u221an****\n> . If\n>\n> ****n****\n> has a divisor larger than its square root, the paired divisor must be smaller than the square root, which we would have already checked.\n\n\nFor example, if\n\n****n = 36****\n, its square root is\n\n****6****\n. The divisors are\n\n****1,2,3,4,6,9,12,18,36****\n. We only need to check\n\n****1,2,3,4,6****\nbecause any larger divisor will have a smaller paired divisor that we\u2019ve already checked.\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(sqrt(n))\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n### [Expected Approach \u2013 2] Optimized Trial Division Method \u2013 O(\u221an) time and O(1) space\n\n> We know that any integer number can be written in the form of\n>\n> ****6k+i,****\n> where\n>\n> ****k****\n> is a nonnegative integer (like 0, 1, 2, 3,\u2026) and\n>\n> ****i****\n> is a number between 0 and 5 (so i can be 0, 1, 2, 3, 4, or 5). If we look closely, we\u2019ll notice that when\n>\n> ****i****\n> is 0, 2, 3, or 4, the numbers\n>\n> ****6k, 6k+2, 6k+3,****\n> and\n>\n> ****6k+4****\n> are all divisible by either 2 or 3. But prime numbers greater than\n>\n> ****3****\n> can\u2019t be divisible by\n>\n> ****2****\n> or\n>\n> ****3****\n> . Therefore, the only forms left that a prime number can have are\n>\n> ****6k+1****\n> or\n>\n> ****6k+5****\n> (since these forms are not divisible by 2 or 3).\n>\n>\n> Instead of checking every number up to the \u221an to see if it divides\n>\n> ****n****\n> , we only check numbers of the form\n>\n> ****6k+1****\n> and\n>\n> ****6k+5.****\n> This reduces the number of checks needed.\n\n\nStep-by-step approach:\n\n\n* Check if\n\n  ****n == 1****\n  or\n\n  ****n == 0****\n  then return\n\n  ****false****\n  .\n* Check if\n\n  ****n****\n  is\n\n  ****2****\n  or\n\n  ****3****\n  and return\n\n  ****true****\n  .\n* Check if\n\n  ****n****\n  is divisible by\n\n  ****2****\n  or\n\n  ****3****\n  and return\n\n  ****false****\n  .\n* Loop from\n\n  ****5****\n  to\n\n  ****\u221an****\n  \u200b, incrementing by\n\n  ****6****\n  .\n  + Checks if\n\n    ****n****\n    is divisible by\n\n    ****i****\n    (which corresponds to\n\n    ****6k+1****\n    ) or by\n\n    ****i+2****\n    (which corresponds to\n\n    ****6k+5****\n    ).\n* If no divisors are found, return\n\n  ****true****\n  .\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(sqrt(n))\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n****Primality Testing Methods****\n\n* [Primality Test | Set 1 (Introduction and School Method)](\n* [Primality Test | Set 2 (Fermat Method)](\n* [Primality Test | Set 3 (Miller\u2013Rabin)](\n* [Primality Test | Set 4 (Solovay-Strassen)](\n* [Lucas Primality Test](\n\nSieve Algorithms for Prime Number Generation\n\n* [Sieve of Eratosthenes](\n* [Sieve of Eratosthenes in O(n) time complexity](\n* [Segmented Sieve](\n* [Sieve of Sundaram](\n* [Bitwise Sieve](\n\n\nFor more related article on Sieve algorithms , please refer to\n\n[Recent Articles on Sieve](\n\n\n****Prime Number Algorithms and Related Problems****\n\n* [Find two distinct prime numbers with](\n  a\n\n  [given product](\n* [Print all prime numbers less than or equal to N](\n* [Recursive program for prime number](\n* [Find two prime numbers with](\n  a\n\n  [given sum](\n* [Find the highest occurring digit in prime numbers in a range](\n* [Prime Factorization using Sieve O(log n) for multiple queries](\n* [Program to print all prime factors of a given number](\n* [Least prime factor of numbers till n](\n* [Prime factors of LCM of array elements](\n* [Program for Goldbach\u2019s Conjecture](\n* [Prime numbers and Fibonacci](\n* [Composite Number](\n\n\nFor more related problems on prime number, please refer to\n\n\n[Recent Articles on Prime Numbers](\n\n  ",
        "metadata": {
            "lesson_name": "Check for Prime Number",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Program for Sum of the digits of a given number\n\nContent:\nGiven a number\n\n****n****\n, find the sum of its digits.\n\n\n****Examples :****\n\n> ****Input:****\n> n = 687\n>\n>\n>\n> ****Output:****\n> 21\n>\n>\n>\n> ****Explanation:****\n> **The sum of its digits are: 6 + 8 + 7 = 21**\n>\n> ****Input:****\n> n = 12\n>\n>\n>\n> ****Output:****\n> 3\n>\n>\n>\n> ****Explanation:****\n> **The sum of its digits are: 1 + 2 = 3**\n\nTable of Content\n\n* [[Expected Approach] Sum of the digits of a given number using recursion](#expected-approach-sum-of-the-digits-of-a-given-number-using-recursion)\n* [[Alternate Approach] Sum of the digits of a given number using tail recursion](#alternate-approach-sum-of-the-digits-of-a-given-number-using-tail-recursion)\n* [[Alternate Approach] Converting Number to String](#sum-of-the-digits-of-a-given-number-with-input-as-string)\n### ****[Expected Approach] Sum of the digits using recursion****\n\n> **The idea is to count the digits by removing the digits from the input number starting from**\n> ****right(least significant digit)****\n> **to**\n> ****left(most significant digit)****\n> **till the number is reduced to 0 because the rightmost digit can be removed simply by performing**\n> ****integer division by 10****\n> **. For eg: n = 1567, then 1567 / 10 = 156.7 = 156(Integer Division).**\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(log n)\n\n\n\n****Auxiliary Space:****\nO(log n)\n\n\n### ****[Alternate Approach] Using tail recursion****\n\n> This approach ensures that the recursive call is the last operation, allowing for better memory efficiency and preventing stack overflow.\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(log n)\n\n\n\n****Auxiliary Space:****\nO(log n)\n\n\n### ****[Alternate Approach]**** Converting Number to String\n\n> When the number of digits of that number exceeds 10\n>\n> 19\n> , we can\u2019t take that number as an integer since the range of long long int doesn\u2019t satisfy the given number. So take input as a string, run a loop from start to the length of the string and increase the sum with that character(in this case it is numeric)\n\n\n\n\n\n\n\n****Time Complexity:****\nO(n)\n\n\n\n****Auxiliary Space:****\nO(1)\n\n",
        "metadata": {
            "lesson_name": "Program for Sum of the digits of a given number",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: Applications, Advantages and Disadvantages of Array\n\nContent:\nTable of Content\n\n* [Applications of Array Data Structure:](#applications-of-array-data-structure)\n* [Advantages of Array Data Structure:](#advantages-of-array-data-structure)\n* [Disadvantages of Array Data Structure:](#disadvantages-of-array-data-structure)\n### ****Applications of Array Data Structure:****\n\nArrays mainly have advantages like random access and cache friendliness\nover other data structures that make them useful.\n\nBelow are some applications of arrays.\n\n* ****Storing and accessing data****: Arrays store elements in a specific order and allow constant-time\n  O(1) access to any element.\n* ****Searching****: If data in array is sorted, we can search an item in O(log n) time.\n  We can also find floor(), ceiling(), kth smallest, kth largest, etc\n  efficiently.\n* ****Matrices****: Two-dimensional arrays are used for matrices in computations like\n  graph algorithms and image processing.\n* ****Implementing other data structures:****\n  Arrays are used as the underlying data structure for implementing\n  stacks and queues.\n* ****Dynamic programming****: Dynamic programming algorithms often use arrays to store\n  intermediate results of subproblems in order to solve a larger\n  problem.\n* ****Data Buffers:****\n  Arrays serve as data buffers and queues, temporarily storing incoming\n  data like network packets, file streams, and database results before\n  processing.\n\n### ****Advantages of Array Data Structure:****\n\n* ****Efficient and Fast Access:****\n  Arrays allow direct and efficient access to any element in the\n  collection with constant access time, as the data is stored in\n  contiguous memory locations.\n* ****Memory Efficiency:****\n  Arrays store elements in contiguous memory, allowing efficient\n  allocation in a single block and reducing memory fragmentation.\n* ****Versatility:****\n  Arrays can be used to store a wide range of data types, including\n  integers, floating-point numbers, characters, and even complex data\n  structures such as objects and pointers.\n* ****Compatibility with hardware:**** The array data structure is compatible with most hardware\n  architectures, making it a versatile tool for programming in a wide\n  range of environments.\n\n### ****Disadvantages of Array Data Structure:****\n\n* ****Fixed Size:****\n  Arrays have a fixed size set at creation. Expanding an array requires\n  creating a new one and copying elements, which is time-consuming and\n  memory-intensive.\n* ****Memory Allocation Issues:****\n  Allocating large arrays can cause memory exhaustion, leading to\n  crashes, especially on systems with limited resources.\n* ****Insertion and Deletion Challenges:****\n  Adding or removing elements requires shifting subsequent elements,\n  making these operations inefficient.\n* ****Limited Data Type Support:****\n  Arrays support only elements of the same type, limiting their use with\n  complex data types.\n* ****Lack of Flexibility:****\n  Fixed size and limited type support make arrays less adaptable than\n  structures like linked lists or trees.",
        "metadata": {
            "lesson_name": "Applications, Advantages and Disadvantages of Array",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Program to find area of a circle\n\nContent:\n\nGiven the radius of a circle, find the area of that circle.\n\n\n![Area-of-circle](\n> The area of a circle can simply be evaluated using the following formula.\n>\n>\n> [Tex]Area = \\pi r^2[/Tex]\n>\n>\n> where r is radius of circle and it maybe in float because value of pie is 3.14\n\n****Approach****\n: Using the given radius, find the area using the above formula: (pi \\* r \\* r) and print the result in float.\n\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(1)\n\n\n\n****Auxiliary Space:****\nO(1), since no extra space has been taken.\n",
        "metadata": {
            "lesson_name": "Program to find area of a circle",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Program to find simple interest\n\nContent:\nGiven Principal\n\n****p****\n, Rate\n\n****r****\nand Time\n\n****t,****\nthe task is to calculate Simple Interest.\n\n\n****Examples :****\n\n> ****Input****\n> : p = 10000, r = 5, t = 5\n>\n>\n>\n> ****Output****\n> :2500\n>\n>\n>\n> ****Explanation****\n> : We need to find simple interest on Rs. 10,000 at the rate of 5% for 5 units of time.\n>\n>\n> ****Input****\n> : p = 3000, r = 7, t = 1\n>\n>\n>\n> ****Output****\n> :210\n\n\nThe basic idea is to calculate by applying the formula\n\n****SI = (p x t x r)/100****\n\n\n\n\n\n\n\n\n****Time complexity****\n: O(1)\n\n\n\n****Auxiliary Space****\n: O(1)\n",
        "metadata": {
            "lesson_name": "Program to find simple interest",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA II\nLesson Name: Introduction to Circular Queue\n\nContent:\n\nTable of Content\n\n* [Operations on Circular Queue](#operations-on-circular-queue)\n* [Implement Circular Queue using Array](#implement-circular-queue-using-array)\n* [Complexity Analysis of Circular Queue Operations](#complexity-analysis-of-circular-queue-operations)\n### Operations on Circular Queue\n\n* ****getFront:****\n  Get the front item from the queue.\n* ****getRear:****\n  Get the last item from the queue.\n* ****enqueue(value):****\n  To\n\n  ****insert****\n  an element into the circular queue. In a circular queue, the new element is always inserted at the rear position.\n* ****dequeue()****\n  : To\n\n  ****delete****\n  an element from the circular queue. In a circular queue, the element is always deleted from the front position.\n\n### Implement Circular Queue using Array\n\n1. Initialize an\n\n   ****array****\n   of\n\n   ****size n****\n   , where\n\n   ****n is the maximum number of element****\n   s that the queue can hold.\n2. Initialize\n\n   ****three variables (size, capacity, and front.)****\n3. ****Enqueue:****\n   To enqueue an\n\n   ****element x****\n   into the queue, do the following:\n   1. Check if\n\n      ****size == capacity****\n      (queue is full), display\n\n      ****\u201cQueue is full\u201d.****\n   2. If not full: calculate\n\n      ****rear = (front + size) % capacity****\n      and\n\n      ****Insert****\n      value at the rear index.\n\n      ****Increment****\n      size by 1.\n4. ****Dequeue:****\n   To dequeue an element from the queue, do the following:\n   1. Check if\n\n      ****size == 0 (****\n      queue is empty), display\n\n      ****\u201cQueue is empty\u201d.****\n   2. If not empty:\n\n      ****retrieve****\n      the element at the\n\n      ****front index****\n      and\n\n      ****move front = (front + 1) % capacity****\n      . Also,\n\n      ****decrement****\n      size by 1 and\n\n      ****return the removed element.****\n\n\n\n\n\n\n### Complexity Analysis of Circular Queue Operations\n\n****Time Complexity:****\n\n****Auxiliary Space:****\nO(size), where\n\n****size****\nis the number of elements in the circular queue.\n",
        "metadata": {
            "lesson_name": "Introduction to Circular Queue",
            "course_name": "Introduction to DSA II"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: Implement a stack using singly linked list\n\nContent:\n****Stack Operations:****\n\n* [****push()****](\n  Insert a new element into the stack i.e just insert a new element at\n  the beginning of the linked list.\n* [****pop()****](\n  Return the top element of the Stack i.e simply delete the first\n  element from the linked list.\n* [****peek()****]( Return the top element.\n* ****display():**** Print all elements in Stack.\n\nPush Operation:\n\n> * Initialise a node\n> * Update the value of that node by data i.e. ****node->data = data****\n> * Now link this node to the top of the linked list\n> * And update top pointer to the current node\n\nPop Operation:\n\n> * First Check whether there is any node present in the linked list or\n>   not, if not then return\n> * Otherwise make pointer let say ****temp**** to the top node and move forward the top node by 1 step\n> * Now free this temp node\n\nPeek Operation:\n\n> * Check if there is any node present or not, if not then\n>   return.\n> * Otherwise return the value of top node of the linked list\n\nDisplay Operation:\n\n> * Take a ****temp**** node and initialize it with top pointer\n> * Now start traversing temp till it encounters NULL\n> * Simultaneously print the value of the temp node\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(1), for all push(), pop(), and peek(), as we are not performing any\nkind of traversal over the list. We perform all the operations through\nthe current pointer only.\n****Auxiliary Space:**** O(N), where N is the size of the stack\n\n\nIn this implementation, we define a Node class that represents a node\nin the linked list, and a Stack class that uses this node class to\nimplement the stack. The head attribute of the Stack class points to the\ntop of the stack (i.e., the first node in the linked list).\n\nTo push an item onto the stack, we create a new node with the given\nitem and set its next pointer to the current head of the stack. We then\nset the head of the stack to the new node, effectively making it the new\ntop of the stack.\n\nTo pop an item from the stack, we simply remove the first node from the\nlinked list by setting the head of the stack to the next node in the\nlist (i.e., the node pointed to by the next pointer of the current\nhead). We return the data stored in the original head node, which is the\nitem that was removed from the top of the stack.\n\n### Benefits of implementing a stack using a singly linked list include:\n\n****Dynamic memory allocation****: The size of the stack can be increased or decreased dynamically by\nadding or removing nodes from the linked list, without the need to\nallocate a fixed amount of memory for the stack upfront.\n\n****Efficient memory usage:**** Since nodes in a singly linked list only have a next pointer and not a\nprev pointer, they use less memory than nodes in a doubly linked\nlist.\n\n****Easy implementation****: Implementing a stack using a singly linked list is straightforward\nand can be done using just a few lines of code.\n\n****Versatile****: Singly linked lists can be used to implement other data structures\nsuch as queues, linked lists, and trees.\n\nIn summary, implementing a stack using a singly linked list is a simple\nand efficient way to create a dynamic stack data structure in\nPython.\n\n### Real time examples of stack:\n\nStacks are used in various real-world scenarios where a last-in,\nfirst-out (LIFO) data structure is required. Here are some examples of\nreal-time applications of stacks:\n\n****Function call stack****: When a function is called in a program, the return address and all\nthe function parameters are pushed onto the function call stack. The\nstack allows the function to execute and return to the caller function\nin the reverse order in which they were called.\n\n****Undo/Redo operations:****\nIn many applications, such as text editors, image editors, or web\nbrowsers, the undo and redo functionalities are implemented using a\nstack. Every time an action is performed, it is pushed onto the stack.\nWhen the user wants to undo the last action, the top element of the\nstack is popped and the action is reversed.\n\n****Browser history:**** Web browsers use stacks to keep track of the pages visited by the user.\nEvery time a new page is visited, its URL is pushed onto the stack. When\nthe user clicks the \u201cBack\u201d button, the last visited URL is popped from\nthe stack and the user is directed to the previous page.\n\n****Expression evaluation****: Stacks are used in compilers and interpreters to evaluate\nexpressions. When an expression is parsed, it is converted into postfix\nnotation and pushed onto a stack. The postfix expression is then\nevaluated using the stack.\n\n****Call stack in recursion:****\nWhen a recursive function is called, its call is pushed onto the stack.\nThe function executes and calls itself, and each subsequent call is\npushed onto the stack. When the recursion ends, the stack is popped, and\nthe program returns to the previous function call.\n\nIn summary, stacks are widely used in many applications where LIFO\nfunctionality is required, such as function calls, undo/redo operations,\nbrowser history, expression evaluation, and recursive function\ncalls.\n",
        "metadata": {
            "lesson_name": "Implement a stack using singly linked list",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: The Logic Building Problems\n\nContent:\n\nYou are given a\n\n****cubic dice****\nwith\n\n****6****\nfaces. All the individual faces have a number printed on them. The numbers are in the range of\n\n****1 to 6****\n, like any ordinary dice. You will be provided with a face of this cube, your task is to guess the number on the opposite face of the cube.\n\n\n****Examples:****\n\n> ****Input:****\n> n = 2\n>\n>\n>\n> ****Output:****\n> 5\n>\n>\n>\n> ****Explanation:****\n> For dice facing number 5 opposite face will have the number 2.\n>\n>\n> ****Input:****\n> 6 = 6\n>\n>\n>\n> ****Output:****\n> 1\n\nTable of Content\n\n* [[Naive Approach] Using if-else \u2013 O(1) Time and O(1) Space](#naive-approach-using-ifelse-o1-time-and-o1-space)\n* [[Expected Approach] Using Sum of two sides \u2013 O(1) Time and O(1) Space](#expected-approach-using-sum-of-two-sides-o1-time-and-o1-space)\n### ****[Naive Approach] Using if-else \u2013 O(1) Time and O(1) Space****\n\n> In a normal 6-faced dice, 1 is opposite to 6, 2 is opposite to 5, and 3 is opposite to 4. Hence a normal if-else-if block can be placed\n\n\n\n\n\n\n### [Expected Approach] Using Sum of two sides \u2013 O(1) Time and O(1) Space\n\n> The idea is based on the observation that the sum of two opposite sides of a cubical dice is equal to\n>\n> ****7****\n> . So, just subtract the given\n>\n> ****n****\n> from\n>\n> ****7****\n> and print the answer.\n\n\n\n\n\n\n\n*****Time Complexity:*****\n**O(1)**\n\n\n*****Auxiliary Space:*****\n**O(1)**\n",
        "metadata": {
            "lesson_name": "The Logic Building Problems",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Find the number closest to n and divisible by m\n\nContent:\n\nGiven two integers\n\n****n****\nand\n\n****m (m != 0)****\n. Find the number closest to\n\n****n****\nand divisible by\n\n****m****\n. If there is more than one such number, then output the one having maximum absolute value.\n\n\n****Examples:****\n\n\n> Input: n = 13, m = 4\n>\n>\n>\n> Output: 12\n>\n>\n>\n> Explanation: 12 is the closest to 13, divisible by 4.\n>\n>\n> Input: n = -15, m = 6\n>\n>\n>\n> Output: -18\n>\n>\n>\n> Explanation: Both -12 and -18 are closest to -15, but-18 has the maximum absolute value.\n\nTable of Content\n\n* [[Naive Approach] \u2013 O(m) Time and O(1) Space](#naive-approach-om-time-and-o1-space)\n* [[Expected Approach] By finding Quotient \u2013 O(1) Time and O(1) Space](#expected-approach-by-finding-quotient-o1-time-and-o1-space)\n### [Naive Approach] \u2013 O(m) Time and O(1) Space\n\n> The basic idea is to start checking from n \u2013 m to n + m one by one and tack the closest number.\n\n\n\n\n\n\n\n### [Expected Approach] By finding Quotient \u2013 O(1) Time and O(1) Space\n\n> We find the value of n/m. Then we find closest of two possibilities. One is q \\* m other is (m \\* (q + 1)) or (m \\* (q \u2013 1)) depending on whether one of the given two numbers is negative or not.\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(1)\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n",
        "metadata": {
            "lesson_name": "Find the number closest to n and divisible by m",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: How to swap two numbers without using a temporary variable?\n\nContent:\n\n\nGiven two variables, x, and y, swap two variables without using a third variable.\n\n\n![](\n\n\n\n****Method 1 (Using Addition and subtraction)****\n\n\nThe idea is to get a sum in one of the two given\n\n[numbers](\n. The numbers can then be swapped using the sum and subtraction from the sum.\n\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(1).\n\n\n\n****Auxiliary Space:****\nO(1).\n\n\n****Method 2: (Using Multiplication and division)****\n\n\nMultiplication and division can also be used for swapping.\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(1).\n\n\n\n****Auxiliary Space:****\nO(1).\n\n\n****Method 3: (Using Bitwise XOR)****\n\n\n\nThe bitwise XOR operator can be used to swap two variables. The XOR of two numbers x and y returns a number that has all the bits as 1 wherever bits of x and y differ. For example, XOR of 10 (In Binary 1010) and 5 (In Binary 0101) is 1111, and XOR of 7 (0111) and 5 (0101) is (0010).\n\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(1).\n\n\n\n****Auxiliary Space:****\nO(1).\n\n\n****Problems with the above methods****\n\n\n\n****1)****\nThe multiplication and division-based approach doesn\u2019t work if one of the numbers is 0 as the product becomes 0 irrespective of the other number.\n\n\n\n****2)****\nBoth Arithmetic solutions may cause an arithmetic overflow. If x and y are too large, addition and multiplication may go out of the integer range.\n\n\n\n****3)****\nWhen we use pointers to variable and make a function swap, all the above methods fail when both pointers point to the same variable. Let\u2019s take a look at what will happen in this case if both are pointing to the same variable.\n\n\n// Bitwise XOR based method\n\n\n\nx = x ^ x; // x becomes 0\n\n\n\nx = x ^ x; // x remains 0\n\n\n\nx = x ^ x; // x remains 0\n\n\n\n// Arithmetic based method\n\n\n\nx = x + x; // x becomes 2x\n\n\n\nx = x \u2013 x; // x becomes 0\n\n\n\nx = x \u2013 x; // x remains 0\n\n\nLet us see the following program.\n\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(1).\n\n\n\n****Auxiliary Space:****\nO(1).\n\n\nSwapping a variable with itself may be needed in many standard algorithms. The above problem can be avoided by putting a condition before swapping.\n\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(1).\n\n\n\n****Auxiliary Space:****\nO(1).\n\n\n****Method 4 (A mixture of bitwise operators and arithmetic operators)****\n\n\n\nThe idea is the same as discussed in\n\n****Method 1****\nbut uses Bitwise addition and subtraction for swapping.\n\n\nBelow is the implementation of the above approach.\n\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(1)\n\n\n\n****Auxiliary Space:****\nO(1), since no extra space has been taken.\n\n\n****Method 5 (One Line Expression)****\n\n\nWe can write only one line to swap two numbers.\n\n\n* x = x ^ y ^ (y = x);\n* x = x + y \u2013 (y = x);\n* x = (x \\* y) / (y = x);\n* x , y = y, x (In Python)\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(1)\n\n\n\n****Auxiliary Space:****\nO(1)\n",
        "metadata": {
            "lesson_name": "How to swap two numbers without using a temporary variable?",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Program to find sum of first n natural numbers\n\nContent:\n\nGiven a number n, find the sum of the first natural numbers.\n\n\n****Examples :****\n\n\n> ****Input:****\n> n = 3\n>\n>\n>\n> ****Output:****\n> 6\n>\n>\n>\n> ****Explanation****\n> : Note that 1 + 2 + 3 = 6\n>\n>\n>\n>\n>\n> ****Input****\n> : 5\n>\n>\n>\n> ****Output****\n> : 15\n>\n>\n>\n> ****Explanation****\n> : Note that 1 + 2 + 3 + 4 + 5 = 15\n\n### Naive Solution \u2013 O(n) Time and O(1) Space\n\n\nCalculate the sum of all integers from 1 to\n\n`n`\nby iterating through a loop.\n\n\n\n\n\n\n\n\n### Expected Approach \u2013 O(1) Time and O(1) Space\n\n\nAn\n\n****efficient solution****\nis to use the below formula.\n\n\n> ****Sum of first n natural numbers = (n \\* (n+1)) / 2****\n>\n>\n> For example: n = 5\n>\n>\n>\n> Sum = (5 \\* (5 + 1)) / 2 = (5 \\* 6) / 2 = 30 / 2 = 15\n\n****How does this work?****\n\n> ****We can prove this formula using induction.****\n>\n>\n>\n>\n> It is true for n = 1 and n = 2\n>\n>\n>\n> For n = 1, sum = 1 \\* (1 + 1)/2 = 1\n>\n>\n>\n> For n = 2, sum = 2 \\* (2 + 1)/2 = 3\n>\n>\n>\n>\n>\n> Let it be true for k = n-1.\n>\n>\n>\n>\n>\n> Sum of k numbers = (k \\* (k+1))/2\n>\n>\n>\n> Putting k = n-1, we get\n>\n>\n>\n> Sum of k numbers = ((n-1) \\* (n-1+1))/2\n>\n>\n>\n> = (n \u2013 1) \\* n / 2\n>\n>\n>\n>\n>\n> If we add n, we get,\n>\n>\n>\n> Sum of n numbers = n + (n \u2013 1) \\* n / 2\n>\n>\n>\n> = (2n + n\n>\n> 2\n> \u2013 n)/2\n>\n>\n>\n> = n \\* (n + 1)/2\n\n\n\n\n\n\n\n\n\n****Note:****\nThe above program causes\n\n****overflow,****\neven if the\n\n****result****\nis not beyond the\n\n****integer limit****\n. We can avoid overflow up to some extent by\n\n****dividing first****\n.\n\n\n\n\n\n\n\n\n",
        "metadata": {
            "lesson_name": "Program to find sum of first n natural numbers",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA II\nLesson Name: Singly Linked List Problems\n\nContent:\n****Learn Basics of Singly Linked List:****\n\n1. [Basic Terminologies in Linked List](\n2. [Singly Linked List Tutorial](\n3. [Linked List vs Array](\n\n****Basic Operations of Singly Linked List:****\n\n1. [Linked List Insertion](\n2. [Search an element in a Linked List (Iterative and Recursive)](\n3. [Find Length of a Linked List (Iterative and Recursive)](\n4. [Reverse a linked list](\n5. [Linked List Deletion (Deleting a given key)](\n6. [Linked List Deletion (Deleting a key at given position)](\n7. [Write a function to delete a Linked List](\n\n****Easy Problems on Singly Linked List:****\n\n* [Identical Linked Lists](\n* [Print the middle of a given linked list](\n* [Write a function to get Nth node in a Linked List](\n* [Nth node from the end of a Linked List](\n* [Move last element to front of a given Linked List](\n* [Make middle node head in a linked list](\n* [Delete alternate nodes of a Linked List](\n* [Add 1 to a number represented as linked list](\n* [Add two numbers represented by linked lists](\n* [Subtract Two Numbers represented as Linked Lists](\n* [Find the sum of last n nodes of the given Linked List](\n* [Pairwise swap elements of a given linked list](\n* [Remove every k-th node of the linked list](\n* [Remove duplicates from a sorted linked list](\n\n****Intermediate Problems on Singly Linked List:****\n\n* [Detect loop in a linked list](\n* [Find length of loop in linked list](\n* [Function to check if a singly linked list is palindrome](\n* [Remove duplicates from an unsorted linked list](\n* [Remove all occurrences of duplicates from a sorted Linked List](\n* [Swap nodes in a linked list without swapping data](\n* [Intersection point of two Linked Lists.](\n* [Iteratively Reverse a linked list using only 2 pointers (An Interesting Method)](\n* [Segregate even and odd nodes in a Linked List](\n* [Alternate Odd and Even Nodes in a Singly Linked List](\n* [Rearrange a Linked List in Zig-Zag fashion](\n* [Adding two polynomials using Linked List](\n* [Union and Intersection of two Linked Lists](\n* [Sort linked list which is already sorted on absolute values](\n\n****Hard Problems on Singly Linked List:****\n\n* [Reverse a Linked List in groups of given size](\n* [Flattening a Linked List](\n* [Reverse alternate K nodes in a Singly Linked List](\n* [Alternating split of a given Singly Linked List](\n* [Delete nodes which have a greater value on right side](\n* [Given a linked list of line segments, remove middle points](\n* [Clone a linked list with next and random pointer](\n* [Rearrange a given linked list in-place.](\n* [Select a Random Node from a Singly Linked List](\n* [In-place Merge two linked lists without changing links of first list](\n* [Length of longest palindrome list in a linked list using O(1) extra space](\n* [Rotate Linked List block wise](\n* [Count rotations in sorted and rotated linked list](\n\n****Quick Links:****\n\n* ['Practice Problems' on Linked List](\n    * ['Videos' on Linked List](\n* ['Quizzes' on Linked List](\n",
        "metadata": {
            "lesson_name": "Singly Linked List Problems",
            "course_name": "Introduction to DSA II"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA II\nLesson Name: Introduction to Heap \u2013 Data Structure and Algorithm Tutorials\n\nContent:\nProperties of Heap:\n\n* The minimum or maximum element is always at the root of the heap, allowing constant-time access.\n* The relationship between a parent node at index\n\n  ****\u2018i\u2019****\n  and its children is given by the formulas: left child at index\n\n  ****2i+1****\n  and right child at index\n\n  ****2i+2****\n  for 0-based indexing of node numbers.\n* As the tree is complete binary, all levels are filled except possibly the last level. And the last level is filled from left to right.\n* When we insert an item, we insert it at the last available slot and then rearrange the nodes so that the heap property is maintained.\n* When we remove an item, we swap root with the last node to make sure either the max or min item is removed. Then we rearrange the remaining nodes to ensure heap property (max or min)\n\nOperations Supported by Heap:\n\n\nOperations supported by\n\n****min \u2013 heap****\nand\n\n****max \u2013 heap****\nare same. The difference is just that min-heap contains minimum element at root of the tree and max \u2013 heap contains maximum element at the root of the tree.\n\n\n****Heapify:****\nIt is the process to rearrange the elements to maintain the property of heap data structure. It is done when root is removed (we replace root with the last node and then call heapify to ensure that heap property is maintained) or heap is built (we call heapify from the last internal node to root) to make sure that the heap property is maintained. This operation also takes\n\n****O(log n)****\ntime.\n\n\n* For\n\n  ****max-heap,****\n  it\n\n\n  makes sure the maximum element is the root of that binary tree and all descendants also follow the same property.\n* For\n\n  ****min-heap,****\n  it balances in such a way that the minimum element is the root and all descendants also follow the same property.\n\n****Insertion****\n: When a new element is inserted into the heap, it can disrupt the heap\u2019s properties. To restore and maintain the heap structure, a heapify operation is performed. This operation ensures the heap properties are preserved and has a time complexity of\n\n****O(log n)****\n.\n\n\n\n****Examples:****\n\n> Assume initially heap(taking\n>\n> ****max-heap****\n> ) is as follows\n>\n>\n> 8\n>\n>\n>\n> /   \\\n>\n>\n>\n> 4     5\n>\n>\n>\n> / \\\n>\n>\n>\n> 1   2\n>\n>\n> Now if we insert 10 into the heap\n>\n>\n>\n> 8\n>\n>\n>\n> /      \\\n>\n>\n>\n> 4       5\n>\n>\n>\n> /  \\      /\n>\n>\n>\n> 1     2  10\n>\n>\n> After repeatedly comparing with the parent nodes and swapping if required, the final heap will be look like this\n>\n>\n>\n> 10\n>\n>\n>\n> /    \\\n>\n>\n>\n> 4      8\n>\n>\n>\n> /  \\     /\n>\n>\n>\n> 1     2 5\n\n### Deletion:\n\n* If we delete the element from the heap it always deletes the root element of the tree and replaces it with the last element of the tree.\n* Since we delete the root element from the heap it will distort the properties of the heap so we need to perform heapify operations so that it maintains the property of the heap.\n\n\nIt takes\n\n****O(log n)****\ntime.\n\n\n****Example:****\n\n> Assume initially heap(taking max-heap) is as follows\n>\n>\n>\n> 15\n>\n>\n>\n> /   \\\n>\n>\n>\n> 5     7\n>\n>\n>\n> /  \\\n>\n>\n>\n> 2     3\n>\n>\n> Now if we delete 15 into the heap it will be replaced by leaf node of the tree for temporary.\n>\n>\n>\n> 3\n>\n>\n>\n> /   \\\n>\n>\n>\n> 5     7\n>\n>\n>\n> /\n>\n>\n>\n> 2\n>\n>\n> After heapify operation final heap will be look like this\n>\n>\n>\n> 7\n>\n>\n>\n> /   \\\n>\n>\n>\n> 5     3\n>\n>\n>\n> /\n>\n>\n>\n> 2\n\n### getMax (For max-heap) or getMin (For min-heap):\n\n\nIt finds the maximum element or minimum element for\n\n****max-heap****\nand\n\n****min-heap****\nrespectively and as we know minimum and maximum elements will always be the root node itself for min-heap and max-heap respectively. It takes\n\n****O(1)****\ntime.\n\n\n### removeMin or removeMax:\n\n\nThis operation returns and deletes the maximum element and minimum element from the max-heap and min-heap respectively. In short, it deletes the root element of the heap binary tree.\n\n\nImplementation of Heap Data Structure:-\n\n\nThe following code shows the implementation of a\n\n****max-heap****\n.\n\n\nLet\u2019s understand the\n\n****maxHeapify****\nfunction in detail:-\n\n\n****maxHeapify****\nis the function responsible for restoring the property of the Max Heap. It arranges the node\n\n****i****\n, and its subtrees accordingly so that the heap property is maintained.\n\n\n1. Suppose we are given an array,\n\n   ****arr[]****\n   representing the complete binary tree. The left and the right child of\n\n   ****i****\n   ****th****\n   node are in indices\n\n   ****2\\*i+1****\n   and\n\n   ****2\\*i+2****\n   .\n2. We set the index of the current element,\n\n   ****i****\n   , as the \u2018MAXIMUM\u2019.\n3. If\n\n   ****arr[2 \\* i + 1] > arr[i]****\n   , i.e., the left child is larger than the current value, it is set as \u2018MAXIMUM\u2019.\n4. Similarly if\n\n   ****arr[2 \\* i + 2] > arr[i]****\n   , i.e., the right child is larger than the current value, it is set as \u2018MAXIMUM\u2019.\n5. Swap the \u2018MAXIMUM\u2019 with the current element.\n6. Repeat steps\n\n   ****2 to 5****\n   till the property of the heap is restored.\n\n\n\n\n\n",
        "metadata": {
            "lesson_name": "Introduction to Heap \u2013 Data Structure and Algorithm Tutorials",
            "course_name": "Introduction to DSA II"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Program to print multiplication table of a number\n\nContent:\nGiven a number\n\n****n****\n, we need to print its table.\n\n\n****Examples :****\n\n\n> ****Input****\n> : 5\n>\n>\n>\n> ****Output****\n> :\n>\n>\n>\n> 5 \\* 1 = 5\n>\n>\n>\n> 5 \\* 2 = 10\n>\n>\n>\n> 5 \\* 3 = 15\n>\n>\n>\n> 5 \\* 4 = 20\n>\n>\n>\n> 5 \\* 5 = 25\n>\n>\n>\n> 5 \\* 6 = 30\n>\n>\n>\n> 5 \\* 7 = 35\n>\n>\n>\n> 5 \\* 8 = 40\n>\n>\n>\n> 5 \\* 9 = 45\n>\n>\n>\n> 5 \\* 10 = 50\n\nTable of Content\n\n* [Iterative Approach \u2013 O(1) Time and O(1) Space](#using-a-loop-o1-time-and-o1-space)\n* [Recursive Approach \u2013 O(1) Time and O(1) Space](#using-recursion-o1-space-and-o1-time)\n### Iterative Approach \u2013 O(1) Time and O(1) Space\n\n\n\n\n\n\n### ****Recursive Approach \u2013 O(1) Time and O(1) Space****\n\n\n\n\n\n\n\n****Time Complexity:****\nO(1)\n\n\n\n****Auxiliary Space:****\nO(1), since the recursion stack will only go up to 10.\n\n",
        "metadata": {
            "lesson_name": "Program to print multiplication table of a number",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Check whether a given number is even or odd\n\nContent:\nGiven a number\n\n****n****\n, check whether it is even or odd. Return\n\n****true****\nfor even and\n\n****false****\nfor odd.\n\n\n****Examples:****\n\n\n> ****Input****\n> : 2\n>\n>\n>\n> ****Output****\n> : true\n>\n>\n> ****Input****\n> : 5\n>\n>\n>\n> ****Output****\n> : false\n\nTable of Content\n\n* [By Finding the Remainder \u2013 O(1) Time and O(1) Space](#by-finding-the-reminder-o1-time-and-o1-space)\n* [Using Bitwise AND Operator \u2013 O(1) Time and O(1) Space](#using-bitwaise-operators-o1-time-and-o1-space)\n* [Using Bitwise Shift Operators \u2013 O(1) Time and O(1) Space](#using-bitwaise-shift-operators-o1-time-and-o1-space)\n### By Finding the Remainder \u2013 O(1) Time and O(1) Space\n\n\nWe can check the remainder when divided by 2. If the remainder is 0, the number is even; otherwise, it is odd\n\n\n\n\n\n\n### Using Bitwise AND Operator \u2013 O(1) Time and O(1) Space\n\n> The last bit of all odd numbers is always 1, while for even numbers it\u2019s 0. So, when performing bitwise AND operation with 1, odd numbers give 1, and even numbers give 0.\n>\n>\n> Ex: 5 (101) -> 101\n>\n>\n>\n> & 001\n>\n>\n>\n> \u2014-\n>\n>\n>\n> 001 , so this we can say it is an odd number.\n\n\n\n\n\n\n\n\n****Time Complexity: O(1)****\n\n\n****Auxiliary Space: O(1)****\n\n### Using Bitwise Shift Operators \u2013 O(1) Time and O(1) Space\n\n![](\nC++\n\n\n\n\n\n\n",
        "metadata": {
            "lesson_name": "Check whether a given number is even or odd",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA II\nLesson Name: What is Priority Queue | Introduction to Priority Queue\n\nContent:\n****Properties of Priority Queue****\n\n*****So, a priority Queue is an extension of the*****\n[*****queue*****](\n*****with the following properties.*****\n\n* Every item has a priority associated with it.\n* An element with high priority is dequeued before an element with low priority.\n* If two elements have the same priority, they are served according to their order in the queue.\n\n\nIn the below priority queue, an element with a maximum ASCII value will have the highest priority. The elements with higher priority are served first.\n\n\n![](\n\n****How is Priority assigned to the elements in a Priority Queue?****\n\n\nIn a priority queue, generally, the value of an element is considered for assigning the priority.\n\n\nFor example, the element with the highest value is assigned the highest priority and the element with the lowest value is assigned the lowest priority. The reverse case can also be used i.e., the element with the lowest value can be assigned the highest priority. Also, the priority can be assigned according to our needs.\n\n\n****Operations of a Priority Queue:****\n\n\nA typical priority queue supports the following operations:\n\n\n### ****1) Insertion in a Priority Queue****\n\n\nWhen a new element is inserted in a priority queue, it moves to the empty slot from top to bottom and left to right. However, if the element is not in the correct place then it will be compared with the parent node. If the element is not in the correct order, the elements are swapped. The swapping process continues until all the elements are placed in the correct position.\n\n\n### ****2) Deletion in a Priority Queue****\n\n\nAs you know that in a max heap, the maximum element is the root node. And it will remove the element which has maximum priority first. Thus, you remove the root node from the queue. This removal creates an empty slot, which will be further filled with new insertion. Then, it compares the newly inserted element with all the elements inside the queue to maintain the heap invariant.\n\n\n### ****3) Peek in a Priority Queue****\n\n\nThis operation helps to return the maximum element from Max Heap or the minimum element from Min Heap without deleting the node from the priority queue.\n\n\nTypes of Priority Queue:\n\n### ****1) Ascending Order Priority Queue****\n\n\nAs the name suggests, in ascending order priority queue, the element with a lower priority value is given a higher priority in the priority list. For example, if we have the following elements in a priority queue arranged in ascending order like 4,6,8,9,10. Here, 4 is the smallest number, therefore, it will get the highest priority in a priority queue and so when we dequeue from this type of priority queue, 4 will remove from the queue and dequeue returns 4.\n\n\n### ****2) Descending order Priority Queue****\n\n\nThe root node is the maximum element in a max heap, as you may know. It will also remove the element with the highest priority first. As a result, the root node is removed from the queue. This deletion leaves an empty space, which will be filled with fresh insertions in the future. The heap invariant is then maintained by comparing the newly inserted element to all other entries in the queue.\n\n\n![Types of Priority Queues](\n\nTypes of Priority Queues\n\n****Difference between Priority Queue and Normal Queue?****\n\n\nThere is no priority attached to elements in a queue, the rule of first-in-first-out(FIFO) is implemented whereas, in a priority queue, the elements have a priority. The elements with higher priority are served first.\n\n\n****How to Implement Priority Queue?****\n\n\nPriority queue can be implemented using the following data structures:\n\n\n* Arrays\n* Linked list\n* Heap data structure\n* Binary search tree\n\n****Let\u2019s discuss all these in detail.****\n\n### ****1) Implement Priority Queue Using Array:****\n\n\nA simple implementation is to use an array of the following structure.\n\n\n> struct item {\n>\n>\n>\n> int item;\n>\n>\n>\n> int priority;\n>\n>\n>\n> }\n\n* ****enqueue():****\n  This function is used to insert new data into the queue.\n* ****dequeue():****\n  This function removes the element with the highest priority from the queue.\n* ****peek()/top():****\n  This function is used to get the highest priority element in the queue without removing it from the queue.\n\n\n\n\n\n\n> ****Note:****\n> Read\n>\n> [****this article****](\n>\n> for more details.\n\n### ****2) Implement Priority Queue Using Linked List:****\n\n\nIn a LinkedList implementation, the entries are sorted in descending order based on their priority. The highest priority element is always added to the front of the priority queue, which is formed using linked lists. The functions like\n\n****push()****\n,\n\n****pop()****\n, and\n\n****peek()****\nare used to implement a priority queue using a linked list and are explained as follows:\n\n\n* ****push():****\n  This function is used to insert new data into the queue.\n* ****pop():****\n  This function removes the element with the highest priority from the queue.\n* ****peek() / top():****\n  This function is used to get the highest priority element in the queue without removing it from the queue.\n\n\n\n\n\n\n\n\nRefer to\n\n[this article](\nfor more details.\n\n\n> ****Note:****\n> We can also use Linked List, time complexity of all operations with linked list remains same as array. The advantage with linked list is\n>\n>\n> deleteHighestPriority()\n>\n>\n> can be more efficient as we don\u2019t have to move items.\n\n### ****3) Implement Priority Queue Using Heaps:****\n\n\nBinary Heap is generally preferred for priority queue implementation because heaps provide better performance compared to arrays or LinkedList. Considering the properties of a heap, The entry with the largest key is on the top and can be removed immediately. It will, however, take time O(log n) to restore the heap property for the remaining keys. However if another entry is to be inserted immediately, then some of this time may be combined with the O(log n) time needed to insert the new entry. Thus the representation of a priority queue as a heap proves advantageous for large n, since it is represented efficiently in contiguous storage and is guaranteed to require only logarithmic time for both insertions and deletions. Operations on Binary Heap are as follows:\n\n\n* ****insert(p):****\n  Inserts a new element with priority p.\n* ****extractMax():****\n  Extracts an element with maximum priority.\n* ****remove(i):****\n  Removes an element pointed by an iterator i.\n* ****getMax():****\n  Returns an element with maximum priority.\n* ****changePriority(i, p):****\n  Changes the priority of an element pointed by\n\n  ****i to p****\n  .\n\n> Refer to\n>\n> [this article](\n> for code implementation.\n\n### ****4) Implement Priority Queue Using Binary Search Tree:****\n\n\nA Self-Balancing Binary Search Tree like AVL Tree, Red-Black Tree, etc. can also be used to implement a priority queue. Operations like peek(), insert() and delete() can be performed using BST.\n\n\n****Applications of Priority Queue:****\n\n* CPU Scheduling\n* Graph algorithms like\n\n  [Dijkstra\u2019s shortest path algorithm](\n  ,\n\n  [Prim\u2019s Minimum Spanning Tree](\n  , etc.\n* All\n\n  [queue applications](\n  where priority is involved.\n* Data compression in Huffman code\n* Event-driven simulation such as customers waiting in a queue.\n* Finding Kth largest/smallest element.\n\n****Advantages of Priority Queue:****\n\n* It helps to access the elements in a faster way. This is because elements in a priority queue are ordered by priority, one can easily retrieve the highest priority element without having to search through the entire queue.\n* The ordering of elements in a Priority Queue is done dynamically. Elements in a priority queue can have their priority values updated, which allows the queue to dynamically reorder itself as priorities change.\n* Efficient algorithms can be implemented. Priority queues are used in many algorithms to improve their efficiency, such as Dijkstra\u2019s algorithm for finding the shortest path in a graph and the A\\* search algorithm for pathfinding.\n* Included in real-time systems. This is because priority queues allow you to quickly retrieve the highest priority element, they are often used in real-time systems where time is of the essence.\n\n****Disadvantages of Priority Queue:****\n\n* High complexity. Priority queues are more complex than simple data structures like arrays and linked lists, and may be more difficult to implement and maintain.\n* High consumption of memory. Storing the priority value for each element in a priority queue can take up additional memory, which may be a concern in systems with limited resources.\n* It is not always the most efficient data structure. In some cases, other data structures like heaps or binary search trees may be more efficient for certain operations, such as finding the minimum or maximum element in the queue.\n* At times it is less predictable:. This is because the order of elements in a priority queue is determined by their priority values, the order in which elements are retrieved may be less predictable than with other data structures like stacks or queues, which follow a first-in, first-out (FIFO) or last-in, first-out (LIFO) order.\n",
        "metadata": {
            "lesson_name": "What is Priority Queue | Introduction to Priority Queue",
            "course_name": "Introduction to DSA II"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA II\nLesson Name: Recursive Functions\n\nContent:\nNeed of Recursive Function:\n\n\nA recursive function is a function that solves a problem by solving smaller instances of the same problem. This technique is often used in programming to solve problems that can be broken down into simpler, similar subproblems.\n\n\n### 1. ****Solving complex tasks:****\n\n\nRecursive functions break complex problems into smaller instances of the same problem, resulting in compact and readable code.\n\n\n### 2. Divide and Conquer:\n\n\nRecursive functions are suitable for divide-and-conquer algorithms such as merge sort and quicksort, breaking problems into smaller subproblems, solving them recursively, and merging the solutions with the original problem.\n\n\n### 3. ****Backtracking**** :\n\n\nRecursive backtracking is ideal for exploring and solving problems like N-Queens and Sudoku.\n\n\n\n### 4. Dynamic ****programming:****\n\n\nRecursive functions efficiently solve dynamic programming problems by solving subproblems and combining their solutions into a complete solution.\n\n\n### 5. Tree and ****graph structures:****\n\n\nRecursive functions are great for working with tree and graph structures, simplifying traversal and pattern recognition tasks\n\n****.****\n\nHow to write a Recursive Function:\n\n### Components of a recursive function:\n\n****Base case:****\nEvery recursive function must have a base case. The base case is the simplest scenario that does not require further recursion. This is a termination condition that prevents the function from calling itself indefinitely. Without a proper base case, a recursive function can lead to infinite recursion.\n\n\n****Recursive case:****\nIn the recursive case, the function calls itself with the modified arguments. This is the essence of recursion \u2013 solving a larger problem by breaking it down into smaller instances of the same problem. The recursive case should move closer to the base case with each iteration.\n\n\nLet\u2019s consider the example of\n\n[factorial of number](\n:\n\n\nIn this example, the base case is when\n\n****n****\nis\n\n****0****\n, and the function returns\n\n****1****\n. The recursive case multiplies\n\n****n****\nwith the result of the function called with parameter\n\n****n \u2013 1****\n. The process continues until the base case is reached.\n\n\nIt\u2019s essential to ensure that the recursive function has a correct base case and that the recursive calls lead to the base case, otherwise, the procedure might run indefinitely, leading to a stack overflow (exceeding the available memory allocated for function calls).\n\n\n\n\n\n\n\n****Time Complexity:****\nO(n)\n\n\n\n****Auxiliary Space:****\nO(n)\n\n",
        "metadata": {
            "lesson_name": "Recursive Functions",
            "course_name": "Introduction to DSA II"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Factorial Coding Problems\n\nContent:\n\n[Factorial](\nof a number\n\n****n****\nis defined as the product of all the\n\n****positive****\nnumbers less than n. In other words, Factorial of a number\n\n****n****\ncan be calculated as:\n\n****n \u00d7 (n \u2013 1) \u00d7 (n \u2013 2) \u00d7 \u2026 \u00d7 1.****\nFactorial of a number n is denoted as\n\n****n!****\n. It is widely used in Combinatorics and Algebra to find the number of ways to arrange or select items.\n\n\n****Examples:****\n\n> ****0!****\n> = 1\n>\n>\n> ****1!****\n> = 1\n>\n>\n> ****3!****\n> = 3 x 2 x 1 = 6\n\n\nHere is a list of problems based on Factorial.\n\n\n* [Factorial of a Number](\n* [Check Factorial](\n* [Factorial of Large number](\n* [Count trailing zeroes](\n* [Sum of Digits](\n* [Double Factorial](\n* [Last Non-Zero digit](\n* [Check Strong Number](\n* [Factorial without Multiplication](\n* [Length of factorial](\n* [Sum of Factorials till N (1! + 2! + 3! + \u2026 + N!)](\n* [Smallest number at least n trailing zeroes](\n* [Factorial of an Array](\n* [K-th Prime Factor](\n* [nCr](\n* [Ways to go from one point to another](\n* [Check Krishnamurthy Number](\n* [nCr using Fermat Little Theorem](\n* [Ways to arrange K different objects](\n\n> Recommended Links\n>\n>\n> * [Factorial Formula](\n> * [Interesting Facts about Factorial](\n",
        "metadata": {
            "lesson_name": "Factorial Coding Problems",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Prime Number Coding Problems\n\nContent:\n\n[Prime Numbers](\nare natural numbers greater than 1 and can be divided by itself and 1 only. For instance, numbers 2, 3, 5, 7, and 11 are the prime numbers since they can only be divided by 1 and themselves, there is no other number that can fully divide them Since it is manually very difficult to check if a number is prime (no direct formula) and find prime factors, problems related to prime become really interesting coding problems.\n\n\nHere is a list of example problems based on prime.\n\n\n* [Check for Prime Number](\n* [All Prime Factors](\n* [Largest Prime Factor](\n* [Check for Co-Prime](\n* [Primes in an Array](\n* [Primes with Given Sum](\n* [Pair of Primes with Given Sum and Min Diff](\n* [Prime Number Gap](\n* [Find the next prime](\n* [Check for Strong Prime](\n* [Closest Prime](\n* [N Digit Numbers with Prime Digits](\n* [Sieve of Eratosthenes](\n* [Nth Prime Number](\n* [Program to print prime numbers from 1 to N.](\n* [Segmented Sieve](",
        "metadata": {
            "lesson_name": "Prime Number Coding Problems",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Mathematical Algorithms (Difficulty Wise)\n\nContent:\n\n### ****Mathematical Concepts:****\n\n* [Numbers](\n* [Prime Numbers](\n* [Arithmetic Progression](\n* [Geometric Progression](\n* [GCD](\n  and\n\n  [LCM](\n* [Factorial](\n* [Permutation](\n  and\n\n  [Combination](\n* [Catalan Number](\n* [Modular Arithmetic](\n\n### ****Basic Problems****\n\n* [Sum of Naturals](\n* [Sum of Squares of Naturals](\n* [Nth Term of AP](\n* [Nth Term of GP](\n* [Nth Triangular Number](\n* [Sum of Sums of Natural Numbers](\n* [Count Digits](\n* [Sum of Digits](\n* [Reverse Digits](\n* [K-th Digit in a^b](\n* [Palindrome Number](\n* [GCD of Two Numbers](\n* [LCM of Two Numbers](\n* [Add two fractions](\n* [Check for Co-Prime](\n* [Factorial of a Number](\n* [GCD of more than 2](\n* [LCM of more than 2](\n* [Padovan Sequence](\n\n### ****Easy Problems****\n\n* [Pair Cube Count](\n* [Sum of 2, 22, 222, \u2026\u2026\u2026](\n* [Sum of 1^2 + 3^2 + 5^2 + . . . + (2\\*n \u2013 1)^2](\n* [Sum of 0.6, 0.06, 0.006, 0.0006, \u2026to n terms](\n* [n-th term of 2, 12, 36, 80, 150\u2026.](\n* [Digit Root](\n* [Fibonacci Numbers](\n* [Lucas Number](\n* [Check for Power](\n* [Three Divisors](\n* [Square Root](\n* [Binomial Coefficient](\n* [Pascal Triangle](\n* [nth Row of the Pascal Triangle](\n* [Armstrong Numbers](\n* [Determinant of a Matrix](\n* [Modular Exponentiation](\n* [Check for Perfect Squares](\n* [Divisibility by 3](\n* [Divisibility by 4](\n* [Divisibility by 7](\n* [Divisibility by 11](\n* [Divisibility by 13](\n* [Divisibility by 29](\n\n### ****Medium Problems****\n\n* [Linear Diophantine Equations](\n* [Euler's Totient Function](\n* [Sieve of Eratosthenes](\n* [All Divisors](\n* [Prime Factorization](\n* [Largest Prime Factor](\n* [Factorial of a Large Number](\n* [Largest Power Divisible in Factorial](\n* [Last Non-zero Digit of Factorial](\n* [Power Set](\n* [Add Two Polynomials](\n* [All Permutations of a String](\n* [Next Permutation](\n* [Check for Carmichael Numbers](\n* [Collatz sequence](\n* [Grid Unique Paths](\n* [Nth Even Fibonacci Number](\n* [Last 2 Digits of Nth Fibonacci](\n\n### ****Hard Problems****\n\n* [Josephus Problem](\n* [Water Jug Tutorial](\n* [Segmented Sieve](\n* [k-th prime factor](\n* [N-th Root](\n* [Sum of Digits in Factorial](\n* [Egg Dropping](\n* [Next String](",
        "metadata": {
            "lesson_name": "Mathematical Algorithms (Difficulty Wise)",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Find Recurring Sequence in a Fraction\n\nContent:\n\nGiven a fraction, find a recurring sequence of digits if it exists, otherwise, print \u201cNo recurring sequence\u201d.\n\n// C++ program to find repeating\n// sequence in a fraction\n#include <bits/stdc++.h>\nusing namespace std;\n\n// This function returns repeating sequence of\n// a fraction.  If repeating sequence doesn't\n// exist, then returns empty string\nstring fractionToDecimal( int numr, int denr)\n{\nstring res; // Initialize result\n\n// Create a map to store already\n// seen remainders, remainder is used\n// as key and its position in\n// result is stored as value.\n// Note that we need\n// position for cases like 1/6.\n// In this case,the recurring sequence\n// doesn't start from first\n// remainder.\nmap< int , int > mp;\nmp.clear();\n\n// Find first remainder\nint rem = numr % denr;\n\n// Keep finding remainder until either remainder\n// becomes 0 or repeats\nwhile ((rem != 0)\n&& (mp.find(rem) == mp.end()))\n{\n// Store this remainder\nmp[rem] = res.length();\n\n// Multiply remainder with 10\nrem = rem * 10;\n\n// Append rem / denr to result\nint res_part = rem / denr;\nres += to_string(res_part);\n\n// Update remainder\nrem = rem % denr;\n}\n\nreturn (rem == 0) ? \"\" : res.substr(mp[rem]);\n}\n\n// Driver code\nint main()\n{\nint numr = 50, denr = 22;\nstring res = fractionToDecimal(numr, denr);\nif (res == \"\" )\ncout << \"No recurring sequence\" ;\nelse\ncout << \"Recurring sequence is \" << res;\nreturn 0;\n}\n```\n\n\n\n\n\n\n**Time Complexity : O(N)**\n\n**Auxiliary Space : O(N) ,**\n                                                                                                                                        as we use map as extra space.\n                                                                                                                                        ",
        "metadata": {
            "lesson_name": "Find Recurring Sequence in a Fraction",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA II\nLesson Name: Introduction to Divide and Conquer Algorithm\n\nContent:\nTable of Content\n\n                                                                                                                                        * [Divide and Conquer Algorithm Definition](#divide-and-conquer-algorithm-definition)\n                                                                                                                                        * [Working of Divide and Conquer Algorithm](#working-of-divide-and-conquer-algorithm)\n                                                                                                                                        * [Characteristics of Divide and Conquer Algorithm](#characteristics-of-divide-and-conquer-algorithm)\n                                                                                                                                        * [Examples of Divide and Conquer Algorithm](#examples-of-divide-and-conquer-algorithm)\n                                                                                                                                        * [Complexity Analysis of Divide and Conquer Algorithm](#complexity-analysis-of-divide-and-conquer-algorithm)\n                                                                                                                                        * [Applications of Divide and Conquer Algorithm](#applications-of-divide-and-conquer-algorithm)\n                                                                                                                                        * [Advantages of Divide and Conquer Algorithm](#advantages-of-divide-and-conquer-algorithm)\n                                                                                                                                        * [Disadvantages of Divide and Conquer Algorithm](#disadvantages-of-divide-and-conquer-algorithm)\n\n                                                                                                                                        ****Divide and Conquer****\n\n                                                                                                                                        Algorithm Definition:\n\n                                                                                                                                        > ****Divide and Conquer Algorithm****\n                                                                                                                                        > involves breaking a larger problem into smaller subproblems, solving them independently, and then combining their solutions to solve the original problem. The basic idea is to recursively divide the problem into smaller subproblems until they become simple enough to be solved directly. Once the solutions to the subproblems are obtained, they are then combined to produce the overall solution.\n\nWorking of Divide and Conquer Algorithm:\n\n\nDivide and Conquer Algorithm can be divided into three steps:\n\n****Divide****\n                                                                                                                                       ,\n\n                                                                                                                                    ****Conquer****\n                                                                                                                                        and\n\n                                                                                                                                    ****Merge****\n                                                                                                                                        .\n\n\n![Working-of-Divide-and-Conquer-Algorithm](\n\n### ****1. Divide:****\n\n* Break down the original problem into smaller subproblems.\n* Each subproblem should represent a part of the overall problem.\n* The goal is to divide the problem until no further division is possible.\n\n### ****2. Conquer:****\n\n* Solve each of the smaller subproblems individually.\n* If a subproblem is small enough (often referred to as the \u201cbase case\u201d), we solve it directly without further recursion.\n* The goal is to find solutions for these subproblems independently.\n\n### 3. Merge:\n\n* Combine the sub-problems to get the final solution of the whole problem.\n* Once the smaller subproblems are solved, we recursively combine their solutions to get the solution of larger problem.\n* The goal is to formulate a solution for the original problem by merging the results from the subproblems.\n\nCharacteristics of Divide and Conquer Algorithm:\n\n\nDivide and Conquer Algorithm involves breaking down a problem into smaller, more manageable parts, solving each part individually, and then combining the solutions to solve the original problem. The characteristics of Divide and Conquer Algorithm are:\n\n\n\n                                                                                                                                    * ****Dividing the Problem****\n                                                                                                                                    : The first step is to break the problem into smaller, more manageable subproblems. This division can be done recursively until the subproblems become simple enough to solve directly.\n* ****Independence of Subproblems****\n  : Each subproblem should be independent of the others, meaning that solving one subproblem does not depend on the solution of another. This allows for parallel processing or concurrent execution of subproblems, which can lead to efficiency gains.\n* ****Conquering Each Subproblem****\n  : Once divided, the subproblems are solved individually. This may involve applying the same divide and conquer approach recursively until the subproblems become simple enough to solve directly, or it may involve applying a different algorithm or technique.\n                                                                                                                                    * ****Combining Solutions****\n                                                                                                                                    : After solving the subproblems, their solutions are combined to obtain the solution to the original problem. This combination step should be relatively efficient and straightforward, as the solutions to the subproblems should be designed to fit together seamlessly.\n\n                                                                                                                                    ****Examples of Divide and Conquer Algorithm:****\n\n                                                                                                                                    ### ****1. Finding the maximum element in the array:****\n\n\n                                                                                                                                    We can use Divide and Conquer Algorithm to find the maximum element in the array by dividing the array into two equal sized subarrays, finding the maximum of those two individual halves by again dividing them into two smaller halves. This is done till we reach subarrays of size 1. After reaching the elements, we return the maximum element and combine the subarrays by returning the maximum in each subarray.\n\n\n\n\n\n\n### ****2. Finding the minimum element in the array:****\n\n\nSimilarly, we can use Divide and Conquer Algorithm to find the minimum element in the array by dividing the array into two equal sized subarrays, finding the minimum of those two individual halves by again dividing them into two smaller halves. This is done till we reach subarrays of size 1. After reaching the elements, we return the minimum element and combine the subarrays by returning the minimum in each subarray.\n\n\n### 3. [Merge Sort:](\n\n\nWe can use Divide and Conquer Algorithm to sort the array in ascending or descending order by dividing the array into smaller subarrays, sorting the smaller subarrays and then merging the sorted arrays to sort the original array.\n\n\nComplexity Analysis of Divide and Conquer Algorithm:\n\n> T(n) = aT(n/b) + f(n), where\n> n = size of input\n> a = number of subproblems in the recursion\n> n/b = size of each subproblem. All subproblems are assumed to have the same size.\n> f(n) = cost of the work done outside the recursive call, which includes the cost of dividing the problem and cost of merging the solutions\n\nApplications of Divide and Conquer Algorithm:\n\n\nThe following are some standard algorithms that follow Divide and Conquer algorithm:\n\n\n* [****Quicksort****](\n  is a sorting algorithm that picks a pivot element and rearranges the array elements so that all elements smaller than the picked pivot element move to the left side of the pivot, and all greater elements move to the right side. Finally, the algorithm recursively sorts the subarrays on the left and right of the pivot element.\n* [****Merge Sort****](\n  is also a sorting algorithm. The algorithm divides the array into two halves, recursively sorts them, and finally merges the two sorted halves.\n* [****Closest Pair of Points****](\n  The problem is to find the closest pair of points in a set of points in the x-y plane. The problem can be solved in O(n^2) time by calculating the distances of every pair of points and comparing the distances to find the minimum. The Divide and Conquer algorithm solves the problem in O(N log N) time.\n* [****Strassen\u2019s Algorithm****](\n  is an efficient algorithm to multiply two matrices. A simple method to multiply two matrices needs 3 nested loops and is O(n^3). Strassen\u2019s algorithm multiplies two matrices in O(n^2.8974) time.\n* [****Cooley\u2013Tukey Fast Fourier Transform (FFT) algorithm****](\n  is the most common algorithm for FFT. It is a divide and conquer algorithm which works in O(N log N) time.\n* [****Karatsuba algorithm for fast multiplication****](\n  does the multiplication of two binary strings in O(n\n\n  1.59\n  ) where n is the length of binary string.\n\n****Advantages of Divide and Conquer Algorithm:****\n\n* ****Solving difficult problems:****\n  Divide and conquer technique is a tool for solving difficult problems conceptually. e.g. Tower of Hanoi puzzle. It requires a way of breaking the problem into sub-problems, and solving all of them as an individual cases and then combining sub- problems to the original problem.\n* ****Algorithm efficiency:****\n  The divide-and-conquer algorithm often helps in the discovery of efficient algorithms. It is the key to algorithms like Quick Sort and Merge Sort, and fast Fourier transforms.\n* ****Parallelism:****\n  Normally Divide and Conquer algorithms are used in multi-processor machines having shared-memory systems where the communication of data between processors does not need to be planned in advance, because distinct sub-problems can be executed on different processors.\n* ****Memory access:****\n  These algorithms naturally make an efficient use of memory caches. Since the subproblems are small enough to be solved in cache without using the main memory that is slower one. Any algorithm that uses cache efficiently is called cache oblivious.\n\n****Disadvantages of Divide and Conquer Algorithm:****\n\n* ****Overhead:****\n  The process of dividing the problem into subproblems and then combining the solutions can require additional time and resources. This overhead can be significant for problems that are already relatively small or that have a simple solution.\n* ****Complexity:****\n  Dividing a problem into smaller subproblems can increase the complexity of the overall solution. This is particularly true when the subproblems are interdependent and must be solved in a specific order.\n* ****Difficulty of implementation:****\n  Some problems are difficult to divide into smaller subproblems or require a complex algorithm to do so. In these cases, it can be challenging to implement a divide and conquer solution.\n* ****Memory limitations:****\n  When working with large data sets, the memory requirements for storing the intermediate results of the subproblems can become a limiting factor.\n\nFrequently Asked Questions (FAQs) on Divide and Conquer Algorithm:\n\n### ****1. What is the Divide and Conquer algorithm?****\n\n> Divide and Conquer is a problem-solving technique where a problem is divided into smaller, more manageable subproblems. These subproblems are solved recursively, and then their solutions are combined to solve the original problem.\n\n### ****2. What are the key steps involved in the Divide and Conquer algorithm?****\n\n> The main steps are:\n>\n>\n> ****Divide****\n> : Break the problem into smaller subproblems.\n>\n>\n> ****Conquer****\n> : Solve the subproblems recursively.\n>\n>\n> ****Combine****\n> : Merge or combine the solutions of the subproblems to obtain the solution to the original problem.\n\n### ****3. What are some examples of problems solved using Divide and Conquer?****\n\n> Divide and Conquer Algorithm is used in sorting algorithms like Merge Sort and Quick Sort, finding closest pair of points, Strassen\u2019s Algorithm, etc.\n\n### ****4. How does Merge Sort use the Divide and Conquer approach?****\n\n> Merge Sort divides the array into two halves, recursively sorts each half, and then merges the sorted halves to produce the final sorted array.\n\n### ****5. What is the time complexity of Divide and Conquer algorithms?****\n\n> The time complexity varies depending on the specific problem and how it\u2019s implemented. Generally, many Divide and Conquer algorithms have a time complexity of O(n log n) or better.\n\n### ****6. Can Divide and Conquer algorithms be parallelized?****\n\n> Yes, Divide and Conquer algorithms are often naturally parallelizable because independent subproblems can be solved concurrently. This makes them suitable for parallel computing environments.\n\n### ****7. What are some strategies for choosing the base case in Divide and Conquer algorithms?****\n\n> The base case should be simple enough to solve directly, without further division. It\u2019s often chosen based on the smallest input size where the problem can be solved trivially.\n\n### ****8. Are there any drawbacks or limitations to using Divide and Conquer?****\n\n> While Divide and Conquer can lead to efficient solutions for many problems, it may not be suitable for all problem types. Overhead from recursion and combining solutions can also be a concern for very large problem sizes.\n\n### ****9. How do you analyze the space complexity of Divide and Conquer algorithms?****\n\n> Space complexity depends on factors like the recursion depth and auxiliary space required for combining solutions. Analyzing space complexity typically involves considering the space used by each recursive call.\n\n### ****10. What are some common advantages of Divide and Conquer Algorithm?****\n\n> Divide and Conquer Algorithm has numerous advantages. Some of them include:\n>\n>\n> * Solving difficult problems\n> * Algorithm efficiency\n> * Parallelism\n> * Memory access\n\n\nDivide and Conquer is a popular algorithmic technique in computer science that involves breaking down a problem into smaller sub-problems, solving each sub-problem independently, and then combining the solutions to the sub-problems to solve the original problem. The basic idea behind this technique is to divide a problem into smaller, more manageable sub-problems that can be solved more easily.\n\n",
        "metadata": {
            "lesson_name": "Introduction to Divide and Conquer Algorithm",
            "course_name": "Introduction to DSA II"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA II\nLesson Name: Introduction to Linked List \u2013 Data Structure and Algorithm Tutorials\n\nContent:\nBasic Terminologies of Linked List\n\n* ****Head:****\n  The Head of a linked list is a pointer to the first node or reference of the first node of linked list. This pointer marks the beginning of the linked list.\n* ****Node:****\n  Linked List consists of a series of nodes where each node has two parts:\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ****data****\n                                              and\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ****next pointer****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           .\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Data:****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Data is the part of node which stores the information in the linked list.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Next pointer:****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Next pointer is the part of the node which points to the next node of the linked list.\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Importance of Linked List\n\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Here are a few advantages of a linked list that is listed below, it will help you understand why it is necessary to know.\n\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Dynamic Data structure:****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The size of memory can be allocated or de-allocated at run time based on the operation insertion or deletion.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Ease of Insertion/Deletion:****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The insertion and deletion of elements are simpler than arrays since no elements need to be shifted after insertion and deletion, Just the address needed to be updated.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Efficient Memory Utilization:****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           As we know Linked List is a dynamic data structure the size increases or decreases as per the requirement so this avoids the wastage of memory.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Implementation:****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Various advanced data structures can be implemented using a linked list like a stack, queue, graph, hash maps, etc.\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Implementations of Basic Operations on Different Types of List\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * [Singly Linked List](\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * [Doubly Linked List](\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * [Circular Linked List](\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ### Basic Operations on Singly Linked List\n\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The following are some basic operations performed on a Single Linked List:\n\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Insertion:****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The insertion operation can be performed in three ways. They are as follows:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           + [Inserting At the Beginning of the list](\n        + [Inserting At End of the list](\n  + [Inserting At Specific location in the list](\n* ****Deletion:****\n  The deletion operation can be performed in three ways. They are as follows:\n  + [Deleting from the Beginning of the list](\n  + [Deleting from the End of the list](\n  + [Deleting a Specific Node](\n* [****Traverse****](\n  ****:****\n  This process displays the elements of a Single-linked list.\n* [****Search:****](\n\n  It is a process of determining and retrieving a specific node either from the front, the end or anywhere in the list.\n\n### ****Operations on Doubly Linked List:****\n\n\nIn a doubly linked list, we perform the following operations\u2026\n\n\n* ****Insertion:****\n  The insertion operation can be performed in three ways as follows:\n  + [Inserting At the Beginning of the list](\n  + [Inserting after a given node.](\n  + [Inserting at the end](\n    .\n  + [Inserting before a given node](\n* ****Deletion:****\n  The deletion operation can be performed in three ways as follows\u2026\n  + [Deleting from the Beginning of the list](\n  + [Deleting from the End of the list](\n  + Deleting a Specific Node\n* ****Display:****\n  This process displays the elements of a double-linked list.\n\n### ****Commonly used operations on Circular Linked List:****\n\n\nThe following operations are performed on a Circular Linked List\n\n\n\n* ****Insertion:****\n  The insertion operation can be performed in three ways:\n  + [Insertion in an empty list](\n  + [Insertion at the beginning of the list](\n  + [Insertion at the end of the list](\n  + [Insertion in between the nodes](\n* ****Deletion:****\n  The deletion operation can be performed in three ways:\n  + [Deleting from the Beginning of the list](\n  + [Deleting from the End of the list](\n  + [Deleting a Specific Node](\n* ****Display:****\n  This process displays the elements of a Circular linked list.\n\n[Linked List vs. Array:](\n\nTime Complexity Analysis of Linked List and Array:\n\n\nPlease refer\n\n[Applications, Advantages and Disadvantages of Linked List](\nfor more details\n\n\nFrequently Asked Questions (FAQs) about Linked List:\n\n### 1. What is linked list data structure?\n\n> Linked list are most commonly used to handle dynamic data elements. Linked list consists of nodes and a node consists of two fields one for storing data and other for keeping the reference of next node.\n\n### 2. What is linked list example?\n\n> A linked list can be assumed as a garland that is made up of flowers. Similarly, a linked list is made up of nodes. Every flower in this particular garland is referred to as a node. In addition, each node points to the next node in this list, and it contains data (in this case, the type of flower).\n\n### 3. Why do we need linked list data structure??\n\n> There are some important advantages to using linked lists over other linear data structures. This is unlike arrays, as they are resizable at runtime. Additionally, they can be easily inserted and deleted.\n\n### 4. What are linked lists used for?\n\n> The linked list is a linear data structure that stores data in nodes. these nodes hold both the data and a reference to the next node in the list. Linked are very efficient at adding and removing nodes because of their simple structure.\n\n### 5. What is the difference between array and linked list?\n\n> There are some following differences between them:\n>\n>\n> * Arrays are data structures containing similar data elements, whereas linked lists are non-primitive data structures containing unordered linked elements.\n> * In an array, elements are indexed, but in a linked list nodes are not indexed.\n> * Accessing an element array is fast if we know the position of an element in the array, while in the Linked list it takes linear time so, the Linked list is quite bit slower.\n> * Operations like insertion and deletion in arrays take a lot of time. Whereas, the performance of these operations is faster in Linked lists.\n> * Arrays are of fixed size and their size is static but Linked lists are dynamic and flexible and can expand and shrink their size.\n\n### 6. Why is a linked list preferred over an array?\n\n> Following are the reason that linked lists are preferred over array\n>\n>\n> * Nodes in a linked array, insertions, and deletions can be done at any point in the list at a constant time.\n> * Arrays are of fixed size and their size is static but Linked lists are dynamic and flexible and can expand and shrink their size.\n> * Linked lists provide an efficient way of storing related data and performing basic operations such as insertion, deletion, and updating of information at the cost of extra space required for storing the address.\n> * Insertion and deletion operations in the linked list are faster as compared to the array.\n\n### 7. Which is the best array or linked list?\n\n> There are some advantages and disadvantages to both arrays and linked lists when it comes to storing linear data of similar types.\n>\n>\n> #### Advantages of linked list over arrays:\n>\n> * ****Dynamic size:****\n>   Linked lists are dynamic and flexible and can expand and shrink their size\n> * ****Ease of Insertion/Deletion:****\n>   Insertion and deletion operations in linked list are faster as compared to the array\n>\n> #### ****Disadvantages of linked list over arrays:****\n>\n> * If the array is sorted we can apply binary search to search any element which takes\n>\n>   ****O(log(n))****\n>   time. But even if the linked list is sorted we cannot apply binary search and the complexity of searching elements in the linked list is\n>\n>   ****O(n)****\n>   .\n> * A linked list takes more memory as compared to the array because extra memory space is required for the pointer with each element in the linked list.\n\n### 8. What are the limitations of linked list?\n\n> Following are some limitations of the linked list:\n>\n>\n> * The use of pointers is more in linked lists hence, complex and requires more memory.\n> * Random access is not possible due to dynamic memory allocation.\n> * Traversing is more time-consuming and reverse traversing is not possible in singly linked lists.\n> * Searching for an element is costly and requires\n>\n>   ****O(n)****\n>   time complexity.\n\n### 9. Why insertion/deletion are faster in a linked list?\n\n> If any element is inserted/ deleted from the array, all the other elements after it will be shifted in memory this takes a lot of time whereas manipulation in Linked List is faster because we just need to manipulate the addresses of nodes, so no bit shifting is required in memory, and it will not take that much of time.\n\n### 10. What is the difference between a singly and doubly linked list?\n\n\nFollowing are some\n\n[difference between single and double linked list.](\n\nConclusion:\n\n\nThere are many advantages of the linked list compared to array, despite the fact that they solve the similar problem to arrays, we have also discussed the advantage, disadvantages, and its application, and we concluded the fact that we can use a linked list if we need the dynamic size of storage and list are good for adding and removing items quickly or for tasks that require sequence but are not suitable for querying or search elements in a large collection of data.\n\n\nSo, it becomes important that we should always keep in mind the\n\n****positive****\nand\n\n****negative****\naspects of a\n\n****data structure****\nand how they relate to the problem you are trying to solve.",
        "metadata": {
            "lesson_name": "Introduction to Linked List \u2013 Data Structure and Algorithm Tutorials",
            "course_name": "Introduction to DSA II"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA II\nLesson Name: Introduction to Pattern Searching \u2013 Data Structure and Algorithm Tutorial\n\nContent:\nFeatures of Pattern Searching Algorithm:\n\n* Pattern searching algorithms should recognize familiar patterns quickly and accurately.\n* Recognize and classify unfamiliar patterns.\n* Identify patterns even when partly hidden.\n* Recognize patterns quickly with ease, and with automaticity.\n\n[Naive Pattern Searching algorithm](\n\n\nNaive pattern searching is the simplest method among other pattern-searching algorithms. It checks for all characters of the main string to the pattern. This algorithm is helpful for smaller texts. It does not need any pre-processing phases. We can find the substring by checking once for the string. It also does not occupy extra space to perform the operation.\n\n\n![Compare text characters with pattern characters](\n\nCompare text characters with pattern characters\n\n\nThe time complexity of Naive Pattern Search method is O(m\\*n). The m is the size of pattern and n is the size of the main string.\n\n\n\n\n\n\n\n****Time Complexity:****\nO(N\\*M)\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n[KMP algorithm](\n\n\nKMP algorithm is used to find a \u201cPattern\u201d in a \u201cText\u201d. This algorithm compares character by character from left to right. But whenever a mismatch occurs, it uses a preprocessed table called \u201cPrefix Table\u201d to skip characters comparison while matching. Sometimes prefix table is also known as LPS Table. Here LPS stands for \u201cLongest proper Prefix which is also Suffix\u201d.\n\n\n### How to use LPS Table\n\n\nWe use the LPS table to decide how many characters are to be skipped for comparison when a mismatch has occurred.\n\n\n\nWhen a mismatch occurs, check the LPS value of the previous character of the mismatched character in the pattern. If it is \u20180\u2019 then start comparing the first character of the pattern with the next character to the mismatched character in the text. If it is not \u20180\u2019 then start comparing the character which is at an index value equal to the LPS value of the previous character to the mismatched character in pattern with the mismatched character in the Text.\n\n\n\n\n\n\n\n![Example of KMP algorithm](\n\nExample of KMP algorithm\n\n\n![Compare first character of pattern with first character of text from left to right](\n\nCompare first character of pattern with first character of text from left to right\n\n\n![Compare first character of pattern with next character of text](\n\nCompare first character of pattern with next character of text\n\n\n![Compare pattern[0] and pattern[1] values](\n\nCompare pattern[0] and pattern[1] values\n\n\n![Compare pattern[0] with next characters in text.](\n\nCompare pattern[0] with next characters in text.\n\n\n![Compare pattern[2] with mismatched characters in text.](\n\nCompare pattern[2] with mismatched characters in text.\n\n### How the KMP Algorithm Works\n\n\nLet\u2019s take a look on working example of KMP Algorithm to find a Pattern in a Text.\n\n\n\n![LPS table](\n\nLPS table\n\n\n![Define variables](\n\nDefine variables\n\n\n![Compare A with B](\n\nCompare A with B\n\n\n![Compare A with C](\n\nCompare A with C\n\n\n![Compare A with D](\n\nCompare A with D\n\n\n![Compare A with A](\n\nCompare A with A\n\n\n![Compare B with B](\n\nCompare B with B\n\n\n![Compare C with D](\n\nCompare C with D\n\n\n![Compare A with D](\n\n\n\n\n\n\n\n****Time complexity:****\nO(n + m)\n\n\n\n****Auxiliary Space:****\nO(M)\n\n\n[Rabin Karp algorithm](\n:\n\n\nRabin-Karp algorithm is an algorithm used for searching/matching patterns in the text using a hash function. Unlike Naive string-matching algorithm, it does not travel through every character in the initial phase rather it filters the characters that do not match and then perform the comparison.\n\n\nRabin-Karp compares a string\u2019s hash values, rather than the strings themselves. For efficiency, the hash value of the next position in the text is easily computed from the hash value of the current position.\n\n\n### Working of Rabin-Karp algorithm\n\n* Initially calculate the hash value of the pattern P.\n* Start iterating from the start of the string:\n  + Calculate the hash value of the current substring having length m.\n  + If the hash value of the current substring and the pattern are same check if the substring is same as the pattern.\n  + If they are same, store the starting index as a valid answer. Otherwise, continue for the next substrings.\n* Return the starting indices as the required answer.\n\n![Example of Rabin Karp](\n\nExample of Rabin Karp\n\n\nBelow is the implementation of the Rabin-Karp algorithm.\n\n\n\n\n\n\n\n****Time Complexity:****\n\n* The average and best-case running time of the Rabin-Karp algorithm is O(n+m), but its worst-case time is O(nm).\n* The worst case of the Rabin-Karp algorithm occurs when all characters of pattern and text are the same as the hash values of all the substrings of txt[] match with the hash value of pat[].\n\n****Space Complexity :****\n\n\nThe space complexity of the Rabin-Karp algorithm is O(1), which means that it is a constant amount of memory that is required, regardless of the size of the input text and pattern. This is because the algorithm only needs to store a few variables that are updated as the algorithm progresses through the text and pattern. Specifically, the algorithm needs to store the hash value of the pattern, the hash value of the current window in the text, and a few loop counters and temporary variables. Since the size of these variables is fixed, the space complexity is constant.\n\n\n[Z algorithm](\n:\n\n\nThis algorithm finds all occurrences of a pattern in a text in linear time. Let length of text be n and of pattern be m, then total time taken is O(m + n) with linear space complexity. Z algorithm works by maintaining an auxiliary array called the Z array. This Z array stores the length of the longest substring, starting from the current index, that also it\u2019s prefix.\n\n\n### What is Z Array?\n\n\nFor a string str[0..n-1], Z array is of same length as string. An element Z[i] of Z array stores length of the longest substring starting from str[i] which is also a prefix of str[0..n-1]. The first entry of Z array is meaning less as complete string is always prefix of itself.\n\n\n****Example:****\n\n> Index            0   1   2   3   4   5   6   7   8   9  10  11\n>\n>\n>\n> Text             a   a   b   c   a   a   b   x   a   a   a   z\n>\n>\n>\n> Z values         X   1   0   0   3   1   0   0   2   2   1   0\n\n### How to construct Z array?\n\n\nA Simple Solution is to run two nested loops, the outer loop goes to every index and the inner loop finds length of the longest prefix that matches the substring starting at current index. The time complexity of this solution is O(n2).\n\n\nWe can construct Z array in linear time. The idea is to maintain an interval [L, R] which is the interval with max R\n\n\n\nsuch that [L, R] is prefix substring (substring which is also a prefix.\n\n\n****Steps for maintaining this interval are as follows \u2013****\n\n> 1. If\n>\n>    ****i > R****\n>    then there is no prefix substring that starts before i and ends after i, so we reset L and R and compute new [L, R] by comparing\n>\n>    ****str[0..]****\n>    to\n>\n>    ****str[i..]****\n>    and get\n>\n>    ****Z[i] (= R-L+1)****\n>    .\n> 2. If\n>\n>    ****i <= R****\n>    then let\n>\n>    ****K = i-L****\n>    ,  now\n>\n>    ****Z[i] >= min(Z[K], R-i+1)****\n>    because str[i..] matches with\n>\n>    ****str[K..]****\n>    for atleast\n>\n>    ****R-i+1****\n>    characters (they are in[L, R] interval which we know is a prefix substring).\n>\n>\n>\n>    Now two sub cases arise:\n>    * If\n>\n>      ****Z[K] < R-i+1****\n>      then there is no prefix substring starting at str[i] (otherwise\n>\n>      ****Z[K]****\n>      would be larger)  so  Z[i] = Z[K]and interval [L, R] remains same.\n>    * If\n>\n>      ****Z[K] >= R-i+1****\n>      then it is possible to extend the [L, R] interval thus we will set L as i and start matching from\n>\n>      ****str[R]****\n>      onwards  and get new R then we will update interval [L, R] and calculate\n>\n>      ****Z[i] (=R-L+1)****\n>      .\n\n![Construction of Z array](\n\n\n\n\n\n\n\n****Time Complexity:****\nO(m+n), where m is length of pattern and n is length of text.\n\n\n\n****Auxiliary Space:****\nO(m+n)\n\n\n[Aho-Corasick algorithm](\n:\n\n****Aho-Corasick Algorithm****\nfinds all words in O(n + m + z) time where z is the total number of occurrences of words in text. The Aho\u2013Corasick string matching algorithm formed the basis of the original Unix command\n\n****\u201cfgrep\u201d****\n.\n\n\n****Preprocessing:****\nBuild an automaton of all words in arr[] The automaton has mainly three functions:\n\n\n> ****Go To:****\n> This function simply follows edges of Trie of all words in arr[].\n>\n>\n>\n> It is represented as 2D array g[][] where we store next state for current state and character.\n>\n>\n> ****Failure:****\n> This function stores all edges that are followed when current character doesn\u2019t have edge in Trie.\n>\n>\n>\n> It is represented as1D array f[] where we store next state for current state.\n>\n>\n> ****Output:****\n> Stores indexes of all words that end at current state.\n>\n>\n>\n> It is represented as 1D  array o[] where we store indices of all matching words as a bitmap for current state.\n\n****Matching:****\nTraverse the given text over built automaton to find all matching words.\n\n\n\nPreprocessing:\n\n\n### ****Illustration of Aho-Corasick algorithm****\n\n****Preprocessing:****\nWe first Build a Trie (or Keyword Tree) of all words.\n\n\n![ Build a Trie (or Keyword Tree) of all words.](\n\nBuild a Trie (or Keyword Tree) of all words.\n\n* This part fills entries in goto g[][] and output o[].\n* Next, we extend Trie into an automaton to support linear time matching.\n\n![ills entries in goto g[][] and output o[]](\n\nFills entries in goto g[][] and output o[]\n\n* This part fills entries in failure f[] and output o[].\n\n****Go to:****\nWe build Trie. And for all characters which don\u2019t have an edge at the root, we add an edge back to root.\n\n\n\n****Failure:****\nFor a state s, we find the longest proper suffix which is a proper prefix of some pattern. This is done using Breadth First Traversal of Trie.\n\n\n\n****Output:****\nFor a state s, indexes of all words ending at s are stored. These indexes are stored as bitwise map (by doing bitwise OR of values). This is also computing using Breadth First Traversal with Failure.\n\n\nBelow is the implementation of the Aho-Corasick Algorithm:\n\n\n\n\n\n\n****Time Complexity:****\nO(n + l + z), where \u2018n\u2019 is the length of the text, \u2018l\u2019 is the length of keywords, and \u2018z\u2019 is the number of matches.\n\n\n\n****Auxiliary Space:****\nO(l \\* q), where \u2018q\u2019 is the length of the alphabet since that is the maximum number of children a node can have.",
        "metadata": {
            "lesson_name": "Introduction to Pattern Searching \u2013 Data Structure and Algorithm Tutorial",
            "course_name": "Introduction to DSA II"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA II\nLesson Name: Introduction to Backtracking\n\nContent:\nTable of Content\n\n* [What is Backtracking?](#what-is-backtracking)\n* [Types of Backtracking Problems](#types-of-backtracking-problems)\n* [How does Backtracking works?](#how-does-backtracking-works)\n* [Determining Backtracking Problems](#determining-backtracking-problems)\n* [Pseudocode for Backtracking](#pseudocode-for-backtracking)\n* [Complexity Analysis of Backtracking](#complexity-analysis-of-backtracking)\n* [How Backtracking is different from Recursion?](#how-backtracking-is-different-from-recursion)\n* [Applications of Backtracking](#applications-of-backtracking)\n* [Must Do Backtracking Problems](#must-do-backtracking-problems)\n\nWhat is Backtracking?\n\n\nBacktracking is a problem-solving algorithmic technique that involves finding a solution incrementally by trying\n\n****different options****\nand\n\n****undoing****\nthem if they lead to a\n\n****dead end****\n. It is commonly used in situations where you need to explore multiple possibilities to solve a problem, like searching for a path in a maze or solving puzzles like Sudoku. When a dead end is reached, the algorithm backtracks to the previous decision point and explores a different path until a solution is found or all possibilities have been exhausted.\n\n\n> Backtracking can be defined as a general algorithmic technique that considers searching every possible combination in order to solve a computational problem.\n\n![backtracking-banner-(1)](\n\nIntroduction to Backtracking\n\n### Basic Terminologies\n\n* ****Candidate:****\n  A candidate is a potential choice or element that can be added to the current solution.\n* ****Solution:****\n  The solution is a valid and complete configuration that satisfies all problem constraints.\n* ****Partial Solution:****\n  A partial solution is an intermediate or incomplete configuration being constructed during the backtracking process.\n* ****Decision Space:****\n  The decision space is the set of all possible candidates or choices at each decision point.\n* ****Decision Point:****\n  A decision point is a specific step in the algorithm where a candidate is chosen and added to the partial solution.\n* ****Feasible Solution:****\n  A feasible solution is a partial or complete solution that adheres to all constraints.\n* ****Dead End:****\n  A dead end occurs when a partial solution cannot be extended without violating constraints.\n* ****Backtrack:****\n  Backtracking involves undoing previous decisions and returning to a prior decision point.\n* ****Search Space:****\n  The search space includes all possible combinations of candidates and choices.\n* ****Optimal Solution:****\n  In optimization problems, the optimal solution is the best possible solution.\n\nTypes of Backtracking Problems\n\n\nProblems associated with backtracking can be categorized into 3 categories:\n\n\n* ****Decision Problems:****\n  Here, we search for a feasible solution.\n* ****Optimization Problems:****\n  For this type, we search for the best solution.\n* ****Enumeration Problems:****\n  We find set of all possible feasible solutions to the problems of this type.\n\nHow does Backtracking works?\n\n> As we know backtracking algorithm explores each and every possible path in order to find a valid solution, this exploration of path can be easily understood via given images:\n>\n>\n> ![backtracking](\n>\n>\n> As shown in the image, \u201c\n>\n> ****IS\u201d****\n> represents the\n>\n> ****Initial State****\n> where the recursion call starts to find a valid solution.\n>\n>\n>\n> ****C :****\n> it represents different\n>\n> ****Checkpoints****\n> for recursive calls\n>\n>\n> ****TN****\n> : it represents the\n>\n> ****Terminal Nodes****\n> where no further recursive calls can be made, these nodes act as base case of recursion and we determine whether the current solution is valid or not at this state.\n>\n>\n> At each Checkpoint, our program makes some decisions and move to other checkpoints untill it reaches a terminal Node, after determining whether a solution is valid or not, the program starts to revert back to the checkpoints and try to explore other paths. For example in the above image\n>\n> ****TN1\u2026TN5****\n> are the terminal node where the solution is not acceptable, while\n>\n> ****TN6****\n> is the state where we found a valid solution.\n>\n>\n> The back arrows in the images shows backtracking in actions, where we revert the changes made by some checkpoint.\n\nDetermining Backtracking Problems:\n\n\nGenerally every constraint satisfaction problem can be solved using backtracking but, Is it optimal to use backtracking every time? Turns out\n\n****NO****\n, there are a vast number of problem that can be solved using\n\n[Greedy](\nor\n\n[Dynamic programming](\nin logarithmic or polynomial time complexity which is far better than exponential complexity of Backtracking. However many problems still exists that can only be solved using Backtracking.\n\n\n> To understand whether a problem is Backtracking based or not, let us take a simple problem:\n>\n>\n>\n> ****Problem:****\n>\n> Imagine you have 3 closed boxes, among which 2 are empty and 1 has a gold coin. Your task is to get the gold coin.\n>\n>\n> ****Why dynamic programming fails to solve this question:****\n>\n> ****D****\n> oes opening or closing one box has any effect on the other box? Turns out NO, each and every box is independent of each other and opening/closing state of one box can not determine the transition for other boxes. Hence DP fails.\n>\n>\n> ****Why greedy fails to solve this question:****\n>\n>\n> Greedy algorithm chooses a local maxima in order to get global maxima, but in this problem each and every box has equal probability of having a gold coin i.e 1/3 hence there is no criteria to make a greedy choice.\n>\n>\n> ****Why Backtracking works:****\n>\n> As discussed already, backtracking algorithm is simply brute forcing each and every choice, hence we can one by one choose every box to find the gold coin, If a box is found empty we can close it back which acts as a Backtracking step.\n>\n>\n> Technically, for backtracking problems:\n>\n>\n> * The algorithm builds a solution by exploring all possible paths created by the choices in the problem, this solution begins with an empty set\n>\n>   ****S={}****\n> * Each choice creates a new sub-tree \u2018\n>\n>   ****s\u2019****\n>   which we add into are set.\n> * Now there exist two cases:\n>   + ****S+s is valid set****\n>   + ****S+s is not valid set****\n> * In case the set is valid then we further make choices and repeat the process until a solution is found, otherwise we backtrack our decision of including \u2018\n>\n>   ****s\u2019****\n>   and explore other paths until a solution is found or all the possible paths are exhausted.\n\nPseudocode for Backtracking\n\n\nThe best way to implement backtracking is through recursion, and all backtracking code can be summarised as per the given Pseudocode:\n\n\n> void\n>\n> ****FIND\\_SOLUTIONS****\n> ( parameters):\n>\n>\n> if (valid\n>\n> ****solution****\n> ):\n>\n>\n> store the\n>\n> ****solution****\n>\n>\n> Return\n>\n>\n> for (all\n>\n> ****choice****\n> ):\n>\n>\n> if (valid\n>\n> ****choice****\n> ):\n>\n>\n> ****APPLY****\n> (\n>\n> ****choice****\n> )\n>\n>\n> ****FIND\\_SOLUTIONS****\n> (parameters)\n>\n>\n> ****BACKTRACK****\n> (remove\n>\n> ****choice****\n> )\n>\n>\n> Return\n\nComplexity Analysis of Backtracking\n\n\nSince backtracking algorithm is purely brute force therefore in terms of time complexity, it performs very poorly. Generally backtracking can be seen having below mentioned time complexities:\n\n\n* Exponential (O(K^N))\n* Factorial (O(N!))\n\n\nThese complexities are due to the fact that at each state we have multiple choices due to which the number of paths increases and sub-trees expand rapidly.\n\n\nHow Backtracking is different from Recursion?\n\n\nRecursion and Backtracking are related concepts in computer science and programming, but they are not the same thing. Let\u2019s explore the key differences between them:\n\n\nApplications of Backtracking\n\n* Creating smart bots to play Board Games such as Chess.\n* Solving mazes and puzzles such as N-Queen problem.\n* Network Routing and Congestion Control.\n* Decryption\n* Text Justification",
        "metadata": {
            "lesson_name": "Introduction to Backtracking",
            "course_name": "Introduction to DSA II"
        }
    },
    {
        "page_content": "Course Name: Linked List Data Structure Guide\nLesson Name: Doubly Linked List Tutorial\n\nContent:\nWhat is a Doubly Linked List?\n\nA ****doubly linked list****\nis a data structure that consists of a set of nodes, each of which\ncontains a ****value**** and ****two pointers****, one pointing to the ****previous node**** in the list and one pointing to the ****next node****\nin the list. This allows for efficient traversal of the list in ****both directions****, making it suitable for applications where frequent ****insertions**** and ****deletions**** are required.\n\n![Insertion-at-the-End-in-Doubly-Linked-List-copy](\n\nDoubly Linked List\n\n\nRepresentation of Doubly Linked List in Data Structure\n\nIn a data structure, a doubly linked list is represented using nodes\nthat have three fields:\n\n1. Data\n2. A pointer to the next node (****next****)\n3. A pointer to the previous node (****prev****)\n\n![Node-Structure-of-Doubly-Linked-List](\n\nNode Structure of Doubly Linked List\n\n\nNode Definition\n\nHere is how a node in a Doubly Linked List is typically\nrepresented:\n\n[Try it on GfG Practice\n![redirect icon](\nC++\n````\nstruct Node {\n\n    // To store the Value or data.\n    int data;\n\n    // Pointer to point the Previous Element\n    Node* prev;\n\n    // Pointer to point the Next Element\n    Node* next;\n\n    // Constructor\n    Node(int d) {\n       data = d;\n       prev = next = nullptr;\n    }\n};\n\nstruct Node {\n\n    // To store the Value or data.\n    int data;\n\n    // Pointer to point the Previous Element\n    Node* prev;\n\n    // Pointer to point the Next Element\n    Node* next;\n};\n\n// Function to create a new node\nstruct Node *createNode(int new_data) {\n    struct Node *new_node = (struct Node *)\n    malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    new_node->prev = NULL;\n    return new_node;\n}\n\nclass Node {\n\n    // To store the Value or data.\n    int data;\n\n    // Reference to the Previous Node\n    Node prev;\n\n    // Reference to the next Node\n    Node next;\n\n    // Constructor\n    Node(int d) {\n       data = d;\n       prev = next = null;\n    }\n};\n\nclass Node:\n\n    def __init__(self, data):\n        # To store the value or data.\n        self.data = data\n\n        # Reference to the previous node\n        self.prev = None\n\n        # Reference to the next node\n        self.next = None\n\nclass Node\n{\n  \t// To store the value or data\n    public int Data;\n\n  \t// Pointer to the next node\n    public Node Next;\n\n  \t// Pointer to the previous node\n    public Node Prev;\n\n    // Constructor\n    public Node(int d)\n    {\n        Data = d;\n        Prev = Next = null;\n    }\n}\n\nclass Node {\n    constructor(data)\n    {\n        // To store the value or data.\n        this.data = data;\n\n        // Reference to the previous node\n        this.prev = null;\n\n        // Reference to the next node\n        this.next = null;\n    }\n}\n\n#include <iostream>\nusing namespace std;\n\n// Define the Node structure\nstruct Node {\n    int data;\n    Node* next;\n    Node* prev;\n\n// Constructor to initialize Node with data\n    Node(int data) : data(data), next(nullptr),\n  \tprev(nullptr) {}\n};\n\n// Function to traverse the doubly linked list\n// in forward direction\nvoid forwardTraversal(Node* head) {\n\n    // Start traversal from the head of the list\n    Node* curr = head;\n\n// Continue until current node is not null\n    // (end of list)\n    while (curr != nullptr) {\n\n        // Output data of the current node\n        cout << curr->data << \" \";\n\n// Move to the next node\n        curr = curr->next;\n}\n\n    // Print newline after traversal\n    cout << endl;\n}\n\n// Function to traverse the doubly linked list\n// in backward direction\nvoid backwardTraversal(Node* tail) {\n\n    // Start traversal from the tail of the list\n    Node* curr = tail;\n\n// Continue until current node is not null\n    // (end of list)\n    while (curr != nullptr) {\n\n        // Output data of the current node\n        cout << curr->data << \" \";\n\n// Move to the previous node\n        curr = curr->prev;\n}\n\n    // Print newline after traversal\n    cout << endl;\n}\n\nint main() {\n\n    // Sample usage of the doubly linked list and\n    // traversal functions\n    Node* head = new Node(1);\n    Node* second = new Node(2);\n    Node* third = new Node(3);\n\n    head->next = second;\nsecond->prev = head;\nsecond->next = third;\n    third->prev = second;\n\n    cout << \"Forward Traversal:\" << endl;\n    forwardTraversal(head);\n\n    cout << \"Backward Traversal:\" << endl;\n    backwardTraversal(third);\n\nreturn 0;\n}\n\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the Node structure\nstruct Node {\n    int data; // Data stored in the node\n    struct Node* next; // Pointer to the next node\n    struct Node* prev; // Pointer to the previous node\n};\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode =\n      (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    newNode->prev = NULL;\nreturn newNode;\n}\n\n// Function to traverse the doubly linked list\n// in forward direction\nvoid forwardTraversal(struct Node* head) {\n\n    // Start traversal from the head of the list\n    struct Node* curr = head;\n\n// Continue until the current node is not\n    // null (end of list)\n    while (curr != NULL) {\n\n        // Output data of the current node\n        printf(\"%d \", curr->data);\n\n// Move to the next node\n        curr = curr->next;\n}\n\n    // Print newline after traversal\n    printf(\"\\n\");\n}\n\n// Function to traverse the doubly linked list\n// in backward direction\nvoid backwardTraversal(struct Node* tail) {\n\n    // Start traversal from the tail of the list\n    struct Node* curr = tail;\n\n// Continue until the current node is not\n    // null (end of list)\n    while (curr != NULL) {\n\n        // Output data of the current node\n        printf(\"%d \", curr->data);\n\n// Move to the previous node\n        curr = curr->prev;\n}\n\n    // Print newline after traversal\n    printf(\"\\n\");\n}\n\nint main() {\n\n    // Sample usage of the doubly linked list and\n    // traversal functions\n    struct Node* head = createNode(1);\n    struct Node* second = createNode(2);\n    struct Node* third = createNode(3);\n\n    head->next = second;\nsecond->prev = head;\nsecond->next = third;\n    third->prev = second;\n\n    printf(\"Forward Traversal:\\n\");\n    forwardTraversal(head);\n\n    printf(\"Backward Traversal:\\n\");\n    backwardTraversal(third);\n\n// Free memory allocated for nodes\n    free(head);\n    free(second);\n    free(third);\n\nreturn 0;\n}\n\n// Define the Node class\nclass Node {\n    int data; // Data stored in the node\n    Node next; // Pointer to the next node\n    Node prev; // Pointer to the previous node\n\n    // Constructor to initialize the node with data\n    public Node(int data) {\n        this.data = data;\n        this.next = null;\n        this.prev = null;\n}\n}\n\n// Class to manage the doubly linked list\nclass GfG {\n\n    // Function to traverse the doubly linked list\n    // in forward direction\n    static void forwardTraversal(Node head) {\n\n        // Start traversal from the head of the list\n        Node curr = head;\n\n// Continue until the current node is\n        // null (end of the list)\n        while (curr != null) {\n\n            // Output data of the current node\n            System.out.print(curr.data + \" \");\n\n// Move to the next node\n            curr = curr.next;\n}\n\n        // Print newline after traversal\n        System.out.println();\n}\n\n    // Function to traverse the doubly linked list\n  \t//in backward direction\n    static void backwardTraversal(Node tail) {\n\n        // Start traversal from the tail of the list\n        Node curr = tail;\n\n// Continue until the current node is\n        // null (end of the list)\n        while (curr != null) {\n\n            // Output data of the current node\n            System.out.print(curr.data + \" \");\n\n// Move to the previous node\n            curr = curr.prev;\n}\n\n        // Print newline after traversal\n        System.out.println();\n}\n\n    public static void main(String[] args) {\n\n        // Sample usage of the doubly linked\n        // list and traversal functions\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.next = second;\nsecond.prev = head;\nsecond.next = third;\n        third.prev = second;\n\n        System.out.println(\"Forward Traversal:\");\n        forwardTraversal(head);\n\n        System.out.println(\"Backward Traversal:\");\n        backwardTraversal(third);\n}\n}\n\n# Define the Node class\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n# Function to traverse the doubly linked list\n# in forward direction\ndef forward_traversal(head):\n\n    # Start traversal from the head of the list\n    curr = head\n\n    # Continue until the current node is\n    # null (end of the list)\n    while curr is not None:\n\n        # Output data of the current node\n        print(curr.data, end=\" \")\n\n        # Move to the next node\n        curr = curr.next\n\n    # Print newline after traversal\n    print()\n\n# Function to traverse the doubly linked\n# list in backward direction\ndef backward_traversal(tail):\n\n    # Start traversal from the tail of the list\n    curr = tail\n\n    # Continue until the current node\n    # is null (end of the list)\n    while curr is not None:\n\n        # Output data of the current node\n        print(curr.data, end=\" \")\n\n        # Move to the previous node\n        curr = curr.prev\n\n    # Print newline after traversal\n    print()\n\n# Sample usage of the doubly linked list\n# and traversal functions\nif __name__ == \"__main__\":\n\n    # Create a doubly linked list with 3 nodes\n    head = Node(1)\n    second = Node(2)\n    third = Node(3)\n\n    head.next = second\n    second.prev = head\n    second.next = third\n    third.prev = second\n\n    print(\"Forward Traversal:\")\n    forward_traversal(head)\n\n    print(\"Backward Traversal:\")\n    backward_traversal(third)\n\nusing System;\n\n// Define the Node class\nclass Node\n{\n    public int Data; // Data stored in the node\n    public Node Next; // Pointer to the next node\n    public Node Prev; // Pointer to the previous node\n\n    // Constructor to initialize the node with data\n    public Node(int data)\n    {\n        Data = data;\nNext = null;\n        Prev = null;\n}\n}\n\n// Class to manage the doubly linked list\nclass GfG\n{\n    // Function to traverse the doubly linked list\n  \t//in forward direction\n    static void ForwardTraversal(Node head)\n    {\n        // Start traversal from the head of the list\n        Node curr = head;\n\n// Continue until the current node is null\n      \t//(end of the list)\n        while (curr != null)\n        {\n            // Output data of the current node\n            Console.Write(curr.Data + \" \");\n\n// Move to the next node\n            curr = curr.Next;\n}\n\n        // Print newline after traversal\n        Console.WriteLine();\n}\n\n    // Function to traverse the doubly linked list\n  \t//in backward direction\n    static void BackwardTraversal(Node tail)\n    {\n        // Start traversal from the tail of the list\n        Node curr = tail;\n\n// Continue until the current node is null\n      \t//(end of the list)\n        while (curr != null)\n        {\n            // Output data of the current node\n            Console.Write(curr.Data + \" \");\n\n// Move to the previous node\n            curr = curr.Prev;\n}\n\n        // Print newline after traversal\n        Console.WriteLine();\n}\n\n    public static void Main()\n    {\n        // Sample usage of the doubly linked list\n      \t//and traversal functions\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.Next = second;\nsecond.Prev = head;\nsecond.Next = third;\n        third.Prev = second;\n\n        Console.WriteLine(\"Forward Traversal:\");\n        ForwardTraversal(head);\n\n        Console.WriteLine(\"Backward Traversal:\");\n        BackwardTraversal(third);\n}\n}\n\n// Define the Node class\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n}\n}\n\n// Function to traverse the doubly linked list\n// in forward direction\nfunction forwardTraversal(head) {\n\n    // Start traversal from the head of the list\n    let curr = head;\n\n// Continue until the current node is null\n    // (end of the list)\n    while (curr !== null) {\n\n        // Output data of the current node\n        console.log(curr.data + \" \");\n\n// Move to the next node\n        curr = curr.next;\n}\n\n    // Print newline after traversal\n    console.log();\n}\n\n// Function to traverse the doubly linked list\n// in backward direction\nfunction backwardTraversal(tail) {\n\n    // Start traversal from the tail of the list\n    let curr = tail;\n\n// Continue until the current node is null\n    // (end of the list)\n    while (curr !== null) {\n\n        // Output data of the current node\n        console.log(curr.data + \" \");\n\n// Move to the previous node\n        curr = curr.prev;\n}\n\n    // Print newline after traversal\n    console.log();\n}\n\n// Sample usage of the doubly linked list\n//and traversal functions\n// Create a doubly linked list with 3 nodes\nconst head = new Node(1);\nconst second = new Node(2);\nconst third = new Node(3);\n\nhead.next = second;\nsecond.prev = head;\nsecond.next = third;\nthird.prev = second;\n\nconsole.log(\"Forward Traversal:\");\nforwardTraversal(head);\n\nconsole.log(\"Backward Traversal:\");\nbackwardTraversal(third);\n\n\n#include <iostream>\n\nusing namespace std;\n\n// Node structure for doubly linked list\nstruct Node {\n    int data;\n    Node * prev;\n    Node * next;\n\n    Node(int val) {\n        data = val;\n        prev = next = nullptr;\n}\n};\n\n// Function to find the length of a doubly\n//linked list\nint findLength(Node * head) {\n    int count = 0;\nfor (Node * cur = head; cur != nullptr; cur = cur -> next)\n        count++;\nreturn count;\n}\n\nint main() {\n\n    // Create a DLL with 3 nodes\n    Node * head = new Node(1);\n    Node * second = new Node(2);\n    Node * third = new Node(3);\n    head -> next = second;\nsecond -> prev = head;\nsecond -> next = third;\n    third -> prev = second;\n\n    cout << \"Length of the doubly linked list: \" <<\n        findLength(head) << endl;\n\nreturn 0;\n}\n\n#include <stdio.h>\n#include <stdlib.h>\n\n// Node structure for doubly linked list\nstruct Node {\n    int data; // Data stored in the node\n    struct Node* prev; // Pointer to the previous node\n    struct Node* next; // Pointer to the next node\n};\n\n// Constructor function to create a new node\nstruct Node* createNode(int val) {\n    struct Node* newNode =\n         (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = val;\n    newNode->prev = NULL;\n    newNode->next = NULL;\nreturn newNode;\n}\n\n// Function to find the length of a doubly linked list\nint findLength(struct Node* head) {\n    int count = 0;\nfor (struct Node* cur = head; cur != NULL; cur = cur->next)\n        count++;\nreturn count;\n}\n\nint main() {\n    // Create a DLL with 3 nodes\n    struct Node* head = createNode(1);\n    struct Node* second = createNode(2);\n    struct Node* third = createNode(3);\n\n    head->next = second;\nsecond->prev = head;\nsecond->next = third;\n    third->prev = second;\n\n    printf(\"Length of the doubly linked list: %d\\n\",\n           findLength(head));\n\nreturn 0;\n}\n\nclass Node {\n    int data;\n    Node prev;\n    Node next;\n\n// Constructor\n    public Node(int val) {\n        data = val;\n        prev = null;\nnext = null;\n}\n}\n\nclass GfG {\n\n    // Function to find the length of\n    // a doubly linked list\n    static int FindLength(Node head) {\n        int count = 0;\nfor (Node cur = head; cur != null; cur = cur.next)\n            count++;\nreturn count;\n}\n\n    // Driver code\n    public static void main(String[] args) {\n\n        // Create a doubly linked list\n        // with 3 nodes\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.next = second;\nsecond.prev = head;\nsecond.next = third;\n        third.prev = second;\n\n        System.out.println(\"Length of doubly linked list: \"\n                           + FindLength(head));\n}\n}\n\nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.prev = None\n        self.next = None\n\n# Function to find the length of\n# a doubly linked list\ndef find_length(head):\n    count = 0\n    cur = head\n    while cur is not None:\n        count += 1\n        cur = cur.next\n    return count\n\n# Driver code\nif __name__ == \"__main__\":\n\n    # Create a doubly linked list\n    # with 3 nodes\n    head = Node(1)\n    second = Node(2)\n    third = Node(3)\n\n    head.next = second\n    second.prev = head\n    second.next = third\n    third.prev = second\n\n    print(\"Length of the doubly linked list: \" +\n          str(find_length(head)))\n\nusing System;\n\nclass Node {\n    public int data;\npublic Node prev;\npublic Node next;\n\n// Constructor\n    public Node(int val) {\n        data = val;\n        prev = null;\nnext = null;\n}\n}\n\npublic class GfG {\n\n    // Function to find the length of\n    // a doubly linked list\n    static int FindLength(Node head) {\n        int count = 0;\nfor (Node cur = head; cur != null; cur = cur.next)\n            count++;\nreturn count;\n}\n\n    // Driver code\n    public static void Main(string[] args) {\n\n        // Create a doubly linked list\n        // with 3 nodes\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.next = second;\nsecond.prev = head;\nsecond.next = third;\n        third.prev = second;\n\n        Console.WriteLine(\"Length of doubly linked list: \"\n                                 + FindLength(head));\n}\n}\n\nclass Node {\n    constructor(val) {\n        this.data = val;\n        this.prev = null;\n        this.next = null;\n}\n}\n\n// Function to find the length of\n// a doubly linked list\nfunction findLength(head) {\n    let count = 0;\n    let cur = head;\n    while (cur !== null) {\n        count++;\n        cur = cur.next;\n}\n    return count;\n}\n\n// Create a doubly linked list with 3 nodes\nconst head = new Node(1);\nconst second = new Node(2);\nconst third = new Node(3);\n\nhead.next = second;\nsecond.prev = head;\nsecond.next = third;\nthird.prev = second;\n\nconsole.log(\"Length of the doubly linked list: \" +\n            findLength(head));\n\n\n\n\n\n\n\n\n\n[Insertion at the End of Doubly Linked List](\n\n![Insertion-at-the-End-in-Doubly-Linked-List](\n\nInsertion at the End in the Doubly Linked List\n\n\nTo insert a new node at the end of the doubly linked list, we can use\nthe following steps:\n\n* Allocate memory for a new node and assign the provided value to its\n  data field.\n* Initialize the next pointer of the new node to nullptr.\n* If the list is empty:\n  + Set the previous pointer of the new node to nullptr.\n  + Update the head pointer to point to the new node.\n                                                                                          * If the list is not empty:\n                                                                                          + Traverse the list starting from the head to reach the last\n                                                                                          node.\n                                                                                          + Set the next pointer of the last node to point to the new\n                                                                                          node.\n                                                                                          + Set the previous pointer of the new node to point to the last\n                                                                                          node.\n\n\n\n\n\n\n\n\n[Insertion at a Specific Position in Doubly Linked List](\n\nTo insert a node at a specific Position in doubly linked list, we can\nuse the following steps:\n\n![Insertion-at-a-Specific-Position-in-Doubly-Linked-List](\n\n\nInsertion at a Specific Position in Doubly Linked List\n\n\n\nTo insert a new node at a specific position,\n\n* If position = 1, create a new node and make it the head of the linked\n  list and return it.\n* Otherwise, traverse the list to reach the node at position \u2013 1,\n  say ****curr****.\n* If the position is valid, create a new node with given data,\n  say ****new\\_node****.\n* Update the next pointer of new node to the next\n                                                                                                                                             of current node and prev pointer of new node to current\n                                                                                                                                             node, ****new\\_node->next = curr->next****and ****new\\_node->prev = curr.****\n                                                                                                                                             * Similarly, update next pointer of current node to\n                                                                                                                                                              thenew node, ****curr->next = new\\_node****.\n                                                                                                                                                              * If the new node is not the last node, update prev pointer of new\n                                                                                                                                                                                                          node\u2019s next to the new node, ****new\\_node->next->prev = new\\_node.****\n\n\n\n\n\n\n\n\n[Deletion at the Beginning of Doubly Linked List](\n\n![Deletion-at-the-Beginning-of-Doubly-Linked-List](\n\nDeletion at the Beginning of Doubly Linked List\n\n\nTo delete a node at the beginning in doubly linked list, we can use the\nfollowing steps:\n\n* Check if the list is empty, there is nothing to delete. Return.\n* Store the head pointer in a variable, say ****temp****.\n* Update the head of linked list to the node next to the current head, ****head = head->next****.\n                                                                        * If the new head is not NULL, update the previous pointer of new head\n                                                                                                           to NULL, ****head->prev = NULL****.\n\n\n\n\n\n\n\n\n[Deletion at the End of Doubly Linked List](\n\n![Deletion-at-the-End-in-Doubly-Linked-List](\n\nDeletion at the End in Doubly Linked List\n\n\nTo delete a node at the end in doubly linked list, we can use the\nfollowing steps:\n\n* Check if the doubly linked list is empty. If it is empty, then there\n  is nothing to delete.\n* If the list is not empty, then move to the last node of the doubly\n  linked list, say ****curr****.\n* Update the second-to-last node's next pointer to NULL, ****curr->prev->next = NULL****.\n* Free the memory allocated for the node that was deleted.\n\n\n\n\n\n\n\n\n[Deletion at a Specific Position in Doubly Linked List](\n\n![Deletion-at-a-Specific-Position-in-Doubly-Linked-List](\n\n\nDeletion at a Specific Position in Doubly Linked List\n\n\n\nTo delete a node at a specific position in doubly linked list, we can\nuse the following steps:\n\n* Traverse to the node at the specified position, say ****curr****.\n* If the position is valid, adjust the pointers to skip the node to be\n  deleted.\n  + If curr is not the head of the linked list, update the next\n    pointer of the node before curr to point to the node after curr, ****curr->prev->next = curr-next****.\n  + If curr is not the last node of the linked list, update the\n    previous pointer of the node after curr to the node before curr, ****curr->next->prev = curr->prev****.\n* Free the memory allocated for the deleted node.\n\n\n\n\n\n\n\n\nAdvantages of Doubly Linked List\n\n* ****Efficient traversal in both directions:**** Doubly linked lists allow for efficient traversal of the list in both\n  directions, making it suitable for applications where frequent\n  insertions and deletions are required.\n* ****Easy insertion and deletion of nodes:**** The presence of pointers to both the previous and next nodes makes it\n  easy to insert or delete nodes from the list, without having to\n  traverse the entire list.\n* ****Can be used to implement a stack or queue:**** Doubly linked lists can be used to implement both stacks and queues,\n  which are common data structures used in programming.\n\nDisadvantages of Doubly Linked List\n\n* ****More complex than singly linked lists:****\n  Doubly linked lists are more complex than singly linked lists, as they\n  require additional pointers for each node.\n* ****More memory overhead:**** Doubly linked lists require more memory overhead than singly linked\n  lists, as each node stores two pointers instead of one.",
        "metadata": {
            "lesson_name": "Doubly Linked List Tutorial",
            "course_name": "Linked List Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA II\nLesson Name: Time complexities of different data structures\n\nContent:\n\n[Time Complexity](\nis a concept in computer science that deals with the quantification of the amount of time taken by a set of code or\n\n[algorithm](\nto process or run as a function of the amount of input. In other words, the time complexity is how long a program takes to process a given input. The efficiency of an algorithm depends on two parameters:\n\n\n* Time Complexity\n* Space Complexity\n\n****Time Complexity:****\nIt is defined as the number of times a particular instruction set is executed rather than the total time taken. It is because the total time taken also depends on some external factors like the compiler used, the processor\u2019s speed, etc.\n\n\n****Space Complexity:****\nIt is the total memory space required by the program for its execution.\n\n\n### Best case time complexity of different data structures for different operations\n\n### ****Worst Case time complexity of different data structures for different operations****\n\n### ****The average time complexity of different data structures for different operations****\n\n### Related Article on Time and Space Complexity:\n\n* [Time and Space Complexity of Binary Search](\n* [Time and Space Complexity of Linear Search](\n* [Time and Space Complexity of Ternary Search](\n* [Time and Space Complexity of Breadth First Search (BFS)](\n* [Time and Space Complexity of Depth First Search (DFS)](\n* [Time and Space Complexity of Insertion Sort](\n* [Time and Space Complexity of Selection Sort](\n* [Time and Space Complexity of Bubble Sort](\n* [Time and Space Complexity of Quick Sort](\n* [Time and Space Complexity of Merge Sort](\n* [Time and Space complexity of Radix Sort Algorithm](\n* [Time and Space Complexity of Linked List](\n* [Time and Space Complexity of Floyd Warshall Algorithm](\n* [Time and Space Complexity of Bellman\u2013Ford Algorithm](\n* [Time and Space Complexity of Dijkstra\u2019s Algorithm](\n* [Time and Space Complexity Analysis of Prim\u2019s Algorithm](",
        "metadata": {
            "lesson_name": "Time complexities of different data structures",
            "course_name": "Introduction to DSA II"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA II\nLesson Name: What is Stack Data Structure? A Complete Tutorial\n\nContent:\nRepresentation of Stack Data Structure:\n\n\nStack follows LIFO (Last In First Out) Principle so the element which is pushed last is popped first.\n\n\n![Stack-representation-in-Data-Structures-(1)](\n\n****Types of Stack:****\n\n* ****Fixed Size Stack****\n  : As the name suggests, a fixed size stack has a fixed size and cannot grow or shrink dynamically. If the stack is full and an attempt is made to add an element to it, an overflow error occurs. If the stack is empty and an attempt is made to remove an element from it, an underflow error occurs.\n* ****Dynamic Size Stack****\n  : A dynamic size stack can grow or shrink dynamically. When the stack is full, it automatically increases its size to accommodate the new element, and when the stack is empty, it decreases its size. This type of stack is implemented using a linked list, as it allows for easy resizing of the stack.\n\nBasic Operations on Stack:\n\n\nIn order to make manipulations in a stack, there are certain operations provided to us.\n\n\n* ****push()****\n  to insert an element into the stack\n* ****pop()****\n  to remove an element from the stack\n* ****top()****\n  Returns the top element of the stack.\n* ****isEmpty()****\n  returns true if stack is empty else false.\n* ****isFull()****\n  returns true if the stack is full else false.\n\n\nTo implement stack, we need to maintain reference to the top item.\n\n\n### ****Push Operation on Stack****\n\n\nAdds an item to the stack. If the stack is full, then it is said to be an\n\n****Overflow condition.****\n\n****Algorithm for Push Operation:****\n\n\n* Before pushing the element to the stack, we check if the stack is\n\n  ****full****\n  .\n* If the stack is full\n\n  ****(top == capacity-1)****\n  , then\n\n  ****Stack Overflows****\n  and we cannot insert the element to the stack.\n* Otherwise, we increment the value of top by 1\n\n  ****(top = top + 1)****\n  and the new value is inserted at\n\n  ****top position****\n  .\n* The elements can be pushed into the stack till we reach the\n\n  ****capacity****\n  of the stack.\n\n![Push-Operation-in-Stack-(1)](\n### ****Pop Operation in Stack****\n\n\nRemoves an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an\n\n****Underflow condition.****\n\n****Algorithm for Pop Operation:****\n\n* Before popping the element from the stack, we check if the stack is\n\n  ****empty****\n  .\n* If the stack is empty (top == -1), then\n\n  ****Stack Underflows****\n  and we cannot remove any element from the stack.\n* Otherwise, we store the value at top, decrement the value of top by 1\n\n  ****(top = top \u2013 1)****\n  and return the stored top value.\n\n![Pop-Operation-in-Stack-(1)](\n### ****Top or Peek Operation on Stack****\n\n\nReturns the top element of the stack.\n\n\n****Algorithm for Top Operation:****\n\n* Before returning the top element from the stack, we check if the stack is empty.\n* If the stack is empty (top == -1), we simply print \u201cStack is empty\u201d.\n* Otherwise, we return the element stored at\n\n  ****index = top****\n  .\n\n![Top-or-Peek-Operation-in-Stack-(1)](\n### ****isEmpty Operation in Stack Data Structure:****\n\n\nReturns true if the stack is empty, else false.\n\n\n****Algorithm for isEmpty Operation****\n:\n\n\n* Check for the value of\n\n  ****top****\n  in stack.\n* If\n\n  ****(top == -1)****\n  , then the stack is\n\n  ****empty****\n  so return\n\n  ****true****\n  .\n* Otherwise, the stack is not empty so return\n\n  ****false****\n  .\n\n![isEmpty-Operation-in-Stack-(1)](\n### isFull ****Operation in Stack**** ****Data Structure**** :\n\n\nReturns true if the stack is full, else false.\n\n\n****Algorithm for isFull Operation:****\n\n* Check for the value of\n\n  ****top****\n  in stack.\n* If\n\n  ****(top == capacity-1),****\n  then the stack is\n\n  ****full****\n  so return\n\n  ****true****\n  .\n* Otherwise, the stack is not full so return\n\n  ****false****\n  .\n\n![isFull-Operation-in-Stack-(1)](\n\nImplementation of Stack\n\n\nThe basic operations that can be performed on a stack include push, pop, and peek. There are two ways to implement a stack \u2013\n\n\n* [****Implementation of Stack using Array****](\n* [****Implementation of Stack using Linked List****](\n\n",
        "metadata": {
            "lesson_name": "What is Stack Data Structure? A Complete Tutorial",
            "course_name": "Introduction to DSA II"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA II\nLesson Name: Hash Functions and Types of Hash functions\n\nContent:\nWhat is a Hash Function?\n\n\nA\n\n****hash function****\nis a function that takes an input (or \u2018message\u2019) and returns a fixed-size string of bytes. The output, typically a number, is called the\n\n****hash code****\nor\n\n****hash value****\n. The main purpose of a hash function is to efficiently map data of arbitrary size to fixed-size values, which are often used as indexes in hash tables.\n\n\n### Key Properties of Hash Functions\n\n* ****Deterministic****\n  : A hash function must consistently produce the same output for the same input.\n* ****Fixed Output Size****\n  : The output of a hash function should have a fixed size, regardless of the size of the input.\n* ****Efficiency****\n  : The hash function should be able to process input quickly.\n* ****Uniformity****\n  : The hash function should distribute the hash values uniformly across the output space to avoid clustering.\n* ****Pre-image Resistance****\n  : It should be computationally infeasible to reverse the hash function, i.e., to find the original input given a hash value.\n* ****Collision Resistance****\n  : It should be difficult to find two different inputs that produce the same hash value.\n* ****Avalanche Effect****\n  : A small change in the input should produce a significantly different hash value.\n\nApplications of Hash Functions\n\n* ****Hash Tables****\n  : The most common use of hash functions in DSA is in hash tables, which provide an efficient way to store and retrieve data.\n* ****Data Integrity****\n  : Hash functions are used to ensure the integrity of data by generating checksums.\n* ****Cryptography****\n  : In cryptographic applications, hash functions are used to create secure hash algorithms like SHA-256.\n* ****Data Structures****\n  : Hash functions are utilized in various data structures such as Bloom filters and hash sets.\n\nTypes of Hash Functions\n\n\nThere are many hash functions that use numeric or alphanumeric keys. This article focuses on discussing different hash functions:\n\n\n1. Division Method.\n2. Multiplication Method\n3. Mid-Square Method\n4. Folding Method\n5. Cryptographic Hash Functions\n6. Universal Hashing\n7. Perfect Hashing\n\n\nLet\u2019s begin discussing these methods in detail.\n\n\n1. Division Method\n\n\nThe division method involves dividing the key by a prime number and using the remainder as the hash value.\n\n\n> **h**\n> (\n>\n> **k**\n> )=\n>\n> **k**\n> mod\n>\n> **m**\n>\n>\n> Where\n>\n> **k**\n> is the key and \ud835\udc5a\n>\n> **m**\n> is a prime number.\n\n****Advantages****\n:\n\n\n* Simple to implement.\n* Works well when \ud835\udc5a\n\n  **m**\n  is a prime number.\n\n****Disadvantages****\n:\n\n\n* Poor distribution if \ud835\udc5a\n\n  **m**\n  is not chosen wisely.\n\n2. Multiplication Method\n\n\nIn the multiplication method, a constant \ud835\udc34\n\n**A**\n(0 < A < 1) is used to multiply the key. The fractional part of the product is then multiplied by \ud835\udc5a\n\n**m**\nto get the hash value.\n\n\n> **h**\n> (\n>\n> **k**\n> )=\u230a\n>\n> **m**\n> (\n>\n> **kA**\n> mod1)\u230b\n>\n>\n> Where \u230a \u230b denotes the floor function.\n\n****Advantages****\n:\n\n\n* Less sensitive to the choice of \ud835\udc5a\n\n  **m**\n  .\n\n****Disadvantages****\n:\n\n\n* More complex than the division method.\n\n3. Mid-Square Method\n\n\nIn the mid-square method, the key is squared, and the middle digits of the result are taken as the hash value.\n\n\n****Steps****\n:\n\n\n1. Square the key.\n2. Extract the middle digits of the squared value.\n\n****Advantages****\n:\n\n\n* Produces a good distribution of hash values.\n\n****Disadvantages****\n:\n\n\n* May require more computational effort.\n\n4. Folding Method\n\n\nThe folding method involves dividing the key into equal parts, summing the parts, and then taking the modulo with respect to \ud835\udc5a\n\n**m**\n.\n\n\n****Steps****\n:\n\n\n1. Divide the key into parts.\n2. Sum the parts.\n3. Take the modulo \ud835\udc5a\n\n   **m**\n   of the sum.\n\n****Advantages****\n:\n\n\n* Simple and easy to implement.\n\n****Disadvantages****\n:\n\n\n* Depends on the choice of partitioning scheme.\n\n5. Cryptographic Hash Functions\n\n\nCryptographic hash functions are designed to be secure and are used in cryptography. Examples include MD5, SHA-1, and SHA-256.\n\n\n****Characteristics****\n:\n\n\n* Pre-image resistance.\n* Second pre-image resistance.\n* Collision resistance.\n\n****Advantages****\n:\n\n\n* High security.\n\n****Disadvantages****\n:\n\n\n* Computationally intensive.\n\n6. Universal Hashing\n\n\nUniversal hashing uses a family of hash functions to minimize the chance of collision for any given set of inputs.\n\n\n> **h**\n> (\n>\n> **k**\n> )=((\n>\n> **a**\n> \u22c5\n>\n> **k**\n> +\n>\n> **b**\n> )mod\n>\n> **p**\n> )mod\n>\n> **m**\n>\n>\n> Where\n>\n> **a**\n> and\n>\n> **b**\n> are randomly chosen constants,\n>\n> **p**\n> is a prime number greater than\n>\n> **m**\n> , and\n>\n> **k**\n> is the key.\n\n****Advantages****\n:\n\n\n* Reduces the probability of collisions.\n\n****Disadvantages****\n:\n\n\n* Requires more computation and storage.\n\n7. Perfect Hashing\n\n\nPerfect hashing aims to create a collision-free hash function for a static set of keys. It guarantees that no two keys will hash to the same value.\n\n\n****Types****\n:\n\n\n* Minimal Perfect Hashing: Ensures that the range of the hash function is equal to the number of keys.\n* Non-minimal Perfect Hashing: The range may be larger than the number of keys.\n\n****Advantages****\n:\n\n\n* No collisions.\n\n****Disadvantages****\n:\n\n\n* Complex to construct.\n\nConclusion\n\n\nIn conclusion, hash functions are very important tools that help store and find data quickly. Knowing the different types of hash functions and how to use them correctly is key to making software work better and more securely. By choosing the right hash function for the job, developers can greatly improve the efficiency and reliability of their systems.\n",
        "metadata": {
            "lesson_name": "Hash Functions and Types of Hash functions",
            "course_name": "Introduction to DSA II"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA II\nLesson Name: Hash Table Data Structure\n\nContent:\n\n****What is Hash Table?****\n\n\nA Hash table is defined as a data structure used to insert, look up, and remove key-value pairs quickly. It operates on the\n\n[hashing concept](\n, where each key is translated by a hash function into a distinct index in an array. The index functions as a storage location for the matching value. In simple words, it maps the keys with the value.\n\n\n![Components-of-Hashing](\n\nHash Function and Table\n\nWhat is Load factor?\n\n\nA hash table\u2019s load factor is determined by how many elements are kept there in relation to how big the table is. The table may be cluttered and have longer search times and collisions if the load factor is high. An ideal load factor can be maintained with the use of a good hash function and proper table resizing.\n\n\nWhat is a Hash function?\n\n\nA Function that translates keys to array indices is known as a hash function. The keys should be evenly distributed across the array via a decent hash function to reduce collisions and ensure quick lookup speeds.\n\n\n* ****Integer universe assumption:****\n\n  The keys are assumed to be integers within a certain range according to the integer universe assumption. This enables the use of basic hashing operations like division or multiplication hashing.\n* ****Hashing by division:****\n\n  This straightforward hashing technique uses the key\u2019s remaining value after dividing it by the array\u2019s size as the index. When an array size is a prime number and the keys are evenly spaced out, it performs well.\n* ****Hashing by multiplication:****\n\n  This straightforward hashing operation multiplies the key by a constant between 0 and 1 before taking the fractional portion of the outcome. After that, the index is determined by multiplying the fractional component by the array\u2019s size. Also, it functions effectively when the keys are scattered equally.\n\n### [Choosing a hash function]( :\n\n\nSelecting a decent hash function is based on the properties of the keys and the intended functionality of the hash table. Using a function that evenly distributes the keys and reduces collisions is crucial.\n\n\n****Criteria based on which a hash function is chosen:****\n\n\n* To ensure that the number of collisions is kept to a minimum, a good hash function should distribute the keys throughout the hash table in a uniform manner. This implies that for all pairings of keys, the likelihood of two keys hashing to the same position in the table should be rather constant.\n* To enable speedy hashing and key retrieval, the hash function should be computationally efficient.\n* It ought to be challenging to deduce the key from its hash value. As a result, attempts to guess the key using the hash value are less likely to succeed.\n* A hash function should be flexible enough to adjust as the data being hashed changes. For instance, the hash function needs to continue to perform properly if the keys being hashed change in size or format.\n\n### [Collision resolution techniques]( :\n\n\nCollisions happen when two or more keys point to the same array index. Chaining, open addressing, and double hashing are a few techniques for resolving collisions.\n\n\n![collision-in-hashing](\n\n\n\n\n* [****Open addressing****](\n  ****:****\n  collisions are handled by looking for the following empty space in the table. If the first slot is already taken, the hash function is applied to the subsequent slots until one is left empty. There are various ways to use this approach, including double hashing, linear probing, and quadratic probing.\n* [****Separate Chaining****](\n  ****:****\n  In separate chaining, a linked list of objects that hash to each slot in the hash table is present. Two keys are included in the linked list if they hash to the same slot. This method is rather simple to use and can manage several collisions.\n* ****Robin Hood hashing:****\n  To reduce the length of the chain, collisions in Robin Hood hashing are addressed by switching off keys. The algorithm compares the distance between the slot and the occupied slot of the two keys if a new key hashes to an already-occupied slot. The existing key gets swapped out with the new one if it is closer to its ideal slot. This brings the existing key closer to its ideal slot. This method has a tendency to cut down on collisions and average chain length.\n\n### Dynamic resizing:\n\n\nThis feature enables the hash table to expand or contract in response to changes in the number of elements contained in the table. This promotes a load factor that is ideal and quick lookup times.\n\n\nExample Implementation of Hash Table\n\n\nPython, Java, C++, and Ruby are just a few of the programming languages that support hash tables. They can be used as a customized data structure in addition to frequently being included in the standard library.\n\n\n****Example: hashIndex = key % noOfBuckets****\n\n\n****Insert****\n: Move to the bucket corresponding to the above-calculated hash index and insert the new node at the end of the list.\n\n\n\n****Delete****\n: To delete a node from hash table, calculate the hash index for the key, move to the bucket corresponding to the calculated hash index, and search the list in the current bucket to find and remove the node with the given key (if found).\n\n\n![](\n\n\nPlease refer\n\n[****Hashing | Set 2 (Separate Chaining)****](\n\nfor details.\n\n\n\n\n\n\n\nComplexity Analysis of a Hash Table:\n\n\nFor lookup, insertion, and deletion operations, hash tables have an average-case time complexity of O(1). Yet, these operations may, in the worst case, require O(n) time, where n is the number of elements in the table.\n\n\nApplications of Hash Table:\n\n* Hash tables are frequently used for indexing and searching massive volumes of data. A search engine might use a hash table to store the web pages that it has indexed.\n* Data is usually cached in memory via hash tables, enabling rapid access to frequently used information.\n* Hash functions are frequently used in cryptography to create digital signatures, validate data, and guarantee data integrity.\n* Hash tables can be used for implementing database indexes, enabling fast access to data based on key values.",
        "metadata": {
            "lesson_name": "Hash Table Data Structure",
            "course_name": "Introduction to DSA II"
        }
    },
    {
        "page_content": "Course Name: Matrix Data Structure Guide\nLesson Name: Print matrix in zig-zag fashion\n\nContent:\n****Example:****\n\n\n> ****Input:****\n>\n>\n> {{1, 2, 3}\n>\n>\n>\n> {4, 5, 6}\n>\n>\n>\n> {7, 8, 9}}\n>\n>\n>\n> ****Output:****\n> 1 2 4 7 5 3 6 8 9\n>\n>\n> ****Input :****\n> [[1, 2, 3, 4],\n>\n>\n>\n> [5, 6, 7, 8],\n>\n>\n>\n> [9, 10, 11, 12],\n>\n>\n>\n> [13, 14, 15, 16]]\n>\n>\n>\n> ****Output::****\n> 1 2 5 9 6 3 4 7 10 13 14 11 8 12 15 16\n\n\nThis approach uses a diagonal traversal technique to print the matrix in a zig-zag pattern. It iterates through the matrix diagonally, switching between incrementing the row and column indices based on the current position. This creates a zig-zag path that covers all elements of the matrix.\n\n\n\n\n\n\n\n****Time complexity:****\nO(n\\*m)\n\n\n\n****Auxiliary space:****\nO(1), since no extra space has been taken.\n\n",
        "metadata": {
            "lesson_name": "Print matrix in zig-zag fashion",
            "course_name": "Matrix Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Matrix Data Structure Guide\nLesson Name: Row-wise vs column-wise traversal of matrix\n\nContent:\nTwo common ways of traversing a matrix are row-major-order and column-major-order\n\n\n\n****Row Major Order:****\nWhen matrix is accessed row by row.\n\n\n\n****Column Major Order:****\nWhen matrix is accessed column by column.\n\n\n\n****Examples:****\n\n> ****Input :****\n> mat[][] = {{1, 2, 3},\n>\n>\n>\n> {4, 5, 6},\n>\n>\n>\n> {7, 8, 9}}\n>\n>\n> ****Output :****\n> Row-wise: 1 2 3 4 5 6 7 8 9\n>\n>\n>\n> Col-wise : 1 4 7 2 5 8 3 6 9\n\n\nIn many problems (like\n\n[Search in a Matrix](\n), we can use any of the above two, so the question arises which one to use?\n\n\nIf we see according to time complexity, both lead to\n\n****O(n****\n****2****\n****)****\n, but when it comes to cache level one of the orders access will be faster as compare to other one. It depends on the language we are using. Most of the languages including C, C++, Java, Python, C# and JavaScrtipt\n\n\nstore matrix in row major form so while accessing the i+1\n\nth\nelement after i\n\nth\n, most probably it will lead to a hit, which will further reduce the time of program.\n\n\nThe following codes are showing the time difference in row major and column major access.\n\n\n\n\n\n\n\n****Time Complexity:****\nO(MAX\\*MAX)\n\n\n\n****Auxiliary Space:****\nO(MAX\\*MAX)",
        "metadata": {
            "lesson_name": "Row-wise vs column-wise traversal of matrix",
            "course_name": "Matrix Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Matrix Data Structure Guide\nLesson Name: Search in a Matrix or 2D Array\n\nContent:\nGiven a matrix\n\n****mat[n][m]****\nand an element\n\n****target****\n. return true if the target is present in the matrix, else return false.\n\n\n****Examples:****\n\n> ****Input****\n> : mat[][] = { {10, 51, 9},\n>\n>\n>\n> {14, 20, 21},\n>\n>\n>\n> {30, 24, 43} }\n>\n>\n>\n> ****target****\n> = 14\n>\n>\n>\n> ****Output****\n> : Found\n>\n>\n>\n>\n>\n> ****Input****\n> : mat[][] = {{31, 5, 9, 11},\n>\n>\n>\n> {14, 7, 21, 26},\n>\n>\n>\n> {30, 4, 43, 50} }\n>\n>\n>\n> ****target****\n> = 42\n>\n>\n>\n> ****Output****\n> : Not Found\n\n\nWe traverse the mat[][] and compare target with every element of the matrix. If matches, then return true If we reach the end we will return false.\n\n\n\n\n\n\n\n\n\n\n****Time Complexity :****\nO(n \\* m), where n and m are the rows and column of matrix.\n\n\n\n****Auxiliary Space :****\nO(1)",
        "metadata": {
            "lesson_name": "Search in a Matrix or 2D Array",
            "course_name": "Matrix Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Matrix Data Structure Guide\nLesson Name: Program for addition of two matrices\n\nContent:\n\n\nGiven two\n\n****N****\nx\n\n****M matrices****\n. Find a\n\n****N****\nx\n\n****M****\nmatrix as the sum of given matrices each value at the sum of values of corresponding elements of the given two matrices.\n\n\n![](\n\n****Approach:****\nBelow is the idea to solve the problem.\n\n\n> Iterate over every cell of matrix (i, j), add the corresponding values of the two matrices and store in a single matrix i.e. the resultant matrix.\n\n\nFollow the below steps to Implement the idea:\n\n\n* Initialize a resultant matrix res[N][M].\n* Run a for loop for counter\n\n  ****i****\n  as each row and in each iteration:\n  + Run a for loop for counter\n\n    ****j****\n    as each column and in each iteration:\n    - Add values of the two matrices for index i, j and store in res[i][j].\n* Return res.\n\n\nBelow is the Implementation of above approach.\n\n\n\n\n\n\n\n\n****Time complexity:****\nO(n x m).\n\n\n\n****Auxiliary space:****\nO(n x m).  since n\n\n2\nextra space has been taken for storing results\n\n\nThe program can be extended for rectangular matrices. The following post can be useful for extending this program.",
        "metadata": {
            "lesson_name": "Program for addition of two matrices",
            "course_name": "Matrix Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Matrix Data Structure Guide\nLesson Name: Program to multiply two matrices\n\nContent:\n\n\nGiven two\n\n[matrices](\n, the task is to multiply them. Matrices can either be square or rectangular:\n\n\n****Examples:****\n\n\n> ****(Square Matrix Multiplication)****\n>\n> ****Input:****\n> m1[m][n] = { {1, 1}, {2, 2} }\n>\n>\n>\n> m2[n][p] = { {1, 1}, {2, 2} }\n>\n>\n>\n> ****Output:****\n> res[m][p] = { {3, 3}, {6, 6} }\n>\n>\n> ****(Rectangular Matrix Multiplication)****\n>\n> ****Input:****\n> m1[3][2] = { {1, 1}, {2, 2}, {3, 3} }\n>\n>\n>\n> m2[2][3] = { {1, 1, 1}, {2, 2, 2} }\n>\n>\n>\n> ****Output:****\n> res[3][3] = { {3, 3, 3}, {6, 6, 6}, {9, 9, 9} }\n>\n>\n> ![](\n\n****Multiplication of two Square or Rectangular Matrices****\n\n> * The number of columns in Matrix-1 must be equal to the number of rows in Matrix-2.\n> * Output of multiplication of Matrix-1 and Matrix-2, results with equal to the number of rows of Matrix-1 and  the number of columns of Matrix-2 i.e. rslt[R1][C2]\n\n\nBelow is the implementation of the multiplication of two\n\n[matrices](\n\n\n\n\n\n\n\n\n****Time complexity:****\nO(R1 \\* C2 \\* R2) for given matrices mat1[R1][C1] and mat2[R2][C2]\n\n\n\n****Auxiliary space:****\nO(R1 \\* C2)\n\n\n****Multiplication of Rectangular Matrices using Pointers in C/C++:****\n\n\nTo solve the problem follow the below idea:\n\n\n> We use pointers in C/C++ to multiply matrices\n\n****Prerequisite:****\n\n[How to pass a 2D array as a parameter in C?](\n\n\n\n  ",
        "metadata": {
            "lesson_name": "Program to multiply two matrices",
            "course_name": "Matrix Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Matrix Data Structure Guide\nLesson Name: Search element in a sorted matrix\n\nContent:\nGiven a\n\n****sorted****\nmatrix\n\n****mat[][]****\nof size\n\n****nxm****\nand an\n\n\nelement\n\n****x****\n, the task is to find if x is\n\n****present****\nin the matrix or not. Matrix is\n\n****sorted****\nin a way such that all elements in a\n\n****row are sorted in increasing order****\nand for row i, where 1 <= i <= n-1, the\n\n****first element****\nof\n\n****row i****\nis\n\n****greater than or equal****\nto the\n\n****last element****\nof\n\n****row i-1.****\n\n\n****Examples:****\n\n> ****Input:****\n> x = 14, mat[][] = [[ 1, 5, 9],\n>\n>\n>\n> [14, 20, 21],\n>\n>\n>\n> [30, 34, 43]]\n>\n>\n>\n> ****Output:****\n> true\n>\n>\n> ****Input:****\n> x = 42, mat[][] = [[ 1, 5, 9, 11],\n>\n>\n>\n> [14, 20, 21, 26],\n>\n>\n>\n> [30, 34, 43, 50]]\n>\n>\n>\n> ****Output:****\n> false\n\nTable of Content\n\n* [[Naive Approach] Comparing with all elements \u2013 O(n\\*m) Time and O(1) Space](#naive-solution-onm-time-and-o1-space)\n* [[Better Approach] Using Binary Search Twice \u2013 O(logn + logm) Time and O(1) Space](#using-binary-search-two-times-olog-n-log-m-time-and-o1-space)\n* [[Expected Approach] Using Binary Search Once \u2013 O(log(n\\*m)) and O(1) Space](#using-one-binary-search-olognm-and-o1-space)\n### ****[Naive Approach] Comparing with all elements \u2013 O(n\\*m) Time and O(1) Space****\n\n\nIn this approach, we will iterate through the entire\n\n****matrix mat[][]****\nand compare\n\n****each element****\nwith\n\n****x****\n. If an element matches the x, we will\n\n****return true****\n. Otherwise, at the end of the traversal, we will\n\n****return false.****\nPlease refer to\n\n[Searching Algorithms for 2D Arrays (Matrix)](\nto know more about the implementation.\n\n\n### ****[Better Approach] Using Binary Search Twice \u2013**** O(logn + logm) Time and O(1) Space\n\n\nFirst, we locate the row where the\n\n****target x****\nmight be by using\n\n****binary search****\n, and then we apply binary search again within that row.\n\n\n\n> To find the correct row, we perform\n>\n> ****binary search****\n> on the\n>\n> ****first****\n> elements of the middle row.\n>\n>\n>\n> Start with l\n>\n> ****ow = 0****\n> and\n>\n> ****high = n \u2013 1.****\n>\n> 1. If\n>\n>    ****x is smaller****\n>    than the\n>\n>    ****first element****\n>    of the middle row\n>\n>    ****(a[mid][0]),****\n>    then x will be smaller than all elements in rows >= mid, so update\n>\n>    ****high = mid \u2013 1.****\n> 2. If\n>\n>    ****x is greater****\n>    than the\n>\n>    ****first element****\n>    of the middle row\n>\n>    ****(a[mid][0])****\n>    , then x will be greater than all elements in rows < mid, so store the current mid row and update\n>\n>    ****low = mid + 1****\n>    .\n>\n>\n> Once we have found the\n>\n> ****correct row,****\n> we can apply\n>\n> ****binary search****\n> within that row to search for the\n>\n> ****target****\n> element\n>\n> ****x****\n> .\n\n\n\n\n\n\n### ****[Expected Approach] Using Binary Search Once \u2013**** O(log(n\\*m)) and O(1) Space\n\n> The idea is to\n>\n> ****consider the given matrix as 1D array****\n> and\n>\n> ****apply****\n> only one\n>\n> ****binary search.****\n> For example, for a matrix of size\n>\n> ****n x m a****\n> nd we can consider it as a\n>\n> ****1D array****\n> of size n\\*m\n>\n> ****,****\n> then the\n>\n> ****first index****\n> would be\n>\n> ****0****\n> and\n>\n> ****last index****\n> would\n>\n> ****n\\*m-1.****\n> So\n>\n> ****,****\n> we need to do binary search from low = 0 to high = (n\\*m-1)\n>\n> ****.****\n>\n> ****How to find the element in 2D matrix corresponding to index = mid?****\n>\n>\n> Since each row of mat[][] will have\n>\n> ****m****\n> elements, so we can find the row of the element as\n>\n> ****(mid / m)****\n> and the column of the element as\n>\n> ****(mid % m)****\n> . Then, we can compare\n>\n> ****x****\n> with\n>\n> ****arr[mid/m][mid%m]****\n> for each mid and complete our binary search.\n\n\n\n\n\n",
        "metadata": {
            "lesson_name": "Search element in a sorted matrix",
            "course_name": "Matrix Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Matrix Data Structure Guide\nLesson Name: Program for subtraction of matrices\n\nContent:\nGiven two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.\n\n\n> ****Input:****\n> m1 = {{1, 2},\n>\n>\n>\n> {3, 4}},\n>\n>\n>\n> m2 = {{4, 3},\n>\n>\n>\n> {2, 1}}\n>\n>\n>\n> ****Output:****\n> {{-3, -1},\n>\n>\n>\n> {1, 3}}\n>\n>\n>\n>\n>\n> ****Input:****\n> m1 = {{3, 3, 3},\n>\n>\n>\n> {3, 3, 3}},\n>\n>\n>\n> m1 = {{2, 2, 2},\n>\n>\n>\n> {1, 1, 1}},\n>\n>\n>\n> ****Output:****\n> {{1, 1, 1},\n>\n>\n>\n> {2, 2, 2}},\n\n\nWe traverse both matrices element by element and subtract m2[i][j] from m1[i][j].\n\n\n\n\n\n\n\n\n\n****Time complexity: O(n****\n****2****\n****)****\n",
        "metadata": {
            "lesson_name": "Program for subtraction of matrices",
            "course_name": "Matrix Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA II\nLesson Name: Collision Resolution Techniques\n\nContent:\nCollision Resolution Techniques\n\n\nThere are mainly two methods to handle collision:\n\n\n1. Separate Chaining\n2. Open Addressing\n\n![Collision-Resolution-Techniques](\n\n### 1) Separate Chaining\n\n\nThe idea behind\n\n[Separate Chaining](\nis to make each cell of the hash table point to a linked list of records that have the same hash function value. Chaining is simple but requires additional memory outside the table.\n\n\n****Example****\n: We have given a hash function and we have to insert some elements in the hash table using a separate chaining method for collision resolution technique.\n\n\n> Hash function = key % 5,\n>\n>\n>\n> Elements = 12, 15, 22, 25 and 37.\n\n\nLet\u2019s see step by step approach to how to solve the above problem:\n\n\n\n\n\n\n\n\n\nHence In this way, the separate chaining method is used as the collision resolution technique.\n\n\n### 2) Open Addressing\n\n\nIn\n\n[open addressing](\n, all elements are stored in the hash table itself. Each table entry contains either a record or NIL. When searching for an element, we examine the table slots one by one until the desired element is found or it is clear that the element is not in the table.\n\n\n#### 2.a) Linear Probing\n\n\nIn linear probing, the hash table is searched sequentially that starts from the original location of the hash. If in case the location that we get is already occupied, then we check for the next location.\n\n\n****Example:****\nLet us consider a simple hash function as \u201ckey mod 5\u201d and a sequence of keys that are to be inserted are 50, 70, 76, 85, 93.\n\n\n\n\n\n\n\n\n\n\n#### 2.b) Quadratic Probing\n\n\nQuadratic probing is an open addressing scheme in computer programming for resolving hash collisions in hash tables. Quadratic probing operates by taking the original hash index and adding successive values of an arbitrary quadratic polynomial until an open slot is found.\n\n\nThis method is also known as the mid-square method because in this method we look for i\n\n2\nth probe (slot) in i-th iteration and the value of i = 0, 1, . . . n \u2013 1. We always start from the original hash location. If only the location is occupied then we check the other slots.\n\n\n\nExample: Let us consider table Size = 7, hash function as Hash(x) = x % 7 and collision resolution strategy to be f(i) = i\n\n2\n. Insert = 22, 30, and 50\n\n\n\n\n\n\n\n\n#### 2.c) Double Hashing\n\n\nDouble hashing is a collision resolving technique in\n\n[Open Addressed](\nHash tables. Double hashing make use of two hash function,\n\n\n* The first hash function is\n\n  ****h1(k)****\n  which takes the key and gives out a location on the hash table. But if the new location is not occupied or empty then we can easily place our key.\n* But in case the location is occupied (collision) we will use secondary hash-function\n\n  ****h2(k)****\n  in combination with the first hash-function\n\n  ****h1(k)****\n  to find the new location on the hash table.\n\n\nThis combination of hash functions is of the form\n\n\n> ****h(k, i) = (h1(k) + i \\* h2(k)) % n****\n\n\nwhere\n\n\n* i is a non-negative integer that indicates a collision number,\n* k = element/key which is being hashed\n* n = hash table size.\n\n****Complexity of the Double hashing algorithm:****\n\n> Time complexity: O(n)\n\n****Example:****\nInsert the keys 27, 43, 692, 72 into the Hash Table of size 7. where first hash-function is\n\n****h1\u200b(k) = k mod 7****\nand second hash-function is\n\n****h2(k) = 1 + (k mod 5)****\n\n",
        "metadata": {
            "lesson_name": "Collision Resolution Techniques",
            "course_name": "Introduction to DSA II"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: Getting Started with Array Data Structure\n\nContent:\nBasic terminologies of Array\n\n* ****Array Index:****\n  In an array, elements are identified by their indexes. Array index\n  starts from 0.\n* ****Array element:**** Elements are items stored in an array and can be accessed by their\n  index.\n* ****Array Length:****\n  The length of an array is determined by the number of elements it can\n  contain.\n\nMemory representation of Array\n\nIn an array, all the elements are stored in contiguous memory\nlocations. So, if we initialize an array, the elements will be allocated\nsequentially in memory. This allows for efficient access and\nmanipulation of elements.\n\n![Memory-Representation-of-Array-(1)](\n\nDeclaration of Array\n\nArrays can be declared in various ways in different languages. For\nbetter illustration, below are some language-specific array\n\n\n\n\n\n\n\n\n\n\n\n\nInitialization of Array\n\nArrays can be initialized in different ways in different languages.\nBelow are some language-specific array initializations:\n\n\n\n\n\n\n\n\n\n\nWhy do we Need Arrays?\n\nAssume there is a class of five students and if we have to keep records\nof their marks in examination then, we can do this by declaring five\nvariables individual and keeping track of records but what if the number\nof students becomes very large, it would be challenging to manipulate\nand maintain the data.\n\nWhat it means is that, we can use normal variables (v1, v2, v3, ..)\nwhen we have a small number of objects. But if we want to store a large\nnumber of instances, it becomes difficult to manage them with normal\nvariables. ****The idea of an array is to represent many instances in one\nvariable****.\n\n\n![Importance-of-Array](\n\nTypes of Arrays\n\nArrays can be classified in two ways:\n\n* On the basis of Size\n* On the basis of Dimensions\n\n![Types-of-Arrays](\n### Types of Arrays on the basis of Size:\n\n****1. Fixed Sized Arrays:****\n\nWe cannot alter or update the size of this array. Here only a fixed\nsize (i,e. the size that is mentioned in square brackets ****[]****) of memory will be allocated for storage. In case, we don\u2019t know the\nsize of the array then if we declare a larger size and store a lesser\nnumber of elements will result in a wastage of memory or we declare a\nlesser size than the number of elements then we won\u2019t get enough memory\nto store all the elements. In such cases, static memory allocation is\nnot preferred.\n\n\n\n\n\n\n\n\n\n****2. Dynamic Sized Arrays:****\n\nThe size of the array changes as per user requirements during execution\nof code so the coders do not have to worry about sizes. They can add and\nremoved the elements as per the need. The memory is mostly dynamically\nallocated and de-allocated in these arrays.\n\n\n\n\n\n\n\n\n\n\n### Types of Arrays on the basis of Dimensions:\n\n****1. One-dimensional Array(1-D Array):**** You can imagine a 1d array as a row, where elements are stored one\nafter another.\n\n![One-Dimensional-Array(1-D-Array)](\n\n****2. Multi-dimensional Array:****\nA multi-dimensional array is an array with more than one dimension. We\ncan use multidimensional array to store complex data in the form of\ntables, etc. We can have 2-D arrays, 3-D arrays, 4-D arrays and so on.\n\n\n* [****Two-Dimensional Array(2-D Array or Matrix):****]( Multidimensional arrays can be considered as an array of\n  arrays or as a matrix consisting of rows and columns.\n\n![Two-Dimensional-Array(2-D-Array-or-Matrix)](\n\n* ****Three-Dimensional Array(3-D Array):**** A 3-D Multidimensional array contains three dimensions, so\n  it can be considered an array of two-dimensional arrays.\n\n![Three-Dimensional-Array(3-D-Array)](\n\nOperations on Array\n\n### 1. Array Traversal:\n\nArray traversal involves visiting all the elements of the array once.\n\n\n\n\n\n\n\n### 2. Insertion in Array:\n\nWe can insert one or multiple elements at any position in the array.\n\n\n\n\n\n\n\n\n### 3. Deletion in Array:\n\nWe can delete an element at any index in an array. Below is the\n\n\n\n\n\n\n\n\n\n\n\n\n### 4. Searching in Array:\n\nWe can traverse over an array and search for an element. Below is the\n\n\n\n\n\n\n\n\nComplexity Analysis of Operations on Array\n\n### Time Complexity:\n\n| Operation | Best Case | Average Case | Worst Case |\n| --- | --- | --- | --- |\n| ****Traversal**** | \u03b8(N) | \u03b8(N) | \u03b8((N) |\n| ****Insertion**** | \u03b8((1) | \u03b8(N) | \u03b8(N) |\n| ****Deletion**** | \u03b8(1) | \u03b8(N) | \u03b8(N) |\n| ****Searching**** | \u03b8(1) | \u03b8(N) | \u03b8(N) |\n\n### Auxiliary Space\n\n| Operation | Best Case | Average Case | Worst Case |\n| --- | --- | --- | --- |\n| ****Traversal**** | \u03b8(1) | \u03b8(1) | \u03b8(1) |\n| ****Insertion**** | \u03b8(1) | \u03b8(N) | \u03b8(N) |\n| ****Deletion**** | \u03b8(1) | \u03b8(N) | \u03b8(N) |\n| ****Searching**** | \u03b8(1) | \u03b8(1) | \u03b8(1) |\n",
        "metadata": {
            "lesson_name": "Getting Started with Array Data Structure",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: Matrix Data Structure Guide\nLesson Name: Traverse a given Matrix using Recursion\n\nContent:\nGiven a\n\n[matrix](\n\n****mat[][]****\nof size\n\n****n x m****\n, the task is to traverse this matrix\n\n[using recursion](\n.\n\n\n\n****Examples:****\n\n\n> ****Input:****\n> mat[][] = [[1, 2, 3],\n>\n>\n>\n> [4, 5, 6],\n>\n>\n>\n> [7, 8, 9]]\n>\n>\n>\n> ****Output:****\n> 1 2 3 4 5 6 7 8 9\n>\n>\n>\n>\n>\n> ****Input:****\n> mat[][] = [[11, 12, 13],\n>\n>\n>\n> [14, 15, 16],\n>\n>\n>\n> [17, 18, 19]]\n>\n>\n>\n> ****Output:****\n> 11 12 13 14 15 16 17 18 19\n\n****Approach:****\n\n\n* Check If the current position is in the bottom-right corner of the matrix\n\n\n\n\n\n\n\n****Time Complexity:****\nO(N \\* M)\n\n\n\n****Auxiliary Space:****\nO(M), because of recursive calling\n\n",
        "metadata": {
            "lesson_name": "Traverse a given Matrix using Recursion",
            "course_name": "Matrix Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Matrix Data Structure Guide\nLesson Name: Program to find transpose of a matrix\n\nContent:\n\nGiven a matrix of size n X m, find the transpose of the matrix.\n\n[Transpose of a matrix](\nis obtained by changing rows to columns and columns to rows. In other words, transpose of mat[n][m] is obtained by changing mat[i][j] to mat[j][i].\n\n\n****Example:****\n\n> ![matrix-transpose](\n\n\nFollow the given steps to solve the problem:\n\n\n* Run a nested loop using two integer pointers i and j for 0 <= i < n and 0 <= j < m\n* Set mat[i][j] equal to mat[j][i]\n\n\n\n\n\n\n\n\n****Time complexity:****\nO(m x n).\n\n\n\n****Auxiliary Space:****\nO(m x n)\n\n\n### ****Approach using constant space for Square Matrix****\n\n**This approach works only for square matrices (i.e., \u2013 where no. of rows are equal to the number of columns). This algorithm is also known as an \u201cin-place\u201d algorithm as it uses no extra space to solve the problem.**\n\n\nFollow the given steps to solve the problem:\n\n\n* Run a nested loop using two integer pointers i and j for 0 <= i < N and i+1 <= j < N\n* Swap mat[i][j] with mat[j][i]\n\n\n\n\n\n\n\n\n****Time complexity:****\nO(n\n\n2\n).\n\n\n\n****Auxiliary Space:****\nO(1)\n",
        "metadata": {
            "lesson_name": "Program to find transpose of a matrix",
            "course_name": "Matrix Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Matrix Data Structure Guide\nLesson Name: Program to find Determinant of a Matrix\n\nContent:\n\n****Determinant of 2 x 2 Matrix:****\n\n![](\n\nDeterminant of 2 x 2 matrix\n\n****Determinant of 3 x 3 Matrix:****\n\n![](\n\nDeterminant of 3 x 3 matrix\n\n****How to calculate?****\n\n\nThe value of the determinant of a matrix can be calculated by the following procedure:\n\n\n* For each element of the first row or first column get the cofactor of those elements.\n* Then multiply the element with the determinant of the corresponding cofactor.\n* Finally, add them with alternate signs. As a base case, the value of the determinant of a 1\\*1 matrix is the single value itself.\n\n\nThe\n\n****cofactor****\nof an element is a matrix that we can get by removing the row and column of that element from that matrix.\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(n\n\n4\n)\n\n\n\n****Space Complexity:****\nO(n\n\n2\n), Auxiliary space used for storing cofactors.\n\n\n****Note:****\nIn the above recursive approach when the size of the matrix is large it consumes more stack size.\n\n\nDeterminant of a Matrix using Determinant properties:\n\n\nWe calculates the determinant of an\n\n`N x N`\nmatrix using Gaussian elimination and a series of transformations that reduce the matrix to upper triangular form.\n\n\n\n> * Converting the given matrix into an\n>\n>   ****upper triangular matrix****\n>   using determinant properties\n> * The determinant of the upper triangular matrix is the product of all diagonal elements.\n> * Iterating every diagonal element and making all the elements down the diagonal as zero using determinant properties\n> * If the diagonal element is zero then search for the next non-zero element in the same column.\n\n\nThere exist two cases:\n\n\n* ****Case 1:****\n  If there is no non-zero element. In this case, the determinant of a matrix is zero\n* ****Case 2:****\n  If there exists a non-zero element there exist two cases\n  + ****Case A:****\n    If the index is with a respective diagonal row element. Using the determinant properties make all the column elements down to it zero\n  + ****Case B:****\n    Swap the row with respect to the diagonal element column and continue the\n\n    ****Case A****\n    operation.\n\n\n\n\n\n\n\n****Time complexity:****\nO(n\n\n3\n)\n\n\n\n****Auxiliary Space:****\nO(n), Space used for storing row.\n\n\n\n\n\n****Determinant of a Matrix****\n\n\nThere is a built-in function or method in\n\n****linalg****\nmodule of\n\n****NumPy****\npackage in python. It can be called\n\n****numpy.linalg.det(mat)****\nwhich returns the determinant value of the matrix mat passed in the argument.\n\n\n\n****Time Complexity:****\nO(n\n\n3\n), as the time complexity of np.linalg.det is O(n\n\n3\n) for an n x n order matrix.\n\n\n\n****Auxiliary Space:****\nO(1)\n",
        "metadata": {
            "lesson_name": "Program to find Determinant of a Matrix",
            "course_name": "Matrix Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Matrix Data Structure Guide\nLesson Name: Adjoint and Inverse of a Matrix\n\nContent:\nGiven a square matrix, find the adjoint and\n\n[inverse](\nof the matrix. We strongly recommend you to refer\n\n[determinant of matrix](\nas a prerequisite for this.\n\n\n****Adjoint****\n(or Adjugate) of a matrix is the matrix obtained by taking the transpose of the cofactor matrix of a given square matrix is called its Adjoint or Adjugate matrix. The Adjoint of any square matrix \u2018A\u2019 (say) is represented as Adj(A).\n\n\n****Important properties:****\n\n\nProduct of a square matrix A with its adjoint yields a diagonal matrix, where each diagonal entry is equal to determinant of A.\n\n\n\ni.e.\n\n\n\nA non-zero square matrix \u2018A\u2019 of order n is said to be\n\n****invertible****\nif there exists a unique square matrix \u2018B\u2019 of order n such that,\n\nLet A[N][N] be input matrix.\n1) Create a matrix adj[N][N] store the adjoint matrix.\n2) For every entry A[i][j] in input matrix where 0 <= i < N\n                                             and 0 <= j < N.\n    a) Find cofactor of A[i][j]\n    b) Find sign of entry.  Sign is + if (i+j) is even else\n    sign is odd.\n    c) Place the cofactor at adj[j][i]\n    ```\n\n    ****How to find Inverse?****\n\n\n    Inverse of a matrix exists only if the matrix is non-singular i.e., determinant should not be 0.\n\n\n\n    Using determinant and adjoint, we can easily find the inverse of a square matrix using the below formula,\n\n\n    ```\n    If det(A) != 0\n    A-1 = adj(A)/det(A)\n    Else\n    \"Inverse doesn't exist\"\n    ```\n\n\n    Inverse is used to find the solution to a system of linear equations.\n\n\n    Below are implementations for finding adjoint and inverse of a matrix.\n\n\n    C++\n\n    ````\n    #include <iostream>\n    #include <vector>\n    using namespace std;\n\n    // Function to get cofactor of mat[p][q] in cof[][]. n is\n    // current dimension of mat[][]\n    void getCof(vector<vector<int>>& mat, vector<vector<int>>& cof,\n                                            int p, int q, int n) {\n        int i = 0, j = 0;\n        for (int row = 0; row < n; row++) {\n            for (int col = 0; col < n; col++) {\n                if (row != p && col != q) {\n                    cof[i][j++] = mat[row][col];\n                    if (j == n - 1) {\n                        j = 0;\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n\n    // Recursive function for finding determinant\n    // of matrix mat of dimension n\n    int getDet(vector<vector<int>>& mat, int n) {\n        if (n == 1) return mat[0][0];\n\n        int det = 0;\n\n        // To store cofactors\n        vector<vector<int>> cof(mat.size(), vector<int>(mat.size()));\n\n        int sign = 1;\n        for (int f = 0; f < n; f++) {\n            getCof(mat, cof, 0, f, n);\n            det += sign * mat[0][f] * getDet(cof, n - 1);\n            sign = -sign;\n        }\n        return det;\n    }\n\n    // Function to get adjoint of mat in adj\n    void adjoint(vector<vector<int>>& mat, vector<vector<int>>& adj) {\n        int n = mat.size();\n        if (n == 1) {\n            adj[0][0] = 1;\n            return;\n        }\n\n        int sign = 1;\n        vector<vector<int>> cof(n, vector<int>(n));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                getCof(mat, cof, i, j, n);\n                sign = ((i + j) % 2 == 0) ? 1 : -1;\n                adj[j][i] = sign * getDet(cof, n - 1);\n            }\n        }\n    }\n\n    // Function to calculate and store inverse, returns\n    // false if matrix is singular\n    bool inverse(vector<vector<int>>& mat, vector<vector<float>>& inv) {\n        int n = mat.size();\n        int det = getDet(mat, n);\n        if (det == 0) {\n            cout << \"Singular matrix, can't find its inverse\";\n            return false;\n        }\n\n        vector<vector<int>> adj(n, vector<int>(n));\n        adjoint(mat, adj);\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                inv[i][j] = adj[i][j] / float(det);\n\n        return true;\n    }\n\n    int main() {\n        vector<vector<int>> mat = { { 5, -2, 2, 7 },\n                                    { 1, 0, 0, 3 },\n                                    { -3, 1, 5, 0 },\n                                    { 3, -1, -9, 4 } };\n\n        int n = mat.size();\n        vector<vector<int>> adj(n, vector<int>(n)); // To store adjoint\n        vector<vector<float>> inv(n, vector<float>(n)); // To store inverse\n\n        // Print the input matrix\n        cout << \"Input matrix is:\\n\";\n        for (auto& row : mat) {\n            for (int val : row) cout << val << \" \";\n            cout << endl;\n        }\n\n        // Print the adjoint matrix\n        cout << \"\\nThe Adjoint is:\\n\";\n        adjoint(mat, adj);\n        for (auto& row : adj) {\n            for (int val : row) cout << val << \" \";\n            cout << endl;\n        }\n\n        // Print the inverse matrix if it exists\n        cout << \"\\nThe Inverse is:\\n\";\n        if (inverse(mat, inv)) {\n            for (auto& row : inv) {\n                for (float val : row) cout << val << \" \";\n                cout << endl;\n            }\n        }\n\n        return 0;\n    }\n\n    ````\n\n    C\n\n    ````\n    #include <stdio.h>\n\n    #define N 4\n\n    // Function to get cofactor of mat[p][q] in cof[][]. n is\n    // current dimension of mat[][]\n    void getCof(int mat[N][N], int cof[N][N], int p, int q, int n) {\n        int i = 0, j = 0;\n        for (int row = 0; row < n; row++) {\n            for (int col = 0; col < n; col++) {\n                if (row != p && col != q) {\n                    cof[i][j++] = mat[row][col];\n                    if (j == n - 1) {\n                        j = 0;\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n\n    // Recursive function for finding determinant of matrix mat of dimension n\n    int getDet(int mat[N][N], int n) {\n        if (n == 1) return mat[0][0];\n        int det = 0;\n\n        int cof[N][N];\n        int sign = 1;\n        for (int f = 0; f < n; f++) {\n            getCof(mat, cof, 0, f, n);\n            det += sign * mat[0][f] * getDet(cof, n - 1);\n            sign = -sign;\n        }\n        return det;\n    }\n\n    // Function to get adjoint of mat in adj\n    void adjoint(int mat[N][N], double adj[N][N]) {\n        if (N == 1) {\n            adj[0][0] = 1;\n            return;\n        }\n\n        int sign = 1;\n        int cof[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                getCof(mat, cof, i, j, N);\n                sign = ((i + j) % 2 == 0) ? 1 : -1;\n                adj[j][i] = sign * getDet(cof, N - 1);\n            }\n        }\n    }\n\n    // Function to calculate and store inverse, returns 0 if matrix is singular\n    int inverse(int mat[N][N], double inv[N][N]) {\n        int det = getDet(mat, N);\n        if (det == 0) {\n            printf(\"Singular matrix, can't find its inverse\\n\");\n            return 0;\n        }\n\n        double adj[N][N];\n        adjoint(mat, adj);\n\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                inv[i][j] = adj[i][j] / det;\n\n        return 1;\n    }\n\n    int main() {\n        int mat[N][N] = { { 5, -2, 2, 7 },\n                          { 1, 0, 0, 3 },\n                          { -3, 1, 5, 0 },\n                          { 3, -1, -9, 4 } };\n\n        double adj[N][N];\n        double inv[N][N];\n\n        // Print the input matrix\n        printf(\"Input matrix is:\\n\");\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                printf(\"%d \", mat[i][j]);\n            }\n            printf(\"\\n\");\n        }\n\n        // Print the adjoint matrix\n        printf(\"\\nThe Adjoint is:\\n\");\n        adjoint(mat, adj);\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                printf(\"%lf \", adj[i][j]);\n            }\n            printf(\"\\n\");\n        }\n\n        // Print the inverse matrix if it exists\n        printf(\"\\nThe Inverse is:\\n\");\n        if (inverse(mat, inv)) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    printf(\"%lf \", inv[i][j]);\n                }\n                printf(\"\\n\");\n            }\n        }\n        return 0;\n    }\n\n    ````\n\n    Java\n\n    ````\n    // Importing required classes\n    import java.util.Arrays;\n    import java.util.Scanner;\n\n    public class GfG {\n\n        // Function to get cofactor of mat[p][q] in cof[][]\n        static void getCof(int[][] mat, int[][] cof, int p, int q, int n) {\n            int i = 0, j = 0;\n            for (int row = 0; row < n; row++) {\n                for (int col = 0; col < n; col++) {\n                    if (row != p && col != q) {\n                        cof[i][j++] = mat[row][col];\n                        if (j == n - 1) {\n                            j = 0;\n                            i++;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Recursive function for finding determinant of\n        // matrix mat of dimension n\n        static int getDet(int[][] mat, int n) {\n            if (n == 1) return mat[0][0];\n            int det = 0;\n            int[][] cof = new int[n][n];\n            int sign = 1;\n            for (int f = 0; f < n; f++) {\n                getCof(mat, cof, 0, f, n);\n                det += sign * mat[0][f] * getDet(cof, n - 1);\n                sign = -sign;\n            }\n            return det;\n        }\n\n        // Function to get adjoint of mat in adj\n        static void adjoint(int[][] mat, int[][] adj) {\n            int n = mat.length;\n            if (n == 1) {\n                adj[0][0] = 1;\n                return;\n            }\n            int sign;\n            int[][] cof = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    getCof(mat, cof, i, j, n);\n                    sign = ((i + j) % 2 == 0) ? 1 : -1;\n                    adj[j][i] = sign * getDet(cof, n - 1);\n                }\n            }\n        }\n\n        // Function to calculate and store inverse, returns\n        // false if matrix is singular\n        static boolean inverse(int[][] mat, float[][] inv) {\n            int n = mat.length;\n            int det = getDet(mat, n);\n            if (det == 0) {\n                System.out.println(\"Singular matrix, can't find its inverse\");\n                return false;\n            }\n            int[][] adj = new int[n][n];\n            adjoint(mat, adj);\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    inv[i][j] = (float) adj[i][j] / det;\n            return true;\n        }\n\n        public static void main(String[] args) {\n            int[][] mat = { { 5, -2, 2, 7 }, { 1, 0, 0, 3 },\n                            { -3, 1, 5, 0 }, { 3, -1, -9, 4 } };\n            int n = mat.length;\n            int[][] adj = new int[n][n]; // To store adjoint\n            float[][] inv = new float[n][n]; // To store inverse\n\n            // Print the input matrix\n            System.out.println(\"Input matrix is:\");\n            for (int[] row : mat) {\n                System.out.println(Arrays.toString(row));\n            }\n\n            // Print the adjoint matrix\n            System.out.println(\"\\nThe Adjoint is:\");\n            adjoint(mat, adj);\n            for (int[] row : adj) {\n                System.out.println(Arrays.toString(row));\n            }\n\n            // Print the inverse matrix if it exists\n            System.out.println(\"\\nThe Inverse is:\");\n            if (inverse(mat, inv)) {\n                for (float[] row : inv) {\n                    System.out.println(Arrays.toString(row));\n                }\n            }\n        }\n    }\n\n    ````\n\n    Python\n\n    ````\n    # Function to get cofactor of mat[p][q] in cof[][]\n    def get_cof(mat, cof, p, q, n):\n        i = 0\n        j = 0\n        for row in range(n):\n            for col in range(n):\n                if row != p and col != q:\n                    cof[i][j] = mat[row][col]\n                    j += 1\n                    if j == n - 1:\n                        j = 0\n                        i += 1\n\n    # Recursive function for finding determinant\n    # of matrix mat of dimension n\n    def get_det(mat, n):\n        if n == 1:\n            return mat[0][0]\n        det = 0\n        cof = [[0] * n for _ in range(n)]  # To store cofactors\n        sign = 1\n        for f in range(n):\n            get_cof(mat, cof, 0, f, n)\n            det += sign * mat[0][f] * get_det(cof, n - 1)\n            sign = -sign\n        return det\n\n    # Function to get adjoint of mat in adj\n    def adjoint(mat, adj):\n        n = len(mat)\n        if n == 1:\n            adj[0][0] = 1\n            return\n        sign = 1\n        cof = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                get_cof(mat, cof, i, j, n)\n                sign = 1 if (i + j) % 2 == 0 else -1\n                adj[j][i] = sign * get_det(cof, n - 1)\n\n    # Function to calculate and store inverse, returns\n    # false if matrix is singular\n    def inverse(mat):\n        n = len(mat)\n        det = get_det(mat, n)\n        if det == 0:\n            print(\"Singular matrix, can't find its inverse\")\n            return None\n        adj = [[0] * n for _ in range(n)]\n        adjoint(mat, adj)\n        inv = [[adj[i][j] / det for j in range(n)] for i in range(n)]\n        return inv\n\n    if __name__ == '__main__':\n        mat = [[5, -2, 2, 7], [1, 0, 0, 3], [-3, 1, 5, 0], [3, -1, -9, 4]]\n        n = len(mat)\n        adj = [[0] * n for _ in range(n)]  # To store adjoint\n\n        # Print the input matrix\n        print(\"Input matrix is:\")\n        for row in mat:\n            print(row)\n\n        # Print the adjoint matrix\n        print(\"\\nThe Adjoint is:\")\n        adjoint(mat, adj)\n        for row in adj:\n            print(row)\n\n        # Print the inverse matrix if it exists\n        print(\"\\nThe Inverse is:\")\n        inv = inverse(mat)\n        if inv:\n            for row in inv:\n                print(row)\n\n    ````\n\n    C#\n\n    ````\n    using System;\n\n    class MatrixOperations {\n\n        // Function to get cofactor of mat[p][q] in cof[][]. n is\n        // current dimension of mat[][]\n        static void GetCof(int[,] mat, int[,] cof, int p, int q, int n) {\n            int i = 0, j = 0;\n            for (int row = 0; row < n; row++) {\n                for (int col = 0; col < n; col++) {\n                    if (row != p && col != q) {\n                        cof[i, j++] = mat[row, col];\n                        if (j == n - 1) {\n                            j = 0;\n                            i++;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Recursive function for finding determinant of matrix mat of dimension n\n        static int GetDet(int[,] mat, int n) {\n            if (n == 1) return mat[0, 0];\n            int det = 0;\n\n            // To store cofactors\n            int[,] cof = new int[n, n];\n\n            int sign = 1;\n            for (int f = 0; f < n; f++) {\n                GetCof(mat, cof, 0, f, n);\n                det += sign * mat[0, f] * GetDet(cof, n - 1);\n                sign = -sign;\n            }\n            return det;\n        }\n\n        // Function to get adjoint of mat in adj\n        static void Adjoint(int[,] mat, double[,] adj) {\n            int n = mat.GetLength(0);\n            if (n == 1) {\n                adj[0, 0] = 1;\n                return;\n            }\n\n            int sign = 1;\n            int[,] cof = new int[n, n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    GetCof(mat, cof, i, j, n);\n                    sign = ((i + j) % 2 == 0) ? 1 : -1;\n                    adj[j, i] = sign * GetDet(cof, n - 1);\n                }\n            }\n        }\n\n        // Function to calculate and store inverse, returns false if matrix is singular\n        static bool Inverse(int[,] mat, double[,] inv) {\n            int n = mat.GetLength(0);\n            int det = GetDet(mat, n);\n            if (det == 0) {\n                Console.WriteLine(\"Singular matrix, can't find its inverse\");\n                return false;\n            }\n\n            double[,] adj = new double[n, n];\n            Adjoint(mat, adj);\n\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    inv[i, j] = adj[i, j] / det;\n\n            return true;\n        }\n\n        static void Main() {\n            int[,] mat = new int[,] { { 5, -2, 2, 7 },\n                                       { 1, 0, 0, 3 },\n                                       { -3, 1, 5, 0 },\n                                       { 3, -1, -9, 4 } };\n            int n = mat.GetLength(0);\n            double[,] adj = new double[n, n]; // To store adjoint\n            double[,] inv = new double[n, n]; // To store inverse\n\n            // Print the input matrix\n            Console.WriteLine(\"Input matrix is:\");\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    Console.Write(mat[i, j] + \" \");\n                }\n                Console.WriteLine();\n            }\n\n            // Print the adjoint matrix\n            Console.WriteLine(\"\\nThe Adjoint is:\");\n            Adjoint(mat, adj);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    Console.Write(adj[i, j] + \" \");\n                }\n                Console.WriteLine();\n            }\n\n            // Print the inverse matrix if it exists\n            Console.WriteLine(\"\\nThe Inverse is:\");\n            if (Inverse(mat, inv)) {\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        Console.Write(inv[i, j] + \" \");\n                    }\n                    Console.WriteLine();\n                }\n            }\n        }\n    }\n\n    ````\n\n    JavaScript\n\n    ````\n    // Function to get cofactor of mat[p][q] in cof[][]. n is\n    // current dimension of mat[][]\n    function getCof(mat, cof, p, q, n) {\n        let i = 0, j = 0;\n        for (let row = 0; row < n; row++) {\n            for (let col = 0; col < n; col++) {\n                if (row !== p && col !== q) {\n                    cof[i][j++] = mat[row][col];\n                    if (j === n - 1) {\n                        j = 0;\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n\n    // Recursive function for finding determinant\n    // of matrix mat of dimension n\n    function getDet(mat, n) {\n        if (n === 1) return mat[0][0];\n        let det = 0;\n\n        // To store cofactors\n        let cof = Array.from({ length: mat.length }, () => Array(mat.length).fill(0));\n\n        let sign = 1;\n        for (let f = 0; f < n; f++) {\n            getCof(mat, cof, 0, f, n);\n            det += sign * mat[0][f] * getDet(cof, n - 1);\n            sign = -sign;\n        }\n        return det;\n    }\n\n    // Function to get adjoint of mat in adj\n    function adjoint(mat, adj) {\n        let n = mat.length;\n        if (n === 1) {\n            adj[0][0] = 1;\n            return;\n        }\n\n        let sign = 1;\n        let cof = Array.from({ length: n }, () => Array(n).fill(0));\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                getCof(mat, cof, i, j, n);\n                sign = ((i + j) % 2 === 0) ? 1 : -1;\n                adj[j][i] = sign * getDet(cof, n - 1);\n            }\n        }\n    }\n\n    // Function to calculate and store inverse, returns\n    // false if matrix is singular\n    function inverse(mat, inv) {\n        let n = mat.length;\n        let det = getDet(mat, n);\n        if (det === 0) {\n            console.log(\"Singular matrix, can't find its inverse\");\n            return false;\n        }\n\n        let adj = Array.from({ length: n }, () => Array(n).fill(0));\n        adjoint(mat, adj);\n\n        for (let i = 0; i < n; i++)\n            for (let j = 0; j < n; j++)\n                inv[i][j] = adj[i][j] / det;\n\n        return true;\n    }\n\n    let mat = [ [ 5, -2, 2, 7 ],\n                [ 1, 0, 0, 3 ],\n                [ -3, 1, 5, 0 ],\n                [ 3, -1, -9, 4 ] ];\n\n    let n = mat.length;\n    let adj = Array.from({ length: n }, () => Array(n).fill(0)); // To store adjoint\n    let inv = Array.from({ length: n }, () => Array(n).fill(0)); // To store inverse\n\n    // Print the input matrix\n    console.log(\"Input matrix is:\");\n    mat.forEach(row => {\n        console.log(row.join(' '));\n    });\n\n    // Print the adjoint matrix\n    console.log(\"\\nThe Adjoint is:\");\n    adjoint(mat, adj);\n    adj.forEach(row => {\n        console.log(row.join(' '));\n    });\n\n    // Print the inverse matrix if it exists\n    console.log(\"\\nThe Inverse is:\");\n    if (inverse(mat, inv)) {\n        inv.forEach(row => {\n            console.log(row.join(' '));\n        });\n    }\n\n    ````\n\n\n\n\n    **Output**\n    ```\n    Input matrix is:\n    5 -2 2 7\n    1 0 0 3\n    -3 1 5 0\n    3 -1 -9 4\n\n    The Adjoint is:\n    -12 76 -60 -36\n    -56 208 -82 -58\n    4 4 -2 -10\n    4 4 20 12\n\n    The Inverse is:\n    -0.136364 0.863636 -0.681818 -0.409091\n    -0.636364 2.36364 -0.931818 -0.659091\n    0.0454545 0.0454545 -0.0227273 -0.113636\n    0.0454545 0.0454545 0.227273 0.136364\n\n    ```\n    ",
        "metadata": {
            "lesson_name": "Adjoint and Inverse of a Matrix",
            "course_name": "Matrix Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Matrix Data Structure Guide\nLesson Name: Validity of a given Tic-Tac-Toe board configuration\n\nContent:\n\nRecommended Practice\n\n[Tic Tac Toe](\n\n\n[Try It!](\n\n\nBasically, to find the validity of an input grid, we can think of the conditions when an input grid is invalid. Let no. of \u201cX\u201ds be countX and no. of \u201cO\u201ds be countO. Since we know that the game starts with X, a given grid of Tic-Tac-Toe game would be definitely invalid if following two conditions meet\n\n\n1. countX != countO AND\n2. countX != countO + 1\n   * Since \u201cX\u201d is always the first move, second condition is also required.\n   * Now does it mean that all the remaining board positions are valid one? The answer is NO. Think of the cases when input grid is such that both X and O are making straight lines. This is also not\n   * valid position because the game ends when one player wins. So we need to check the following condition as well\n3. If input grid shows that both the players are in winning situation, it\u2019s an invalid position.\n4. If input grid shows that the player with O has put a straight-line (i.e. is in win condition) and countX != countO, it\u2019s an invalid position. The reason is that O plays his move only after X plays his\n   * move. Since X has started the game, O would win when both X and O has played equal no. of moves.\n5. If input grid shows that X is in winning condition than xCount must be one greater that oCount.\n   * Armed with above conditions i.e. a), b), c) and d), we can now easily formulate an algorithm/program to check the validity of a given Tic-Tac-Toe board position.\n\n\n\nAnother way to find the validity of a given board is using \u2018inverse method\u2019 i.e. rule out all the possibilities when a given board is invalid.\n\n\n\n\n\n\n\n\n****Time complexity:****\nO(1)\n\n\n\n****Auxiliary Space:****\nO(1), since no extra space has been taken.\n\n\n****Approach 2:****\n\n\nThe algorithm to check if a Tic-Tac-Toe board is valid or not is as follows:\n\n\n* Initialize a 2D array win of size 8\u00d73, which contains all possible winning combinations in Tic-Tac-Toe. Each row of the win array represents a winning combination, and each element in a row represents a cell index on the board.\n* Define a function isCWin(board, c) which takes a board configuration board and a character c (\u2018X\u2019 or \u2018O\u2019) as inputs, and returns true if character c has won on the board.\n* Inside the isCWin function, iterate over each row of the win array. Check if the board has the same character c at all three cell indices of the current row. If yes, return true, as the character c has won.\n* Define a function isValid(board) which takes a board configuration board as input, and returns true if the board is valid, else returns false.\n* Inside the isValid function, count the number of \u2018X\u2019 and \u2018O\u2019 characters on the board, and store them in xCount and oCount variables, respectively.\n* The board can be valid only if either xCount and oCount are the same, or xCount is one more than oCount.\n* If \u2018O\u2019 is a winner on the board, check if \u2018X\u2019 is also a winner. If yes, return false as both \u2018X\u2019 and \u2018O\u2019 cannot win at the same time. If not, return true if xCount and oCount are the same, else return false.\n* If \u2018X\u2019 is a winner on the board, then xCount must be one more than oCount. If not, return false.\n* If \u2018O\u2019 is not a winner, return true as the board is valid.\n\n\n\n\n\n\n\n****Time complexity: O(N^2)****\n\n\n****Auxiliary Space: O(N)****\n",
        "metadata": {
            "lesson_name": "Validity of a given Tic-Tac-Toe board configuration",
            "course_name": "Matrix Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: Applications, Advantages and Disadvantages of Queue\n\nContent:\n\n****Enqueue**** and when an element is deleted from the queue, then the operation is known as ****Dequeue.**** It is important to know that we cannot insert an element if the size of the queue is full and cannot delete an element when the queue itself is empty. If we try to insert an element even after the queue is full, then such a condition is known as overflow whereas, if we try to delete an element even after the queue is empty then such a condition is known as underflow.\n\n****Primary Queue Operations:****\n\n* ****void enqueue(int Element):**** When this operation is performed, an element is inserted in the queue\n  at the end i.e. at the rear end. (Where T is Generic i.e we can define\n  Queue of any type of data structure.) This operation take ****constant time i.e O(1).****\n* ****int dequeue():****\n  When this operation is performed, an element is removed from the front\n  end and is returned. This operation take ****constant time i.e O(1).****\n\n****Auxiliary Queue Operations:****\n\n* ****int front():**** This operation will return the element at the front without removing\n  it and it take O(1) time.\n* ****int rear():**** This operation will return the element at the rear without removing\n  it, Its Time Complexity is O(1).\n* ****int isEmpty():**** This operation indicates whether the queue is empty or not. This\n  Operation also done in O(1).\n* ****int size():**** This operation will return the size of the queue i.e. the total\n  number of elements present in the queue and it\u2019s time complexity is\n  O(1).\n\n****Types of Queues:****\n\n* ****Simple Queue:**** Simple queue also known as a linear queue is the most basic version\n  of a queue. Here, insertion of an element i.e. the Enqueue operation\n  takes place at the rear end and removal of an element i.e. the Dequeue\n  operation takes place at the front end.\n* ****Circular Queue:****This is mainly an efficient array implementation of Simple Queue. In\n  a circular queue, the element of the queue act as a circular ring. The\n  working of a circular queue is similar to the linear queue except for\n  the fact that the last element is connected to the first element. Its\n  advantage is that the memory is utilized in a better way. This is\n  because if there is an empty space i.e. if no element is present at a\n  certain position in the queue, then an element can be easily added at\n  that position.\n* ****Priority Queue:**** This queue is a special type of queue. Its specialty is that it\n  arranges the elements in a queue based on some priority. The priority\n  can be something where the element with the highest value has the\n  priority so it creates a queue with decreasing order of values. The\n  priority can also be such that the element with the lowest value gets\n  the highest priority so in turn it creates a queue with increasing\n  order of values.\n* ****Dequeue:**** Dequeue is also known as Double Ended Queue. As the name suggests\n  double ended, it means that an element can be inserted or removed from\n  both the ends of the queue unlike the other queues in which it can be\n  done only from one end. Because of this property it may not obey the\n  First In First Out property.\n\n****Implementation of Queue:****\n\n* ****Sequential allocation:**** A queue can be implemented using an array. It can organize a limited\n  number of elements.\n* ****Linked list allocation:****\n  A queue can be implemented using a linked list. It can organize an\n  unlimited number of elements.\n\n****Applications of Queue:****\n\n* ****Multi programming:**** Multi programming means when multiple programs are running in the\n  main memory. It is essential to organize these multiple programs and\n  these multiple programs are organized as queues.\n* ****Network:**** In a network, a queue is used in devices such as a router or a\n  switch. another application of a queue is a mail queue which is a\n  directory that stores data and controls files for mail messages.\n* ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that\n  are scheduled to be executed one after another. These jobs are\n  assigned to the processor one by one which is organized using a\n  queue.\n* ****Shared resources:**** Queues are used as waiting lists for a single shared resource.\n\n****Real-time application of Queue:****\n\n* Working as a buffer between a slow and a fast device. For example\n  keyboard and CPU, and two devices on network.\n* ATM Booth Line\n* Ticket Counter Line\n* CPU task scheduling\n* Waiting time of each customer at call centers.\n\n****Advantages of Queue:****\n\n* A large amount of data can be managed efficiently with ease.\n* Operations such as insertion and deletion can be performed with ease\n  as it follows the first in first out rule.\n* Queues are useful when a particular service is used by multiple\n  consumers.\n* Queues are fast in speed for data inter-process communication.\n* Queues can be used in the implementation of other data\n  structures.\n\n****Disadvantages of Queue:****\n\n* The operations such as insertion and deletion of elements from the\n  middle are time consuming.\n* In a classical queue, a new element can only be inserted when the\n  existing elements are deleted from the queue.\n* Searching an element takes O(N) time.\n* Maximum size of a queue must be defined prior in case of array\n  implementation.\n\n",
        "metadata": {
            "lesson_name": "Applications, Advantages and Disadvantages of Queue",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: Linked List Data Structure Guide\nLesson Name: Introduction to Circular Linked List\n\nContent:\nWhat is a Circular Linked List?\n\n\nA\n\n****circular linked list****\nis a special type of linked list where all the nodes are connected to form a circle. Unlike a regular linked list, which ends with a node pointing to\n\n****NULL****\n, the last node in a circular linked list points back to the first node. This means that you can keep traversing the list without ever reaching a\n\n****NULL****\nvalue.\n\n\nTypes of Circular Linked Lists\n\n\nWe can create a circular linked list from both\n\n[singly linked lists](\nand\n\n[doubly linked lists](\n. So, circular linked list are basically of two types:\n\n\n### 1. Circular Singly Linked List\n\n\nIn\n\n****Circular Singly Linked List****\n, each node has just one pointer called the \u201c\n\n****next****\n\u201d pointer. The next pointer of\n\n****last node****\npoints back to the\n\n****first node****\nand this results in forming a circle. In this type of Linked list we can only move through the list in one direction.\n\n\n![Representation-of-circular-linked-list](\n\nRepresentation of Circular Singly Linked List\n\n### 2. Circular Doubly Linked List:\n\n\nIn\n\n****circular doubly linked****\n\n****list,****\neach node has two pointers\n\n****prev****\nand\n\n****next,****\nsimilar to doubly linked list. The\n\n****prev****\npointer points to the previous node and the\n\n****next****\npoints to the next node. Here, in addition to the\n\n****last****\nnode storing the address of the first node, the\n\n****first node****\nwill also store the address of the\n\n****last node****\n.\n\n\n![Representation-of-circular-doubly-linked-list](\n\nRepresentation of Circular Doubly Linked List\n\n****Note:****\nIn this article, we will use the circular singly linked list to explain the working of circular linked lists.\n\n\nRepresentation of a Circular Singly Linked List\n\n\nLet\u2019s take a look on the structure of a circular linked list.\n\n\n\n\n![Node-structure-of-circular-linked-list](\n\nRepresentation of a Circular Singly Linked List\n\n### Create/Declare a Node of Circular Linked List\n\n\n\n\n\n\n\n\nIn the code above, each node has\n\n****data****\nand a\n\n****pointer****\nto the next node. When we create multiple nodes for a circular linked list, we only need to connect the last node back to the first one.\n\n\nExample of Creating a Circular Linked List\n\n\nHere\u2019s an example of creating a circular linked list with three nodes (2, 3, 4):\n\n\n![Circular-Linked-List](\n\n\n\n\n\n\n\n\n\nIn the above code, we have created three nodes\n\n****first, second,****\nand\n\n****last****\nhaving values\n\n****2, 3,****\nand\n\n****4****\nrespectively.\n\n\n* After creating three nodes, we have connected these node in a series.\n* Connect the first node \u201c\n\n  ****first\u201d****\n  to \u201c\n\n  ****second\u201d****\n  node by\n\n  ****s****\n  toring the address of \u201c\n\n  ****second\u201d****\n  node\n\n\n  into\n\n  ****first\u2019s****\n  next\n* Connect the second node \u201c\n\n  ****second\u201d****\n  to \u201c\n\n  ****second\u201d****\n  node by\n\n  ****s****\n  toring the address of \u201c\n\n  ****third****\n  \u201d node into\n\n  ****second\u2019s****\n  next\n* After connecting all the nodes, we reach the key characteristic of a circular linked list:\n\n  linking the last node back to the first node\n\n\n  . Therefore, we store the address of the \u201c\n\n  ****first****\n  \u201d node in the \u201c\n\n  ****last****\n  \u201d node.\n\n### Why have we taken a pointer that points to the last node instead of the first node?\n\n\nFor the insertion of a node at the beginning, we need to traverse the whole list. Also, for insertion at the end, the whole list has to be traversed. If instead of the start pointer, we take a pointer to the last node, then in both cases there won\u2019t be any need to traverse the whole list. So insertion at the beginning or at the end takes constant time, irrespective of the length of the list.\n\n\nOperations on the Circular Linked list:\n\n\nWe can do some operations on the circular linked list similar to the singly and doubly linked list which are:\n\n\n* ****Insertion****\n  + Insertion at the empty list\n  + Insertion at the beginning\n  + Insertion at the end\n  + Insertion at the given position\n* ****Deletion****\n  + Delete the first node\n  + Delete the last node\n  + Delete the node from any position\n* ****Searching****\n\n****Note:****\nWe will be using the circular singly linked list to represent the working of the circular linked list.\n\n\n[Insertion in the circular linked list:](\n\n\nInsertion is a fundamental operation in linked lists that involves adding a new node to the list. The only extra step is connecting the last node to the first one. In the circular linked list mentioned below, we can insert nodes in four ways:\n\n\n### 1. Insertion in an empty List in the circular linked list\n\n> To insert a node in empty circular linked list, creates a\n>\n> ****new node****\n> with the given data, sets its next pointer to point to itself, and updates the\n>\n> ****last****\n> pointer to reference this\n>\n> ****new node****\n> .\n\n![Insertion-in-an-empty-list-in-circular-linked-list](\n\n\n\n\n\n\n### 2. Insertion at the beginning in circular linked list\n\n> To insert a new node at the beginning of a circular linked list, we first create the\n>\n> ****new node****\n> and allocate memory for it. If the list is empty (indicated by the last pointer being\n>\n> ****NULL****\n> ), we make the\n>\n> ****new node****\n> point to itself. If the list already contains nodes then we set the\n>\n> ****new node\u2019s****\n> next pointer to point to the\n>\n> ****current head****\n> of the list (which is\n>\n> ****last->next****\n> ), and then update the last node\u2019s next pointer to point to the\n>\n> ****new node****\n> . This maintains the circular structure of the list.\n\n![Insertion-at-the-beginning-of-circular-linked-list](\n\n\n\n\n\n\n\n### 3. Insertion at the end in circular linked list\n\n> To insert a new node at the end of a circular linked list, we first create the new node and allocate memory for it. If the list is empty (mean,\n>\n> ****last****\n> or\n>\n> ****tail****\n> pointer being\n>\n> ****NULL****\n> ), we initialize the list with the\n>\n> ****new node****\n> and making it point to itself to form a circular structure. If the list already contains nodes then we set the\n>\n> ****new node\u2019s****\n> next pointer to point to the\n>\n> ****current head****\n> (which is\n>\n> ****tail->next****\n> ), then update the\n>\n> ****current tail\u2019s****\n> next pointer to point to the\n>\n> ****new node****\n> . Finally, we update the\n>\n> ****tail pointer****\n> to the\n>\n> ****new node.****\n> This will ensure that the\n>\n> ****new node****\n> is now the\n>\n> ****last node****\n> in the list while maintaining the circular linkage.\n\n![Insertion-at-the-end-of-circular-linked-list](\n\n\n\n\n\n\n### 4. Insertion at specific position in circular linked list\n\n> To insert a new node at a specific position in a circular linked list, we first check if the list is empty. If it is and the\n>\n> ****position****\n> is not\n>\n> ****1****\n> then we print an error message because the position doesn\u2019t exist in the list. If the\n>\n> ****position****\n> is\n>\n> ****1****\n> then we create the\n>\n> ****new node****\n> and make it point to itself. If the list is not empty, we create the\n>\n> ****new node****\n> and traverse the list to find the correct insertion point. If the\n>\n> ****position****\n> is\n>\n> ****1****\n> , we insert the\n>\n> ****new node****\n> at the beginning by adjusting the pointers accordingly. For other positions, we traverse through the list until we reach the desired position and inserting the\n>\n> ****new node****\n> by updating the pointers. If the new node is inserted at the end, we also update the\n>\n> ****last****\n> pointer to reference the new node, maintaining the circular structure of the list.\n\n![Insertion-at-specific-position-of-circular-linked-list](\n\n\n\n\n\n\n\n[Deletion from a Circular Linked List](\n\n\nDeletion involves removing a node from the linked list. The main difference is that we need to ensure the list remains circular after the deletion. We can delete a node in a circular linked list in three ways:\n\n\n### 1. Delete the first node in circular linked list\n\n> To delete the first node of a circular linked list, we first check if the list is empty. If it is then we print a message and return\n>\n> ****NULL****\n> . If the list contains only one node (the\n>\n> ****head****\n> is the same as the\n>\n> ****last****\n> ) then we delete that node and set the\n>\n> ****last****\n> pointer to\n>\n> ****NULL****\n> . If there are multiple nodes then we update the\n>\n> ****last->next****\n> pointer to skip the\n>\n> ****head****\n> node and effectively removing it from the list. We then delete the\n>\n> ****head****\n> node to free the allocated memory. Finally, we return the updated\n>\n> ****last****\n> pointer, which still points to the\n>\n> ****last****\n> node in the list.\n\n![Deletion-from-the-beginning-of-circular-linked-list](\n\n\n\n\n\n\n### 2. Delete a specific node in circular linked list\n\n> To delete a specific node from a circular linked list, we first check if the list is empty. If it is then we print a message and return\n>\n> ****nullptr****\n> . If the list contains only one node and it matches the\n>\n> ****key****\n> then we delete that node and set\n>\n> ****last****\n> to\n>\n> ****nullptr****\n> . If the node to be deleted is the first node then we update the\n>\n> ****next****\n> pointer of the\n>\n> ****last****\n> node to skip the\n>\n> ****head****\n> node and delete the\n>\n> ****head****\n> . For other nodes, we traverse the list using two pointers:\n>\n> ****curr****\n> (to find the node) and\n>\n> ****prev****\n> (to keep track of the previous node). If we find the node with the matching key then we update the next pointer of\n>\n> ****prev****\n> to skip the\n>\n> ****curr****\n> node and delete it. If the node is found and it is the last node, we update the\n>\n> ****last****\n> pointer accordingly. If the node is not found then do nothing and\n>\n> ****tail****\n> or\n>\n> ****last****\n> as it is. Finally, we return the updated\n>\n> ****last****\n> pointer.\n\n![Delete-a-specific-node-in-circular-linked-list](\n\n\n\n\n\n\n### 3. Deletion at the end of Circular linked list\n\n> To delete the last node in a circular linked list, we first check if the list is empty. If it is, we print a message and return\n>\n> ****nullptr****\n> . If the list contains only one node (where the\n>\n> ****head****\n> is the same as the\n>\n> ****last****\n> ), we delete that node and set\n>\n> ****last****\n> to\n>\n> ****nullptr****\n> . For lists with multiple nodes, we need to traverse the list to find the\n>\n> ****second last node****\n> . We do this by starting from the\n>\n> ****head****\n> and moving through the list until we reach the node whose next pointer points to\n>\n> ****last****\n> . Once we find the\n>\n> ****second last****\n> node then we update its next pointer to point back to the\n>\n> ****head,****\n> this effectively removing the last node from the list. We then delete the last node to free up memory and return the updated\n>\n> ****last****\n> pointer, which now points to the last node.\n\n![Deletion-at-the-end-of-circular-linked-list](\n\n\n\n\n\n\n\n\n[Searching in Circular Linked list](\n\n\nSearching in a circular linked list is similar to searching in a regular linked list. We start at a given node and traverse the list until you either find the target value or return to the starting node. Since the list is circular, make sure to keep track of where you started to avoid an infinite loop.\n\n\n> To search for a specific value in a circular linked list, we first check if the list is empty. If it is then we return\n>\n> ****false****\n> . If the list contains nodes then we start from the\n>\n> ****head****\n> node (which is the\n>\n> ****last->next****\n> ) and traverse the list. We use a pointer\n>\n> ****curr****\n> to iterate through the nodes until we reach back to the\n>\n> ****head****\n> . During traversal, if we find a node whose\n>\n> ****data****\n> matches the given\n>\n> ****key****\n> then we return\n>\n> ****true****\n> to indicating that the value was found. After the loop, we also check the last node to ensure we don\u2019t miss it. If the\n>\n> ****key****\n> is not found after traversing the entire list then we return\n>\n> ****false****\n> .\n\n\n\n\n\n\n\n\nAdvantages of Circular Linked Lists\n\n* In circular linked list, the last node points to the first node. There are no null references, making traversal easier and reducing the chances of encountering null pointer exceptions.\n* We can traverse the list from any node and return to it without needing to restart from the head, which is useful in applications requiring a circular iteration.\n* Circular linked lists can easily implement circular queues, where the last element connects back to the first, allowing for efficient resource management.\n* In a circular linked list, each node has a reference to the next node in the sequence. Although it doesn\u2019t have a direct reference to the previous node like a doubly linked list, we can still find the previous node by traversing the list.\n\nDisadvantages of Circular Linked Lists\n\n* Circular linked lists are more complex to implement than singly linked lists.\n* Traversing a circular linked list without a clear stopping condition can lead to infinite loops if not handled carefully.\n* Debugging can be more challenging due to the circular nature, as traditional methods of traversing linked lists may not apply.\n\nApplications of Circular Linked Lists\n\n* It is used for time-sharing among different users, typically through a\n\n  ****Round-Robin scheduling mechanism.****\n* In multiplayer games, a circular linked list can be used to switch between players. After the last player\u2019s turn, the list cycles back to the first player.\n* Circular linked lists are often used in buffering applications, such as streaming data, where data is continuously produced and consumed.\n* In media players, circular linked lists can manage playlists, this allowing users to loop through songs continuously.\n* Browsers use circular linked lists to manage the cache. This allows you to navigate back through your browsing history efficiently by pressing the BACK button.\n",
        "metadata": {
            "lesson_name": "Introduction to Circular Linked List",
            "course_name": "Linked List Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Linked List Data Structure Guide\nLesson Name: Applications, Advantages and Disadvantages of Linked List\n\nContent:\nAdvantages of Linked Lists (or Most Common Use Cases):\n\n* Linked Lists are mostly used because of their effective insertion and deletion.  We only need to change few pointers (or references) to insert (or delete) an item in the middle\n* [Insertion and deletion](\n  at any point in a linked list take O(1) time. Whereas in an\n\n  [array](\n  data structure, insertion / deletion in the middle takes O(n) time.\n* This data structure is simple and can be also used to implement\n\n  [a stack](\n  ,\n\n  [queues,](\n  and other\n\n  [abstract data structures](\n  .\n* Implementation of Queue and Deque data structures : Simple array implementation is not efficient at all. We must use circular array to efficiently implement which is complex. But with linked list, it is easy and straightforward. That is why most of the language libraries use Linked List internally to implement these data structures..\n* Linked List might turn out to be more space efficient compare to arrays in cases where we cannot guess the number of elements in advance. In case of arrays, the whole memory for items is allocated together. Even with dynamic sized arrays like vector in C++ or list in Python or ArrayList in Java. the internal working involves de-allocation of whole memory and allocation of a bigger chunk when insertions happen beyond the current capacity.\n\nApplications of Linked Lists:\n\n* Linked Lists can be used to implement stacks, queue, deque,\n\n  [sparse matrices](\n  and adjacency list representation of graphs.\n* [Dynamic memory allocation](\n  in operating systems and compilers (linked list of free blocks).\n* Manipulation of polynomials\n* Arithmetic operations on long integers.\n* In operating systems, they can be used in Memory management, process scheduling (for example circular linked list for round robin scheduling) and file system.\n* Algorithms that need to frequently insert or delete items from large collections of data.\n* LRU cache, which uses a doubly linked list to keep track of the most recently used items in a cache.\n\nApplications of Linked Lists in real world:\n\n* The list of songs in the music player are linked to the previous and next songs.\n* In a web browser, previous and next web page URLs can be linked through the previous and next buttons (Doubly Linked List)\n* In image viewer, the previous and next images can be linked with the help of the previous and next buttons (Doubly Linked List)\n* Circular Linked Lists can be used to implement things in round manner where we go to every element one by one.\n* Linked List are preferred over arrays for implementations of Queue and Deque data structures because of fast deletions (or insertions) from the front of the linked lists.\n\nDisadvantages of Linked Lists:\n\n\nLinked lists are a popular data structure in computer science, but like any other data structure, they have certain disadvantages as well. Some of the key disadvantages of linked lists are:\n\n\n* ****Slow Access Time:****\n  Accessing elements in a linked list can be slow, as you need to traverse the linked list to find the element you are looking for, which is an O(n) operation. This makes linked lists a poor choice for situations where you need to access elements quickly.\n* ****Pointers or References:****\n  Linked lists use pointers or references to access the next node, which can make them more complex to understand and use compared to arrays. This complexity can make linked lists more difficult to debug and maintain.\n* ****Higher overhead:****\n  Linked lists have a higher overhead compared to arrays, as each node in a linked list requires extra memory to store the reference to the next node.\n* ****Cache Inefficiency:****\n  Linked lists are cache-inefficient because the memory is not contiguous. This means that when you traverse a linked list, you are not likely to get the data you need in the cache, leading to cache misses and slow performance.\n\n\nIn conclusion, linked lists are a powerful and flexible data structure, but they have certain disadvantages that need to be taken into consideration when deciding whether to use them or not. For example, if you need fast access time, arrays might be a better choice, but if you need to insert or delete elements frequently, linked lists might be the better choice.\n",
        "metadata": {
            "lesson_name": "Applications, Advantages and Disadvantages of Linked List",
            "course_name": "Linked List Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Linked List Data Structure Guide\nLesson Name: Find Length of a Linked List (Iterative and Recursive)\n\nContent:\nGiven a Singly Linked List, the task is to find the Length of the Linked List.\n\n\n****Examples:****\n\n\n> ****Input:****\n> LinkedList = 1->3->1->2->1\n>\n>\n>\n> ****Output:****\n> 5\n>\n>\n> ****Input:****\n> LinkedList = 2->4->1->9->5->3->6\n>\n>\n>\n> ****Output:****\n> 7\n\nIterative Approach to Find the Length of a Linked List:\n\n> The idea is similar to\n>\n> [traversal of Linked List](\n> with an additional variable\n>\n>\n> to count the number of nodes in the Linked List.\n\n\nFollowing is the approach to find the length of the Linked List:\n\n\n* Initialize count as 0.\n* Initialize a node pointer, curr = head.\n* Do following while curr is not NULL\n  + curr = curr -> next\n  + Increment count by 1.\n* Return count.\n\n\n\n\n\n\n\n\n****Time complexity:****\nO(N), Where\n\n****N****\nis the size of the linked list\n\n\n\n****Auxiliary Space:****\nO(1), As constant extra space is used.\n\n\nRecursive Approach to Find the Length of a Linked List:\n\n> The idea is to use\n>\n> [recursion](\n> by maintaining a function, say\n>\n> ****countNodes(node)****\n> which takes a node as an argument and calls itself with the next node until we reach the end of the Linked List. Each of the recursive call returns\n>\n> ****1 + count of remaining nodes****\n> .\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(N), where\n\n****N****\nis the length of Linked List.\n\n\n\n****Auxiliary Space:****\nO(N), Extra space is used in the recursion call stack.",
        "metadata": {
            "lesson_name": "Find Length of a Linked List (Iterative and Recursive)",
            "course_name": "Linked List Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Linked List Data Structure Guide\nLesson Name: Print Linked List\n\nContent:\nGiven a Singly Linked List, the task is to print all the elements in the list.\n\n\n****Examples:****\n\n> ****Input:****\n> 1->2->3->4->5->null\n>\n>\n>\n> ****Output:****\n> 1 2 3 4 5\n>\n>\n>\n> ****Explanation:****\n> Every element of each node from head node to last node is printed.\n>\n>\n> ****Input:****\n> 10->20->30->40->50->null\n>\n>\n>\n> ****Output:****\n> 10 20 30 40 50\n>\n>\n>\n> ****Explanation:****\n> Every element of each node from head node to last node is printed.\n\nTable of Content\n\n* [Iterative Approach - O(n) Time and O(1) Space](#iterative-approach-on-time-and-o1-space)\n* [Recursive Approach - O(n) Time and O(n) Memory Space](#recursive-approach-on-time-and-on-memory-space)\n### Iterative Approach - O(n) Time and O(1) Space\n\n\nThe process of printing a\n\n****singly linked list****\ninvolves printing the value of each node and then going on to the next node and print that node's value also and so on, till we reach the last node in the singly linked list, whose next node points towards the null.\n\n\n****Step-by-Step Algorithm****\n\n> * We will initialize a temporary pointer to the head node of the singly linked list.\n> * After that, we will check if that pointer is null or not null, if it is null, then return.\n> * While the pointer is not null, we will access and print the data of the current node, then we move the pointer to next node.\n\n\nProgram to Print the Singly Linked List using Iteration.\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(n), where\n\n****n****\nis the number of nodes in the linked list.\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n### Recursive Approach - O(n) Time and O(n) Memory Space\n\n\nWe can also traverse the singly linked list using recursion. We start at the head node of the singly linked list, check if it is null or not and print its value. We then call the traversal function again with the next node passed as pointer.\n\n\n****Step-by-Step Algorithm****\n\n> * Firstly, we define a recursive method to traverse the singly linked list, which takes a node as a parameter.\n> * In this function, the base case is that if the node is null then we will return from the recursive method.\n> * We then pass the head node as the parameter to this function.\n> * After that, we access and print the data of the current node.\n> * At last, we will make a recursive call to this function with the next node as the parameter.\n\n\nProgram to Print the Singly Linked List using Recursion.\n\n\n\n\n\n\n\n****Time Complexity:****\nO(n), where\n\n****n****\nis number of nodes in the linked list.\n\n\n\n****Space complexity:****\nO(n) because of recursive stack space.",
        "metadata": {
            "lesson_name": "Print Linked List",
            "course_name": "Linked List Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Linked List Data Structure Guide\nLesson Name: Search an element in a Linked List (Iterative and Recursive)\n\nContent:\nGiven a linked list and a\n\n****key****\n, the task is to check if\n\n****key****\nis present in the linked list or not.\n\n\n****Examples:****\n\n> ****Input:****\n> 14 -> 21 -> 11 -> 30 -> 10, key = 14\n>\n>\n>\n> ****Output:****\n> Yes\n>\n>\n>\n> ****Explanation:****\n> 14 is present in the linked list.\n>\n>\n> ****Input:****\n> 6 -> 21 -> 17 -> 30 -> 10 -> 8, key = 13\n>\n>\n>\n> ****Output:****\n> No\n>\n>\n>\n> ****Explanation:****\n> No node in the linked list has value = 13.\n\nTable of Content\n\n* [Search an element in a Linked List (Iterative Approach) \u2013 O(N) Time and O(1) Space](#search-an-element-in-a-linked-list-iterative-approach)\n* [Search an element in a Linked List (Recursive Approach) \u2013 O(N) Time and O(N) Space](#search-an-element-in-a-linked-list-recursive-approach)\n\nSearch an element in a Linked List (Iterative Approach) \u2013 O(N) Time and O(1) Space:\n\n> The idea is to traverse all the nodes of the linked list, starting from the\n>\n> ****head****\n> . While traversing, if we find a node whose value is equal to\n>\n> ****key****\n> then print \u201cYes\u201d, otherwise print \u201cNo\u201d.\n\n\nFollow the below steps to solve the problem:\n\n\n\n* Initialize a node pointer,\n\n  ****curr = head****\n  .\n* Do following while current is not NULL\n  + If the current value (i.e.,\n\n    ****curr->key****\n    ) is equal to the key being searched return true.\n  + Otherwise, move to the next node (\n\n    ****curr = curr->next****\n    ).\n* If the key is not found, return false\n\n\nBelow is the implementation of the above approach.\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(N), Where\n\n****N****\nis the number of nodes in the Linked List.\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\nSearch an element in a Linked List (Recursive Approach) \u2013 O(N) Time and O(N) Space:\n\n> The idea is to recursively traverse all the nodes starting from the\n>\n> ****head****\n> of linked list. For any node, if the value is equal to\n>\n> ****key****\n> , then return true. Otherwise, recursively search the next node. If at any point the head reaches\n>\n> ****NULL****\n> , it means that we have reached the end of linked list so return\n>\n> ****false****\n> .\n\n\nFollow the below steps to solve the problem:\n\n\n* If the head is NULL, return false.\n* If the head\u2019s key is the same as\n\n  ****X****\n  , return true;\n* Else recursively search in the next node.\n\n\nBelow is the recursive implementation of the above algorithm.\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(N), where\n\n****N****\nis the number of nodes in the linked list.\n\n\n\n****Auxiliary Space:****\nO(N), Stack space used by recursive calls",
        "metadata": {
            "lesson_name": "Search an element in a Linked List (Iterative and Recursive)",
            "course_name": "Linked List Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Linked List Data Structure Guide\nLesson Name: Delete a Linked List node at a given position\n\nContent:\nGiven a singly linked list and a position (1-based indexing), the task is to delete a linked list node at the given position.\n\n\n****Note:****\nPosition will be valid (i.e, 1 <= position <= linked list length)\n\n\n****Example:****\n\n\n> ****Input:****\n> position = 2, Linked List = 8->2->3->1->7\n>\n>\n>\n> ****Output:****\n> Linked List =  8->3->1->7\n>\n>\n> ****Input:****\n> position = 1, Linked List = 8->2->3->1->7\n>\n>\n>\n> ****Output:****\n> Linked List = 2->3->1->7\n\n****Approach:****\n\n\nDeletion at a specified position in a linked list involves removing a node from a specific index/position, which can be the first, middle, or last node.\n\n\n> To perform the deletion, If the position is 1, we update the\n>\n> ****head****\n> to point to the\n>\n> ****next node****\n> and delete the current head. For other positions, we traverse the list to reach the node just before the specified\n>\n> ****position****\n> . If the target node exists, we adjust the next of this previous node to point to next of\n>\n> ****next nodes****\n> , which will result in skipping the target node.\n\n![Deletion-specific-At-End--](\n\nDelete a Linked List node at a given position\n\n\nStep-by-step approach:\n\n\n* If list is empty (\n\n  ****head****\n  ==\n\n  ****NULL)****\n  , returns the\n\n  ****head****\n  .\n* If the\n\n  ****position****\n  to delete is\n\n  ****1****\n  (the head node):\n  + Update\n\n    ****head = temp->next****\n* Traverse the list until reaching the desired position:\n  + Initialize\n\n    ****prev****\n    to keep track of the previous node.\n  + Move\n\n    ****temp****\n    through the list until the position is reached.\n* Check for Valid Position:\n  + If\n\n    ****temp****\n    becomes\n\n    ****NULL****\n    , it means the position exceeds the number of nodes in the list. Print a message and return the\n\n    ****head****\n    .\n* If the node to delete is found:\n  + Set\n\n    ****prev->next****\n    to\n\n    ****temp->next****\n    , effectively skipping over the node to be deleted.\n\n\n\n\n\n\n\n****Time Complexity****\n: O(n), where n is the number of nodes in the list\n\n\n\n****Auxiliary Space:****\nO(1)\n",
        "metadata": {
            "lesson_name": "Delete a Linked List node at a given position",
            "course_name": "Linked List Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Linked List Data Structure Guide\nLesson Name: Write a function to delete a Linked List\n\nContent:\nGiven a\n\n****linked list****\n, the task is to\n\n****delete****\nthe linked list completely.\n\n\n****Examples:****\n\n> ****Input:****\n> head: 1 -> 2 -> 3 -> 4 -> 5 -> NULL\n>\n>\n>\n> ****Output:****\n> NULL\n>\n>\n>\n> ****Explanation:****\n> Linked List is Deleted.\n>\n>\n>\n>\n>\n> ****Input:****\n> head: 1 -> 12 -> 1 -> 4 -> 1 -> NULL\n>\n>\n>\n> ****Output:****\n> NULL\n>\n>\n>\n> ****Explanation:****\n> Linked List is Deleted.\n\nTable of Content\n\n* [[Expected Approach \u2013 1] Using Recursion \u2013 O(n) Time and O(n) Space](#expected-approach-1-using-recursion-on-time-and-on-space)\n* [[Expected Approach \u2013 2] Using Iteration \u2013 O(n) Time and O(1) Space](#expected-approach-2-using-iteration-on-time-and-o1-space)\n### [Expected Approach \u2013 1] Using Recursion \u2013 O(n) Time and O(n) Space:\n\n> The idea is to use\n>\n> [****recursion****](\n> to delete the entire linked list. Traverse from the\n>\n> ****head****\n> to the\n>\n> ****end****\n> of the list recursively. While backtracking, delete the\n>\n> ****currrent****\n> node. This ensures that each node is processed after its subsequent nodes.\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(n), where\n\n****n****\nis the number of nodes in the given linked list.\n\n\n\n****Auxiliary Space:****\nO(n)\n\n\n### [Expected Approach \u2013 2] Using Iteration \u2013 O(n) Time and O(1) Space:\n\n> The idea is to\n>\n> ****iteratively****\n> delete the list by starting from the\n>\n> ****head****\n> and moving towards the\n>\n> ****end****\n> . At each step, the function stores a\n>\n> ****reference****\n> to the\n>\n> ****next****\n> node, deletes the\n>\n> ****current****\n> node, and\n>\n> ****moves****\n> to the next node. This continues until all nodes are deleted.\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(n), where\n\n****n****\nis the number of nodes in the given linked list.\n\n\n\n****Auxiliary Space:****\nO(1)",
        "metadata": {
            "lesson_name": "Write a function to delete a Linked List",
            "course_name": "Linked List Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Linked List Data Structure Guide\nLesson Name: Write a function to get Nth node in a Linked List\n\nContent:\nGiven a\n\n****LinkedList****\nand an\n\n****index****\n(1-based). The task is to find the\n\n****data value****\nstored in the node at that\n\n****kth****\nposition. If no such node exists whose index is\n\n****k****\nthen\n\n****return -1.****\n\n****Example:****\n\n\n> ****Input****\n> : 1->10->30->14, index = 2\n>\n>\n>\n> ****Output****\n> : 10\n>\n>\n>\n> ****Explanation****\n> : The node value at index 2 is 10\n>\n>\n> ![Maximum-of-all-subarrays-of-size-K](\n>\n>\n>\n> ****Input****\n> : 1->32->12->10->30->14->100, index = 8\n>\n>\n>\n> ****Output****\n> : -1\n>\n>\n>\n> ****Explanation****\n> : No such node exists at index = 8.\n\nTable of Content\n\n* [[Naive Approach] Recursive Method \u2013 O(n) Time and O(n) Space](#approach-1-using-recursion-on-time-and-on-space)\n* [[Expected Approach-2] Iterative Method \u2013 O(n) Time and O(1) Space](#approach-2-using-iterative-method-on-time-and-o1-space)\n### ****[Naive Approach] Recursive Method \u2013 O(n) Time and O(n) Space****\n\n> The idea is to use the\n>\n> [****recursive****](\n> ****method****\n> to find the value of\n>\n> ****index****\n> node\n>\n> ****(1- based)****\n> . Call the function\n>\n> ****GetNth(head,index)****\n> recusively, where\n>\n> ****head****\n> will represent the\n>\n> ****current head****\n> node . Decrement the index\n>\n> ****value by 1****\n> on every recursion call. When the\n>\n> ****n reaches 1****\n> ,we will return the\n>\n> ****data****\n> of current node.\n\n\n\n\n\n\n\n\n****Time Complexity :****\nO(n)\n\n****,****\nwhere n is the nth node of linked list.\n\n\n\n****Auxiliary Space:****\nO(n), for recursive call stack\n\n\n### ****[Expected Approach-2] Iterative Method \u2013 O(n) Time and O(1) Space****\n\n> The idea is similar to recursive\n>\n> ****approach to find****\n> the value at\n>\n> ****index****\n> node\n>\n> ****(1- based)****\n> .We will use a variable say,\n>\n> ****count = 1****\n> to track the node\n>\n> ****s.****\n> Traverse the list until\n>\n> ****curr != NULL****\n> . Increment the\n>\n>\n> count\n>\n>\n> if count is\n>\n> ****not equal****\n> to\n>\n> ****index****\n> node\n>\n> ****(1- based) ,****\n> else if count equals to the\n>\n> ****index****\n> node, return data at\n>\n> ****current****\n> node.\n\n\n\n\n\n\n\n\n****Time Complexity :****\nO(n)\n\n****,****\nwhere n is the nth node of linked list.\n\n\n\n****Auxiliary Space:****\nO(1)",
        "metadata": {
            "lesson_name": "Write a function to get Nth node in a Linked List",
            "course_name": "Linked List Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Linked List Data Structure Guide\nLesson Name: Program for Nth node from the end of a Linked List\n\nContent:\nGiven a Linked List of\n\n****M****\nnodes and a number\n\n****N****\n, find the value at the Nth node from the end of the Linked List. If there is no Nth node from the end, print -1.\n\n\n****Examples:****\n\n> ****Input:****\n> 1 -> 2 -> 3 -> 4, N = 3\n>\n>\n>\n> ****Output:****\n> 2\n>\n>\n>\n> ****Explanation:****\n> Node 2 is the third node from the end of the linked list.\n>\n>\n> ****Input:****\n> 35 -> 15 -> 4 -> 20, N = 4\n>\n>\n>\n> ****Output:****\n> 35\n>\n>\n>\n> ****Explanation:****\n> Node 35 is the fourth node from the end of the linked list.\n\nTable of Content\n\n* [[Naive Approach] By Finding the length of list \u2013 Two Pass \u2013 O(M) Time and O(1) Space](#naive-approach-finding-the-length-of-list-and-return-the-node-two-pass-om-time-and-o1-space)\n* [[Expected Approach] Using Two Pointers \u2013 One Pass \u2013 O(M) Time and O(1) Space](#expected-approach-using-two-pointers-one-pass-om-time-and-o1-space)\n### ****[Naive Approach]**** Finding the length of list \u2013 Two Pass \u2013 O(M) Time and O(1) Space\n\n> The idea is to count the number of nodes in linked list in the first pass, say\n>\n> ****len****\n> . In the second pass, return the\n>\n> ****(len \u2013 n + 1)th****\n> nodes from beginning of the Linked List.\n\n\n\n\n\n\n\n\n****Time complexity:****\nO(M) where\n\n****M****\nis the size of the linked list\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n### [Expected Approach] Using Two Pointers \u2013 One Pass \u2013 O(M) Time and O(1) Space\n\n> The idea is to maintain two pointers, say\n>\n> ****main\\_ptr****\n> and\n>\n> ****ref\\_ptr****\n> point to the head of Linked List and move\n>\n> ****ref\\_ptr****\n> to the Nth node from the head to ensure that the distance between main\\_ptr and ref\\_ptr is\n>\n> ****(N \u2013 1)****\n> . Now, move both the pointers simultaneously until ref\\_ptr reaches the last node. Since the distance between main\\_ptr and ref\\_ptr is (N \u2013 1), so when ref\\_ptr will reach the\n>\n> ****last node****\n> , main\\_ptr will reach\n>\n> ****Nth****\n> node from the end of Linked List. Return the value of node pointed by main\\_ptr.\n\n\nBelow image is a dry run of the above approach:\n\n\n\n\n\n\n\n\nFollow the given steps to solve the problem:\n\n\n* Maintain two pointers\n\n  ****main\\_ptr****\n  and\n\n  ****ref\\_ptr****\n* Move ref\\_ptr to the Nth node from the start\n* Now move both main\\_ptr and ref\\_ptr, until the ref\\_ptr reaches the last node\n* Now return the data of the main\\_ptr, as it is at the Nth node from the end\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(M) where\n\n****M****\nis the length of the linked list\n\n\n\n****Auxiliary Space:****\nO(1)",
        "metadata": {
            "lesson_name": "Program for Nth node from the end of a Linked List",
            "course_name": "Linked List Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Linked List Data Structure Guide\nLesson Name: Program to find size of Doubly Linked List\n\nContent:\nGiven a\n\n[doubly linked list](\n, The task is to find the\n\n****number of nodes in****\nthe given doubly linked list.\n\n\nExample:\n\n\n> ****Input****\n> : 1<->2<->3<->4\n>\n>\n>\n> ****output****\n> : 4\n>\n>\n> ****Input****\n> : 1<->2\n>\n>\n>\n> ****output****\n> : 2\n\n### By Traversing the Doubly linked list \u2013 O(n) Time and O(1) Space\n\n> The idea is to traverse the doubly linked list starting from the\n>\n> ****head****\n> node. Increment the\n>\n> ****size****\n> variable until we reaches end.\n\n\nAlgorithm :\n\n\n* Initialize a variable\n\n  ****size****\n  to 0\n* Initialize a\n\n  ****curr****\n  node to\n\n  ****head****\n* Do the following while the\n\n  ****curr node****\n  is not NULL\n  + ****curr = curr -> next****\n  + ****size++;****\n* Return\n\n  ****size****\n  .\n\n\n\n\n\n\n\n\n****Time Complexity: O(n),****\nwhere n is the number of nodes in the linked list.\n\n\n\n****Auxiliary Space:****\n\n****O(1)****",
        "metadata": {
            "lesson_name": "Program to find size of Doubly Linked List",
            "course_name": "Linked List Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Linked List Data Structure Guide\nLesson Name: Remove every k-th node of the linked list\n\nContent:\nGiven a\n\n****singly linked list,****\nthe task is to remove every k\n\nth\nnode of the linked list. Assume that k is always less than or equal to the length of the Linked List.\n\n\n****Examples :****\n\n\n> ****Input:****\n> LinkedList: 1 -> 2 -> 3 -> 4 -> 5 -> 6, k = 2\n>\n>\n>\n> ****Output:****\n> 1 -> 3 -> 5\n>\n>\n>\n> ****Explanation:****\n> After removing every 2nd node of the linked list, the resultant linked list will be: 1 -> 3 -> 5 .\n>\n>\n> ****Input:****\n> LinkedList: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10, k = 3\n>\n>\n>\n> ****Output:****\n> 1 -> 2 -> 4 -> 5 -> 7 -> 8 -> 10\n>\n>\n>\n> ****Explanation:****\n> After removing every 3rd node of the linked list, the resultant linked list will be: 1 -> 2 -> 4 -> 5 -> 7 -> 8 -> 10.\n\n### [Expected Approach \u2013 1] Iterative Approach \u2013 O(n) Time and O(1) Space\n\n> The idea is to traverse the linked list while maintaining a\n>\n> ****counter****\n> to track node positions. Every time the counter reaches\n>\n> ****k,****\n> update the next pointer of the\n>\n> ****previous****\n> node to\n>\n> ****skip****\n> the current k\n>\n> th\n> node, effectively removing it from the list. Continue this process until reaching the\n>\n> ****end****\n> of the list. This method ensures that the\n>\n> ****k****\n> ****th****\n>\n> nodes are removed as required while\n>\n> ****preserving****\n> the rest of the list structure.\n\n\n\n\n\n\n\n\n****Time Complexity :****\nO(n),\n\n\nwhere\n\n****n****\nis the number of nodes.\n\n\n\n****Auxiliary Space :****\nO(1)",
        "metadata": {
            "lesson_name": "Remove every k-th node of the linked list",
            "course_name": "Linked List Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: Linked List Data Structure Guide\nLesson Name: Singly Linked List Tutorial\n\nContent:\nUnderstanding Node Structure\n\nIn a singly linked list, each node consists of two parts: data and a\npointer to the next node. This structure allows nodes to be dynamically\nlinked together, forming a chain-like sequence.\n\n\n![Singly-Linked-List](\n\n\n\n\n\n\n\n\nIn this example, the Node class contains an integer data field (****data****) to store the information and a pointer to another Node (****next****) to establish the link to the next node in the list.\n\nOperations on Singly Linked List\n\n* ****Traversal****\n* ****Searching****\n* ****Length****\n* ****Insertion:****\n  + Insert at the beginning\n  + Insert at the end\n  + Insert at a specific position\n* ****Deletion:****\n  + Delete from the beginning\n  + Delete from the end\n  + Delete a specific node\n\nLet's go through each of the operations mentioned above, one by\none.\n\n[****Traversal**** of Singly Linked List](\n\nTraversal involves visiting each node in the linked list and performing\nsome operation on the data. A simple traversal function would print or\nprocess the data of each node.\n\nStep-by-step approach:\n\n* Initialize a pointer current to the head of the list.\n* Use a while loop to iterate through the list until the current\n  pointer reaches NULL.\n* Inside the loop, print the data of the current node and move the\n  current pointer to the next node.\n\n\n\n\n\n\n\n[Searching in Singly Linked List](\n\nSearching in a Singly Linked List refers to the process of looking for\na specific element or value within the elements of the linked list.\n\n\nStep-by-step approach:\n\n1. Traverse the Linked List starting from the head.\n2. Check if the current node's data matches the target value.\n   * If a match is found, return ****true****.\n3. Otherwise, Move to the next node and repeat steps 2.\n4. If the end of the list is reached without finding a match, return ****false****.\n\n\n\n\n\n\n\n\n[Length of Singly Linked List](\n\nFinding Length in Singly Linked List refers to the process of\ndetermining the total number of nodes in a singly linked list.\n\nStep-by-step approach:\n\n* Initialize a counter ****length**** to 0.\n* Start from the head of the list, assign it to current.\n* Traverse the list:\n  + Increment ****length**** for each node.\n  + Move to the next node (****current = current->next****).\n* Return the final value of ****length****.\n\n\n\n\n\n\n\n\n\n[Insertion in Singly Linked List](\n\nInsertion is a fundamental operation in linked lists that involves\nadding a new node to the list. There are several scenarios for\ninsertion:\n\n### a. [Insertion at the Beginning of Singly Linked List](\n\n![Insertion-at-the-Beginning-of-Singly-Linked-List](\n\n\nInsert a Node at the Front/Beginning of Linked List\n\n\n\nStep-by-step approach:\n\n* Create a new node with the given value.\n* Set the ****next**** pointer of the new node to the current head.\n* Move the head to point to the new node.\n* Return the new head of the linked list.\n\n\n\n\n\n\n\n### b. [Insertion at the End of Singly Linked List:](\n\nTo insert a node at the end of the list, traverse the list until the\nlast node is reached, and then link the new node to the current last\nnode-\n\n![Insertion-at-the-End-of-Singly-Linked-List](\n\nInsertion at end of Linked List\n\n\nStep-by-step approach:\n\n* Create a new node with the given value.\n* Check if the list is empty:\n  + If it is, make the new node the head and return.\n* Traverse the list until the last node is reached.\n* Link the new node to the current last node by setting the last node's\n  next pointer to the new node.\n\n\n\n\n\n\n\n\n\n\n### c. [Insertion at a Specific Position of the Singly Linked List:](\n\nTo insert a node at a specific position, traverse the list to the\ndesired position, link the new node to the next node, and update the\nlinks accordingly.\n\n![Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy](\n\n\n\n\nWe mainly find the node after which we need to insert the new node. If\nwe encounter a NULL before reaching that node, it means that the given\nposition is invalid.\n\n\n\n\n\n\n\n\n\n\n\n\n\n[Deletion in Singly Linked List](\n\nDeletion involves removing a node from the linked list. Similar to\ninsertion, there are different scenarios for deletion:\n\n### a. [****Deletion at the Beginning of**** Singly Linked List****:****](\n\nTo delete the first node, update the head to point to the second node\nin the list.\n\n![Deletion-at-beginning-](\n\nDeletion at beginning in a Linked List\n\n\nSteps-by-step approach:\n\n* Check if the head is ****NULL****.\n  + If it is, return ****NULL**** (the list is empty).\n* Store the current head node in a temporary variable ****temp****.\n* Move the head pointer to the next node.\n* Delete the temporary node.\n* Return the new head of the linked list.\n\n\n\n\n\n\n\n### b. [Deletion at the End of Singly Linked List:](\n\nTo delete the last node, traverse the list until the second-to-last\nnode and update its next field to None.\n\n![Deletion-At-End](\n\nDeletion at the end of linked list\n\n\nStep-by-step approach:\n\n* Check if the head is ****NULL****.\n  + If it is, return NULL (the list is empty).\n* Check if the head's ****next**** is ****NULL**** (only one node in the list).\n  + If true, delete the head and return ****NULL****.\n* Traverse the list to find the second last node (****second\\_last****).\n* Delete the last node (the node after ****second\\_last****).\n* Set the ****next**** pointer of the second last node to ****NULL****.\n* Return the head of the linked list.\n\n\n\n\n\n\n\n\n\n### c. [Deletion at a Specific Position of Singly Linked List:](\n\nTo delete a node at a specific position, traverse the list to the\ndesired position, update the links to bypass the node to be\ndeleted.\n\n![Deletion-specific-At-End--](\n\nDelete a Linked List node at a given position\n\n\nStep-by-step approach:\n\n* Check if the list is empty or the position is invalid, return if\n  so.\n* If the head needs to be deleted, update the head and delete the\n  node.\n* Traverse to the node before the position to be deleted.\n* If the position is out of range, return.\n* Store the node to be deleted.\n* Update the links to bypass the node.\n* Delete the stored node.\n\n\n\n\n\n\n\n",
        "metadata": {
            "lesson_name": "Singly Linked List Tutorial",
            "course_name": "Linked List Data Structure Guide"
        }
    },
    {
        "page_content": "Course Name: The Logic Building Problems\nLesson Name: Fraction to Recurring Decimal\n\nContent:\nGiven two integers ****a**** and ****b**** (b != 0), the task is to return the fraction ****a/b**** in string format. If the fractional part is repeating, enclose the repeating part in parentheses.****Examples:****\n\n\n> ****Input****\n> : a = 1, b = 2\n>\n>\n>\n> ****Output****\n> : \u201c0.5\u201d\n>\n>\n>\n> ****Explanation:****\n> 1/2 = 0.5 with no repeating part.\n>\n>\n>\n>\n>\n> ****Input****\n> : a = 50, b = 22\n>\n>\n>\n> ****Output****\n> : \u201c2.(27)\u201d\n>\n>\n>\n> ****Explanation:****\n> 50/22 = 2.27272727\u2026 Since fractional part (27) is repeating, it is enclosed in parentheses.\n\n****Approach****\n:\n\n\n> The idea is to first calculate the integral quotient (absolute part before decimal point) and then calculate the fractional part. To check if the fractional part is repeating, insert the remainder (a % b) in a\n>\n> [hash map](\n> with key as remainder and value as the index position at which this remainder occurs. If at any point of time, the remainder becomes zero, then there doesn\u2019t exist a repeating fraction otherwise if the remainder is already found in the map, then there exists a repeating fraction.\n\n\n\n\n\n\n\n****Time Complexity****\n: O(max(log10(a), log10(b))), we can make any number of recurring digits in the fraction. For example:\n\n\n* 2/9 = 0.22222..\n* 21/99 = 0.212121\u2026\n* 213/999 = 0.213213\u2026\n* 2134/9999 = 0.21342134\u2026\n* 21345/99999 = 0.2134521345\u2026 and so on.\n\n****Auxiliary Space****\n: O(max(log10(a), log10(b))), to store the result.\n\n",
        "metadata": {
            "lesson_name": "Fraction to Recurring Decimal",
            "course_name": "The Logic Building Problems"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: C Arrays\n\nContent:\nLet\u2019s take a look a simple example to demonstrate the use of vector\n\n\n\nTable of Content\n\n* [Syntax of Vector](#create-a-vector)\n* [Declaration and Initialization](#initialize-a-vector)\n* [Basic Vector Operations](#basic-vector-operations)\n\n+ [Accessing Elements](#accessing-elements)\n+ [Updating Elements](#updating-elements)\n+ [Traversing Vector](#traversal)\n+ [Inserting Elements](#insert)\n+ [Deleting Elements](#delete)\n\n* [Other Common Operations on Vector](#common-examples-of-vector-in-c)\n* [Passing Vector to Functions](#passing-vector-to-functions)\n* [Internal Working of Vector](#internal-working-of-vector)\n* [2D Vectors](#2d-vectors)\n* [All Member Functions of Vector](#all-member-functions-of-stdvector)\n\nSyntax of Vector\n\nVector is defined as the ****std::vector****\nclass template which contains its implementation and some useful member\nfunctions. It is defined inside the ****<vector>**** header file.\n\n> ****vector****<**T**> vec\\_name;\n\nwhere,\n\n* ****T:**** Type of elements in the vector.\n* ****vec\\_name:**** Name assigned to the vector.\n\nTo master vectors and other STL components, check out our [****Complete C++ Course****]( which covers the ins and outs of C++ STL with real-world examples and\nhands-on projects.\n\n\nDeclaration and Initialization\n\nDeclaration and initialization are the process of creating an instance\nof std::vector class and assigning it some initial value. In C++,\nvectors can be declared and initialized in multiple ways as shown\nbelow:\n\n****1. Default Initialization****\n\nAn empty vector can be created using the below declaration. This vector\ncan be filled later on in the program.\n\n> ****vector****<T> vec\\_name;\n\n****2. Initialization with Size and Default Value****\n\nA vector of a specific size can also be declared and initialized to the\ngiven value as default value.\n\n> ****vector****<T> vec\\_name(size, value);\n\n****3. Initialization Using Initializer List****\n\nVector can also be initialized using a list of values enclosed in ****{} braces**** separated by comma.\n\n> ****vector****<T> vec\\_name = { v1, v2, v3\u2026.};\n> ****vector****<T> vec\\_name ({ v1, v2, v3\u2026.});\n\nLet\u2019s take a look at an example that shows implements the above\n\n\n\nMore ways to declare and initialize vectors are discussed in this\narticle \u2013 [8 Ways to Initialize Vector in C++](\n\nBasic Vector Operations\n\nThe basic operations of vector are shown below:\n\n### 1. Accessing Elements\n\nJust like arrays, vector elements can be accessed using their index\ninside the [****[] subscript operator****]( This method is fast but doesn\u2019t check whether the given index exists\nin the vector or not. So, there is another member method [****vector at()****]( for safely accessing elements:\n\n\n\nTo know more about accessing vector elements, refer to the article \u2013 [How to Access an Element in a Vector in C++?](\n\n### 2. Updating Elements\n\nUpdating elements is very similar to the accessing except that we use\nan additional assignment operator to assign a new value to a particular\nelement. It uses the same methods: [] subscript operator and vector\nat().\n\n\n\nMore methods to update vector elements are discussed in this article \u2013 [How to Update Vector Elements in C++?](\n\n### 3. Traversing Vector\n\nVector in C++ can be traversed using indexes in a loop. The indexes\nstart from 0 and go up to vector size \u2013 1. To iterate through this\nrange, we can use a loop and determine the size of the vector using the [vector size()]( method.\n\n\n\nMore ways to traverse vectors are discussed in this article \u2013 [How to Iterate Through a Vector in C++?](\n\n### 4. Inserting Elements\n\nAn element can be inserted into a vector using [****vector insert()****](\nmethod which takes linear time. But for the insertion at the end, the [****vector push\\_back()****](\nmethod can be used. It is much faster, taking only constant time.\n\n\nMore ways to insert an element in the vector are discussed in this\narticle \u2013 [How to Add Elements in a Vector in C++?](\n\n### 5. Deleting Elements\n\nAn element can be deleted from a vector using [****vector erase()****](\nbut this method needs iterator to the element to be deleted. If only the\nvalue of the element is known, then find() function is used to find the\nposition of this element.\n\nFor the deletion at the end, the [****vector pop\\_back()****](\nmethod can be used, and it is much faster, taking only constant\ntime.\n\n\n\nTo know more about the deletion of an element in the vector, refer to\nthis article \u2013 [How to Remove an Element from Vector in C++?](\n\nOther Common Operations on Vector\n\nVector is one of the most frequently used containers in C++. It is used\nin many situations for different purposes. The following examples aim to\nhelp you master vector operations beyond the basics.",
        "metadata": {
            "lesson_name": "C Arrays",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: Different Types of Queues and its Applications\n\nContent:\n**Types of Queues:**\n\nThere are **five different types of queues** that are used in\ndifferent scenarios. They are:\n\n1. Input Restricted Queue (this is a Simple Queue)\n2. Output Restricted Queue (this is also a Simple Queue)\n3. Circular Queue\n4. Double Ended Queue (Deque)\n5. Priority Queue\n   * Ascending Priority Queue\n   * Descending Priority Queue\n\n![Types of Queues](\n\nTypes of Queues\n\n**1.** [**Circular Queue**]( Circular Queue is a linear data structure in which the\noperations are performed based on FIFO (First In First Out) principle and\nthe last position is connected back to the first position to make a\ncircle. It is also called **\u2018Ring Buffer\u2019**. This queue is\nprimarily used in the following cases:\n\n1. **Memory Management:** The unused memory locations in the\n   case of ordinary queues can be utilized in circular queues.\n2. **Traffic system:** In a computer-controlled traffic\n   system, circular queues are used to switch on the traffic lights one by\n   one repeatedly as per the time set.\n3. **CPU Scheduling:** Operating systems often maintain a\n   queue of processes that are ready to execute or that are waiting for a\n   particular event to occur.\n\nThe time complexity for the circular Queue is O(1).\n\n**2. Input restricted Queue:** In this type of Queue, the\ninput can be taken from one side only(rear) and deletion of elements can\nbe done from both sides(front and rear). This kind of Queue does not\nfollow FIFO(first in first out).  This queue is used in cases where\nthe consumption of the data needs to be in FIFO order but if there is a\nneed to remove the recently inserted data for some reason and one such\ncase can be irrelevant data, performance issue, etc.\n\n\n\n![Input Restricted Queue](\n\nInput Restricted Queue\n\n**Advantages of Input restricted Queue:**\n\n* Prevents overflow and overloading of the queue by limiting the number of\n  items added\n* Helps maintain stability and predictable performance of the system\n\n**Disadvantages of Input restricted Queue:**\n\n* May lead to resource wastage if the restriction is set too low and items\n  are frequently discarded\n* May lead to waiting or blocking if the restriction is set too high and\n  the queue is full, preventing new items from being added.\n\n**3. Output restricted Queue:** In this type of Queue, the\ninput can be taken from both sides(rear and front) and the deletion of the\nelement can be done from only one side(front).  This queue is used in\nthe case where the inputs have some priority order to be executed and the\ninput can be placed even in the first place so that it is executed\nfirst.\n\n![Output Restricted Queue](\n\nOutput Restricted Queue\n\n**4.** [**Double ended Queue**]( Double Ended Queue is also a Queue data structure in\nwhich the insertion and deletion operations are performed at both the ends\n(front and rear). That means, we can insert at both front and rear\npositions and can delete from both front and rear positions.  Since\nDeque supports both stack and queue operations, it can be used as both.\nThe Deque data structure supports clockwise and anticlockwise rotations in\nO(1) time which can be useful in certain applications. Also, the problems\nwhere elements need to be removed and or added both ends can be\nefficiently solved using Deque.\n\n![Double Ended Queue](\n\nDouble Ended Queue\n\n**5.** [**Priority Queue**]( A priority queue is a special type of queue in which\neach element is associated with a priority and is served according to its\npriority. There are two types of Priority Queues. They are:\n\n1. **Ascending Priority Queue:** Element can be inserted\n   arbitrarily but only smallest element can be removed. For example,\n   suppose there is an array having elements 4, 2, 8 in the same order. So,\n   while inserting the elements, the insertion will be in the same sequence\n   but while deleting, the order will be 2, 4, 8.\n2. **Descending priority Queue:** Element can be inserted\n   arbitrarily but only the largest element can be removed first from the\n   given Queue. For example, suppose there is an array having elements 4,\n   2, 8 in the same order. So, while inserting the elements, the insertion\n   will be in the same sequence but while deleting, the order will be 8, 4, 2.\n\nThe time complexity of the Priority Queue is O(logn).\n\n[**Applications of a Queue:**](\n\nThe [queue]( is used when things don\u2019t have to be processed immediately, but have to be processed in First In First Out order like [Breadth First Search]( This property of Queue makes it also useful in the following kind of scenarios.\n\n1. When a resource is shared among multiple consumers. Examples include   [CPU scheduling](   [Disk Scheduling](\n2. When data is transferred asynchronously (data not necessarily received\n   at the same rate as sent) between two processes. Examples include IO\n   Buffers, [pipes]( file IO, etc.\n3. Linear Queue: A linear queue is a type of queue where data elements are\n   added to the end of the queue and removed from the front of the queue.\n   Linear queues are used in applications where data elements need to be\n   processed in the order in which they are received. Examples include\n   printer queues and message queues.\n4. Circular Queue: A circular queue is similar to a linear queue, but the\n   end of the queue is connected to the front of the queue. This allows for\n   efficient use of space in memory and can improve performance. Circular\n   queues are used in applications where the data elements need to be\n   processed in a circular fashion. Examples include CPU scheduling and\n   memory management.\n5. Priority Queue: A priority queue is a type of queue where each element\n   is assigned a priority level. Elements with higher priority levels are\n   processed before elements with lower priority levels. Priority queues\n   are used in applications where certain tasks or data elements need to be\n   processed with higher priority. Examples include operating system task\n   scheduling and network packet scheduling.\n6. Double-ended Queue: A double-ended queue, also known as a deque, is a\n   type of queue where elements can be added or removed from either end of\n   the queue. This allows for more flexibility in data processing and can\n   be used in applications where elements need to be processed in multiple\n   directions. Examples include job scheduling and searching algorithms.\n7. Concurrent Queue: A concurrent queue is a type of queue that is designed\n   to handle multiple threads accessing the queue simultaneously.\n   Concurrent queues are used in multi-threaded applications where data\n   needs to be shared between threads in a thread-safe manner. Examples\n   include database transactions and web server requests.\n\n**Issues of Queue :**\n\nSome common issues that can arise when using queues:\n\n1. Queue overflow: Queue overflow occurs when the queue reaches its maximum\n   capacity and is unable to accept any more elements. This can cause data\n   loss and can lead to application crashes.\n2. Queue underflow: Queue underflow occurs when an attempt is made to\n   remove an element from an empty queue. This can cause errors and\n   application crashes.\n3. Priority inversion: Priority inversion occurs in priority queues when a\n   low-priority task holds a resource that a high-priority task needs. This\n   can cause delays in processing and can impact system performance.\n4. Deadlocks: Deadlocks occur when multiple threads or processes are\n   waiting for each other to release resources, resulting in a situation\n   where none of the threads can proceed. This can happen when using\n   concurrent queues and can lead to system crashes.\n5. Performance issues: Queue performance can be impacted by various\n   factors, such as the size of the queue, the frequency of access, and the\n   type of operations performed on the queue. Poor queue performance can\n   lead to slower system performance and reduced user experience.\n6. Synchronization issues: Synchronization issues can arise when multiple\n   threads are accessing the same queue simultaneously. This can result in\n   data corruption, race conditions, and other errors.\n7. Memory management issues: Queues can use up significant amounts of\n   memory, especially when processing large data sets. Memory leaks and\n   other memory management issues can occur, leading to system crashes and\n   other errors.\n\n**Reference :**\n\nSome references for further reading on queues:\n\n1. \u201cData Structures and Algorithms in Java\u201d by Robert Lafore \u2013 This book\n   provides an in-depth explanation of different types of queues and their\n   implementations in Java.\n2. \u201cIntroduction to Algorithms\u201d by Thomas H. Cormen et al. \u2013 This textbook\n   covers the basic concepts of data structures and algorithms, including\n   queues and their various applications.\n3. \u201cConcurrency in C# Cookbook\u201d by Stephen Cleary \u2013 This book provides\n   practical examples of how to use concurrent queues in C# programming.\n4. \u201cQueue (abstract data type)\u201d on Wikipedia \u2013 This article provides an\n   overview of queues and their properties, as well as examples of their\n   applications.\n5. \u201cThe Art of Computer Programming, Volume 1: Fundamental Algorithms\u201d by\n   Donald E. Knuth \u2013 This book includes a detailed analysis of different\n   queue algorithms and their performance.\n6. \u201cQueues and the Producer-Consumer Problem\u201d by Douglas C. Schmidt \u2013 This\n   paper discusses how queues can be used to solve the producer-consumer\n   problem in concurrent programming.",
        "metadata": {
            "lesson_name": "Different Types of Queues and its Applications",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: Basic Operations for Queue in Data Structure\n\nContent:\n**Basic Operations on Queue:**\n\nSome of the basic operations for Queue in Data Structure are:\n\n* **enqueue() \u2013** Insertion of elements to the queue.\n* **dequeue() \u2013** Removal of elements from the queue.\n* **peek() or front()-** Acquires the data element available\n  at the front node of the queue without deleting it.\n* **rear() \u2013** This operation returns the element at the rear\n  end without removing it.\n* **isFull() \u2013** Validates if the queue is full.\n* **isEmpty() \u2013** Checks if the queue is empty.\n* **size():** This operation returns the size of the queue\n  i.e. the total number of elements it contains.\n\n![](\n\nQueue Data Structure\n\n### **Operation 1: enqueue()**\n\nInserts an element at the end of the queue i.e. at the rear end.\n\nThe following steps should be taken to enqueue (insert) data into a queue:\n\n* Check if the queue is full.\n* If the queue is full, return overflow error and exit.\n* If the queue is not full, increment the rear pointer to point to the\n  next empty space.\n* Add the data element to the queue location, where the rear is pointing.\n* return success.\n\n![Enqueue representation](\n\n\n\n\n\n\n\n\n\n**Complexity Analysis:**\n**Time Complexity:** O(1)\n**Space Complexity:** O(N)\n\n### **Operation 2: dequeue()**\n\nThis operation removes and returns an element that is at the front end of\nthe queue.\n\nThe following steps are taken to perform the dequeue operation:\n\n* Check if the queue is empty.\n* If the queue is empty, return the underflow error and exit.\n* If the queue is not empty, access the data where the front is pointing.\n* Increment the front pointer to point to the next available data element.\n* The Return success.\n\n![Dequeue operation](\n\n\n**Complexity Analysis:**\n**Time Complexity:** O(1)\n**Space Complexity:** O(N)\n\n### Operation 4 : rear()\n\nThis operation returns the element at the rear end without removing it.\n\nThe following steps are taken to perform the rear operation:\n\n* If the queue is empty return the most minimum value.\n* otherwise, return the rear value.\n\n\n\n\n**Complexity Analysis:**\n**Time Complexity:** O(1)\n**Space Complexity:** O(N)\n\n### **Operation 5: isEmpty():**\n\nThis operation returns a boolean value that indicates whether the queue is\nempty or not.\n\nThe following steps are taken to perform the Empty operation:\n\n* check if front value is equal to -1 or not, if yes then return true\n  means queue is empty.\n* Otherwise return false, means queue is not empty\n\n\n\n\n**Complexity Analysis:**\n**Time Complexity:** O(1)\n**Space Complexity:** O(N)\n\n### **Operation 6 : isFull()**\n\nThis operation returns a boolean value that indicates whether the queue is\nfull or not.\n\nThe following steps are taken to perform the isFull() operation:\n\n* Check if front value is equal to zero and rear is equal to the capacity\n  of queue if yes then return true.\n\n\n**Complexity Analysis:**\n**Time Complexity:** O(1)\n**Space Complexity:** O(N)\n\n### Operation 7: size()\n\nThis operation returns the size of the queue i.e. the total number of\nelements it contains.\n\n\n\n**Complexity Analysis:**\n**Time Complexity:** O(1)\n**Space Complexity:** O(N)\n\n",
        "metadata": {
            "lesson_name": "Basic Operations for Queue in Data Structure",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: Introduction to Queue Data Structure\n\nContent:\nBasic Terminologies of Queue\n\n* ****Front:**** Position of the entry in a queue ready to be served, that is, the\n  first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.\n* ****Rear:****\n  Position of the last entry in the queue, that is, the one most\n  recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.\n* ****Size:**** Size refers to the ****current**** number of elements in the queue.\n* ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.\n\n****Representation of Queue****\n\n![Representation-of-Queue-Data-Structure](\n\nOperations on Queue\n\n### ****1. Enqueue:****\n\nEnqueue operation ****adds (or stores) an element to the end of the queue****.\n\n****Steps:****\n\n1. Check if the ****queue is full****. If so, return an ****overflow**** error and exit.\n2. If the queue is ****not full****, increment the ****rear**** pointer to the next available position.\n3. Insert the element at the rear.\n\n\n![Enqueue-Operation-in-Queue-01.webp](\n\n\n![Enqueue-Operation-in-Queue-02.webp](\n\n\n![Enqueue-Operation-in-Queue-03.webp](\n\n\n![Enqueue-Operation-in-Queue-04.webp](\n\n\n![Enqueue-Operation-in-Queue-05.webp](\n\n\n![Enqueue-Operation-in-Queue-06.webp](\n\n\n\nPrevious\n\n\n\n\n\nPause\n\nNext\n\n\n\n\n\n3 / 6\n\n\n\n### ****2. Dequeue:****\n\nDequeue operation removes the element at the front of the queue. The\nfollowing steps are taken to perform the dequeue operation:\n\n\n1. Check if the ****queue is empty****. If so, return an ****underflow**** error.\n2. Remove the element at the ****front****.\n3. ****Increment**** the ****front**** pointer to the next element.\n\n\n![Dequeue-Operation-in-Queue-01-.webp](\n\n\n![Dequeue-Operation-in-Queue-02-.webp](\n\n\n![Dequeue-Operation-in-Queue-03.webp](\n\n\n![Dequeue-Operation-in-Queue-04.webp](\n\n\n![Dequeue-Operation-in-Queue-05.webp](\n\n\n![Dequeue-Operation-in-Queue-06.webp](\n\n\n\nPrevious\n\n\n\n\n\nPlay\n\nNext\n\n\n\n\n\n1 / 6\n\n\n\n### ****3. Peek or Front Operation:****\n\nThis operation returns the element at the front end without removing\nit.\n\n### 4. Size Operation:\n\nThis operation returns the numbers of elements present in the\nqueue.\n\n### ****5. isEmpty Operation:****\n\nThis operation returns a boolean value that indicates whether the queue\nis empty or not.\n\n### ****6. isFull Operation:****\n\nThis operation returns a boolean value that indicates whether the queue\nis full or not.\n\nImplementation of Queue Data Structure\n\nQueue can be implemented using following data structures:\n\n* [Implementation of Queue using Arrays](\n* [Implementation of Queue using Linked List](\n\nComplexity Analysis of Operations on Queue\n\n| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |\n| --- | --- | --- |\n| ****enqueue**** | O(1) | O(1) |\n| ****dequeue**** | O(1) | O(1) |\n| front | O(1) | O(1) |\n| size | O(1) | O(1) |\n| isEmpty | O(1) | O(1) |\n| isFull | O(1) | O(1) |\n\n****Types of Queues****\n\nQueue data structure can be classified into 4 types:\n\n1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the\n   element from the front of the queue.\n2. [****Double-Ended Queue (Deque)****](\n   In a double-ended queue the insertion and deletion operations, both\n   can be performed from both ends. They are of two types:\n   * ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be\n     taken from only one end but deletion can be done from any of the\n     ends.\n   * ****Output Restricted Queue:****\n     This is also a simple queue. In this type of queue, the input can\n     be taken from both ends but deletion can be done from only one\n     end.\n3. [****Circular Queue:****]( This is a special type of queue where the last position is connected\n   back to the first position. Here also the operations are performed in\n   FIFO order.\n4. [****Priority Queue****](\n   A priority queue is a special queue where the elements are accessed\n   based on the priority assigned to them. They are of two types:\n   * ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in\n     increasing order of their priority values. Element with smallest\n     priority value is popped first.\n   * ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in\n     decreasing order of their priority values. Element with largest\n     priority is popped first.\n\n![Types-of-Queue](\n\n****Applications of Queue Data Structure****\n\nApplication of queue is common. In a computer system, there may be\nqueues of tasks waiting for the printer, for access to disk storage, or\neven in a time-sharing system, for use of the CPU. Within a single\nprogram, there may be multiple requests to be kept in a queue, or one\ntask may create other tasks, which must be done in turn by keeping them\nin a queue.\n\n* A Queue is always used as a buffer when we have a speed mismatch\n  between a producer and consumer. For example keyboard and CPU.\n* Queue can be used where we have a single resource and multiple\n  consumers like a single CPU and multiple processes.\n* In a network, a queue is used in devices such as a router/switch and\n  mail queue.\n* Queue can be used in various algorithm techniques like Breadth First\n  Search, Topological Sort, etc.",
        "metadata": {
            "lesson_name": "Introduction to Queue Data Structure",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: Applications, Advantages and Disadvantages of Linked List\n\nContent:\nAdvantages of Linked Lists (or Most Common Use Cases):\n\n* Linked Lists are mostly used because of their effective insertion and\n  deletion.  We only need to change few pointers (or references) to\n  insert (or delete) an item in the middle\n* [Insertion and deletion]( at any point in a linked list take O(1) time. Whereas in an [array](\n  data structure, insertion / deletion in the middle takes O(n)\n  time.\n* This data structure is simple and can be also used to implement [a stack]( [queues,]( and other [abstract data structures](\n* Implementation of Queue and Deque data structures : Simple array\n  implementation is not efficient at all. We must use circular array to\n  efficiently implement which is complex. But with linked list, it is\n  easy and straightforward. That is why most of the language libraries\n  use Linked List internally to implement these data structures..\n* Linked List might turn out to be more space efficient compare to\n  arrays in cases where we cannot guess the number of elements in\n  advance. In case of arrays, the whole memory for items is allocated\n  together. Even with dynamic sized arrays like vector in C++ or list in\n  Python or ArrayList in Java. the internal working involves\n  de-allocation of whole memory and allocation of a bigger chunk when\n  insertions happen beyond the current capacity.\n\nApplications of Linked Lists:\n\n* Linked Lists can be used to implement stacks, queue, deque, [sparse matrices]( and adjacency list representation of graphs.\n* [Dynamic memory allocation](\n  in operating systems and compilers (linked list of free blocks).\n* Manipulation of polynomials\n* Arithmetic operations on long integers.\n* In operating systems, they can be used in Memory management, process\n  scheduling (for example circular linked list for round robin\n  scheduling) and file system.\n* Algorithms that need to frequently insert or delete items from large\n  collections of data.\n* LRU cache, which uses a doubly linked list to keep track of the most\n  recently used items in a cache.\n\nApplications of Linked Lists in real world:\n\n* The list of songs in the music player are linked to the previous and\n  next songs.\n* In a web browser, previous and next web page URLs can be linked\n  through the previous and next buttons (Doubly Linked List)\n* In image viewer, the previous and next images can be linked with the\n  help of the previous and next buttons (Doubly Linked List)\n* Circular Linked Lists can be used to implement things in round manner\n  where we go to every element one by one.\n* Linked List are preferred over arrays for implementations of Queue\n  and Deque data structures because of fast deletions (or insertions)\n  from the front of the linked lists.\n\nDisadvantages of Linked Lists:\n\nLinked lists are a popular data structure in computer science, but like\nany other data structure, they have certain disadvantages as well. Some\nof the key disadvantages of linked lists are:\n\n* ****Slow Access Time:**** Accessing elements in a linked list can be slow, as you need to\n  traverse the linked list to find the element you are looking for,\n  which is an O(n) operation. This makes linked lists a poor choice for\n  situations where you need to access elements quickly.\n* ****Pointers or References:****\n  Linked lists use pointers or references to access the next node, which\n  can make them more complex to understand and use compared to arrays.\n  This complexity can make linked lists more difficult to debug and\n  maintain.\n* ****Higher overhead:**** Linked lists have a higher overhead compared to arrays, as each node\n  in a linked list requires extra memory to store the reference to the\n  next node.\n* ****Cache Inefficiency:**** Linked lists are cache-inefficient because the memory is not\n  contiguous. This means that when you traverse a linked list, you are\n  not likely to get the data you need in the cache, leading to cache\n  misses and slow performance.\n\nIn conclusion, linked lists are a powerful and flexible data structure,\nbut they have certain disadvantages that need to be taken into\nconsideration when deciding whether to use them or not. For example, if\nyou need fast access time, arrays might be a better choice, but if you\nneed to insert or delete elements frequently, linked lists might be the\nbetter choice.\n",
        "metadata": {
            "lesson_name": "Applications, Advantages and Disadvantages of Linked List",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: Singly Linked List Tutorial\n\nContent:\nUnderstanding Node Structure\n\nIn a singly linked list, each node consists of two parts: data and a\npointer to the next node. This structure allows nodes to be dynamically\nlinked together, forming a chain-like sequence.\n\n\n![Singly-Linked-List](\n\n\n\n\n\n\n\n\nIn this example, the Node class contains an integer data field (****data****) to store the information and a pointer to another Node (****next****) to establish the link to the next node in the list.\n\nOperations on Singly Linked List\n\n* ****Traversal****\n* ****Searching****\n* ****Length****\n* ****Insertion:****\n  + Insert at the beginning\n  + Insert at the end\n  + Insert at a specific position\n* ****Deletion:****\n  + Delete from the beginning\n  + Delete from the end\n  + Delete a specific node\n\nLet's go through each of the operations mentioned above, one by\none.\n\n[****Traversal**** of Singly Linked List](\n\nTraversal involves visiting each node in the linked list and performing\nsome operation on the data. A simple traversal function would print or\nprocess the data of each node.\n\nStep-by-step approach:\n\n* Initialize a pointer current to the head of the list.\n* Use a while loop to iterate through the list until the current\n  pointer reaches NULL.\n* Inside the loop, print the data of the current node and move the\n  current pointer to the next node.\n\n\n\n\n\n\n\n[Searching in Singly Linked List](\n\nSearching in a Singly Linked List refers to the process of looking for\na specific element or value within the elements of the linked list.\n\n\nStep-by-step approach:\n\n1. Traverse the Linked List starting from the head.\n2. Check if the current node's data matches the target value.\n   * If a match is found, return ****true****.\n3. Otherwise, Move to the next node and repeat steps 2.\n4. If the end of the list is reached without finding a match, return ****false****.\n\n\n\n\n\n\n\n\n[Length of Singly Linked List](\n\nFinding Length in Singly Linked List refers to the process of\ndetermining the total number of nodes in a singly linked list.\n\nStep-by-step approach:\n\n* Initialize a counter ****length**** to 0.\n* Start from the head of the list, assign it to current.\n* Traverse the list:\n  + Increment ****length**** for each node.\n  + Move to the next node (****current = current->next****).\n* Return the final value of ****length****.\n\n\n\n\n\n\n\n\n\n[Insertion in Singly Linked List](\n\nInsertion is a fundamental operation in linked lists that involves\nadding a new node to the list. There are several scenarios for\ninsertion:\n\n### a. [Insertion at the Beginning of Singly Linked List](\n\n![Insertion-at-the-Beginning-of-Singly-Linked-List](\n\n\nInsert a Node at the Front/Beginning of Linked List\n\n\n\nStep-by-step approach:\n\n* Create a new node with the given value.\n* Set the ****next**** pointer of the new node to the current head.\n* Move the head to point to the new node.\n* Return the new head of the linked list.\n\n\n\n\n\n\n\n### b. [Insertion at the End of Singly Linked List:](\n\nTo insert a node at the end of the list, traverse the list until the\nlast node is reached, and then link the new node to the current last\nnode-\n\n![Insertion-at-the-End-of-Singly-Linked-List](\n\nInsertion at end of Linked List\n\n\nStep-by-step approach:\n\n* Create a new node with the given value.\n* Check if the list is empty:\n  + If it is, make the new node the head and return.\n* Traverse the list until the last node is reached.\n* Link the new node to the current last node by setting the last node's\n  next pointer to the new node.\n\n\n\n\n\n\n\n\n\n\n### c. [Insertion at a Specific Position of the Singly Linked List:](\n\nTo insert a node at a specific position, traverse the list to the\ndesired position, link the new node to the next node, and update the\nlinks accordingly.\n\n![Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy](\n\n\n\n\nWe mainly find the node after which we need to insert the new node. If\nwe encounter a NULL before reaching that node, it means that the given\nposition is invalid.\n\n\n\n\n\n\n\n\n\n\n\n\n\n[Deletion in Singly Linked List](\n\nDeletion involves removing a node from the linked list. Similar to\ninsertion, there are different scenarios for deletion:\n\n### a. [****Deletion at the Beginning of**** Singly Linked List****:****](\n\nTo delete the first node, update the head to point to the second node\nin the list.\n\n![Deletion-at-beginning-](\n\nDeletion at beginning in a Linked List\n\n\nSteps-by-step approach:\n\n* Check if the head is ****NULL****.\n  + If it is, return ****NULL**** (the list is empty).\n* Store the current head node in a temporary variable ****temp****.\n* Move the head pointer to the next node.\n* Delete the temporary node.\n* Return the new head of the linked list.\n\n\n\n\n\n\n\n### b. [Deletion at the End of Singly Linked List:](\n\nTo delete the last node, traverse the list until the second-to-last\nnode and update its next field to None.\n\n![Deletion-At-End](\n\nDeletion at the end of linked list\n\n\nStep-by-step approach:\n\n* Check if the head is ****NULL****.\n  + If it is, return NULL (the list is empty).\n* Check if the head's ****next**** is ****NULL**** (only one node in the list).\n  + If true, delete the head and return ****NULL****.\n* Traverse the list to find the second last node (****second\\_last****).\n* Delete the last node (the node after ****second\\_last****).\n* Set the ****next**** pointer of the second last node to ****NULL****.\n* Return the head of the linked list.\n\n\n\n\n\n\n\n\n\n### c. [Deletion at a Specific Position of Singly Linked List:](\n\nTo delete a node at a specific position, traverse the list to the\ndesired position, update the links to bypass the node to be\ndeleted.\n\n![Deletion-specific-At-End--](\n\nDelete a Linked List node at a given position\n\n\nStep-by-step approach:\n\n* Check if the list is empty or the position is invalid, return if\n  so.\n* If the head needs to be deleted, update the head and delete the\n  node.\n* Traverse to the node before the position to be deleted.\n* If the position is out of range, return.\n* Store the node to be deleted.\n* Update the links to bypass the node.\n* Delete the stored node.\n\n\n\n\n\n\n\n",
        "metadata": {
            "lesson_name": "Singly Linked List Tutorial",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: Introduction to Circular Linked List\n\nContent:\nWhat is a Circular Linked List?\n\nA ****circular linked list****\nis a special type of linked list where all the nodes are connected to\nform a circle. Unlike a regular linked list, which ends with a node\npointing to ****NULL****, the last node in a circular linked list points back to the first\nnode. This means that you can keep traversing the list without ever\nreaching a ****NULL**** value.\n\nTypes of Circular Linked Lists\n\nWe can create a circular linked list from both [singly linked lists]( and [doubly linked lists]( So, circular linked list are basically of two types:\n\n### 1. Circular Singly Linked List\n\nIn ****Circular Singly Linked List****, each node has just one pointer called the \u201c****next****\u201d pointer. The next pointer of ****last node**** points back to the ****first node**** and this results in forming a circle. In this type of Linked list we\ncan only move through the list in one direction.\n\n![Representation-of-circular-linked-list](\n\nRepresentation of Circular Singly Linked List\n\n### 2. Circular Doubly Linked List:\n\nIn ****circular doubly linked**** ****list,**** each node has two pointers ****prev**** and ****next,**** similar to doubly linked list. The ****prev**** pointer points to the previous node and the ****next**** points to the next node. Here, in addition to the ****last**** node storing the address of the first node, the ****first node**** will also store the address of the ****last node****.\n\n![Representation-of-circular-doubly-linked-list](\n\nRepresentation of Circular Doubly Linked List\n\n****Note:**** In this article, we will use the circular singly linked list to explain\nthe working of circular linked lists.\n\nRepresentation of a Circular Singly Linked List\n\nLet\u2019s take a look on the structure of a circular linked list.\n\n\n\n![Node-structure-of-circular-linked-list](\n\nRepresentation of a Circular Singly Linked List\n\n### Create/Declare a Node of Circular Linked List\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the code above, each node has ****data**** and a ****pointer**** to the next node. When we create multiple nodes for a circular linked\nlist, we only need to connect the last node back to the first one.\n\nExample of Creating a Circular Linked List\n\nHere\u2019s an example of creating a circular linked list with three nodes\n(2, 3, 4):\n\n![Circular-Linked-List](\n\n\n\n\n\n\n\n\n\n\n\nIn the above code, we have created three nodes ****first, second,**** and ****last**** having values ****2, 3,**** and ****4**** respectively.\n\n* After creating three nodes, we have connected these node in a\n  series.\n* Connect the first node \u201c****first\u201d**** to \u201c****second\u201d**** node by ****s****toring the address of \u201c****second\u201d**** nodeinto ****first\u2019s**** next\n* Connect the second node \u201c****second\u201d**** to \u201c****second\u201d**** node by ****s****toring the address of \u201c****third****\u201d node into ****second\u2019s**** next\n* After connecting all the nodes, we reach the key characteristic of a\n  circular linked list: linking the last node back to the first node. Therefore, we store the address of the \u201c****first****\u201d node in the \u201c****last****\u201d node.\n\n### Why have we taken a pointer that points to the last node instead of the first node?\n\nFor the insertion of a node at the beginning, we need to traverse the\nwhole list. Also, for insertion at the end, the whole list has to be\ntraversed. If instead of the start pointer, we take a pointer to the\nlast node, then in both cases there won\u2019t be any need to traverse the\nwhole list. So insertion at the beginning or at the end takes constant\ntime, irrespective of the length of the list.\n\nOperations on the Circular Linked list:\n\nWe can do some operations on the circular linked list similar to the\nsingly and doubly linked list which are:\n\n* ****Insertion****\n  + Insertion at the empty list\n  + Insertion at the beginning\n  + Insertion at the end\n  + Insertion at the given position\n* ****Deletion****\n  + Delete the first node\n  + Delete the last node\n  + Delete the node from any position\n* ****Searching****\n\n****Note:**** We will be using the circular singly linked list to represent the\nworking of the circular linked list.\n\n[Insertion in the circular linked list:](\n\nInsertion is a fundamental operation in linked lists that involves\nadding a new node to the list. The only extra step is connecting the\nlast node to the first one. In the circular linked list mentioned below,\nwe can insert nodes in four ways:\n\n### 1. Insertion in an empty List in the circular linked list\n\n> To insert a node in empty circular linked list, creates a ****new node**** with the given data, sets its next pointer to point to itself, and\n> updates the ****last**** pointer to reference this ****new node****.\n\n![Insertion-in-an-empty-list-in-circular-linked-list](\n\n\n\n\n\n\n### 2. Insertion at the beginning in circular linked list\n\n> To insert a new node at the beginning of a circular linked list, we\n> first create the ****new node****\n> and allocate memory for it. If the list is empty (indicated by the\n> last pointer being ****NULL****), we make the ****new node****\n> point to itself. If the list already contains nodes then we set the ****new node\u2019s**** next pointer to point to the ****current head**** of the list (which is ****last->next****), and then update the last node\u2019s next pointer to point to the ****new node****. This maintains the circular structure of the list.\n\n![Insertion-at-the-beginning-of-circular-linked-list](\n\n\n\n\n\n\n\n### 3. Insertion at the end in circular linked list\n\n> To insert a new node at the end of a circular linked list, we first\n> create the new node and allocate memory for it. If the list is empty\n> (mean, ****last**** or ****tail**** pointer being ****NULL****), we initialize the list with the ****new node**** and making it point to itself to form a circular structure. If the\n> list already contains nodes then we set the ****new node\u2019s**** next pointer to point to the ****current head**** (which is ****tail->next****), then update the ****current tail\u2019s**** next pointer to point to the ****new node****. Finally, we update the ****tail pointer**** to the ****new node.**** This will ensure that the ****new node**** is now the ****last node**** in the list while maintaining the circular linkage.\n\n![Insertion-at-the-end-of-circular-linked-list](\n\n\n\n\n\n\n### 4. Insertion at specific position in circular linked list\n\n> To insert a new node at a specific position in a circular linked\n> list, we first check if the list is empty. If it is and the ****position**** is not ****1****\n> then we print an error message because the position doesn\u2019t exist in\n> the list. If the ****position**** is ****1**** then we create the ****new node**** and make it point to itself. If the list is not empty, we create the ****new node**** and traverse the list to find the correct insertion point. If the ****position**** is ****1****, we insert the ****new node****\n> at the beginning by adjusting the pointers accordingly. For other\n> positions, we traverse through the list until we reach the desired\n> position and inserting the ****new node****\n> by updating the pointers. If the new node is inserted at the end, we\n> also update the ****last****\n> pointer to reference the new node, maintaining the circular structure\n> of the list.\n\n![Insertion-at-specific-position-of-circular-linked-list](\n\n\n\n\n\n\n\n[Deletion from a Circular Linked List](\n\nDeletion involves removing a node from the linked list. The main\ndifference is that we need to ensure the list remains circular after the\ndeletion. We can delete a node in a circular linked list in three\nways:\n\n### 1. Delete the first node in circular linked list\n\n> To delete the first node of a circular linked list, we first check if\n> the list is empty. If it is then we print a message and return ****NULL****. If the list contains only one node (the ****head**** is the same as the ****last****) then we delete that node and set the ****last**** pointer to ****NULL****. If there are multiple nodes then we update the ****last->next**** pointer to skip the ****head**** node and effectively removing it from the list. We then delete the ****head**** node to free the allocated memory. Finally, we return the updated ****last**** pointer, which still points to the ****last**** node in the list.\n\n![Deletion-from-the-beginning-of-circular-linked-list](\n\n\n\n\n\n\n### 2. Delete a specific node in circular linked list\n\n> To delete a specific node from a circular linked list, we first check\n> if the list is empty. If it is then we print a message and return ****nullptr****. If the list contains only one node and it matches the ****key**** then we delete that node and set ****last**** to ****nullptr****. If the node to be deleted is the first node then we update\n> the ****next**** pointer of the ****last**** node to skip the ****head**** node and delete the ****head****. For other nodes, we traverse the list using two pointers: ****curr**** (to find the node) and ****prev****\n> (to keep track of the previous node). If we find the node with the\n> matching key then we update the next pointer of ****prev**** to skip the ****curr****\n> node and delete it. If the node is found and it is the last node, we\n> update the ****last****\n> pointer accordingly. If the node is not found then do nothing and ****tail**** or ****last**** as it is. Finally, we return the updated ****last**** pointer.\n\n![Delete-a-specific-node-in-circular-linked-list](\n\n\n\n\n\n\n### 3. Deletion at the end of Circular linked list\n\n> To delete the last node in a circular linked list, we first check if\n> the list is empty. If it is, we print a message and return ****nullptr****. If the list contains only one node (where the ****head**** is the same as the ****last****), we delete that node and set ****last**** to ****nullptr****. For lists with multiple nodes, we need to traverse the list to find\n> the ****second last node****. We do this by starting from the ****head**** and moving through the list until we reach the node whose next\n> pointer points to ****last****. Once we find the ****second last**** node then we update its next pointer to point back to the ****head,****\n> this effectively removing the last node from the list. We then delete\n> the last node to free up memory and return the updated ****last**** pointer, which now points to the last node.\n\n![Deletion-at-the-end-of-circular-linked-list](\n\n\n\n\n\n\n\n\n[Searching in Circular Linked list](\n\nSearching in a circular linked list is similar to searching in a\nregular linked list. We start at a given node and traverse the list\nuntil you either find the target value or return to the starting node.\nSince the list is circular, make sure to keep track of where you started\nto avoid an infinite loop.\n\n> To search for a specific value in a circular linked list, we first\n> check if the list is empty. If it is then we return ****false****. If the list contains nodes then we start from the ****head**** node (which is the ****last->next****) and traverse the list. We use a pointer ****curr**** to iterate through the nodes until we reach back to the ****head****. During traversal, if we find a node whose ****data**** matches the given ****key**** then we return ****true**** to indicating that the value was found. After the loop, we also check\n> the last node to ensure we don\u2019t miss it. If the ****key**** is not found after traversing the entire list then we return ****false****.\n\n\n\n\n\n\n\n\nAdvantages of Circular Linked Lists\n\n* In circular linked list, the last node points to the first node.\n  There are no null references, making traversal easier and reducing the\n  chances of encountering null pointer exceptions.\n* We can traverse the list from any node and return to it without\n  needing to restart from the head, which is useful in applications\n  requiring a circular iteration.\n* Circular linked lists can easily implement circular queues, where the\n  last element connects back to the first, allowing for efficient\n  resource management.\n* In a circular linked list, each node has a reference to the next node\n  in the sequence. Although it doesn\u2019t have a direct reference to the\n  previous node like a doubly linked list, we can still find the\n  previous node by traversing the list.\n\nDisadvantages of Circular Linked Lists\n\n* Circular linked lists are more complex to implement than singly\n  linked lists.\n* Traversing a circular linked list without a clear stopping condition\n  can lead to infinite loops if not handled carefully.\n* Debugging can be more challenging due to the circular nature, as\n  traditional methods of traversing linked lists may not apply.\n\nApplications of Circular Linked Lists\n\n* It is used for time-sharing among different users, typically through\n  a ****Round-Robin scheduling mechanism.****\n* In multiplayer games, a circular linked list can be used to switch\n  between players. After the last player\u2019s turn, the list cycles back to\n  the first player.\n* Circular linked lists are often used in buffering applications, such\n  as streaming data, where data is continuously produced and\n  consumed.\n* In media players, circular linked lists can manage playlists, this\n  allowing users to loop through songs continuously.\n* Browsers use circular linked lists to manage the cache. This allows\n  you to navigate back through your browsing history efficiently by\n  pressing the BACK button.",
        "metadata": {
            "lesson_name": "Introduction to Circular Linked List",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: What is Stack Data Structure? A Complete Tutorial\n\nContent:\nRepresentation of Stack Data Structure:\n\nStack follows LIFO (Last In First Out) Principle so the element which\nis pushed last is popped first.\n\n\n![Stack-representation-in-Data-Structures-(1)](\n\n****Types of Stack:****\n\n* ****Fixed Size Stack****\n  : As the name suggests, a fixed size stack has a fixed size and cannot\n  grow or shrink dynamically. If the stack is full and an attempt is\n  made to add an element to it, an overflow error occurs. If the stack\n  is empty and an attempt is made to remove an element from it, an\n  underflow error occurs.\n* ****Dynamic Size Stack****\n  : A dynamic size stack can grow or shrink dynamically. When the stack\n  is full, it automatically increases its size to accommodate the new\n  element, and when the stack is empty, it decreases its size. This type\n  of stack is implemented using a linked list, as it allows for easy\n  resizing of the stack.\n\nBasic Operations on Stack:\n\nIn order to make manipulations in a stack, there are certain operations\nprovided to us.\n\n\n* ****push()****  to insert an element into the stack\n* ****pop()****  to remove an element from the stack\n* ****top()****  Returns the top element of the stack.\n* ****isEmpty()****  returns true if stack is empty else false.\n* ****isFull()****  returns true if the stack is full else false.\n\nTo implement stack, we need to maintain reference to the top\nitem.\n\n### ****Push Operation on Stack****\n\nAdds an item to the stack. If the stack is full, then it is said to be\nan  ****Overflow condition.****\n\n ****Algorithm for Push Operation:****\n\n* Before pushing the element to the stack, we check if the stack is  ****full****  .\n* If the stack is full  ****(top == capacity-1)****  , then  ****Stack Overflows****  and we cannot insert the element to the stack.\n* Otherwise, we increment the value of top by 1  ****(top = top + 1)****  and the new value is inserted at  ****top position****  .\n* The elements can be pushed into the stack till we reach the  ****capacity****  of the stack.\n\n![Push-Operation-in-Stack-(1)](\n### ****Pop Operation in Stack****\n\nRemoves an item from the stack. The items are popped in the reversed\norder in which they are pushed. If the stack is empty, then it is said\nto be an  ****Underflow condition.****\n\n****Algorithm for Pop Operation:****\n\n* Before popping the element from the stack, we check if the stack is  ****empty****  .\n* If the stack is empty (top == -1), then  ****Stack Underflows****  and we cannot remove any element from the stack.\n* Otherwise, we store the value at top, decrement the value of top by 1  ****(top = top \u2013 1)****  and return the stored top value.\n\n![Pop-Operation-in-Stack-(1)](\n### ****Top or Peek Operation on Stack****\n\nReturns the top element of the stack.\n\n****Algorithm for Top Operation:****\n\n* Before returning the top element from the stack, we check if the\n  stack is empty.\n* If the stack is empty (top == -1), we simply print \u201cStack is empty\u201d.\n* Otherwise, we return the element stored at  ****index = top****  .\n\n![Top-or-Peek-Operation-in-Stack-(1)](\n### ****isEmpty Operation in Stack Data Structure:****\n\nReturns true if the stack is empty, else false.\n\n****Algorithm for isEmpty Operation****:\n\n* Check for the value of  ****top****  in stack.\n* If  ****(top == -1)****, then the stack is  ****empty****  so return  ****true****  .\n* Otherwise, the stack is not empty so return  ****false****  .\n\n![isEmpty-Operation-in-Stack-(1)](\n### isFull ****Operation in Stack**** ****Data Structure****:\n\nReturns true if the stack is full, else false.\n\n****Algorithm for isFull Operation:****\n\n* Check for the value of  ****top****  in stack.\n* If  ****(top == capacity-1),****  then the stack is  ****full****  so return  ****true****.\n* Otherwise, the stack is not full so return  ****false****.\n\n![isFull-Operation-in-Stack-(1)](\n\nImplementation of Stack\n\n\nThe basic operations that can be performed on a stack include push, pop,\nand peek. There are two ways to implement a stack \u2013\n\n\n* [****Implementation of Stack using Array****](\n* [****Implementation of Stack using Linked List****](\n\n****Complexity Analysis of Operations on Stack Data Structure:****\n\n| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |\n| --- | --- | --- |\n| ****push()**** | O(1) | O(1) |\n| ****pop()**** | O(1) | O(1) |\n| top() or  ****pee****k() | O(1) | O(1) |\n| isEmpty() | O(1) | O(1) |\n| isFull() | O(1) | O(1) |",
        "metadata": {
            "lesson_name": "What is Stack Data Structure? A Complete Tutorial",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: Implement Stack using Array\n\nContent:\nImplement Stack using Array:\n\n> To implement a stack using an array, initialize an array and treat\n> its end as the stack\u2019s top. Implement ****push**** (add to end), ****pop**** (remove from end), and ****peek**** (check end) operations, handling cases for an ****empty**** or f****ull stack****.\n\n****Step-by-step approach:****\n\n1. ****Initialize an array**** to represent the stack.\n2. Use the ****end of the array**** to represent the ****top of the stack****.\n3. Implement ****push**** (add to end), ****pop**** (remove from the end), and ****peek**** (check end) operations, ensuring to handle empty and full stack\n   conditions.\n\nImplement Stack Operations using Array:\n\n\nHere are the following operations of implement stack using array:\n\n### ****Push Operation in Stack:****\n\nAdds an item to the stack. If the stack is full, then it is said to be\nan ****Overflow condition.****\n\n****Algorithm for Push Operation:****\n\n> * Before pushing the element to the stack, we check if the stack\n>   is ****full****.\n> * If the stack is full ****(top == capacity-1)**** , then ****Stack Overflows****and we cannot insert the element to the stack.\n> * Otherwise, we increment the value of top by 1 ****(top = top + 1)**** and the new value is inserted at ****top position****.\n> * The elements can be pushed into the stack till we reach\n>   the ****capacity**** of the stack.\n\n![push-operation-in-stack-1.webp](\n\n\n![push-operation-in-stack-2.webp](\n\n\n![push-operation-in-stack-3.webp](\n\n\n![push-operation-in-stack-4.webp](\n\n\n![push-operation-in-stack-5.webp](\n\n\n![push-operation-in-stack-6.webp](\n\n\n\nPrevious\n\n\n\n\n\nPause\n\nNext\n\n\n\n\n\n5 / 6\n\n### ****Pop Operation in Stack:****\n\nRemoves an item from the stack. The items are popped in the reversed\norder in which they are pushed. If the stack is empty, then it is said\nto be an ****Underflow condition.****\n\n****Algorithm for Pop Operation:****\n\n> * Before popping the element from the stack, we check if the stack\n>   is ****empty****.\n> * If the stack is empty (top == -1), then ****Stack Underflows**** and we cannot remove any element from the stack.\n> * Otherwise, we store the value at top, decrement the value of top by\n>   1 ****(top = top \u2013 1)**** and return the stored top value.\n\n![pop-operation-in-stack-1.webp](\n\n\n![pop-operation-in-stack-2.webp](\n\n\n![pop-operation-in-stack-3.webp](\n\n\n![pop-operation-in-stack-4.webp](\n\n\n![pop-operation-in-stack-5.webp](\n\n\n![pop-operation-in-stack-6.webp](\n\n\n\nPrevious\n\n\n\n\n\nPlay\n\nNext\n\n\n\n\n\n1 / 6\n\n\n\n\n### ****Top or Peek Operation in Stack:****\n\nReturns the top element of the stack.\n\n****Algorithm for Top Operation:****\n\n> * Before returning the top element from the stack, we check if the\n>   stack is empty.\n> * If the stack is empty (top == -1), we simply print \u201cStack is\n>   empty\u201d.\n> * Otherwise, we return the element stored at ****index = top****.\n\n### ****isEmpty Operation in Stack:****\n\nReturns true if the stack is empty, else false.\n\n****Algorithm for isEmpty Operation****:\n\n> * Check for the value of ****top**** in stack.\n> * If ****(top == -1)**** , then the stack is ****empty****so return ****true****.\n> * Otherwise, the stack is not empty so return ****false****.\n\n### isFull ****Operation in Stack****:\n\nReturns true if the stack is full, else false.\n\n****Algorithm for isFull Operation:****\n\n> * Check for the value of ****top**** in stack.\n> * If ****(top == capacity-1),**** then the stack is ****full**** so return ****true****.\n> * Otherwise, the stack is not full so return ****false.****\n\n\n\n\n\n\n\n### Complexity Analysis:\n\n* ****Time Complexity****:\n  + `push`: O(1)\n  + `pop`: O(1)\n  + `peek`: O(1)\n  + `is_empty`: O(1)\n  + is\\_full: O(1)\n* ****Auxiliary Space****: O(n), where n is the number of items in the stack.\n\nAdvantages of Array Implementation:\n\n* Easy to implement.\n* Memory is saved as pointers are not involved.\n\nDisadvantages of Array Implementation:\n\n* It is not dynamic i.e., it doesn\u2019t grow and shrink depending on needs\n  at runtime. [But in case of dynamic sized arrays like vector in C++,\n  list in Python, ArrayList in Java, stacks can grow and shrink with\n  array implementation as well].\n* The total size of the stack must be defined beforehand.\n",
        "metadata": {
            "lesson_name": "Implement Stack using Array",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: Applications, Advantages and Disadvantages of Stack\n\nContent:\nApplications of Stacks:\n\n* ****Function calls:****\n  Stacks are used to keep track of the return addresses of function\n  calls, allowing the program to return to the correct location after a\n  function has finished executing.\n* ****Recursion:**** Stacks are used to store the local variables and return addresses of\n  recursive function calls, allowing the program to keep track of the\n  current state of the recursion.\n* ****Expression evaluation:**** Stacks are used to evaluate expressions in postfix notation (Reverse\n  Polish Notation).\n* ****Syntax parsing:**** Stacks are used to check the validity of syntax in programming\n  languages and other formal languages.\n* ****Memory management:**** Stacks are used to allocate and manage memory in some operating\n  systems and programming languages.\n* Used to solve popular problems like [Next Greater]( [Previous Greater]( [Next Smaller]( [Previous Smaller]( [Largest Area in a Histogram]( and [Stock Span Problems](\n\nAdvantages of Stacks:\n\n* ****Simplicity:**** Stacks are a simple and easy-to-understand data structure, making\n  them suitable for a wide range of applications.\n* ****Efficiency:**** Push and pop operations on a stack can be performed in constant time ****(O(1))****, providing efficient access to data.\n* ****Last-in, First-out (LIFO):****\n  Stacks follow the LIFO principle, ensuring that the last element added\n  to the stack is the first one removed. This behavior is useful in many\n  scenarios, such as function calls and expression evaluation.\n* ****Limited memory usage:**** Stacks only need to store the elements that have been pushed onto\n  them, making them memory-efficient compared to other data\n  structures.\n\nDisadvantages of Stacks:\n\n* ****Limited access:****\n  Elements in a stack can only be accessed from the top, making it\n  difficult to retrieve or modify elements in the middle of the\n  stack.\n* ****Potential for overflow:**** If more elements are pushed onto a stack than it can hold, an\n  overflow error will occur, resulting in a loss of data.\n* ****Not suitable for random access:**** Stacks do not allow for random access to elements, making them\n  unsuitable for applications where elements need to be accessed in a\n  specific order.\n* ****Limited capacity:****\n  Stacks have a fixed capacity, which can be a limitation if the number\n  of elements that need to be stored is unknown or highly\n  variable.\n",
        "metadata": {
            "lesson_name": "Applications, Advantages and Disadvantages of Stack",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: Introduction to DSA I\n\nLesson Name: Doubly Linked List Tutorial\n\nContent:\nWhat is a Doubly Linked List?\n\nA ****doubly linked list****\nis a data structure that consists of a set of nodes, each of which\ncontains a ****value**** and ****two pointers****, one pointing to the ****previous node**** in the list and one pointing to the ****next node****\nin the list. This allows for efficient traversal of the list in ****both directions****, making it suitable for applications where frequent ****insertions**** and ****deletions**** are required.\n\n![Insertion-at-the-End-in-Doubly-Linked-List-copy](\n\nDoubly Linked List\n\n\nRepresentation of Doubly Linked List in Data Structure\n\nIn a data structure, a doubly linked list is represented using nodes\nthat have three fields:\n\n1. Data\n2. A pointer to the next node (****next****)\n3. A pointer to the previous node (****prev****)\n\n![Node-Structure-of-Doubly-Linked-List](\n\nNode Structure of Doubly Linked List\n\n\nNode Definition\n\nHere is how a node in a Doubly Linked List is typically\nrepresented:\n\n[Try it on GfG Practice\n![redirect icon](\nC++\n````\nstruct Node {\n\n    // To store the Value or data.\n    int data;\n\n    // Pointer to point the Previous Element\n    Node* prev;\n\n    // Pointer to point the Next Element\n    Node* next;\n\n    // Constructor\n    Node(int d) {\n       data = d;\n       prev = next = nullptr;\n    }\n};\n\nstruct Node {\n\n    // To store the Value or data.\n    int data;\n\n    // Pointer to point the Previous Element\n    Node* prev;\n\n    // Pointer to point the Next Element\n    Node* next;\n};\n\n// Function to create a new node\nstruct Node *createNode(int new_data) {\n    struct Node *new_node = (struct Node *)\n    malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    new_node->prev = NULL;\n    return new_node;\n}\n\nclass Node {\n\n    // To store the Value or data.\n    int data;\n\n    // Reference to the Previous Node\n    Node prev;\n\n    // Reference to the next Node\n    Node next;\n\n    // Constructor\n    Node(int d) {\n       data = d;\n       prev = next = null;\n    }\n};\n\nclass Node:\n\n    def __init__(self, data):\n        # To store the value or data.\n        self.data = data\n\n        # Reference to the previous node\n        self.prev = None\n\n        # Reference to the next node\n        self.next = None\n\nclass Node\n{\n  \t// To store the value or data\n    public int Data;\n\n  \t// Pointer to the next node\n    public Node Next;\n\n  \t// Pointer to the previous node\n    public Node Prev;\n\n    // Constructor\n    public Node(int d)\n    {\n        Data = d;\n        Prev = Next = null;\n    }\n}\n\nclass Node {\n    constructor(data)\n    {\n        // To store the value or data.\n        this.data = data;\n\n        // Reference to the previous node\n        this.prev = null;\n\n        // Reference to the next node\n        this.next = null;\n    }\n}\n\n#include <iostream>\nusing namespace std;\n\n// Define the Node structure\nstruct Node {\n    int data;\n    Node* next;\n    Node* prev;\n\n// Constructor to initialize Node with data\n    Node(int data) : data(data), next(nullptr),\n  \tprev(nullptr) {}\n};\n\n// Function to traverse the doubly linked list\n// in forward direction\nvoid forwardTraversal(Node* head) {\n\n    // Start traversal from the head of the list\n    Node* curr = head;\n\n// Continue until current node is not null\n    // (end of list)\n    while (curr != nullptr) {\n\n        // Output data of the current node\n        cout << curr->data << \" \";\n\n// Move to the next node\n        curr = curr->next;\n}\n\n    // Print newline after traversal\n    cout << endl;\n}\n\n// Function to traverse the doubly linked list\n// in backward direction\nvoid backwardTraversal(Node* tail) {\n\n    // Start traversal from the tail of the list\n    Node* curr = tail;\n\n// Continue until current node is not null\n    // (end of list)\n    while (curr != nullptr) {\n\n        // Output data of the current node\n        cout << curr->data << \" \";\n\n// Move to the previous node\n        curr = curr->prev;\n}\n\n    // Print newline after traversal\n    cout << endl;\n}\n\nint main() {\n\n    // Sample usage of the doubly linked list and\n    // traversal functions\n    Node* head = new Node(1);\n    Node* second = new Node(2);\n    Node* third = new Node(3);\n\n    head->next = second;\nsecond->prev = head;\nsecond->next = third;\n    third->prev = second;\n\n    cout << \"Forward Traversal:\" << endl;\n    forwardTraversal(head);\n\n    cout << \"Backward Traversal:\" << endl;\n    backwardTraversal(third);\n\nreturn 0;\n}\n\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the Node structure\nstruct Node {\n    int data; // Data stored in the node\n    struct Node* next; // Pointer to the next node\n    struct Node* prev; // Pointer to the previous node\n};\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode =\n      (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    newNode->prev = NULL;\nreturn newNode;\n}\n\n// Function to traverse the doubly linked list\n// in forward direction\nvoid forwardTraversal(struct Node* head) {\n\n    // Start traversal from the head of the list\n    struct Node* curr = head;\n\n// Continue until the current node is not\n    // null (end of list)\n    while (curr != NULL) {\n\n        // Output data of the current node\n        printf(\"%d \", curr->data);\n\n// Move to the next node\n        curr = curr->next;\n}\n\n    // Print newline after traversal\n    printf(\"\\n\");\n}\n\n// Function to traverse the doubly linked list\n// in backward direction\nvoid backwardTraversal(struct Node* tail) {\n\n    // Start traversal from the tail of the list\n    struct Node* curr = tail;\n\n// Continue until the current node is not\n    // null (end of list)\n    while (curr != NULL) {\n\n        // Output data of the current node\n        printf(\"%d \", curr->data);\n\n// Move to the previous node\n        curr = curr->prev;\n}\n\n    // Print newline after traversal\n    printf(\"\\n\");\n}\n\nint main() {\n\n    // Sample usage of the doubly linked list and\n    // traversal functions\n    struct Node* head = createNode(1);\n    struct Node* second = createNode(2);\n    struct Node* third = createNode(3);\n\n    head->next = second;\nsecond->prev = head;\nsecond->next = third;\n    third->prev = second;\n\n    printf(\"Forward Traversal:\\n\");\n    forwardTraversal(head);\n\n    printf(\"Backward Traversal:\\n\");\n    backwardTraversal(third);\n\n// Free memory allocated for nodes\n    free(head);\n    free(second);\n    free(third);\n\nreturn 0;\n}\n\n// Define the Node class\nclass Node {\n    int data; // Data stored in the node\n    Node next; // Pointer to the next node\n    Node prev; // Pointer to the previous node\n\n    // Constructor to initialize the node with data\n    public Node(int data) {\n        this.data = data;\n        this.next = null;\n        this.prev = null;\n}\n}\n\n// Class to manage the doubly linked list\nclass GfG {\n\n    // Function to traverse the doubly linked list\n    // in forward direction\n    static void forwardTraversal(Node head) {\n\n        // Start traversal from the head of the list\n        Node curr = head;\n\n// Continue until the current node is\n        // null (end of the list)\n        while (curr != null) {\n\n            // Output data of the current node\n            System.out.print(curr.data + \" \");\n\n// Move to the next node\n            curr = curr.next;\n}\n\n        // Print newline after traversal\n        System.out.println();\n}\n\n    // Function to traverse the doubly linked list\n  \t//in backward direction\n    static void backwardTraversal(Node tail) {\n\n        // Start traversal from the tail of the list\n        Node curr = tail;\n\n// Continue until the current node is\n        // null (end of the list)\n        while (curr != null) {\n\n            // Output data of the current node\n            System.out.print(curr.data + \" \");\n\n// Move to the previous node\n            curr = curr.prev;\n}\n\n        // Print newline after traversal\n        System.out.println();\n}\n\n    public static void main(String[] args) {\n\n        // Sample usage of the doubly linked\n        // list and traversal functions\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.next = second;\nsecond.prev = head;\nsecond.next = third;\n        third.prev = second;\n\n        System.out.println(\"Forward Traversal:\");\n        forwardTraversal(head);\n\n        System.out.println(\"Backward Traversal:\");\n        backwardTraversal(third);\n}\n}\n\n# Define the Node class\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n# Function to traverse the doubly linked list\n# in forward direction\ndef forward_traversal(head):\n\n    # Start traversal from the head of the list\n    curr = head\n\n    # Continue until the current node is\n    # null (end of the list)\n    while curr is not None:\n\n        # Output data of the current node\n        print(curr.data, end=\" \")\n\n        # Move to the next node\n        curr = curr.next\n\n    # Print newline after traversal\n    print()\n\n# Function to traverse the doubly linked\n# list in backward direction\ndef backward_traversal(tail):\n\n    # Start traversal from the tail of the list\n    curr = tail\n\n    # Continue until the current node\n    # is null (end of the list)\n    while curr is not None:\n\n        # Output data of the current node\n        print(curr.data, end=\" \")\n\n        # Move to the previous node\n        curr = curr.prev\n\n    # Print newline after traversal\n    print()\n\n# Sample usage of the doubly linked list\n# and traversal functions\nif __name__ == \"__main__\":\n\n    # Create a doubly linked list with 3 nodes\n    head = Node(1)\n    second = Node(2)\n    third = Node(3)\n\n    head.next = second\n    second.prev = head\n    second.next = third\n    third.prev = second\n\n    print(\"Forward Traversal:\")\n    forward_traversal(head)\n\n    print(\"Backward Traversal:\")\n    backward_traversal(third)\n\nusing System;\n\n// Define the Node class\nclass Node\n{\n    public int Data; // Data stored in the node\n    public Node Next; // Pointer to the next node\n    public Node Prev; // Pointer to the previous node\n\n    // Constructor to initialize the node with data\n    public Node(int data)\n    {\n        Data = data;\nNext = null;\n        Prev = null;\n}\n}\n\n// Class to manage the doubly linked list\nclass GfG\n{\n    // Function to traverse the doubly linked list\n  \t//in forward direction\n    static void ForwardTraversal(Node head)\n    {\n        // Start traversal from the head of the list\n        Node curr = head;\n\n// Continue until the current node is null\n      \t//(end of the list)\n        while (curr != null)\n        {\n            // Output data of the current node\n            Console.Write(curr.Data + \" \");\n\n// Move to the next node\n            curr = curr.Next;\n}\n\n        // Print newline after traversal\n        Console.WriteLine();\n}\n\n    // Function to traverse the doubly linked list\n  \t//in backward direction\n    static void BackwardTraversal(Node tail)\n    {\n        // Start traversal from the tail of the list\n        Node curr = tail;\n\n// Continue until the current node is null\n      \t//(end of the list)\n        while (curr != null)\n        {\n            // Output data of the current node\n            Console.Write(curr.Data + \" \");\n\n// Move to the previous node\n            curr = curr.Prev;\n}\n\n        // Print newline after traversal\n        Console.WriteLine();\n}\n\n    public static void Main()\n    {\n        // Sample usage of the doubly linked list\n      \t//and traversal functions\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.Next = second;\nsecond.Prev = head;\nsecond.Next = third;\n        third.Prev = second;\n\n        Console.WriteLine(\"Forward Traversal:\");\n        ForwardTraversal(head);\n\n        Console.WriteLine(\"Backward Traversal:\");\n        BackwardTraversal(third);\n}\n}\n\n// Define the Node class\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n}\n}\n\n// Function to traverse the doubly linked list\n// in forward direction\nfunction forwardTraversal(head) {\n\n    // Start traversal from the head of the list\n    let curr = head;\n\n// Continue until the current node is null\n    // (end of the list)\n    while (curr !== null) {\n\n        // Output data of the current node\n        console.log(curr.data + \" \");\n\n// Move to the next node\n        curr = curr.next;\n}\n\n    // Print newline after traversal\n    console.log();\n}\n\n// Function to traverse the doubly linked list\n// in backward direction\nfunction backwardTraversal(tail) {\n\n    // Start traversal from the tail of the list\n    let curr = tail;\n\n// Continue until the current node is null\n    // (end of the list)\n    while (curr !== null) {\n\n        // Output data of the current node\n        console.log(curr.data + \" \");\n\n// Move to the previous node\n        curr = curr.prev;\n}\n\n    // Print newline after traversal\n    console.log();\n}\n\n// Sample usage of the doubly linked list\n//and traversal functions\n// Create a doubly linked list with 3 nodes\nconst head = new Node(1);\nconst second = new Node(2);\nconst third = new Node(3);\n\nhead.next = second;\nsecond.prev = head;\nsecond.next = third;\nthird.prev = second;\n\nconsole.log(\"Forward Traversal:\");\nforwardTraversal(head);\n\nconsole.log(\"Backward Traversal:\");\nbackwardTraversal(third);\n\n\n#include <iostream>\n\nusing namespace std;\n\n// Node structure for doubly linked list\nstruct Node {\n    int data;\n    Node * prev;\n    Node * next;\n\n    Node(int val) {\n        data = val;\n        prev = next = nullptr;\n}\n};\n\n// Function to find the length of a doubly\n//linked list\nint findLength(Node * head) {\n    int count = 0;\nfor (Node * cur = head; cur != nullptr; cur = cur -> next)\n        count++;\nreturn count;\n}\n\nint main() {\n\n    // Create a DLL with 3 nodes\n    Node * head = new Node(1);\n    Node * second = new Node(2);\n    Node * third = new Node(3);\n    head -> next = second;\nsecond -> prev = head;\nsecond -> next = third;\n    third -> prev = second;\n\n    cout << \"Length of the doubly linked list: \" <<\n        findLength(head) << endl;\n\nreturn 0;\n}\n\n#include <stdio.h>\n#include <stdlib.h>\n\n// Node structure for doubly linked list\nstruct Node {\n    int data; // Data stored in the node\n    struct Node* prev; // Pointer to the previous node\n    struct Node* next; // Pointer to the next node\n};\n\n// Constructor function to create a new node\nstruct Node* createNode(int val) {\n    struct Node* newNode =\n         (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = val;\n    newNode->prev = NULL;\n    newNode->next = NULL;\nreturn newNode;\n}\n\n// Function to find the length of a doubly linked list\nint findLength(struct Node* head) {\n    int count = 0;\nfor (struct Node* cur = head; cur != NULL; cur = cur->next)\n        count++;\nreturn count;\n}\n\nint main() {\n    // Create a DLL with 3 nodes\n    struct Node* head = createNode(1);\n    struct Node* second = createNode(2);\n    struct Node* third = createNode(3);\n\n    head->next = second;\nsecond->prev = head;\nsecond->next = third;\n    third->prev = second;\n\n    printf(\"Length of the doubly linked list: %d\\n\",\n           findLength(head));\n\nreturn 0;\n}\n\nclass Node {\n    int data;\n    Node prev;\n    Node next;\n\n// Constructor\n    public Node(int val) {\n        data = val;\n        prev = null;\nnext = null;\n}\n}\n\nclass GfG {\n\n    // Function to find the length of\n    // a doubly linked list\n    static int FindLength(Node head) {\n        int count = 0;\nfor (Node cur = head; cur != null; cur = cur.next)\n            count++;\nreturn count;\n}\n\n    // Driver code\n    public static void main(String[] args) {\n\n        // Create a doubly linked list\n        // with 3 nodes\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.next = second;\nsecond.prev = head;\nsecond.next = third;\n        third.prev = second;\n\n        System.out.println(\"Length of doubly linked list: \"\n                           + FindLength(head));\n}\n}\n\nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.prev = None\n        self.next = None\n\n# Function to find the length of\n# a doubly linked list\ndef find_length(head):\n    count = 0\n    cur = head\n    while cur is not None:\n        count += 1\n        cur = cur.next\n    return count\n\n# Driver code\nif __name__ == \"__main__\":\n\n    # Create a doubly linked list\n    # with 3 nodes\n    head = Node(1)\n    second = Node(2)\n    third = Node(3)\n\n    head.next = second\n    second.prev = head\n    second.next = third\n    third.prev = second\n\n    print(\"Length of the doubly linked list: \" +\n          str(find_length(head)))\n\nusing System;\n\nclass Node {\n    public int data;\npublic Node prev;\npublic Node next;\n\n// Constructor\n    public Node(int val) {\n        data = val;\n        prev = null;\nnext = null;\n}\n}\n\npublic class GfG {\n\n    // Function to find the length of\n    // a doubly linked list\n    static int FindLength(Node head) {\n        int count = 0;\nfor (Node cur = head; cur != null; cur = cur.next)\n            count++;\nreturn count;\n}\n\n    // Driver code\n    public static void Main(string[] args) {\n\n        // Create a doubly linked list\n        // with 3 nodes\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.next = second;\nsecond.prev = head;\nsecond.next = third;\n        third.prev = second;\n\n        Console.WriteLine(\"Length of doubly linked list: \"\n                                 + FindLength(head));\n}\n}\n\nclass Node {\n    constructor(val) {\n        this.data = val;\n        this.prev = null;\n        this.next = null;\n}\n}\n\n// Function to find the length of\n// a doubly linked list\nfunction findLength(head) {\n    let count = 0;\n    let cur = head;\n    while (cur !== null) {\n        count++;\n        cur = cur.next;\n}\n    return count;\n}\n\n// Create a doubly linked list with 3 nodes\nconst head = new Node(1);\nconst second = new Node(2);\nconst third = new Node(3);\n\nhead.next = second;\nsecond.prev = head;\nsecond.next = third;\nthird.prev = second;\n\nconsole.log(\"Length of the doubly linked list: \" +\n            findLength(head));\n\n\n\n\n\n\n\n\n\n[Insertion at the End of Doubly Linked List](\n\n![Insertion-at-the-End-in-Doubly-Linked-List](\n\nInsertion at the End in the Doubly Linked List\n\n\nTo insert a new node at the end of the doubly linked list, we can use\nthe following steps:\n\n* Allocate memory for a new node and assign the provided value to its\n  data field.\n* Initialize the next pointer of the new node to nullptr.\n* If the list is empty:\n  + Set the previous pointer of the new node to nullptr.\n  + Update the head pointer to point to the new node.\n                                                                                          * If the list is not empty:\n                                                                                          + Traverse the list starting from the head to reach the last\n                                                                                          node.\n                                                                                          + Set the next pointer of the last node to point to the new\n                                                                                          node.\n                                                                                          + Set the previous pointer of the new node to point to the last\n                                                                                          node.\n\n\n\n\n\n\n\n\n[Insertion at a Specific Position in Doubly Linked List](\n\nTo insert a node at a specific Position in doubly linked list, we can\nuse the following steps:\n\n![Insertion-at-a-Specific-Position-in-Doubly-Linked-List](\n\n\nInsertion at a Specific Position in Doubly Linked List\n\n\n\nTo insert a new node at a specific position,\n\n* If position = 1, create a new node and make it the head of the linked\n  list and return it.\n* Otherwise, traverse the list to reach the node at position \u2013 1,\n  say ****curr****.\n* If the position is valid, create a new node with given data,\n  say ****new\\_node****.\n* Update the next pointer of new node to the next\n                                                                                                                                             of current node and prev pointer of new node to current\n                                                                                                                                             node, ****new\\_node->next = curr->next****and ****new\\_node->prev = curr.****\n                                                                                                                                             * Similarly, update next pointer of current node to\n                                                                                                                                                              thenew node, ****curr->next = new\\_node****.\n                                                                                                                                                              * If the new node is not the last node, update prev pointer of new\n                                                                                                                                                                                                          node\u2019s next to the new node, ****new\\_node->next->prev = new\\_node.****\n\n\n\n\n\n\n\n\n[Deletion at the Beginning of Doubly Linked List](\n\n![Deletion-at-the-Beginning-of-Doubly-Linked-List](\n\nDeletion at the Beginning of Doubly Linked List\n\n\nTo delete a node at the beginning in doubly linked list, we can use the\nfollowing steps:\n\n* Check if the list is empty, there is nothing to delete. Return.\n* Store the head pointer in a variable, say ****temp****.\n* Update the head of linked list to the node next to the current head, ****head = head->next****.\n                                                                        * If the new head is not NULL, update the previous pointer of new head\n                                                                                                           to NULL, ****head->prev = NULL****.\n\n\n\n\n\n\n\n\n[Deletion at the End of Doubly Linked List](\n\n![Deletion-at-the-End-in-Doubly-Linked-List](\n\nDeletion at the End in Doubly Linked List\n\n\nTo delete a node at the end in doubly linked list, we can use the\nfollowing steps:\n\n* Check if the doubly linked list is empty. If it is empty, then there\n  is nothing to delete.\n* If the list is not empty, then move to the last node of the doubly\n  linked list, say ****curr****.\n* Update the second-to-last node's next pointer to NULL, ****curr->prev->next = NULL****.\n* Free the memory allocated for the node that was deleted.\n\n\n\n\n\n\n\n\n[Deletion at a Specific Position in Doubly Linked List](\n\n![Deletion-at-a-Specific-Position-in-Doubly-Linked-List](\n\n\nDeletion at a Specific Position in Doubly Linked List\n\n\n\nTo delete a node at a specific position in doubly linked list, we can\nuse the following steps:\n\n* Traverse to the node at the specified position, say ****curr****.\n* If the position is valid, adjust the pointers to skip the node to be\n  deleted.\n  + If curr is not the head of the linked list, update the next\n    pointer of the node before curr to point to the node after curr, ****curr->prev->next = curr-next****.\n  + If curr is not the last node of the linked list, update the\n    previous pointer of the node after curr to the node before curr, ****curr->next->prev = curr->prev****.\n* Free the memory allocated for the deleted node.\n\n\n\n\n\n\n\n\nAdvantages of Doubly Linked List\n\n* ****Efficient traversal in both directions:**** Doubly linked lists allow for efficient traversal of the list in both\n  directions, making it suitable for applications where frequent\n  insertions and deletions are required.\n* ****Easy insertion and deletion of nodes:**** The presence of pointers to both the previous and next nodes makes it\n  easy to insert or delete nodes from the list, without having to\n  traverse the entire list.\n* ****Can be used to implement a stack or queue:**** Doubly linked lists can be used to implement both stacks and queues,\n  which are common data structures used in programming.\n\nDisadvantages of Doubly Linked List\n\n* ****More complex than singly linked lists:****\n  Doubly linked lists are more complex than singly linked lists, as they\n  require additional pointers for each node.\n* ****More memory overhead:**** Doubly linked lists require more memory overhead than singly linked\n  lists, as each node stores two pointers instead of one.",
        "metadata": {
            "lesson_name": "Doubly Linked List Tutorial",
            "course_name": "Introduction to DSA I\n"
        }
    },
    {
        "page_content": "Course Name: Queue\nLesson Name: Introduction to Queue Data Structure\n\nContent:\nBasic Terminologies of Queue\n\n* ****Front:**** Position of the entry in a queue ready to be served, that is, the\n  first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.\n* ****Rear:****\n  Position of the last entry in the queue, that is, the one most\n  recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.\n* ****Size:**** Size refers to the ****current**** number of elements in the queue.\n* ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.\n\n****Representation of Queue****\n\n![Representation-of-Queue-Data-Structure](\n\nOperations on Queue\n\n### ****1. Enqueue:****\n\nEnqueue operation ****adds (or stores) an element to the end of the queue****. \n\n****Steps:****\n\n1. Check if the ****queue is full****. If so, return an ****overflow**** error and exit.\n2. If the queue is ****not full****, increment the ****rear**** pointer to the next available position.\n3. Insert the element at the rear.\n\n\n![Enqueue-Operation-in-Queue-01.webp](\n\n\n![Enqueue-Operation-in-Queue-02.webp](\n\n\n![Enqueue-Operation-in-Queue-03.webp](\n\n\n![Enqueue-Operation-in-Queue-04.webp](\n\n\n![Enqueue-Operation-in-Queue-05.webp](\n\n\n![Enqueue-Operation-in-Queue-06.webp](\n\n\n\nPrevious\n\n\n\n\n\nPause\n\nNext\n\n\n\n\n\n3 / 6\n\n\n\n### ****2. Dequeue:****\n\nDequeue operation removes the element at the front of the queue. The\nfollowing steps are taken to perform the dequeue operation:\n\n\n1. Check if the ****queue is empty****. If so, return an ****underflow**** error.\n2. Remove the element at the ****front****.\n3. ****Increment**** the ****front**** pointer to the next element.\n\n\n![Dequeue-Operation-in-Queue-01-.webp](\n\n\n![Dequeue-Operation-in-Queue-02-.webp](\n\n\n![Dequeue-Operation-in-Queue-03.webp](\n\n\n![Dequeue-Operation-in-Queue-04.webp](\n\n\n![Dequeue-Operation-in-Queue-05.webp](\n\n\n![Dequeue-Operation-in-Queue-06.webp](\n\n\n\nPrevious\n\n\n\n\n\nPlay\n\nNext\n\n\n\n\n\n1 / 6\n\n\n\n### ****3. Peek or Front Operation:****\n\nThis operation returns the element at the front end without removing\nit.\n\n### 4. Size Operation:\n\nThis operation returns the numbers of elements present in the\nqueue.\n\n### ****5. isEmpty Operation:****\n\nThis operation returns a boolean value that indicates whether the queue\nis empty or not.\n\n### ****6. isFull Operation:****\n\nThis operation returns a boolean value that indicates whether the queue\nis full or not.\n\nImplementation of Queue Data Structure\n\nQueue can be implemented using following data structures:\n\n* [Implementation of Queue using Arrays](\n* [Implementation of Queue using Linked List](\n\nComplexity Analysis of Operations on Queue\n\n| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |\n| --- | --- | --- |\n| ****enqueue**** | O(1) | O(1) |\n| ****dequeue**** | O(1) | O(1) |\n| front | O(1) | O(1) |\n| size | O(1) | O(1) |\n| isEmpty | O(1) | O(1) |\n| isFull | O(1) | O(1) |\n\n****Types of Queues****\n\nQueue data structure can be classified into 4 types:\n\n1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the\n   element from the front of the queue.\n2. [****Double-Ended Queue (Deque)****](\n   In a double-ended queue the insertion and deletion operations, both\n   can be performed from both ends. They are of two types:\n   * ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be\n     taken from only one end but deletion can be done from any of the\n     ends.\n   * ****Output Restricted Queue:****\n     This is also a simple queue. In this type of queue, the input can\n     be taken from both ends but deletion can be done from only one\n     end.\n3. [****Circular Queue:****]( This is a special type of queue where the last position is connected\n   back to the first position. Here also the operations are performed in\n   FIFO order.\n4. [****Priority Queue****](\n   A priority queue is a special queue where the elements are accessed\n   based on the priority assigned to them. They are of two types:\n   * ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in\n     increasing order of their priority values. Element with smallest\n     priority value is popped first.\n   * ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in\n     decreasing order of their priority values. Element with largest\n     priority is popped first.\n\n![Types-of-Queue](\n\n****Applications of Queue Data Structure****\n\nApplication of queue is common. In a computer system, there may be\nqueues of tasks waiting for the printer, for access to disk storage, or\neven in a time-sharing system, for use of the CPU. Within a single\nprogram, there may be multiple requests to be kept in a queue, or one\ntask may create other tasks, which must be done in turn by keeping them\nin a queue.\n\n* A Queue is always used as a buffer when we have a speed mismatch\n  between a producer and consumer. For example keyboard and CPU.\n* Queue can be used where we have a single resource and multiple\n  consumers like a single CPU and multiple processes.\n* In a network, a queue is used in devices such as a router/switch and\n  mail queue.\n* Queue can be used in various algorithm techniques like Breadth First\n  Search, Topological Sort, etc.",
        "metadata": {
            "lesson_name": "Introduction to Queue Data Structure",
            "course_name": "Queue"
        }
    },
    {
        "page_content": "Course Name: Queue\nLesson Name: Different Types of Queues and its Applications\n\nContent:\n**Types of Queues:**\n\nThere are **five different types of queues** that are used in\ndifferent scenarios. They are:\n\n1. Input Restricted Queue (this is a Simple Queue)\n2. Output Restricted Queue (this is also a Simple Queue)\n3. Circular Queue\n4. Double Ended Queue (Deque)\n5. Priority Queue\n   * Ascending Priority Queue\n   * Descending Priority Queue\n\n![Types of Queues](\n\nTypes of Queues\n\n**1.** [**Circular Queue**]( Circular Queue is a linear data structure in which the\noperations are performed based on FIFO (First In First Out) principle and\nthe last position is connected back to the first position to make a\ncircle. It is also called **\u2018Ring Buffer\u2019**. This queue is\nprimarily used in the following cases:\n\n1. **Memory Management:** The unused memory locations in the\n   case of ordinary queues can be utilized in circular queues.\n2. **Traffic system:** In a computer-controlled traffic\n   system, circular queues are used to switch on the traffic lights one by\n   one repeatedly as per the time set.\n3. **CPU Scheduling:** Operating systems often maintain a\n   queue of processes that are ready to execute or that are waiting for a\n   particular event to occur.\n\nThe time complexity for the circular Queue is O(1).\n\n**2. Input restricted Queue:** In this type of Queue, the\ninput can be taken from one side only(rear) and deletion of elements can\nbe done from both sides(front and rear). This kind of Queue does not\nfollow FIFO(first in first out).  This queue is used in cases where\nthe consumption of the data needs to be in FIFO order but if there is a\nneed to remove the recently inserted data for some reason and one such\ncase can be irrelevant data, performance issue, etc.\n\n\n\n![Input Restricted Queue](\n\nInput Restricted Queue\n\n**Advantages of Input restricted Queue:**\n\n* Prevents overflow and overloading of the queue by limiting the number of\n  items added\n* Helps maintain stability and predictable performance of the system\n\n**Disadvantages of Input restricted Queue:**\n\n* May lead to resource wastage if the restriction is set too low and items\n  are frequently discarded\n* May lead to waiting or blocking if the restriction is set too high and\n  the queue is full, preventing new items from being added.\n\n**3. Output restricted Queue:** In this type of Queue, the\ninput can be taken from both sides(rear and front) and the deletion of the\nelement can be done from only one side(front).  This queue is used in\nthe case where the inputs have some priority order to be executed and the\ninput can be placed even in the first place so that it is executed\nfirst.\n\n![Output Restricted Queue](\n\nOutput Restricted Queue\n\n**4.** [**Double ended Queue**]( Double Ended Queue is also a Queue data structure in\nwhich the insertion and deletion operations are performed at both the ends\n(front and rear). That means, we can insert at both front and rear\npositions and can delete from both front and rear positions.  Since\nDeque supports both stack and queue operations, it can be used as both.\nThe Deque data structure supports clockwise and anticlockwise rotations in\nO(1) time which can be useful in certain applications. Also, the problems\nwhere elements need to be removed and or added both ends can be\nefficiently solved using Deque.\n\n![Double Ended Queue](\n\nDouble Ended Queue\n\n**5.** [**Priority Queue**]( A priority queue is a special type of queue in which\neach element is associated with a priority and is served according to its\npriority. There are two types of Priority Queues. They are:\n\n1. **Ascending Priority Queue:** Element can be inserted\n   arbitrarily but only smallest element can be removed. For example,\n   suppose there is an array having elements 4, 2, 8 in the same order. So,\n   while inserting the elements, the insertion will be in the same sequence\n   but while deleting, the order will be 2, 4, 8.\n2. **Descending priority Queue:** Element can be inserted\n   arbitrarily but only the largest element can be removed first from the\n   given Queue. For example, suppose there is an array having elements 4,\n   2, 8 in the same order. So, while inserting the elements, the insertion\n   will be in the same sequence but while deleting, the order will be 8, 4,\n   2.\n\nThe time complexity of the Priority Queue is O(logn).\n\n[**Applications of a Queue:**](\n\nThe\n[queue](\nis used when things don\u2019t have to be processed immediately, but have to be\nprocessed in First In First Out order like\n[Breadth First Search]( This property of Queue makes it also useful in the following kind of\nscenarios.\n\n1. When a resource is shared among multiple consumers. Examples include\n   [CPU scheduling](\n   [Disk Scheduling](\n2. When data is transferred asynchronously (data not necessarily received\n   at the same rate as sent) between two processes. Examples include IO\n   Buffers,\n   [pipes]( file IO, etc.\n3. Linear Queue: A linear queue is a type of queue where data elements are\n   added to the end of the queue and removed from the front of the queue.\n   Linear queues are used in applications where data elements need to be\n   processed in the order in which they are received. Examples include\n   printer queues and message queues.\n4. Circular Queue: A circular queue is similar to a linear queue, but the\n   end of the queue is connected to the front of the queue. This allows for\n   efficient use of space in memory and can improve performance. Circular\n   queues are used in applications where the data elements need to be\n   processed in a circular fashion. Examples include CPU scheduling and\n   memory management.\n5. Priority Queue: A priority queue is a type of queue where each element\n   is assigned a priority level. Elements with higher priority levels are\n   processed before elements with lower priority levels. Priority queues\n   are used in applications where certain tasks or data elements need to be\n   processed with higher priority. Examples include operating system task\n   scheduling and network packet scheduling.\n6. Double-ended Queue: A double-ended queue, also known as a deque, is a\n   type of queue where elements can be added or removed from either end of\n   the queue. This allows for more flexibility in data processing and can\n   be used in applications where elements need to be processed in multiple\n   directions. Examples include job scheduling and searching algorithms.\n7. Concurrent Queue: A concurrent queue is a type of queue that is designed\n   to handle multiple threads accessing the queue simultaneously.\n   Concurrent queues are used in multi-threaded applications where data\n   needs to be shared between threads in a thread-safe manner. Examples\n   include database transactions and web server requests.\n\n**Issues of Queue :**\n\nSome common issues that can arise when using queues:\n\n1. Queue overflow: Queue overflow occurs when the queue reaches its maximum\n   capacity and is unable to accept any more elements. This can cause data\n   loss and can lead to application crashes.\n2. Queue underflow: Queue underflow occurs when an attempt is made to\n   remove an element from an empty queue. This can cause errors and\n   application crashes.\n3. Priority inversion: Priority inversion occurs in priority queues when a\n   low-priority task holds a resource that a high-priority task needs. This\n   can cause delays in processing and can impact system performance.\n4. Deadlocks: Deadlocks occur when multiple threads or processes are\n   waiting for each other to release resources, resulting in a situation\n   where none of the threads can proceed. This can happen when using\n   concurrent queues and can lead to system crashes.\n5. Performance issues: Queue performance can be impacted by various\n   factors, such as the size of the queue, the frequency of access, and the\n   type of operations performed on the queue. Poor queue performance can\n   lead to slower system performance and reduced user experience.\n6. Synchronization issues: Synchronization issues can arise when multiple\n   threads are accessing the same queue simultaneously. This can result in\n   data corruption, race conditions, and other errors.\n7. Memory management issues: Queues can use up significant amounts of\n   memory, especially when processing large data sets. Memory leaks and\n   other memory management issues can occur, leading to system crashes and\n   other errors.\n\n**Reference :**\n\nSome references for further reading on queues:\n\n1. \u201cData Structures and Algorithms in Java\u201d by Robert Lafore \u2013 This book\n   provides an in-depth explanation of different types of queues and their\n   implementations in Java.\n2. \u201cIntroduction to Algorithms\u201d by Thomas H. Cormen et al. \u2013 This textbook\n   covers the basic concepts of data structures and algorithms, including\n   queues and their various applications.\n3. \u201cConcurrency in C# Cookbook\u201d by Stephen Cleary \u2013 This book provides\n   practical examples of how to use concurrent queues in C# programming.\n4. \u201cQueue (abstract data type)\u201d on Wikipedia \u2013 This article provides an\n   overview of queues and their properties, as well as examples of their\n   applications.\n5. \u201cThe Art of Computer Programming, Volume 1: Fundamental Algorithms\u201d by\n   Donald E. Knuth \u2013 This book includes a detailed analysis of different\n   queue algorithms and their performance.\n6. \u201cQueues and the Producer-Consumer Problem\u201d by Douglas C. Schmidt \u2013 This\n   paper discusses how queues can be used to solve the producer-consumer\n   problem in concurrent programming.",
        "metadata": {
            "lesson_name": "Different Types of Queues and its Applications",
            "course_name": "Queue"
        }
    },
    {
        "page_content": "Course Name: Queue\nLesson Name: Basic Operations for Queue in Data Structure\n\nContent:\n**Basic Operations on Queue:**\n\nSome of the basic operations for Queue in Data Structure are:\n\n* **enqueue() \u2013** Insertion of elements to the queue.\n* **dequeue() \u2013** Removal of elements from the queue.\n* **peek() or front()-** Acquires the data element available\n  at the front node of the queue without deleting it.\n* **rear() \u2013** This operation returns the element at the rear\n  end without removing it.\n* **isFull() \u2013** Validates if the queue is full.\n* **isEmpty() \u2013** Checks if the queue is empty.\n* **size():** This operation returns the size of the queue\n  i.e. the total number of elements it contains.\n\n![](\n\nQueue Data Structure\n\n### **Operation 1: enqueue()**\n\nInserts an element at the end of the queue i.e. at the rear end.\n\nThe following steps should be taken to enqueue (insert) data into a queue:\n\n* Check if the queue is full.\n* If the queue is full, return overflow error and exit.\n* If the queue is not full, increment the rear pointer to point to the\n  next empty space.\n* Add the data element to the queue location, where the rear is pointing.\n* return success.\n\n![Enqueue representation](\n\nEnqueue representation\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `printf``(``\"\\nQueue is full\\n\"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `System.out.println(``\"\\nQueue is full\\n\"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to add an item to the queue.`  `// It changes rear and size`  `void` `enqueue(``struct` `Queue* queue,` `int` `item)`  `{`  `if` `(isFull(queue))`  `return``;`  `queue->rear = (queue->rear + 1) % queue->capacity;`  `queue->array[queue->rear] = item;`  `queue->size = queue->size + 1;`  `printf``(``\"%d enqueued to queue\\n\"``, item);`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to add an item to the queue.`  `# It changes rear and size`  `def` `EnQueue(``self``, item):`  `if` `self``.isFull():`  `print``(``\"Full\"``)`  `return`  `self``.rear` `=` `(``self``.rear` `+` `1``)` `%` `(``self``.capacity)`  `self``.Q[``self``.rear]` `=` `item`  `self``.size` `=` `self``.size` `+` `1`  `print``(``\"% s enqueued to queue\"` `%` `str``(item))`  `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `void` `enqueue(``int` `item)`  `{`  `if` `(rear == max - 1) {`  `Console.WriteLine(``\"Queue Overflow\"``);`  `return``;`  `}`  `else` `{`  `ele[++rear] = item;`  `}`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `enqueue(element){`  `// adding element to the queue`  `this``.items.push(element);`  `}`    `// This code is contributed by Susobhan Akhuli`  `</script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 2: dequeue()**\n\nThis operation removes and returns an element that is at the front end of\nthe queue.\n\nThe following steps are taken to perform the dequeue operation:\n\n* Check if the queue is empty.\n* If the queue is empty, return the underflow error and exit.\n* If the queue is not empty, access the data where the front is pointing.\n* Increment the front pointer to point to the next available data element.\n* The Return success.\n\n![Dequeue operation](\n\nDequeue operation\n\nBelow is the Implementation of above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `printf``(``\"\\nQueue is empty\\n\"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i = 0; i < rear - 1; i++) {`  `queue[i] = queue[i + 1];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `System.out.println(``\"\\nQueue is empty\\n\"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i =` `0``; i < rear -` `1``; i++) {`  `queue[i] = queue[i +` `1``];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to remove an item from queue.`  `// It changes front and size`  `int` `dequeue(``struct` `Queue* queue)`  `{`  `if` `(isEmpty(queue)) {`  `printf``(``\"\\nQueue is empty\\n\"``);`  `return``;`  `}`  `int` `item = queue->array[queue->front];`  `queue->front = (queue->front + 1) % queue->capacity;`  `queue->size = queue->size - 1;`  `return` `item;`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to remove an item from queue.`  `# It changes front and size`      `def` `DeQueue(``self``):`  `if` `self``.isEmpty():`  `print``(``\"Queue is empty\"``)`  `return`    `print``(``\"% s dequeued from queue\"` `%` `str``(``self``.Q[``self``.front]))`  `self``.front` `=` `(``self``.front` `+` `1``)` `%` `(``self``.capacity)`  `self``.size` `=` `self``.size` `-` `1`  `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to remove an item from queue.`  `// It changes front and size`  `public` `int` `dequeue()`  `{`  `if` `(front == rear + 1) {`  `Console.WriteLine(``\"Queue is Empty\"``);`  `return` `-1;`  `}`  `else` `{`  `int` `p = ele[front++];`  `return` `p;`  `}`  `}`  `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `dequeue(){`  `// removing element from the queue`  `// returns underflow when called`  `// on empty queue`  `if``(``this``.isEmpty()){`  `document.write(``\"<br>Queue is empty<br>\"``);`  `return` `-1;`  `}`  `return` `this``.items.shift();`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 3: front()**\n\nThis operation returns the element at the front end without removing it.\n\nThe following steps are taken to perform the front operation:\n\n* If the queue is empty return the most minimum value.\n* otherwise, return the front value.\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}` |\n| --- |\n\n\n\n\n\nJava\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(Queue queue)`  `{`  `if` `(isempty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.front];`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to get front of queue`  `def` `que_front(``self``):`  `if` `self``.isempty():`  `return` `\"Queue is empty\"`  `return` `self``.Q[``self``.front]`    `# This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[front];`  `}`    `// This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `// Function to get front of queue`  `front(){`  `// returns the Front element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `\"No elements in Queue<br>\"``;`  `return` `this``.items[0];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### Operation 4 : rear()\n\nThis operation returns the element at the rear end without removing it.\n\nThe following steps are taken to perform the rear operation:\n\n* If the queue is empty return the most minimum value.\n* otherwise, return the rear value.\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get rear of queue`  `int` `rear(Queue* queue)`  `{`  `if` `(isEmpty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}` |\n| --- |\n\n\n\n\n\nJava\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get rear of queue`  `int` `rear(Queue queue)`  `{`  `if` `(isEmpty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.rear];`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to get rear of queue`  `def` `que_rear(``self``):`  `if` `self``.isEmpty():`  `return` `\"Queue is empty\"`  `return` `self``.Q[``self``.rear]`    `# This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[rear];`  `}`    `// This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `rear(){`  `// returns the Rear element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `\"No elements in Queue<br>\"``;`  `return` `this``.items[``this``.items.length-1];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 5: isEmpty():**\n\nThis operation returns a boolean value that indicates whether the queue is\nempty or not.\n\nThe following steps are taken to perform the Empty operation:\n\n* check if front value is equal to -1 or not, if yes then return true\n  means queue is empty.\n* Otherwise return false, means queue is not empty\n\nBelow is the implementation of the above approach:\n\n* C++\n* Java\n* C#\n* C\n* Python3\n* Javascript\n\nC++\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check whether`  `// the queue is empty or not:`  `boolean` `isEmpty()`  `{`  `if` `(front == -``1``)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC#\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by lokeshmvs21.` |\n| --- |\n\n\n\n\n\nC\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Queue is empty when size is 0`  `bool` `isEmpty(``struct` `Queue* queue)`  `{`  `return` `(queue->size == 0);`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Queue is empty when size is 0`  `def` `isEmpty(``self``):`  `return` `self``.size` `=``=` `0`  `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `</script>`  `isEmpty(){`  `// return true if the queue is empty.`  `return` `this``.items.length == 0;`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 6 : isFull()**\n\nThis operation returns a boolean value that indicates whether the queue is\nfull or not.\n\nThe following steps are taken to perform the isFull() operation:\n\n* Check if front value is equal to zero and rear is equal to the capacity\n  of queue if yes then return true.\n* otherwise return false\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* C#\n* Python3\n* Javascript\n\nC++\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check`  `// whether the queue is full or not.`  `bool` `isFull()`  `{`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check`  `// whether the queue is full or not.`  `boolean` `isFull()`  `{`  `if` `(front ==` `0` `&& rear == MAX_SIZE -` `1``) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Queue is full when size becomes`  `// equal to the capacity`  `bool` `isFull(``struct` `Queue* queue)`  `{`  `return` `(queue->size == queue->capacity);`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `bool` `isFull(``int` `item) {` `return` `(rear == max - 1); }`  `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Queue is full when size becomes`  `# equal to the capacity`      `def` `isFull(``self``):`  `return` `self``.size` `=``=` `self``.capacity`    `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `function` `isFull() {`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityamaharshi21.` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### Operation 7: size()\n\nThis operation returns the size of the queue i.e. the total number of\nelements it contains.\n\n\n* C++\n* Java\n* Python\n* C#\n* Javascript\n\nC++\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// CPP program to illustrate`  `// Implementation of size() function`  `#include <iostream>`  `#include <queue>`  `using` `namespace` `std;`    `int` `main()`  `{`  `int` `sum = 0;`  `queue<``int``> myqueue;`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `cout << myqueue.size();`    `return` `0;`  `}` |\n| --- |\n\n\n\n\n\nJava\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Java program to illustrate implementation of size()`  `// function`    `import` `java.util.*;`    `public` `class` `Main {`  `public` `static` `void` `main(String[] args)`  `{`  `int` `sum =` `0``;`  `Queue<Integer> myqueue =` `new` `LinkedList<>();`  `myqueue.add(``1``);`  `myqueue.add(``8``);`  `myqueue.add(``3``);`  `myqueue.add(``6``);`  `myqueue.add(``2``);`    `// Queue becomes 1, 8, 3, 6, 2`    `System.out.println(myqueue.size());`  `}`  `}`    `// This code is contributed by lokesh.` |\n| --- |\n\n\n\n\n\nPython\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `from` `collections` `import` `deque`    `def` `main():`  `sum` `=` `0`  `myqueue` `=` `deque()`  `myqueue.append(``1``)`  `myqueue.append(``8``)`  `myqueue.append(``3``)`  `myqueue.append(``6``)`  `myqueue.append(``2``)`    `# Queue becomes 1, 8, 3, 6, 2`    `print``(``len``(myqueue))`    `main()`    `# This code is contributed by aadityamaharshi21.` |\n| --- |\n\n\n\n\n\nC#\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `using` `System;`  `using` `System.Collections.Generic;`    `namespace` `ConsoleApp1 {`  `class` `MainClass {`  `public` `static` `void` `Main(``string``[] args)`  `{`  `int` `sum = 0;`  `Queue<``int``> myqueue =` `new` `Queue<``int``>();`  `myqueue.Enqueue(1);`  `myqueue.Enqueue(8);`  `myqueue.Enqueue(3);`  `myqueue.Enqueue(6);`  `myqueue.Enqueue(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `Console.WriteLine(myqueue.Count);`  `}`  `}`  `}`    `// This code is contributed by adityamaharshi21.` |\n| --- |\n\n\n\n\n\nJavascript\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Javascript code`  `let sum = 0;`  `let myqueue=[];`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `console.log(myqueue.length);` |\n| --- |\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n",
        "metadata": {
            "lesson_name": "Basic Operations for Queue in Data Structure",
            "course_name": "Queue"
        }
    },
    {
        "page_content": "Course Name: Queue\nLesson Name: Applications, Advantages and Disadvantages of Queue\n\nContent:\n****Enqueue**** and when an element is deleted from the queue, then the operation is\nknown as ****Dequeue.****It is important to know that we cannot insert an element if the size of\nthe queue is full and cannot delete an element when the queue itself is\nempty. If we try to insert an element even after the queue is full, then\nsuch a condition is known as overflow whereas, if we try to delete an\nelement even after the queue is empty then such a condition is known as\nunderflow.\n\n****Primary Queue Operations:****\n\n* ****void enqueue(int Element):**** When this operation is performed, an element is inserted in the queue\n  at the end i.e. at the rear end. (Where T is Generic i.e we can define\n  Queue of any type of data structure.) This operation take ****constant time i.e O(1).****\n* ****int dequeue():****\n  When this operation is performed, an element is removed from the front\n  end and is returned. This operation take ****constant time i.e O(1).****\n\n****Auxiliary Queue Operations:****\n\n* ****int front():**** This operation will return the element at the front without removing\n  it and it take O(1) time.\n* ****int rear():**** This operation will return the element at the rear without removing\n  it, Its Time Complexity is O(1).\n* ****int isEmpty():**** This operation indicates whether the queue is empty or not. This\n  Operation also done in O(1).\n* ****int size():**** This operation will return the size of the queue i.e. the total\n  number of elements present in the queue and it\u2019s time complexity is\n  O(1).\n\n****Types of Queues:****\n\n* ****Simple Queue:**** Simple queue also known as a linear queue is the most basic version\n  of a queue. Here, insertion of an element i.e. the Enqueue operation\n  takes place at the rear end and removal of an element i.e. the Dequeue\n  operation takes place at the front end.\n* ****Circular Queue:****This is mainly an efficient array implementation of Simple Queue. In\n  a circular queue, the element of the queue act as a circular ring. The\n  working of a circular queue is similar to the linear queue except for\n  the fact that the last element is connected to the first element. Its\n  advantage is that the memory is utilized in a better way. This is\n  because if there is an empty space i.e. if no element is present at a\n  certain position in the queue, then an element can be easily added at\n  that position.\n* ****Priority Queue:**** This queue is a special type of queue. Its specialty is that it\n  arranges the elements in a queue based on some priority. The priority\n  can be something where the element with the highest value has the\n  priority so it creates a queue with decreasing order of values. The\n  priority can also be such that the element with the lowest value gets\n  the highest priority so in turn it creates a queue with increasing\n  order of values.\n* ****Dequeue:**** Dequeue is also known as Double Ended Queue. As the name suggests\n  double ended, it means that an element can be inserted or removed from\n  both the ends of the queue unlike the other queues in which it can be\n  done only from one end. Because of this property it may not obey the\n  First In First Out property.\n\n****Implementation of Queue:****\n\n* ****Sequential allocation:**** A queue can be implemented using an array. It can organize a limited\n  number of elements.\n* ****Linked list allocation:****\n  A queue can be implemented using a linked list. It can organize an\n  unlimited number of elements.\n\n****Applications of Queue:****\n\n* ****Multi programming:**** Multi programming means when multiple programs are running in the\n  main memory. It is essential to organize these multiple programs and\n  these multiple programs are organized as queues.\n* ****Network:**** In a network, a queue is used in devices such as a router or a\n  switch. another application of a queue is a mail queue which is a\n  directory that stores data and controls files for mail messages.\n* ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that\n  are scheduled to be executed one after another. These jobs are\n  assigned to the processor one by one which is organized using a\n  queue.\n* ****Shared resources:**** Queues are used as waiting lists for a single shared resource.\n\n****Real-time application of Queue:****\n\n* Working as a buffer between a slow and a fast device. For example\n  keyboard and CPU, and two devices on network.\n* ATM Booth Line\n* Ticket Counter Line\n* CPU task scheduling\n* Waiting time of each customer at call centers.\n\n****Advantages of Queue:****\n\n* A large amount of data can be managed efficiently with ease.\n* Operations such as insertion and deletion can be performed with ease\n  as it follows the first in first out rule.\n* Queues are useful when a particular service is used by multiple\n  consumers.\n* Queues are fast in speed for data inter-process communication.\n* Queues can be used in the implementation of other data\n  structures.\n\n****Disadvantages of Queue:****\n\n* The operations such as insertion and deletion of elements from the\n  middle are time consuming.\n* In a classical queue, a new element can only be inserted when the\n  existing elements are deleted from the queue.\n* Searching an element takes O(N) time.\n* Maximum size of a queue must be defined prior in case of array\n  implementation.",
        "metadata": {
            "lesson_name": "Applications, Advantages and Disadvantages of Queue",
            "course_name": "Queue"
        }
    },
    {
        "page_content": "Course Name: Queue\nLesson Name: Introduction to Queue Data Structure\n\nContent:\nBasic Terminologies of Queue\n\n* ****Front:**** Position of the entry in a queue ready to be served, that is, the\n  first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.\n* ****Rear:****\n  Position of the last entry in the queue, that is, the one most\n  recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.\n* ****Size:**** Size refers to the ****current**** number of elements in the queue.\n* ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.\n\n****Representation of Queue****\n\n![Representation-of-Queue-Data-Structure](\n\nOperations on Queue\n\n### ****1. Enqueue:****\n\nEnqueue operation ****adds (or stores) an element to the end of the queue****. \n\n****Steps:****\n\n1. Check if the ****queue is full****. If so, return an ****overflow**** error and exit.\n2. If the queue is ****not full****, increment the ****rear**** pointer to the next available position.\n3. Insert the element at the rear.\n\n\n![Enqueue-Operation-in-Queue-01.webp](\n\n\n![Enqueue-Operation-in-Queue-02.webp](\n\n\n![Enqueue-Operation-in-Queue-03.webp](\n\n\n![Enqueue-Operation-in-Queue-04.webp](\n\n\n![Enqueue-Operation-in-Queue-05.webp](\n\n\n![Enqueue-Operation-in-Queue-06.webp](\n\n\n\nPrevious\n\n\n\n\n\nPause\n\nNext\n\n\n\n\n\n3 / 6\n\n\n\n### ****2. Dequeue:****\n\nDequeue operation removes the element at the front of the queue. The\nfollowing steps are taken to perform the dequeue operation:\n\n\n1. Check if the ****queue is empty****. If so, return an ****underflow**** error.\n2. Remove the element at the ****front****.\n3. ****Increment**** the ****front**** pointer to the next element.\n\n\n![Dequeue-Operation-in-Queue-01-.webp](\n\n\n![Dequeue-Operation-in-Queue-02-.webp](\n\n\n![Dequeue-Operation-in-Queue-03.webp](\n\n\n![Dequeue-Operation-in-Queue-04.webp](\n\n\n![Dequeue-Operation-in-Queue-05.webp](\n\n\n![Dequeue-Operation-in-Queue-06.webp](\n\n\n\nPrevious\n\n\n\n\n\nPlay\n\nNext\n\n\n\n\n\n1 / 6\n\n\n\n### ****3. Peek or Front Operation:****\n\nThis operation returns the element at the front end without removing\nit.\n\n### 4. Size Operation:\n\nThis operation returns the numbers of elements present in the\nqueue.\n\n### ****5. isEmpty Operation:****\n\nThis operation returns a boolean value that indicates whether the queue\nis empty or not.\n\n### ****6. isFull Operation:****\n\nThis operation returns a boolean value that indicates whether the queue\nis full or not.\n\nImplementation of Queue Data Structure\n\nQueue can be implemented using following data structures:\n\n* [Implementation of Queue using Arrays](\n* [Implementation of Queue using Linked List](\n\nComplexity Analysis of Operations on Queue\n\n| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |\n| --- | --- | --- |\n| ****enqueue**** | O(1) | O(1) |\n| ****dequeue**** | O(1) | O(1) |\n| front | O(1) | O(1) |\n| size | O(1) | O(1) |\n| isEmpty | O(1) | O(1) |\n| isFull | O(1) | O(1) |\n\n****Types of Queues****\n\nQueue data structure can be classified into 4 types:\n\n1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the\n   element from the front of the queue.\n2. [****Double-Ended Queue (Deque)****](\n   In a double-ended queue the insertion and deletion operations, both\n   can be performed from both ends. They are of two types:\n   * ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be\n     taken from only one end but deletion can be done from any of the\n     ends.\n   * ****Output Restricted Queue:****\n     This is also a simple queue. In this type of queue, the input can\n     be taken from both ends but deletion can be done from only one\n     end.\n3. [****Circular Queue:****]( This is a special type of queue where the last position is connected\n   back to the first position. Here also the operations are performed in\n   FIFO order.\n4. [****Priority Queue****](\n   A priority queue is a special queue where the elements are accessed\n   based on the priority assigned to them. They are of two types:\n   * ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in\n     increasing order of their priority values. Element with smallest\n     priority value is popped first.\n   * ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in\n     decreasing order of their priority values. Element with largest\n     priority is popped first.\n\n![Types-of-Queue](\n\n****Applications of Queue Data Structure****\n\nApplication of queue is common. In a computer system, there may be\nqueues of tasks waiting for the printer, for access to disk storage, or\neven in a time-sharing system, for use of the CPU. Within a single\nprogram, there may be multiple requests to be kept in a queue, or one\ntask may create other tasks, which must be done in turn by keeping them\nin a queue.\n\n* A Queue is always used as a buffer when we have a speed mismatch\n  between a producer and consumer. For example keyboard and CPU.\n* Queue can be used where we have a single resource and multiple\n  consumers like a single CPU and multiple processes.\n* In a network, a queue is used in devices such as a router/switch and\n  mail queue.\n* Queue can be used in various algorithm techniques like Breadth First\n  Search, Topological Sort, etc.",
        "metadata": {
            "lesson_name": "Introduction to Queue Data Structure",
            "course_name": "Queue"
        }
    },
    {
        "page_content": "Course Name: Queue\nLesson Name: Different Types of Queues and its Applications\n\nContent:\n**Types of Queues:**\n\nThere are **five different types of queues** that are used in\ndifferent scenarios. They are:\n\n1. Input Restricted Queue (this is a Simple Queue)\n2. Output Restricted Queue (this is also a Simple Queue)\n3. Circular Queue\n4. Double Ended Queue (Deque)\n5. Priority Queue\n   * Ascending Priority Queue\n   * Descending Priority Queue\n\n![Types of Queues](\n\nTypes of Queues\n\n**1.** [**Circular Queue**]( Circular Queue is a linear data structure in which the\noperations are performed based on FIFO (First In First Out) principle and\nthe last position is connected back to the first position to make a\ncircle. It is also called **\u2018Ring Buffer\u2019**. This queue is\nprimarily used in the following cases:\n\n1. **Memory Management:** The unused memory locations in the\n   case of ordinary queues can be utilized in circular queues.\n2. **Traffic system:** In a computer-controlled traffic\n   system, circular queues are used to switch on the traffic lights one by\n   one repeatedly as per the time set.\n3. **CPU Scheduling:** Operating systems often maintain a\n   queue of processes that are ready to execute or that are waiting for a\n   particular event to occur.\n\nThe time complexity for the circular Queue is O(1).\n\n**2. Input restricted Queue:** In this type of Queue, the\ninput can be taken from one side only(rear) and deletion of elements can\nbe done from both sides(front and rear). This kind of Queue does not\nfollow FIFO(first in first out).  This queue is used in cases where\nthe consumption of the data needs to be in FIFO order but if there is a\nneed to remove the recently inserted data for some reason and one such\ncase can be irrelevant data, performance issue, etc.\n\n\n\n![Input Restricted Queue](\n\nInput Restricted Queue\n\n**Advantages of Input restricted Queue:**\n\n* Prevents overflow and overloading of the queue by limiting the number of\n  items added\n* Helps maintain stability and predictable performance of the system\n\n**Disadvantages of Input restricted Queue:**\n\n* May lead to resource wastage if the restriction is set too low and items\n  are frequently discarded\n* May lead to waiting or blocking if the restriction is set too high and\n  the queue is full, preventing new items from being added.\n\n**3. Output restricted Queue:** In this type of Queue, the\ninput can be taken from both sides(rear and front) and the deletion of the\nelement can be done from only one side(front).  This queue is used in\nthe case where the inputs have some priority order to be executed and the\ninput can be placed even in the first place so that it is executed\nfirst.\n\n![Output Restricted Queue](\n\nOutput Restricted Queue\n\n**4.** [**Double ended Queue**]( Double Ended Queue is also a Queue data structure in\nwhich the insertion and deletion operations are performed at both the ends\n(front and rear). That means, we can insert at both front and rear\npositions and can delete from both front and rear positions.  Since\nDeque supports both stack and queue operations, it can be used as both.\nThe Deque data structure supports clockwise and anticlockwise rotations in\nO(1) time which can be useful in certain applications. Also, the problems\nwhere elements need to be removed and or added both ends can be\nefficiently solved using Deque.\n\n![Double Ended Queue](\n\nDouble Ended Queue\n\n**5.** [**Priority Queue**]( A priority queue is a special type of queue in which\neach element is associated with a priority and is served according to its\npriority. There are two types of Priority Queues. They are:\n\n1. **Ascending Priority Queue:** Element can be inserted\n   arbitrarily but only smallest element can be removed. For example,\n   suppose there is an array having elements 4, 2, 8 in the same order. So,\n   while inserting the elements, the insertion will be in the same sequence\n   but while deleting, the order will be 2, 4, 8.\n2. **Descending priority Queue:** Element can be inserted\n   arbitrarily but only the largest element can be removed first from the\n   given Queue. For example, suppose there is an array having elements 4,\n   2, 8 in the same order. So, while inserting the elements, the insertion\n   will be in the same sequence but while deleting, the order will be 8, 4,\n   2.\n\nThe time complexity of the Priority Queue is O(logn).\n\n[**Applications of a Queue:**](\n\nThe\n[queue](\nis used when things don\u2019t have to be processed immediately, but have to be\nprocessed in First In First Out order like\n[Breadth First Search]( This property of Queue makes it also useful in the following kind of\nscenarios.\n\n1. When a resource is shared among multiple consumers. Examples include\n   [CPU scheduling](\n   [Disk Scheduling](\n2. When data is transferred asynchronously (data not necessarily received\n   at the same rate as sent) between two processes. Examples include IO\n   Buffers,\n   [pipes]( file IO, etc.\n3. Linear Queue: A linear queue is a type of queue where data elements are\n   added to the end of the queue and removed from the front of the queue.\n   Linear queues are used in applications where data elements need to be\n   processed in the order in which they are received. Examples include\n   printer queues and message queues.\n4. Circular Queue: A circular queue is similar to a linear queue, but the\n   end of the queue is connected to the front of the queue. This allows for\n   efficient use of space in memory and can improve performance. Circular\n   queues are used in applications where the data elements need to be\n   processed in a circular fashion. Examples include CPU scheduling and\n   memory management.\n5. Priority Queue: A priority queue is a type of queue where each element\n   is assigned a priority level. Elements with higher priority levels are\n   processed before elements with lower priority levels. Priority queues\n   are used in applications where certain tasks or data elements need to be\n   processed with higher priority. Examples include operating system task\n   scheduling and network packet scheduling.\n6. Double-ended Queue: A double-ended queue, also known as a deque, is a\n   type of queue where elements can be added or removed from either end of\n   the queue. This allows for more flexibility in data processing and can\n   be used in applications where elements need to be processed in multiple\n   directions. Examples include job scheduling and searching algorithms.\n7. Concurrent Queue: A concurrent queue is a type of queue that is designed\n   to handle multiple threads accessing the queue simultaneously.\n   Concurrent queues are used in multi-threaded applications where data\n   needs to be shared between threads in a thread-safe manner. Examples\n   include database transactions and web server requests.\n\n**Issues of Queue :**\n\nSome common issues that can arise when using queues:\n\n1. Queue overflow: Queue overflow occurs when the queue reaches its maximum\n   capacity and is unable to accept any more elements. This can cause data\n   loss and can lead to application crashes.\n2. Queue underflow: Queue underflow occurs when an attempt is made to\n   remove an element from an empty queue. This can cause errors and\n   application crashes.\n3. Priority inversion: Priority inversion occurs in priority queues when a\n   low-priority task holds a resource that a high-priority task needs. This\n   can cause delays in processing and can impact system performance.\n4. Deadlocks: Deadlocks occur when multiple threads or processes are\n   waiting for each other to release resources, resulting in a situation\n   where none of the threads can proceed. This can happen when using\n   concurrent queues and can lead to system crashes.\n5. Performance issues: Queue performance can be impacted by various\n   factors, such as the size of the queue, the frequency of access, and the\n   type of operations performed on the queue. Poor queue performance can\n   lead to slower system performance and reduced user experience.\n6. Synchronization issues: Synchronization issues can arise when multiple\n   threads are accessing the same queue simultaneously. This can result in\n   data corruption, race conditions, and other errors.\n7. Memory management issues: Queues can use up significant amounts of\n   memory, especially when processing large data sets. Memory leaks and\n   other memory management issues can occur, leading to system crashes and\n   other errors.\n\n**Reference :**\n\nSome references for further reading on queues:\n\n1. \u201cData Structures and Algorithms in Java\u201d by Robert Lafore \u2013 This book\n   provides an in-depth explanation of different types of queues and their\n   implementations in Java.\n2. \u201cIntroduction to Algorithms\u201d by Thomas H. Cormen et al. \u2013 This textbook\n   covers the basic concepts of data structures and algorithms, including\n   queues and their various applications.\n3. \u201cConcurrency in C# Cookbook\u201d by Stephen Cleary \u2013 This book provides\n   practical examples of how to use concurrent queues in C# programming.\n4. \u201cQueue (abstract data type)\u201d on Wikipedia \u2013 This article provides an\n   overview of queues and their properties, as well as examples of their\n   applications.\n5. \u201cThe Art of Computer Programming, Volume 1: Fundamental Algorithms\u201d by\n   Donald E. Knuth \u2013 This book includes a detailed analysis of different\n   queue algorithms and their performance.\n6. \u201cQueues and the Producer-Consumer Problem\u201d by Douglas C. Schmidt \u2013 This\n   paper discusses how queues can be used to solve the producer-consumer\n   problem in concurrent programming.",
        "metadata": {
            "lesson_name": "Different Types of Queues and its Applications",
            "course_name": "Queue"
        }
    },
    {
        "page_content": "Course Name: Queue\nLesson Name: Basic Operations for Queue in Data Structure\n\nContent:\n**Basic Operations on Queue:**\n\nSome of the basic operations for Queue in Data Structure are:\n\n* **enqueue() \u2013** Insertion of elements to the queue.\n* **dequeue() \u2013** Removal of elements from the queue.\n* **peek() or front()-** Acquires the data element available\n  at the front node of the queue without deleting it.\n* **rear() \u2013** This operation returns the element at the rear\n  end without removing it.\n* **isFull() \u2013** Validates if the queue is full.\n* **isEmpty() \u2013** Checks if the queue is empty.\n* **size():** This operation returns the size of the queue\n  i.e. the total number of elements it contains.\n\n![](\n\nQueue Data Structure\n\n### **Operation 1: enqueue()**\n\nInserts an element at the end of the queue i.e. at the rear end.\n\nThe following steps should be taken to enqueue (insert) data into a queue:\n\n* Check if the queue is full.\n* If the queue is full, return overflow error and exit.\n* If the queue is not full, increment the rear pointer to point to the\n  next empty space.\n* Add the data element to the queue location, where the rear is pointing.\n* return success.\n\n![Enqueue representation](\n\nEnqueue representation\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `printf``(``\"\\nQueue is full\\n\"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `System.out.println(``\"\\nQueue is full\\n\"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to add an item to the queue.`  `// It changes rear and size`  `void` `enqueue(``struct` `Queue* queue,` `int` `item)`  `{`  `if` `(isFull(queue))`  `return``;`  `queue->rear = (queue->rear + 1) % queue->capacity;`  `queue->array[queue->rear] = item;`  `queue->size = queue->size + 1;`  `printf``(``\"%d enqueued to queue\\n\"``, item);`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to add an item to the queue.`  `# It changes rear and size`  `def` `EnQueue(``self``, item):`  `if` `self``.isFull():`  `print``(``\"Full\"``)`  `return`  `self``.rear` `=` `(``self``.rear` `+` `1``)` `%` `(``self``.capacity)`  `self``.Q[``self``.rear]` `=` `item`  `self``.size` `=` `self``.size` `+` `1`  `print``(``\"% s enqueued to queue\"` `%` `str``(item))`  `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `void` `enqueue(``int` `item)`  `{`  `if` `(rear == max - 1) {`  `Console.WriteLine(``\"Queue Overflow\"``);`  `return``;`  `}`  `else` `{`  `ele[++rear] = item;`  `}`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `enqueue(element){`  `// adding element to the queue`  `this``.items.push(element);`  `}`    `// This code is contributed by Susobhan Akhuli`  `</script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 2: dequeue()**\n\nThis operation removes and returns an element that is at the front end of\nthe queue.\n\nThe following steps are taken to perform the dequeue operation:\n\n* Check if the queue is empty.\n* If the queue is empty, return the underflow error and exit.\n* If the queue is not empty, access the data where the front is pointing.\n* Increment the front pointer to point to the next available data element.\n* The Return success.\n\n![Dequeue operation](\n\nDequeue operation\n\nBelow is the Implementation of above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `printf``(``\"\\nQueue is empty\\n\"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i = 0; i < rear - 1; i++) {`  `queue[i] = queue[i + 1];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `System.out.println(``\"\\nQueue is empty\\n\"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i =` `0``; i < rear -` `1``; i++) {`  `queue[i] = queue[i +` `1``];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to remove an item from queue.`  `// It changes front and size`  `int` `dequeue(``struct` `Queue* queue)`  `{`  `if` `(isEmpty(queue)) {`  `printf``(``\"\\nQueue is empty\\n\"``);`  `return``;`  `}`  `int` `item = queue->array[queue->front];`  `queue->front = (queue->front + 1) % queue->capacity;`  `queue->size = queue->size - 1;`  `return` `item;`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to remove an item from queue.`  `# It changes front and size`      `def` `DeQueue(``self``):`  `if` `self``.isEmpty():`  `print``(``\"Queue is empty\"``)`  `return`    `print``(``\"% s dequeued from queue\"` `%` `str``(``self``.Q[``self``.front]))`  `self``.front` `=` `(``self``.front` `+` `1``)` `%` `(``self``.capacity)`  `self``.size` `=` `self``.size` `-` `1`  `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to remove an item from queue.`  `// It changes front and size`  `public` `int` `dequeue()`  `{`  `if` `(front == rear + 1) {`  `Console.WriteLine(``\"Queue is Empty\"``);`  `return` `-1;`  `}`  `else` `{`  `int` `p = ele[front++];`  `return` `p;`  `}`  `}`  `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `dequeue(){`  `// removing element from the queue`  `// returns underflow when called`  `// on empty queue`  `if``(``this``.isEmpty()){`  `document.write(``\"<br>Queue is empty<br>\"``);`  `return` `-1;`  `}`  `return` `this``.items.shift();`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 3: front()**\n\nThis operation returns the element at the front end without removing it.\n\nThe following steps are taken to perform the front operation:\n\n* If the queue is empty return the most minimum value.\n* otherwise, return the front value.\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}` |\n| --- |\n\n\n\n\n\nJava\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(Queue queue)`  `{`  `if` `(isempty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.front];`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to get front of queue`  `def` `que_front(``self``):`  `if` `self``.isempty():`  `return` `\"Queue is empty\"`  `return` `self``.Q[``self``.front]`    `# This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[front];`  `}`    `// This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `// Function to get front of queue`  `front(){`  `// returns the Front element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `\"No elements in Queue<br>\"``;`  `return` `this``.items[0];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### Operation 4 : rear()\n\nThis operation returns the element at the rear end without removing it.\n\nThe following steps are taken to perform the rear operation:\n\n* If the queue is empty return the most minimum value.\n* otherwise, return the rear value.\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get rear of queue`  `int` `rear(Queue* queue)`  `{`  `if` `(isEmpty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}` |\n| --- |\n\n\n\n\n\nJava\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get rear of queue`  `int` `rear(Queue queue)`  `{`  `if` `(isEmpty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.rear];`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to get rear of queue`  `def` `que_rear(``self``):`  `if` `self``.isEmpty():`  `return` `\"Queue is empty\"`  `return` `self``.Q[``self``.rear]`    `# This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[rear];`  `}`    `// This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `rear(){`  `// returns the Rear element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `\"No elements in Queue<br>\"``;`  `return` `this``.items[``this``.items.length-1];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 5: isEmpty():**\n\nThis operation returns a boolean value that indicates whether the queue is\nempty or not.\n\nThe following steps are taken to perform the Empty operation:\n\n* check if front value is equal to -1 or not, if yes then return true\n  means queue is empty.\n* Otherwise return false, means queue is not empty\n\nBelow is the implementation of the above approach:\n\n* C++\n* Java\n* C#\n* C\n* Python3\n* Javascript\n\nC++\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check whether`  `// the queue is empty or not:`  `boolean` `isEmpty()`  `{`  `if` `(front == -``1``)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC#\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by lokeshmvs21.` |\n| --- |\n\n\n\n\n\nC\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Queue is empty when size is 0`  `bool` `isEmpty(``struct` `Queue* queue)`  `{`  `return` `(queue->size == 0);`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Queue is empty when size is 0`  `def` `isEmpty(``self``):`  `return` `self``.size` `=``=` `0`  `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `</script>`  `isEmpty(){`  `// return true if the queue is empty.`  `return` `this``.items.length == 0;`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 6 : isFull()**\n\nThis operation returns a boolean value that indicates whether the queue is\nfull or not.\n\nThe following steps are taken to perform the isFull() operation:\n\n* Check if front value is equal to zero and rear is equal to the capacity\n  of queue if yes then return true.\n* otherwise return false\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* C#\n* Python3\n* Javascript\n\nC++\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check`  `// whether the queue is full or not.`  `bool` `isFull()`  `{`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check`  `// whether the queue is full or not.`  `boolean` `isFull()`  `{`  `if` `(front ==` `0` `&& rear == MAX_SIZE -` `1``) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Queue is full when size becomes`  `// equal to the capacity`  `bool` `isFull(``struct` `Queue* queue)`  `{`  `return` `(queue->size == queue->capacity);`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `bool` `isFull(``int` `item) {` `return` `(rear == max - 1); }`  `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Queue is full when size becomes`  `# equal to the capacity`      `def` `isFull(``self``):`  `return` `self``.size` `=``=` `self``.capacity`    `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `function` `isFull() {`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityamaharshi21.` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### Operation 7: size()\n\nThis operation returns the size of the queue i.e. the total number of\nelements it contains.\n\n\n* C++\n* Java\n* Python\n* C#\n* Javascript\n\nC++\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// CPP program to illustrate`  `// Implementation of size() function`  `#include <iostream>`  `#include <queue>`  `using` `namespace` `std;`    `int` `main()`  `{`  `int` `sum = 0;`  `queue<``int``> myqueue;`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `cout << myqueue.size();`    `return` `0;`  `}` |\n| --- |\n\n\n\n\n\nJava\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Java program to illustrate implementation of size()`  `// function`    `import` `java.util.*;`    `public` `class` `Main {`  `public` `static` `void` `main(String[] args)`  `{`  `int` `sum =` `0``;`  `Queue<Integer> myqueue =` `new` `LinkedList<>();`  `myqueue.add(``1``);`  `myqueue.add(``8``);`  `myqueue.add(``3``);`  `myqueue.add(``6``);`  `myqueue.add(``2``);`    `// Queue becomes 1, 8, 3, 6, 2`    `System.out.println(myqueue.size());`  `}`  `}`    `// This code is contributed by lokesh.` |\n| --- |\n\n\n\n\n\nPython\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `from` `collections` `import` `deque`    `def` `main():`  `sum` `=` `0`  `myqueue` `=` `deque()`  `myqueue.append(``1``)`  `myqueue.append(``8``)`  `myqueue.append(``3``)`  `myqueue.append(``6``)`  `myqueue.append(``2``)`    `# Queue becomes 1, 8, 3, 6, 2`    `print``(``len``(myqueue))`    `main()`    `# This code is contributed by aadityamaharshi21.` |\n| --- |\n\n\n\n\n\nC#\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `using` `System;`  `using` `System.Collections.Generic;`    `namespace` `ConsoleApp1 {`  `class` `MainClass {`  `public` `static` `void` `Main(``string``[] args)`  `{`  `int` `sum = 0;`  `Queue<``int``> myqueue =` `new` `Queue<``int``>();`  `myqueue.Enqueue(1);`  `myqueue.Enqueue(8);`  `myqueue.Enqueue(3);`  `myqueue.Enqueue(6);`  `myqueue.Enqueue(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `Console.WriteLine(myqueue.Count);`  `}`  `}`  `}`    `// This code is contributed by adityamaharshi21.` |\n| --- |\n\n\n\n\n\nJavascript\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Javascript code`  `let sum = 0;`  `let myqueue=[];`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `console.log(myqueue.length);` |\n| --- |\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n",
        "metadata": {
            "lesson_name": "Basic Operations for Queue in Data Structure",
            "course_name": "Queue"
        }
    },
    {
        "page_content": "Course Name: Queue\nLesson Name: Applications, Advantages and Disadvantages of Queue\n\nContent:\n****Enqueue**** and when an element is deleted from the queue, then the operation is\nknown as ****Dequeue.****It is important to know that we cannot insert an element if the size of\nthe queue is full and cannot delete an element when the queue itself is\nempty. If we try to insert an element even after the queue is full, then\nsuch a condition is known as overflow whereas, if we try to delete an\nelement even after the queue is empty then such a condition is known as\nunderflow.\n\n****Primary Queue Operations:****\n\n* ****void enqueue(int Element):**** When this operation is performed, an element is inserted in the queue\n  at the end i.e. at the rear end. (Where T is Generic i.e we can define\n  Queue of any type of data structure.) This operation take ****constant time i.e O(1).****\n* ****int dequeue():****\n  When this operation is performed, an element is removed from the front\n  end and is returned. This operation take ****constant time i.e O(1).****\n\n****Auxiliary Queue Operations:****\n\n* ****int front():**** This operation will return the element at the front without removing\n  it and it take O(1) time.\n* ****int rear():**** This operation will return the element at the rear without removing\n  it, Its Time Complexity is O(1).\n* ****int isEmpty():**** This operation indicates whether the queue is empty or not. This\n  Operation also done in O(1).\n* ****int size():**** This operation will return the size of the queue i.e. the total\n  number of elements present in the queue and it\u2019s time complexity is\n  O(1).\n\n****Types of Queues:****\n\n* ****Simple Queue:**** Simple queue also known as a linear queue is the most basic version\n  of a queue. Here, insertion of an element i.e. the Enqueue operation\n  takes place at the rear end and removal of an element i.e. the Dequeue\n  operation takes place at the front end.\n* ****Circular Queue:****This is mainly an efficient array implementation of Simple Queue. In\n  a circular queue, the element of the queue act as a circular ring. The\n  working of a circular queue is similar to the linear queue except for\n  the fact that the last element is connected to the first element. Its\n  advantage is that the memory is utilized in a better way. This is\n  because if there is an empty space i.e. if no element is present at a\n  certain position in the queue, then an element can be easily added at\n  that position.\n* ****Priority Queue:**** This queue is a special type of queue. Its specialty is that it\n  arranges the elements in a queue based on some priority. The priority\n  can be something where the element with the highest value has the\n  priority so it creates a queue with decreasing order of values. The\n  priority can also be such that the element with the lowest value gets\n  the highest priority so in turn it creates a queue with increasing\n  order of values.\n* ****Dequeue:**** Dequeue is also known as Double Ended Queue. As the name suggests\n  double ended, it means that an element can be inserted or removed from\n  both the ends of the queue unlike the other queues in which it can be\n  done only from one end. Because of this property it may not obey the\n  First In First Out property.\n\n****Implementation of Queue:****\n\n* ****Sequential allocation:**** A queue can be implemented using an array. It can organize a limited\n  number of elements.\n* ****Linked list allocation:****\n  A queue can be implemented using a linked list. It can organize an\n  unlimited number of elements.\n\n****Applications of Queue:****\n\n* ****Multi programming:**** Multi programming means when multiple programs are running in the\n  main memory. It is essential to organize these multiple programs and\n  these multiple programs are organized as queues.\n* ****Network:**** In a network, a queue is used in devices such as a router or a\n  switch. another application of a queue is a mail queue which is a\n  directory that stores data and controls files for mail messages.\n* ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that\n  are scheduled to be executed one after another. These jobs are\n  assigned to the processor one by one which is organized using a\n  queue.\n* ****Shared resources:**** Queues are used as waiting lists for a single shared resource.\n\n****Real-time application of Queue:****\n\n* Working as a buffer between a slow and a fast device. For example\n  keyboard and CPU, and two devices on network.\n* ATM Booth Line\n* Ticket Counter Line\n* CPU task scheduling\n* Waiting time of each customer at call centers.\n\n****Advantages of Queue:****\n\n* A large amount of data can be managed efficiently with ease.\n* Operations such as insertion and deletion can be performed with ease\n  as it follows the first in first out rule.\n* Queues are useful when a particular service is used by multiple\n  consumers.\n* Queues are fast in speed for data inter-process communication.\n* Queues can be used in the implementation of other data\n  structures.\n\n****Disadvantages of Queue:****\n\n* The operations such as insertion and deletion of elements from the\n  middle are time consuming.\n* In a classical queue, a new element can only be inserted when the\n  existing elements are deleted from the queue.\n* Searching an element takes O(N) time.\n* Maximum size of a queue must be defined prior in case of array\n  implementation.",
        "metadata": {
            "lesson_name": "Applications, Advantages and Disadvantages of Queue",
            "course_name": "Queue"
        }
    },
    {
        "page_content": "Course Name: Stack\nLesson Name: What is Stack Data Structure? A Complete Tutorial\n\nContent:\nRepresentation of Stack Data Structure:\n\nStack follows LIFO (Last In First Out) Principle so the element which\nis pushed last is popped first.\n\n\n![Stack-representation-in-Data-Structures-(1)](\n\n****Types of Stack:****\n\n* ****Fixed Size Stack**** \n  : As the name suggests, a fixed size stack has a fixed size and cannot\n  grow or shrink dynamically. If the stack is full and an attempt is\n  made to add an element to it, an overflow error occurs. If the stack\n  is empty and an attempt is made to remove an element from it, an\n  underflow error occurs.\n* ****Dynamic Size Stack**** \n  : A dynamic size stack can grow or shrink dynamically. When the stack\n  is full, it automatically increases its size to accommodate the new\n  element, and when the stack is empty, it decreases its size. This type\n  of stack is implemented using a linked list, as it allows for easy\n  resizing of the stack.\n\nBasic Operations on Stack:\n\nIn order to make manipulations in a stack, there are certain operations\nprovided to us.\n\n\n* ****push()****  to insert an element into the stack\n* ****pop()****  to remove an element from the stack\n* ****top()****  Returns the top element of the stack.\n* ****isEmpty()****  returns true if stack is empty else false.\n* ****isFull()****  returns true if the stack is full else false.\n\nTo implement stack, we need to maintain reference to the top\nitem.\n\n### ****Push Operation on Stack****\n\nAdds an item to the stack. If the stack is full, then it is said to be\nan  ****Overflow condition.**** \n\n ****Algorithm for Push Operation:**** \n\n* Before pushing the element to the stack, we check if the stack is  ****full****  .\n* If the stack is full  ****(top == capacity-1)****  , then  ****Stack Overflows****  and we cannot insert the element to the stack.\n* Otherwise, we increment the value of top by 1  ****(top = top + 1)****  and the new value is inserted at  ****top position****  .\n* The elements can be pushed into the stack till we reach the  ****capacity****  of the stack.\n\n![Push-Operation-in-Stack-(1)](\n### ****Pop Operation in Stack****\n\nRemoves an item from the stack. The items are popped in the reversed\norder in which they are pushed. If the stack is empty, then it is said\nto be an  ****Underflow condition.**** \n\n****Algorithm for Pop Operation:**** \n\n* Before popping the element from the stack, we check if the stack is  ****empty****  .\n* If the stack is empty (top == -1), then  ****Stack Underflows****  and we cannot remove any element from the stack.\n* Otherwise, we store the value at top, decrement the value of top by 1  ****(top = top \u2013 1)****  and return the stored top value.\n\n![Pop-Operation-in-Stack-(1)](\n### ****Top or Peek Operation on Stack****\n\nReturns the top element of the stack. \n\n****Algorithm for Top Operation:**** \n\n* Before returning the top element from the stack, we check if the\n  stack is empty.\n* If the stack is empty (top == -1), we simply print \u201cStack is empty\u201d.\n* Otherwise, we return the element stored at  ****index = top****  .\n\n![Top-or-Peek-Operation-in-Stack-(1)](\n### ****isEmpty Operation in Stack Data Structure:****\n\nReturns true if the stack is empty, else false. \n\n****Algorithm for isEmpty Operation****: \n\n* Check for the value of  ****top****  in stack.\n* If  ****(top == -1)****, then the stack is  ****empty****  so return  ****true****  .\n* Otherwise, the stack is not empty so return  ****false****  .\n\n![isEmpty-Operation-in-Stack-(1)](\n### isFull ****Operation in Stack**** ****Data Structure****:\n\nReturns true if the stack is full, else false. \n\n****Algorithm for isFull Operation:**** \n\n* Check for the value of  ****top****  in stack.\n* If  ****(top == capacity-1),****  then the stack is  ****full****  so return  ****true****.\n* Otherwise, the stack is not full so return  ****false****.\n\n![isFull-Operation-in-Stack-(1)](\n\nImplementation of Stack\n\n\nThe basic operations that can be performed on a stack include push, pop,\nand peek. There are two ways to implement a stack \u2013\n\n\n* [****Implementation of Stack using Array****](\n* [****Implementation of Stack using Linked List****](\n\n****Complexity Analysis of Operations on Stack Data Structure:****\n\n| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |\n| --- | --- | --- |\n| ****push()**** | O(1) | O(1) |\n| ****pop()**** | O(1) | O(1) |\n| top() or  ****pee****k() | O(1) | O(1) |\n| isEmpty() | O(1) | O(1) |\n| isFull() | O(1) | O(1) |",
        "metadata": {
            "lesson_name": "What is Stack Data Structure? A Complete Tutorial",
            "course_name": "Stack"
        }
    },
    {
        "page_content": "Course Name: Stack\nLesson Name: Implement Stack using Array\n\nContent:\nImplement Stack using Array:\n\n> To implement a stack using an array, initialize an array and treat\n> its end as the stack\u2019s top. Implement ****push**** (add to end), ****pop**** (remove from end), and ****peek**** (check end) operations, handling cases for an ****empty**** or f****ull stack****.\n\n****Step-by-step approach:****\n\n1. ****Initialize an array**** to represent the stack.\n2. Use the ****end of the array**** to represent the ****top of the stack****.\n3. Implement ****push**** (add to end), ****pop**** (remove from the end), and ****peek**** (check end) operations, ensuring to handle empty and full stack\n   conditions.\n\nImplement Stack Operations using Array:\n\n\nHere are the following operations of implement stack using array:\n\n### ****Push Operation in Stack:****\n\nAdds an item to the stack. If the stack is full, then it is said to be\nan ****Overflow condition.****\n\n****Algorithm for Push Operation:****\n\n> * Before pushing the element to the stack, we check if the stack\n>   is ****full****.\n> * If the stack is full ****(top == capacity-1)****, then ****Stack Overflows****and we cannot insert the element to the stack.\n> * Otherwise, we increment the value of top by 1 ****(top = top + 1)****and the new value is inserted at ****top position****.\n> * The elements can be pushed into the stack till we reach\n>   the ****capacity****of the stack.\n\n![push-operation-in-stack-1.webp](\n\n\n![push-operation-in-stack-2.webp](\n\n\n![push-operation-in-stack-3.webp](\n\n\n![push-operation-in-stack-4.webp](\n\n\n![push-operation-in-stack-5.webp](\n\n\n![push-operation-in-stack-6.webp](\n\n\n\nPrevious\n\n\n\n\n\nPause\n\nNext\n\n\n\n\n\n5 / 6\n\n### ****Pop Operation in Stack:****\n\nRemoves an item from the stack. The items are popped in the reversed\norder in which they are pushed. If the stack is empty, then it is said\nto be an ****Underflow condition.****\n\n****Algorithm for Pop Operation:****\n\n> * Before popping the element from the stack, we check if the stack\n>   is ****empty****.\n> * If the stack is empty (top == -1), then ****Stack Underflows****and we cannot remove any element from the stack.\n> * Otherwise, we store the value at top, decrement the value of top by\n>   1 ****(top = top \u2013 1)****and return the stored top value.\n\n![pop-operation-in-stack-1.webp](\n\n\n![pop-operation-in-stack-2.webp](\n\n\n![pop-operation-in-stack-3.webp](\n\n\n![pop-operation-in-stack-4.webp](\n\n\n![pop-operation-in-stack-5.webp](\n\n\n![pop-operation-in-stack-6.webp](\n\n\n\nPrevious\n\n\n\n\n\nPlay\n\nNext\n\n\n\n\n\n1 / 6\n\n  \n\n\n### ****Top or Peek Operation in Stack:****\n\nReturns the top element of the stack.\n\n****Algorithm for Top Operation:****\n\n> * Before returning the top element from the stack, we check if the\n>   stack is empty.\n> * If the stack is empty (top == -1), we simply print \u201cStack is\n>   empty\u201d.\n> * Otherwise, we return the element stored at ****index = top****.\n\n### ****isEmpty Operation in Stack:****\n\nReturns true if the stack is empty, else false.\n\n****Algorithm for isEmpty Operation****:\n\n> * Check for the value of ****top****in stack.\n> * If ****(top == -1)****, then the stack is ****empty****so return ****true****.\n> * Otherwise, the stack is not empty so return ****false****.\n\n### isFull ****Operation in Stack****:\n\nReturns true if the stack is full, else false.\n\n****Algorithm for isFull Operation:****\n\n> * Check for the value of ****top****in stack.\n> * If ****(top == capacity-1),****then the stack is ****full****so return ****true****.\n> * Otherwise, the stack is not full so return ****false.****\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### Complexity Analysis:\n\n* ****Time Complexity****:\n  + `push`: O(1)\n  + `pop`: O(1)\n  + `peek`: O(1)\n  + `is_empty`: O(1)\n  + is\\_full: O(1)\n* ****Auxiliary Space****: O(n), where n is the number of items in the stack.\n\nAdvantages of Array Implementation:\n\n* Easy to implement.\n* Memory is saved as pointers are not involved.\n\nDisadvantages of Array Implementation:\n\n* It is not dynamic i.e., it doesn\u2019t grow and shrink depending on needs\n  at runtime. [But in case of dynamic sized arrays like vector in C++,\n  list in Python, ArrayList in Java, stacks can grow and shrink with\n  array implementation as well].\n* The total size of the stack must be defined beforehand.",
        "metadata": {
            "lesson_name": "Implement Stack using Array",
            "course_name": "Stack"
        }
    },
    {
        "page_content": "Course Name: Stack\nLesson Name: Implement a stack using singly linked list\n\nContent:\n****Stack Operations:****\n\n* [****push()****](\n  Insert a new element into the stack i.e just insert a new element at\n  the beginning of the linked list.\n* [****pop()****](\n  Return the top element of the Stack i.e simply delete the first\n  element from the linked list.\n* [****peek()****]( Return the top element.\n* ****display():**** Print all elements in Stack.\n\nPush Operation:\n\n> * Initialise a node\n> * Update the value of that node by data i.e. ****node->data = data****\n> * Now link this node to the top of the linked list\n> * And update top pointer to the current node\n\nPop Operation:\n\n> * First Check whether there is any node present in the linked list or\n>   not, if not then return\n> * Otherwise make pointer let say ****temp**** to the top node and move forward the top node by 1 step\n> * Now free this temp node\n\nPeek Operation:\n\n> * Check if there is any node present or not, if not then\n>   return.\n> * Otherwise return the value of top node of the linked list\n\nDisplay Operation:\n\n> * Take a ****temp**** node and initialize it with top pointer\n> * Now start traversing temp till it encounters NULL\n> * Simultaneously print the value of the temp node\n\n\n\n\n\n\n\n\n****Time Complexity:****\nO(1), for all push(), pop(), and peek(), as we are not performing any\nkind of traversal over the list. We perform all the operations through\nthe current pointer only.  \n****Auxiliary Space:**** O(N), where N is the size of the stack\n\n\nIn this implementation, we define a Node class that represents a node\nin the linked list, and a Stack class that uses this node class to\nimplement the stack. The head attribute of the Stack class points to the\ntop of the stack (i.e., the first node in the linked list).\n\nTo push an item onto the stack, we create a new node with the given\nitem and set its next pointer to the current head of the stack. We then\nset the head of the stack to the new node, effectively making it the new\ntop of the stack.\n\nTo pop an item from the stack, we simply remove the first node from the\nlinked list by setting the head of the stack to the next node in the\nlist (i.e., the node pointed to by the next pointer of the current\nhead). We return the data stored in the original head node, which is the\nitem that was removed from the top of the stack.\n\n### Benefits of implementing a stack using a singly linked list include:\n\n****Dynamic memory allocation****: The size of the stack can be increased or decreased dynamically by\nadding or removing nodes from the linked list, without the need to\nallocate a fixed amount of memory for the stack upfront.\n\n****Efficient memory usage:**** Since nodes in a singly linked list only have a next pointer and not a\nprev pointer, they use less memory than nodes in a doubly linked\nlist.\n\n****Easy implementation****: Implementing a stack using a singly linked list is straightforward\nand can be done using just a few lines of code.\n\n****Versatile****: Singly linked lists can be used to implement other data structures\nsuch as queues, linked lists, and trees.\n\nIn summary, implementing a stack using a singly linked list is a simple\nand efficient way to create a dynamic stack data structure in\nPython.\n\n### Real time examples of stack:\n\nStacks are used in various real-world scenarios where a last-in,\nfirst-out (LIFO) data structure is required. Here are some examples of\nreal-time applications of stacks:\n\n****Function call stack****: When a function is called in a program, the return address and all\nthe function parameters are pushed onto the function call stack. The\nstack allows the function to execute and return to the caller function\nin the reverse order in which they were called.\n\n****Undo/Redo operations:****\nIn many applications, such as text editors, image editors, or web\nbrowsers, the undo and redo functionalities are implemented using a\nstack. Every time an action is performed, it is pushed onto the stack.\nWhen the user wants to undo the last action, the top element of the\nstack is popped and the action is reversed.\n\n****Browser history:**** Web browsers use stacks to keep track of the pages visited by the user.\nEvery time a new page is visited, its URL is pushed onto the stack. When\nthe user clicks the \u201cBack\u201d button, the last visited URL is popped from\nthe stack and the user is directed to the previous page.\n\n****Expression evaluation****: Stacks are used in compilers and interpreters to evaluate\nexpressions. When an expression is parsed, it is converted into postfix\nnotation and pushed onto a stack. The postfix expression is then\nevaluated using the stack.\n\n****Call stack in recursion:****\nWhen a recursive function is called, its call is pushed onto the stack.\nThe function executes and calls itself, and each subsequent call is\npushed onto the stack. When the recursion ends, the stack is popped, and\nthe program returns to the previous function call.\n\nIn summary, stacks are widely used in many applications where LIFO\nfunctionality is required, such as function calls, undo/redo operations,\nbrowser history, expression evaluation, and recursive function\ncalls.\n",
        "metadata": {
            "lesson_name": "Implement a stack using singly linked list",
            "course_name": "Stack"
        }
    },
    {
        "page_content": "Course Name: Stack\nLesson Name: Applications, Advantages and Disadvantages of Stack\n\nContent:\nApplications of Stacks:\n\n* ****Function calls:****\n  Stacks are used to keep track of the return addresses of function\n  calls, allowing the program to return to the correct location after a\n  function has finished executing.\n* ****Recursion:**** Stacks are used to store the local variables and return addresses of\n  recursive function calls, allowing the program to keep track of the\n  current state of the recursion.\n* ****Expression evaluation:**** Stacks are used to evaluate expressions in postfix notation (Reverse\n  Polish Notation).\n* ****Syntax parsing:**** Stacks are used to check the validity of syntax in programming\n  languages and other formal languages.\n* ****Memory management:**** Stacks are used to allocate and manage memory in some operating\n  systems and programming languages.\n* Used to solve popular problems like [Next Greater]( [Previous Greater]( [Next Smaller]( [Previous Smaller]( [Largest Area in a Histogram]( and [Stock Span Problems](\n\nAdvantages of Stacks:\n\n* ****Simplicity:**** Stacks are a simple and easy-to-understand data structure, making\n  them suitable for a wide range of applications.\n* ****Efficiency:**** Push and pop operations on a stack can be performed in constant time ****(O(1))****, providing efficient access to data.\n* ****Last-in, First-out (LIFO):****\n  Stacks follow the LIFO principle, ensuring that the last element added\n  to the stack is the first one removed. This behavior is useful in many\n  scenarios, such as function calls and expression evaluation.\n* ****Limited memory usage:**** Stacks only need to store the elements that have been pushed onto\n  them, making them memory-efficient compared to other data\n  structures.\n\nDisadvantages of Stacks:\n\n* ****Limited access:****\n  Elements in a stack can only be accessed from the top, making it\n  difficult to retrieve or modify elements in the middle of the\n  stack.\n* ****Potential for overflow:**** If more elements are pushed onto a stack than it can hold, an\n  overflow error will occur, resulting in a loss of data.\n* ****Not suitable for random access:**** Stacks do not allow for random access to elements, making them\n  unsuitable for applications where elements need to be accessed in a\n  specific order.\n* ****Limited capacity:****\n  Stacks have a fixed capacity, which can be a limitation if the number\n  of elements that need to be stored is unknown or highly\n  variable.\n",
        "metadata": {
            "lesson_name": "Applications, Advantages and Disadvantages of Stack",
            "course_name": "Stack"
        }
    }
]