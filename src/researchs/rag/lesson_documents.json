[
    {
        "page_content": "****Examples :****\n\n\n\n\n\n```\nInput:  1/2 + 3/2\nOutput: 2/1\n\nInput:  1/3 + 3/9\nOutput: 2/3\n\nInput:  1/5 + 3/15\nOutput: 2/5\n```\n\n\n\n\n\n\n\n****Algorithm to add two fractions****\n\n\n\n\n\n* Find a common denominator by finding the LCM (Least Common Multiple) of the two denominators.\n* Change the\n\n  [fractions](https://www.geeksforgeeks.org/fractions/)\n  to have the same denominator and add both terms.\n* Reduce the final fraction obtained into its simpler form by dividing both numerator and denominator by their largest common factor.\n\n\n\n\n\nC++\n\n````\n// C++ program to add 2 fractions\n#include<bits/stdc++.h>\nusing namespace std;\n\n// Function to return gcd of a and b\nint gcd(int a, int b)\n{\n    if (a == 0)\n        return b;\n    return gcd(b%a, a);\n}\n\n// Function to convert the obtained fraction\n// into it's simplest form\nvoid lowest(int &den3, int &num3)\n{\n    // Finding gcd of both terms\n    int common_factor = gcd(num3,den3);\n\n// Converting both terms into simpler\n    // terms by dividing them by common factor\n    den3 = den3/common_factor;\n    num3 = num3/common_factor;\n}\n\n//Function to add two fractions\nvoid addFraction(int num1, int den1, int num2,\n                 int den2, int &num3, int &den3)\n{\n    // Finding gcd of den1 and den2\n    den3 = gcd(den1,den2);\n\n// Denominator of final fraction obtained\n    // finding LCM of den1 and den2\n    // LCM * GCD = a * b\n    den3 = (den1*den2) / den3;\n\n// Changing the fractions to have same denominator\n    // Numerator of the final fraction obtained\n    num3 = (num1)*(den3/den1) + (num2)*(den3/den2);\n\n// Calling function to convert final fraction\n    // into it's simplest form\n    lowest(den3,num3);\n}\n\n// Driver program\nint main()\n{\n    int num1=1, den1=500, num2=2, den2=1500, den3, num3;\n    addFraction(num1, den1, num2, den2, num3, den3);\n    printf(\"%d/%d + %d/%d is equal to %d/%d\\n\", num1, den1,\n                                   num2, den2, num3, den3);\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to add 2 fractions\n\nclass GFG{\n// Function to return gcd of a and b\nstatic int gcd(int a, int b)\n{\n    if (a == 0)\n        return b;\n    return gcd(b%a, a);\n}\n\n// Function to convert the obtained fraction\n// into it's simplest form\nstatic void lowest(int den3, int num3)\n{\n    // Finding gcd of both terms\n    int common_factor = gcd(num3,den3);\n\n// Converting both terms into simpler\n    // terms by dividing them by common factor\n    den3 = den3/common_factor;\n    num3 = num3/common_factor;\n    System.out.println(num3+\"/\"+den3);\n}\n\n//Function to add two fractions\nstatic void addFraction(int num1, int den1,\n                        int num2, int den2)\n{\n    // Finding gcd of den1 and den2\n    int den3 = gcd(den1,den2);\n\n// Denominator of final fraction obtained\n    // finding LCM of den1 and den2\n    // LCM * GCD = a * b\n    den3 = (den1*den2) / den3;\n\n// Changing the fractions to have same denominator\n    // Numerator of the final fraction obtained\n    int num3 = (num1)*(den3/den1) + (num2)*(den3/den2);\n\n// Calling function to convert final fraction\n    // into it's simplest form\n    lowest(den3,num3);\n}\n\n// Driver program\npublic static void main(String[] args)\n{\n    int num1=1, den1=500, num2=2, den2=1500;\n    System.out.print(num1+\"/\"+den1+\" + \"+num2+\"/\"+den2+\" is equal to \");\n    addFraction(num1, den1, num2, den2);\n}\n}\n// This code is contributed by mits\n\n````\n\nPython3\n\n````\n# Python3 program to add 2 fractions\n\n# Function to return gcd of a and b\ndef gcd(a, b):\n    if (a == 0):\n        return b;\n    return gcd(b % a, a);\n\n# Function to convert the obtained\n# fraction into it's simplest form\ndef lowest(den3, num3):\n\n    # Finding gcd of both terms\n    common_factor = gcd(num3, den3);\n\n    # Converting both terms\n    # into simpler terms by\n    # dividing them by common factor\n    den3 = int(den3 / common_factor);\n    num3 = int(num3 / common_factor);\n    print(num3, \"/\", den3);\n\n# Function to add two fractions\ndef addFraction(num1, den1, num2, den2):\n\n    # Finding gcd of den1 and den2\n    den3 = gcd(den1, den2);\n\n    # Denominator of final\n    # fraction obtained finding\n    # LCM of den1 and den2\n    # LCM * GCD = a * b\n    den3 = (den1 * den2) / den3;\n\n    # Changing the fractions to\n    # have same denominator Numerator\n    # of the final fraction obtained\n    num3 = ((num1) * (den3 / den1) +\n            (num2) * (den3 / den2));\n\n    # Calling function to convert\n    # final fraction into it's\n    # simplest form\n    lowest(den3, num3);\n\n# Driver Code\nnum1 = 1; den1 = 500;\nnum2 = 2; den2 = 1500;\n\nprint(num1, \"/\", den1, \" + \", num2, \"/\",\n      den2, \" is equal to \", end = \"\");\naddFraction(num1, den1, num2, den2);\n\n# This code is contributed by mits\n\n````\n\nC#\n\n````\n// C# program to add 2 fractions\n\nclass GFG{\n// Function to return gcd of a and b\nstatic int gcd(int a, int b)\n{\n    if (a == 0)\n        return b;\n    return gcd(b%a, a);\n}\n\n// Function to convert the obtained fraction\n// into it's simplest form\nstatic void lowest(int den3, int num3)\n{\n    // Finding gcd of both terms\n    int common_factor = gcd(num3,den3);\n\n// Converting both terms into simpler\n    // terms by dividing them by common factor\n    den3 = den3/common_factor;\n    num3 = num3/common_factor;\n    System.Console.WriteLine(num3+\"/\"+den3);\n}\n\n//Function to add two fractions\nstatic void addFraction(int num1, int den1, int num2, int den2)\n{\n    // Finding gcd of den1 and den2\n    int den3 = gcd(den1,den2);\n\n// Denominator of final fraction obtained\n    // finding LCM of den1 and den2\n    // LCM * GCD = a * b\n    den3 = (den1*den2) / den3;\n\n// Changing the fractions to have same denominator\n    // Numerator of the final fraction obtained\n    int num3 = (num1)*(den3/den1) + (num2)*(den3/den2);\n\n// Calling function to convert final fraction\n    // into it's simplest form\n    lowest(den3,num3);\n}\n\n// Driver program\npublic static void Main()\n{\n    int num1=1, den1=500, num2=2, den2=1500;\n    System.Console.Write(num1+\"/\"+den1+\" + \"+num2+\"/\"+den2+\" is equal to \");\n    addFraction(num1, den1, num2, den2);\n}\n}\n// This code is contributed by mits\n\n````\n\nJavaScript\n\n````\n<script>\n\n// Javascript program to add 2 fractions\n\n// Function to return gcd of a and b\n\nconst gcd = (a, b) => {\n    if (a == 0)\n        return b;\n    return gcd(b % a, a);\n}\n\n// Function to convert the\n// obtained fraction into\n// it's simplest form\n\nconst lowest = (den3, num3) => {\n    // Finding gcd of both terms\n    let common_factor = gcd(num3, den3);\n\n// Converting both terms\n    // into simpler terms by\n    // dividing them by common factor\n\n    den3 = parseInt(den3 / common_factor);\n    num3 = parseInt(num3 / common_factor);\n\n    document.write(`${num3}/${den3}`)\n}\n\n\n// Function to add two fractions\nconst addFraction = (num1, den1, num2, den2) => {\n    // Finding gcd of den1 and den2\n    let den3 = gcd(den1, den2);\n\n// Denominator of final\n    // fraction obtained finding\n    // LCM of den1 and den2\n    // LCM * GCD = a * b\n    den3 = (den1 * den2) / den3;\n\n// Changing the fractions to\n    // have same denominator Numerator\n    // of the final fraction obtained\n    let num3 = ((num1) * (den3 / den1) +\n            (num2) * (den3 / den2));\n\n// Calling function to convert\n    // final fraction into it's\n    // simplest form\n    lowest(den3, num3);\n}\n\n// Driver Code\nlet num1 = 1;\nlet den1 = 500;\nlet num2 = 2;\nlet den2 = 1500;\n\ndocument.write(`${num1}/${den1} + ${num2}/${den2} is equal to `);\n\naddFraction(num1, den1, num2, den2);\n\n// This code is contributed by _saurabh_jaiswal\n\n</script>\n\n````\n\nPHP\n\n````\n<?php\n// PHP program to add\n// 2 fractions\n\n// Function to return\n// gcd of a and b\nfunction gcd($a, $b)\n{\n    if ($a == 0)\n        return $b;\n    return gcd($b % $a, $a);\n}\n\n// Function to convert the\n// obtained fraction into\n// it's simplest form\nfunction lowest(&$den3, &$num3)\n{\n    // Finding gcd of both terms\n    $common_factor = gcd($num3, $den3);\n\n// Converting both terms\n    // into simpler terms by\n    // dividing them by common factor\n\n    $den3 = (int)$den3 / $common_factor;\n    $num3 = (int) $num3 / $common_factor;\n}\n\n// Function to add\n// two fractions\nfunction addFraction($num1, $den1, $num2,\n                     $den2, &$num3, &$den3)\n{\n    // Finding gcd of den1 and den2\n    $den3 = gcd($den1, $den2);\n\n// Denominator of final\n    // fraction obtained finding\n    // LCM of den1 and den2\n    // LCM * GCD = a * b\n    $den3 = ($den1 * $den2) / $den3;\n\n// Changing the fractions to\n    // have same denominator Numerator\n    // of the final fraction obtained\n    $num3 = ($num1) * ($den3 / $den1) +\n            ($num2) * ($den3 / $den2);\n\n// Calling function to convert\n    // final fraction into it's\n    // simplest form\n    lowest($den3, $num3);\n}\n\n// Driver Code\n$num1 = 1; $den1 = 500;\n$num2 = 2; $den2 = 1500;\n$den3; $num3;\naddFraction($num1, $den1, $num2,\n            $den2, $num3, $den3);\necho $num1, \"/\", $den1, \" + \",\n     $num2,\"/\", $den2, \" is equal to \",\n               $num3, \"/\", $den3, \"\\n\";\n\n// This code is contributed by aj_36\n?>\n\n````\n\n****Output :****\n\n\n```\n1/500 + 2/1500 is equal to 1/300\n```\n\n****Time Complexity:****\nO(log(min(a, b)), where a and b are two integers.\n\n\n****Auxiliary Space:****\nO(1), no extra space required so it is a constant.\n",
        "metadata": {
            "lesson_id": "bc7282ef-2185-47e3-acbc-5b5597cbbbfc",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "Add two fraction a/b and c/d and print answer in simplest form.",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "\n****Examples:****\n\n\n```\nInput: n = 15\nOutput: false\nDivisors of 15 are 1, 3 and 5. Sum of\ndivisors is 9 which is not equal to 15.\nInput: n = 6\nOutput: true\nDivisors of 6 are 1, 2 and 3. Sum of\ndivisors is 6.\n\n\n```\n\n\n\n\nRecommended Practice\n\n[Perfect Number](https://www.geeksforgeeks.org/problems/perfect-number3759/1/)\n\n\n[Try It!](https://www.geeksforgeeks.org/problems/perfect-number3759/1/)\n\n\nA\n\n****Simple Solution****\nis to go through every number from 1 to n-1 and check if it is a divisor. Maintain sum of all divisors. If sum becomes equal to n, then return true, else return false.\n\n\n\nAn\n\n****Efficient Solution****\nis to go through numbers till square root of n. If a number \u2018i\u2019 divides n, then add both \u2018i\u2019 and n/i to sum.\n\n\n\nBelow is the implementation of efficient solution.\n\n\n\n\n\nC++\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// C++ program to check if a given number is perfect\n// or not\n#include<iostream>\nusing namespace std;\n\n// Returns true if n is perfect\nbool isPerfect( long long int n)\n{\n// To store sum of divisors\nlong long int sum = 1;\n\n// Find all divisors and add them\nfor ( long long int i=2; i*i<=n; i++)\n{\nif (n%i==0)\n{\nif (i*i!=n)\nsum = sum + i + n/i;\nelse\nsum=sum+i;\n}\n}\n// If sum of divisors is equal to\n// n, then n is a perfect number\nif (sum == n && n != 1)\nreturn true ;\n\nreturn false ;\n}\n\n// Driver program\nint main()\n{\ncout << \"Below are all perfect numbers till 10000\\n\" ;\nfor ( int n =2; n<10000; n++)\nif (isPerfect(n))\ncout << n << \" is a perfect number\\n\" ;\n\nreturn 0;\n}\n```\n\n\n\n\n\nJava\n----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// Java program to check if a given\n// number is perfect or not\nimport java.io.*;\npublic class GFG\n{\n\n// Returns true if n is perfect\nstatic boolean isPerfect( int n)\n{\n// To store sum of divisors\nint sum = 1 ;\n\n// Find all divisors and add them\nfor ( int i = 2 ; i * i <= n; i++)\n{\nif (n % i== 0 )\n{\nif (i * i != n)\nsum = sum + i + n / i;\nelse\nsum = sum + i;\n}\n}\n// If sum of divisors is equal to\n// n, then n is a perfect number\nif (sum == n && n != 1 )\nreturn true ;\n\nreturn false ;\n}\n\n// Driver program\npublic static void main (String[] args)\n{\nSystem.out.println( \"Below are all perfect\" +\n\"numbers till 10000\" );\nfor ( int n = 2 ; n < 10000 ; n++)\nif (isPerfect(n))\nSystem.out.println( n +\n\" is a perfect number\" );\n}\n}\n\n// This code is contributed by mits\n```\n\n\n\n\n\nPython3\n-------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n# Python3 code to check if a given\n# number is perfect or not\n\n# Returns true if n is perfect\ndef isPerfect( n ):\n\n# To store sum of divisors\nsum = 1\n\n# Find all divisors and add them\ni = 2\nwhile i * i < = n:\nif n % i = = 0 :\nsum = sum + i + n / i\ni + = 1\n\n# If sum of divisors is equal to\n# n, then n is a perfect number\n\nreturn ( True if sum = = n and n! = 1 else False )\n\n# Driver program\nprint ( \"Below are all perfect numbers till 10000\" )\nn = 2\nfor n in range ( 10000 ):\nif isPerfect (n):\nprint (n , \" is a perfect number\" )\n\n# This code is contributed by \"Sharad_Bhardwaj\".\n```\n\n\n\n\n\nC#\n--\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// C# program to check if a given\n// number is perfect or not\n\nclass GFG\n{\n\n// Returns true if n is perfect\nstatic bool isPerfect( int n)\n{\n// To store sum of divisors\nint sum = 1;\n\n// Find all divisors and add them\nfor ( int i = 2; i * i <= n; i++)\n{\nif (n % i==0)\n{\nif (i * i != n)\nsum = sum + i + n / i;\nelse\nsum = sum + i;\n}\n}\n// If sum of divisors is equal to\n// n, then n is a perfect number\nif (sum == n && n != 1)\nreturn true ;\n\nreturn false ;\n}\n\n// Driver program\nstatic void Main()\n{\nSystem.Console.WriteLine( \"Below are all perfect\" +\n\"numbers till 10000\" );\nfor ( int n = 2; n < 10000; n++)\nif (isPerfect(n))\nSystem.Console.WriteLine( n +\n\" is a perfect number\" );\n}\n}\n\n// This code is contributed by chandan_jnu\n```\n\n\n\n\n\nJavascript\n----------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n<script>\n\n// Javascript program to check if a given number is perfect\n// or not\n\n// Returns true if n is perfect\nfunction isPerfect(n)\n{\n// To store sum of divisors\nsum = 1;\n\n// Find all divisors and add them\nfor (let i=2; i*i<=n; i++)\n{\nif (n%i==0)\n{\nif (i*i!=n)\nsum = sum + i + n/i;\nelse\nsum=sum+i;\n}\n}\n// If sum of divisors is equal to\n// n, then n is a perfect number\nif (sum == n && n != 1)\nreturn true ;\n\nreturn false ;\n}\n\n// Driver program\n\ndocument.write( \"Below are all perfect numbers till 10000\" + \"<br>\" );\nfor (let n =2; n<10000; n++)\nif (isPerfect(n))\ndocument.write(n + \" is a perfect number\" + \"<br>\" );\n\n// This code is contributed by Mayank Tyagi\n\n</script>\n```\n\n\n\n\n\nPHP\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n<?php\n// PHP program to check if a given number\n// is perfect or not\n\n// Returns true if n is perfect\nfunction isPerfect( $n )\n{\n// To store sum of divisors\n$sum = 1;\n\n// Find all divisors and add them\nfor ( $i = 2; $i * $i <= $n ; $i ++)\n{\nif ( $n % $i == 0)\n{\nif ( $i * $i != $n )\n$sum = $sum + $i + (int)( $n / $i );\nelse\n$sum = $sum + $i ;\n}\n}\n// If sum of divisors is equal to\n// n, then n is a perfect number\nif ( $sum == $n && $n != 1)\nreturn true;\n\nreturn false;\n}\n\n// Driver Code\necho \"Below are all perfect numbers till 10000\\n\" ;\nfor ( $n = 2; $n < 10000; $n ++)\nif (isPerfect( $n ))\necho \"$n is a perfect number\\n\" ;\n\n// This code is contributed by mits\n?>\n```\n\n\n\n\n\n\n\n**Output**\n```\nBelow are all perfect numbers till 10000\n6 is a perfect number\n28 is a perfect number\n496 is a perfect number\n8128 is a perfect number\n\n\n\n```\n\n****Time Complexity:****\nO(log(n))\n\n",
        "metadata": {
            "lesson_id": "aad6df64-c3f4-40e1-961b-817fa187f81f",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "A number is a perfect number if is equal to sum of its proper divisors, that is, sum of its positive divisors excluding the number itself. Write a function to check if a given number is perfect or not.",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "A number is called as a\n\n****Jumping Number****\nif all adjacent digits in it differ by\n\n****1****\n. The difference between\n\n****\u20189****\n\u2019 and\n\n****\u20180\u2019****\nis not considered as 1.\n\n\n\nAll single digit numbers are considered as Jumping Numbers. For example 7, 8987 and 4343456 are\n\n****Jumping numbers****\nbut 796 and 89098 are not.\n\n\n\nGiven a positive number\n\n****x****\n, print all\n\n****Jumping Numbers****\nsmaller than or equal to\n\n****x****\n. The numbers can be printed in any order.\n\n\n****Example:****\n\n```\nInput: x = 20\nOutput:  0 1 2 3 4 5 6 7 8 9 10 12\n\nInput: x = 105\nOutput:  0 1 2 3 4 5 6 7 8 9 10 12\n         21 23 32 34 43 45 54 56 65\n         67 76 78 87 89 98 101\n\nNote: Order of output doesn't matter,\n                                                                                                                                    i.e. numbers can be printed in any order\n```\n\n\nOne\n\n****Simple Solution****\nis to traverse all\n\n[numbers](https://www.geeksforgeeks.org/numbers/)\nfrom\n\n****0****\nto\n\n****x****\n. For every traversed number, check if it is a Jumping number. If\n\n****yes****\n, then print it. Otherwise ignore it.\n\n\nC++14\n\n````\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid print_sieve(int& x)\n{\n    int i,temp,digit;\n    bool check;\n\n    for(i=0;i<=x;i++)\n    {\n        if(i<10)\n        {\n            cout<<i<<\" \";\n            continue;\n        }\n        check=1;\n        temp=i;\n        digit=temp%10;\n        temp/=10;\n        while(temp)\n        {\n            if(abs(digit-temp%10)!=1)\n            {\n                check=0;\n                break;\n            }\n            digit=temp%10;\n            temp/=10;\n        }\n        if(check)\n        cout<<i<<\" \";\n    }\n}\n\nint main()\n{\n    int x=105;\n    print_sieve(x);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to implement\n// the above approach\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\nclass GFG\n{\n  public static void print_sieve(int x)\n  {\n    int i, temp, digit;\n    int check;\n\n    for(i = 0; i <= x; i++)\n    {\n      if(i < 10)\n      {\n        System.out.print(i + \" \");\n        continue;\n      }\n      check = 1;\n      temp = i;\n      digit = temp % 10;\n      temp /= 10;\n      while(temp != 0)\n      {\n        if(Math.abs(digit - temp % 10) != 1)\n        {\n          check = 0;\n          break;\n        }\n        digit = temp % 10;\n        temp /= 10;\n      }\n      if(check != 0)\n        System.out.print(i + \" \");\n    }\n  }\n\n  // Driver Code\n  public static void main(String[] args)\n  {\n    int x = 105;\n    print_sieve(x);\n  }\n}\n\n// This code is contributed by Pushpesh Raj.\n\n````\n\nPython\n\n````\n# Python3 program to implement the approach\n\n# Function to print the jumping numbers\n# in the range [0, x]\ndef print_sieve(x):\n\n    # iterating over all the numbers\n    # in the range [0, x]\n    for i in range(x + 1):\n        if(i < 10):\n\n            # all numbers in [0, 9] are\n            # jumping numbers\n            print(i, end=\" \")\n            continue\n\n        # the variable check tracks if\n        # the number is valid\n        check = 1\n        temp = i\n        digit = temp % 10\n        temp //= 10\n        while(temp > 0):\n\n            if(abs(digit - temp % 10) != 1):\n\n                check = 0\n                break\n\n            digit = temp % 10\n            temp //= 10\n\n        # printing i if check is 1\n        if(check):\n            print(i, end=\" \")\n\n# Driver Code\nx = 105\nprint_sieve(x)\n\n# This code is contributed by phasing17\n\n````\n\nC#\n\n````\n// C# program to implement\n// the above approach\nusing System;\n\nclass GFG\n{\n\n  static void print_sieve(int x)\n  {\n    int i, temp, digit;\n    int check;\n\n    for(i = 0; i <= x; i++)\n    {\n      if(i < 10)\n      {\n        Console.Write(i + \" \");\n        continue;\n      }\n      check = 1;\n      temp = i;\n      digit = temp % 10;\n      temp /= 10;\n      while(temp != 0)\n      {\n        if(Math.Abs(digit - temp % 10) != 1)\n        {\n          check = 0;\n          break;\n        }\n        digit = temp % 10;\n        temp /= 10;\n      }\n      if(check != 0)\n        Console.Write(i + \" \");\n    }\n  }\n\n  // Driver Code\n  public static void Main()\n  {\n    int x = 105;\n    print_sieve(x);\n  }\n}\n\n// This code is contributed by code_hunt.\n\n````\n\nJavaScript\n\n````\n<script>\n\nfunction print_sieve(x)\n{\n    let i,temp,digit;\n    let check;\n\n    for(i = 0; i <= x; i++)\n    {\n        if(i < 10)\n        {\n            document.write(i,\" \");\n            continue;\n        }\n        check = 1;\n        temp = i;\n        digit = temp % 10;\n        temp = Math.floor(temp / 10);\n        while(temp)\n        {\n            if(Math.abs(digit - temp % 10) != 1)\n            {\n                check = 0;\n                break;\n            }\n            digit = temp % 10;\n            temp = Math.floor(temp / 10);\n        }\n        if(check)\n            document.write(i,\" \");\n    }\n}\n\nlet x = 105;\nprint_sieve(x);\n\n// This code is contributed by shinjanpatra\n\n</script>\n\n````\n\n\n\n\n**Output**\n```\n0 1 2 3 4 5 6 7 8 9 10 12 21 23 32 34 43 45 54 56 65 67 76 78 87 89 98 101\n```\n\n*****Time Complexity:*****\nO(x)\n\n\n\n*****Auxiliary Space:*****\nO(1)\n\n\nAn\n\n****Efficient Solution****\ncan solve this problem in\n\n****O(k)****\ntime where\n\n****k****\nis number of Jumping Numbers smaller than or equal to\n\n****x****\n. The idea is use\n\n[BFS](https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/)\nor\n\n[DFS](https://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/)\n.\n\n\n\nAssume that we have a graph where the starting node is\n\n****0****\nand we need to traverse it from the start node to all the reachable nodes.\n\n\nWith the restrictions given in the graph about the jumping numbers, what do you think should be the restrictions defining the next transitions in the graph.\n\n\n```\nLets take a example for input x = 90\n\nStart node = 0\nFrom 0, we can move to 1 2 3 4 5 6 7 8 9\n[these are not in our range so we don't add it]\n\nNow from 1, we can move to 12 and 10\nFrom 2, 23 and 21\nFrom 3, 34 and 32\n.\n.\n.\n.\n.\n.\nand so on.\n```\n\n\nBelow is BFS based implementation of above idea.\n\n\nC++\n\n````\n// Finds and prints all jumping numbers smaller than or\n// equal to x.\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Prints all jumping numbers smaller than or equal to x starting\n// with 'num'. It mainly does BFS starting from 'num'.\nvoid bfs(int x, int num)\n{\n    // Create a queue and enqueue 'i' to it\n    queue<int> q;\n    q.push(num);\n\n    // Do BFS starting from i\n    while (!q.empty()) {\n        num = q.front();\n        q.pop();\n\n        if (num <= x) {\n            cout << num << \" \";\n            int last_dig = num % 10;\n\n            // If last digit is 0, append next digit only\n            if (last_dig == 0)\n                q.push((num * 10) + (last_dig + 1));\n\n            // If last digit is 9, append previous digit only\n            else if (last_dig == 9)\n                q.push((num * 10) + (last_dig - 1));\n\n            // If last digit is neither 0 nor 9, append both\n            // previous and next digits\n            else {\n                q.push((num * 10) + (last_dig - 1));\n                q.push((num * 10) + (last_dig + 1));\n            }\n        }\n    }\n}\n\n// Prints all jumping numbers smaller than or equal to\n// a positive number x\nvoid printJumping(int x)\n{\n    cout << 0 << \" \";\n    for (int i = 1; i <= 9 && i <= x; i++)\n        bfs(x, i);\n}\n\n// Driver program\nint main()\n{\n    int x = 40;\n    printJumping(x);\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Finds and prints all jumping numbers smaller than or\n// equal to x.\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\nclass GFG {\n\n    // Prints all jumping numbers smaller than or equal to x starting\n    // with 'num'. It mainly does BFS starting from 'num'.\n    public void bfs(int x, int num)\n    {\n        // Create a queue and enqueue 'i' to it\n        Queue<Integer> q = new LinkedList<Integer>();\n        q.add(num);\n\n        // Do BFS starting from i\n        while (!q.isEmpty()) {\n            num = q.peek();\n            q.poll();\n            if (num <= x) {\n                System.out.print(num + \" \");\n                int last_digit = num % 10;\n\n                // If last digit is 0, append next digit only\n                if (last_digit == 0) {\n                    q.add((num * 10) + (last_digit + 1));\n                }\n\n                // If last digit is 9, append previous digit only\n                else if (last_digit == 9) {\n                    q.add((num * 10) + (last_digit - 1));\n                }\n\n                // If last digit is neither 0 nor 9, append both\n                // previous and next digits\n                else {\n                    q.add((num * 10) + (last_digit - 1));\n                    q.add((num * 10) + (last_digit + 1));\n                }\n            }\n        }\n    }\n\n    // Prints all jumping numbers smaller than or equal to\n    // a positive number x\n    public void printJumping(int x)\n    {\n        System.out.print(\"0 \");\n\n        for (int i = 1; i <= 9 && i <= x; i++) {\n            this.bfs(x, i);\n        }\n    }\n\n    // Driver program\n    public static void main(String[] args) throws IOException\n    {\n        int x = 40;\n        GFG obj = new GFG();\n        obj.printJumping(x);\n    }\n}\n\n````\n\nPython\n\n````\n# Class queue for use later\nclass Queue:\n    def __init__(self):\n        self.lst = []\n\n    def is_empty(self):\n        return self.lst == []\n\n    def enqueue(self, elem):\n        self.lst.append(elem)\n\n    def dequeue(self):\n        return self.lst.pop(0)\n\n# Prints all jumping numbers smaller than or equal to\n# x starting with 'num'. It mainly does BFS starting\n# from 'num'.\ndef bfs(x, num):\n\n    # Create a queue and enqueue i to it\n    q = Queue()\n    q.enqueue(num)\n\n    # Do BFS starting from 1\n    while (not q.is_empty()):\n        num = q.dequeue()\n\n        if num<= x:\n            print(str(num), end =' ')\n            last_dig = num % 10\n\n            # If last digit is 0, append next digit only\n            if last_dig == 0:\n                q.enqueue((num * 10) + (last_dig + 1))\n\n            # If last digit is 9, append previous digit\n            # only\n            elif last_dig == 9:\n                q.enqueue((num * 10) + (last_dig - 1))\n\n            # If last digit is neither 0 nor 9, append\n            # both previous digit and next digit\n            else:\n                q.enqueue((num * 10) + (last_dig - 1))\n                q.enqueue((num * 10) + (last_dig + 1))\n\n# Prints all jumping numbers smaller than or equal to\n# a positive number x\ndef printJumping(x):\n    print (str(0), end =' ')\n    for i in range(1, 10):\n        bfs(x, i)\n\n# Driver Program ( Change value of x as desired )\nx = 40\nprintJumping(x)\n\n# This code is contributed by Saket Modi\n\n````\n\nC#\n\n````\n// C# program to finds and prints all jumping\n// numbers smaller than or equal to x.\nusing System;\nusing System.Collections.Generic;\n\nclass GFG\n{\n\n    // Prints all jumping numbers smaller than or\n    // equal to x starting with 'num'. It mainly\n    // does BFS starting from 'num'.\n    public void bfs(int x, int num)\n    {\n        // Create a queue and enqueue 'i' to it\n        Queue<int> q = new Queue<int>();\n        q.Enqueue(num);\n\n        // Do BFS starting from i\n        while (q.Count!=0)\n        {\n            num = q.Peek();\n            q.Dequeue();\n            if (num <= x)\n            {\n                Console.Write(num + \" \");\n                int last_digit = num % 10;\n\n                // If last digit is 0, append next digit only\n                if (last_digit == 0)\n                {\n                    q.Enqueue((num * 10) + (last_digit + 1));\n                }\n\n                // If last digit is 9, append previous digit only\n                else if (last_digit == 9)\n                {\n                    q.Enqueue((num * 10) + (last_digit - 1));\n                }\n\n                // If last digit is neither 0 nor 9, append both\n                // previous and next digits\n                else\n                {\n                    q.Enqueue((num * 10) + (last_digit - 1));\n                    q.Enqueue((num * 10) + (last_digit + 1));\n                }\n            }\n        }\n    }\n\n    // Prints all jumping numbers smaller than or equal to\n    // a positive number x\n    public void printJumping(int x)\n    {\n        Console.Write(\"0 \");\n\n        for (int i = 1; i <= 9 && i <= x; i++)\n        {\n            this.bfs(x, i);\n        }\n    }\n\n    // Driver code\n    public static void Main(String[] args)\n    {\n        int x = 40;\n        GFG obj = new GFG();\n        obj.printJumping(x);\n    }\n}\n\n// This code has been contributed by 29AjayKumar\n\n````\n\nJavaScript\n\n````\n<script>\n\n// Finds and prints all jumping numbers\n// smaller than or equal to x.\n\n// Prints all jumping numbers smaller than\n// or equal to x starting with 'num'. It\n// mainly does BFS starting from 'num'.\nfunction bfs(x, num)\n{\n\n    // Create a queue and enqueue 'i' to it\n    let q = [];\n    q.push(num);\n\n    // Do BFS starting from i\n    while (q.length != 0)\n    {\n        num = q.shift();\n\n        if (num <= x)\n        {\n            document.write(num + \" \");\n            let last_digit = num % 10;\n\n            // If last digit is 0, append next digit only\n            if (last_digit == 0)\n            {\n                q.push((num * 10) + (last_digit + 1));\n            }\n\n            // If last digit is 9, append previous\n            // digit only\n            else if (last_digit == 9)\n            {\n                q.push((num * 10) + (last_digit - 1));\n            }\n\n            // If last digit is neither 0 nor 9,\n            // append both previous and next digits\n            else\n            {\n                q.push((num * 10) + (last_digit - 1));\n                q.push((num * 10) + (last_digit + 1));\n            }\n        }\n    }\n}\n\n// Prints all jumping numbers smaller\n// than or equal to a positive number x\nfunction printJumping(x)\n{\n    document.write(\"0 \");\n\n    for(let i = 1; i <= 9 && i <= x; i++)\n    {\n        bfs(x, i);\n    }\n}\n\n// Driver code\nlet x = 40;\nprintJumping(x);\n\n// This code is contributed by rag2127\n\n</script>\n\n````\n\n\n\n\n**Output**\n```\n0 1 10 12 2 21 23 3 32 34 4 5 6 7 8 9\n```\n\n*****Time Complexity:*****\nO(k) time where\n\n****k****\nis number of Jumping Numbers smaller than or equal to\n\n****x****\n\n\n*****Auxiliary Space:*****\nO(1)\n\n\nThanks to Gaurav Ahirwar for above solution.\n\n\n****Exercise:****\n\n\n1. Change the above solution to use DFS instead of BFS.\n2. Extend your solution to print all numbers in sorted order instead of any order.\n3. Further extend the solution to print all numbers in a given range.\n\n****DFS based solution:****\n\n\nIn the\n\n[DFS](https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/)\nbased approach we start building our numbers from single digits , i.e. from 1 \u2013 9. Then we check for next possible digit and if possible we call the dfs for those numbers, increasing the number of digits with each call.\n\n\n****Algorithm:****\n\n```\n1. We will start from every possible single digit, i.e. from 1 to 9\n2. In the dfs we first write the base case, then\n3. We print the current number\n4. We get the last digit of current number and\n  check the possibilities for the next digit.\n  The next digit can either be last digit + 1 or last digit - 1\n5. If the last digit is either 0 or 9 we have only one option for\n  next number, else both the options are possible.\n```\n\n\nSee\n\n****C++ implementation****\nof above approach:\n\n\nC++\n\n````\n// C++ implementation of the above approach\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nvoid dfs(ll cnum, const ll& num)\n{\n    if (cnum > num) // base case\n        return;\n\n    cout << cnum << \" \"; // print the current number\n\n    int l_dig = cnum % 10; // get the last digit of current number\n\n    // for the next digit we have two options\n    ll first = cnum * 10 + l_dig + 1;\n    ll second = cnum * 10 + l_dig - 1;\n\n    if (l_dig == 0) // here as second option will give us a\n                    // -ve number we will skip it\n        dfs(first, num);\n    else if (l_dig == 9) // here as first option will give\n                         // us a -ve number we will skip it\n        dfs(second, num);\n    else // else we call on both the options\n    {\n        dfs(first, num);\n        dfs(second, num);\n    }\n}\n\nvoid PrintJumping(long long X)\n{\n    cout << 0 << \" \";\n    for (ll i = 1; i <= 9; i++) {\n        dfs(i, X); // generate all the numbers starting\n                   // from i\n    }\n}\n\nint main()\n{\n\n    long long X = 40;\n    PrintJumping(X);\n    return 0;\n}\n// This code is contributed by Abhijeet Kumar(abhijeet19403)\n\n````\n\nJava\n\n````\n// Java implementation of the above approach\nimport java.util.*;\n\nclass gfg2 {\n    static void dfs(long cnum, long num)\n    {\n        if (cnum > num) // base case\n            return;\n\n        System.out.print(cnum\n                         + \" \"); // print the current number\n\n        int l_dig = (int)(cnum % 10); // get the last digit\n                                      // of current number\n\n        // for the next digit we have two options\n        long first = cnum * 10 + l_dig + 1;\n        long second = cnum * 10 + l_dig - 1;\n\n        if (l_dig == 0) // here as second option will give\n                        // us a -ve number we will skip it\n            dfs(first, num);\n        else if (l_dig\n                 == 9) // here as first option will give\n                       // us a -ve number we will skip it\n            dfs(second, num);\n        else // else we call on both the options\n        {\n            dfs(first, num);\n            dfs(second, num);\n        }\n    }\n\n    static void PrintJumping(long X)\n    {\n        System.out.print(0 + \" \");\n        for (long i = 1L; i <= 9; i++) {\n            dfs(i, X); // generate all the numbers starting\n                       // from i\n        }\n    }\n    public static void main(String[] args)\n    {\n        long X = 40;\n        PrintJumping(X);\n    }\n}\n// This code is contributed by karandeep1234\n\n````\n\nPython\n\n````\n# Python3 implementation of the above approach\ndef dfs(cnum, num):\n    # base case\n    if cnum > num:\n        return\n\n    # print the current number\n    print(cnum, end=\" \")\n\n    # get the last digit of the current number\n    l_dig = cnum % 10\n\n    # for the next digit we have two options\n    first = cnum * 10 + l_dig + 1\n    second = cnum * 10 + l_dig - 1\n\n    # here as second option will give us a -ve number\n    # we will skip it\n    if l_dig == 0:\n        dfs(first, num)\n    # here as first option will give us a -ve number\n    # we will skip it\n    elif l_dig == 9:\n        dfs(second, num)\n    # else we will call on both the options\n    else:\n        dfs(first, num)\n        dfs(second, num)\n\n# Print Jumping numbers\ndef PrintJumping(X):\n    print(0, end=\" \")\n    for i in range(1, 10):\n        dfs(i, X)\n\n# Driver code\nif __name__ == '__main__':\n    X = 40\n    PrintJumping(X)\n\n    # This code is contributed by factworx412\n\n````\n\nC#\n\n````\n// C# implementation of the above approach\nusing System;\n\nclass GFG {\n  static void dfs(long cnum, long num)\n  {\n    if (cnum > num) // base case\n      return;\n\n    Console.Write(cnum\n                  + \" \"); // print the current number\n\n    int l_dig = (int)(cnum % 10); // get the last digit\n    // of current number\n\n    // for the next digit we have two options\n    long first = cnum * 10 + l_dig + 1;\n    long second = cnum * 10 + l_dig - 1;\n\n    if (l_dig == 0) // here as second option will give\n      // us a -ve number we will skip it\n      dfs(first, num);\n    else if (l_dig\n             == 9) // here as first option will give\n      // us a -ve number we will skip it\n      dfs(second, num);\n    else // else we call on both the options\n    {\n      dfs(first, num);\n      dfs(second, num);\n    }\n  }\n\n  static void PrintJumping(long X)\n  {\n    Console.Write(0 + \" \");\n    for (long i = 1L; i <= 9; i++) {\n      dfs(i, X); // generate all the numbers starting\n      // from i\n    }\n  }\n  static void Main(string[] args)\n  {\n    long X = 40;\n    PrintJumping(X);\n  }\n}\n\n// This code is contributed by karandeep1234\n\n````\n\nJavaScript\n\n````\n    // Javascript implementation of the above approach\n    function dfs(cnum, num)\n    {\n        if (cnum > num) // base case\n            return;\n\n        console.log(cnum+\" \"); // print the current number\n\n        let l_dig = cnum % 10; // get the last digit of current number\n\n        // for the next digit we have two options\n        let first = cnum * 10 + l_dig + 1;\n        let second = cnum * 10 + l_dig - 1;\n\n        if (l_dig == 0) // here as second option will give us a\n                        // -ve number we will skip it\n            dfs(first, num);\n        else if (l_dig == 9) // here as first option will give\n                            // us a -ve number we will skip it\n            dfs(second, num);\n        else // else we call on both the options\n        {\n            dfs(first, num);\n            dfs(second, num);\n        }\n    }\n\n    function PrintJumping(X)\n    {\n        console.log(0+\" \");\n        for(let i = 1; i <= 9; i++) {\n            dfs(i, X); // generate all the numbers starting\n                    // from i\n        }\n    }\n\n        let X = 40;\n        PrintJumping(X);\n\n    // This code is contributed by Aman Kumar.\n\n````\n\n\n\n\n**Output**\n```\n0 1 12 10 2 23 21 3 34 32 4 5 6 7 8 9\n```\n\n****Time Complexity:****\nO(k)\n\n\nHere k is the total number of jumping numbers.\n\n\n****Auxiliary Space:****\nO(len(N))\n\n\nHere len(N) is the maximum length from all the jumping numbers, the extra space is used due to recursive function call stack.\n\n",
        "metadata": {
            "lesson_id": "b1a2bec7-f49b-4d01-a799-d27664456f71",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "\n\n[****LCM****](https://www.geeksforgeeks.org/lcm-least-common-multiple/)\nof two numbers is the smallest number which can be divided by both numbers.\n\n\n> ****Input****\n> : a = 12, b = 18\n>\n>\n>\n> ****Output****\n> : 36\n>\n>\n>\n> 36 is the smallest number divisible by both 12 and 18\n>\n>\n> ****Input****\n> : a = 5, b = 11\n>\n>\n>\n> ****Output****\n> : 55\n>\n>\n>\n> 55 is the smallest number divisible by both 5 and 11\n\n\nA\n\n****simple solution****\nis to\n\n[find all prime factors](https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/)\nof both numbers, then find union of all factors present in both\n\n[numbers](https://www.geeksforgeeks.org/numbers/)\n. Finally, return the product of elements in union.\n\n\nAn\n\n****efficient solution****\nis based on the below formula for LCM of two numbers \u2018a\u2019 and \u2018b\u2019.\n\n\n![relation---------between---------hcf---------and---------lcm_________](https://media.geeksforgeeks.org/wp-content/uploads/20241122160112040184/relation---------between---------hcf---------and---------lcm_________.webp)\n> a x b = LCM(a, b) \\* GCD (a, b)\n>\n>\n>\n>\n>\n> LCM(a, b) = (a x b) / GCD(a, b)\n\n\nWe have discussed\n\n[function to find GCD of two numbers](https://www.geeksforgeeks.org/c-program-find-gcd-hcf-two-numbers/)\n. Using GCD, we can find LCM.\n\n\nBelow is the implementation of the above idea:\n\n\n\nC++\n\n````\n// C++ program to find LCM of two numbers\n#include <iostream>\nusing namespace std;\n\n// Recursive function to return gcd of a and b\nlong long gcd(long long int a, long long int b)\n{\n  if (b == 0)\n    return a;\n  return gcd(b, a % b);\n}\n\n// Function to return LCM of two numbers\nlong long lcm(int a, int b)\n{\n    return (a / gcd(a, b)) * b;\n}\n\n// Driver program to test above function\nint main()\n{\n    int a = 15, b = 20;\n    cout <<\"LCM of \" << a << \" and \"\n         << b << \" is \" << lcm(a, b);\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find LCM of two numbers\n#include <stdio.h>\n\n// Recursive function to return gcd of a and b\nint gcd(int a, int b)\n{\n    if (a == 0)\n        return b;\n    return gcd(b % a, a);\n}\n\n// Function to return LCM of two numbers\nint lcm(int a, int b)\n{\n    return (a / gcd(a, b)) * b;\n}\n\n// Driver program to test above function\nint main()\n{\n    int a = 15, b = 20;\n    printf(\"LCM of %d and %d is %d \", a, b, lcm(a, b));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find LCM of two numbers.\nimport java.io.*;\npublic class Test\n{\n    // Recursive method to return gcd of a and b\n    static int gcd(int a, int b)\n    {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    // method to return LCM of two numbers\n    static int lcm(int a, int b)\n    {\n        return (a / gcd(a, b)) * b;\n    }\n\n    // Driver method\n    public static void main(String[] args)\n    {\n        int a = 15, b = 20;\n        System.out.println(\"LCM of \" + a +\n                           \" and \" + b +\n                      \" is \" + lcm(a, b));\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to find LCM of two numbers\n\n# Recursive function to return gcd of a and b\ndef gcd(a,b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n# Function to return LCM of two numbers\ndef lcm(a,b):\n    return (a // gcd(a,b))* b\n\n# Driver program to test above function\na = 15\nb = 20\nprint('LCM of', a, 'and', b, 'is', lcm(a, b))\n\n# This code is contributed by Danish Raza\n\n````\n\nC#\n\n````\n// C# program to find LCM\n// of two numbers.\nusing System;\nclass GFG {\n\n    // Recursive method to\n    // return gcd of a and b\n    static int gcd(int a, int b)\n    {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    // method to return\n    // LCM of two numbers\n    static int lcm(int a, int b)\n    {\n        return (a / gcd(a, b)) * b;\n    }\n\n    // Driver method\n    public static void Main()\n    {\n        int a = 15, b = 20;\n        Console.WriteLine(\"LCM of \" + a +\n         \" and \" + b + \" is \" + lcm(a, b));\n    }\n}\n\n// This code is contributed by anuj_67.\n\n````\n\nJavaScript\n\n````\n<script>\n\n// Javascript program to find LCM of two numbers\n\n// Recursive function to return gcd of a and b\nfunction gcd(a, b)\n{\nif (b == 0)\n    return a;\nreturn gcd(b, a % b);\n}\n\n// Function to return LCM of two numbers\nfunction lcm(a, b)\n{\n    return (a / gcd(a, b)) * b;\n}\n\n// Driver program to test above function\n\n    let a = 15, b = 20;\n    document.write(\"LCM of \" + a + \" and \"\n    + b + \" is \" + lcm(a, b));\n\n\n// This code is contributed by Mayank Tyagi\n\n</script>\n\n````\n\nPHP\n\n````\n<?php\n// PHP program to find LCM of two numbers\n\n// Recursive function to\n// return gcd of a and b\nfunction gcd( $a, $b)\n{\n   if ($a == 0)\n        return $b;\n    return gcd($b % $a, $a);\n}\n\n// Function to return LCM\n// of two numbers\nfunction lcm( $a, $b)\n{\n    return ($a / gcd($a, $b)) * $b;\n}\n\n    // Driver Code\n    $a = 15;\n    $b = 20;\n    echo \"LCM of \",$a, \" and \"\n         ,$b, \" is \", lcm($a, $b);\n\n// This code is contributed by anuj_67.\n?>\n\n````\n\n\n\n\n**Output**\n```\nLCM of 15 and 20 is 60\n```\n\n****Time Complexity:****\nO(log(min(a,b))\n\n\n\n****Auxiliary Space:****\nO(log(min(a,b))\n\n\n****Another Efficient Approach: Using conditional for loop****\n\nC++\n\n````\n// C++ program to find LCM of 2 numbers\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to return LCM of two numbers\nint LCM(int a, int b)\n{\n    int greater = max(a, b);\n    int smallest = min(a, b);\n    for (int i = greater; ; i += greater) {\n        if (i % smallest  == 0)\n            return i;\n    }\n}\n\n// Driver program to test above function\nint main()\n{\n    int a = 10, b = 5;\n    cout << \"LCM of \" << a << \" and \"\n         << b << \" is \" << LCM(a, b);\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find LCM of 2 numbers\n\nimport java.util.Scanner;\n\npublic class LCM {\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int a = 10;\n        int b = 5;\n        int lcm = findLCM(a, b);\n        System.out.println(\"LCM of \" + a + \" and \" + b\n                           + \" is \" + lcm);\n        sc.close();\n    }\n    // Function to return LCM of two numbers\n    public static int findLCM(int a, int b)\n    {\n        int greater = Math.max(a, b);\n        int smallest = Math.min(a, b);\n        for (int i = greater;; i += greater) {\n            if (i % smallest == 0)\n                return i;\n        }\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to find LCM of two numbers\n\n# Function to return LCM of two numbers\ndef LCM(a, b):\n    greater = max(a, b)\n    smallest = min(a, b)\n    for i in range(greater, a*b+1, greater):\n        if i % smallest == 0:\n            return i\n\n# Driver program to test above function\nif __name__ == '__main__':\n    a = 10\n    b = 5\n    print(\"LCM of\", a, \"and\", b, \"is\", LCM(a, b))\n\n````\n\nC#\n\n````\n// C# program to find LCM of 2 numbers\nusing System;\n\nclass LCMProgram\n{\n\n  // Function to return LCM of two numbers\n  static int LCM(int a, int b)\n  {\n    int greater = Math.Max(a, b);\n    int smallest = Math.Min(a, b);\n    for (int i = greater;; i += greater) {\n      if (i % smallest == 0)\n        return i;\n    }\n  }\n\n  // Driver program to test above function\n  static void Main()\n  {\n    int a = 10, b = 5;\n    Console.WriteLine(\"LCM of \" + a + \" and \" + b\n                      + \" is \" + LCM(a, b));\n  }\n}\n\n````\n\nJavaScript\n\n````\n// Javascript program to find LCM of two numbers\n\n// Function to return LCM of two numbers\nfunction LCM(a, b){\n    let greater = Math.max(a, b);\n    let smallest = Math.min(a, b);\n    for(let i = greater; i <= a*b; i+=greater){\n        if(i % smallest == 0){\n            return i;\n        }\n    }\n}\n\n// Driver program to test above function\nlet a = 10;\nlet b = 5;\nconsole.log(\"LCM of\", a, \"and\", b, \"is\", LCM(a, b));\n\n````\n\n\n\n\n**Output**\n```\nLCM of 10 and 5 is 10\n```\n\n****Time Complexity:****\nO(min(a,b))\n\n\n\n****Auxiliary Space:****\nO(1)\n",
        "metadata": {
            "lesson_id": "023ee905-49cc-4ff9-b0f6-57f68b7a1d9a",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "LCM of two numbers is the smallest number which can be divided by both numbers.",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "Given two numbers\n\n****a****\nand\n\n****b****\n, the task is to find the\n\n[GCD](https://www.geeksforgeeks.org/greatest-common-divisor-gcd/)\nof the two numbers.\n\n\n****Note:****\nThe GCD (Greatest Common Divisor) or HCF (Highest Common Factor) of two numbers is the largest number that divides both of them.\n\n\n\n![gcd](https://media.geeksforgeeks.org/wp-content/uploads/20240920171939/gcd.webp)\n\n\n\n\n****Examples:****\n\n> ****Input:****\n> a = 20, b = 28\n>\n>\n>\n> ****Output:****\n> 4\n>\n>\n>\n> ****Explanation:****\n> The factors of 20 are 1, 2, 4, 5, 10 and 20. The factors of 28 are 1, 2, 4, 7, 14 and 28. Among these factors, 1, 2 and 4 are the common factors of both 20 and 28. The greatest among the common factors is 4.\n>\n>\n> ****Input:****\n> a = 60, b = 36\n>\n>\n>\n> ****Output:****\n> 12\n\nNaive Approach for GCD of two numbers:\n--------------------------------------\n\n> The basic idea is to find the minimum of the two numbers and find its highest factor which is also a factor of the other\n>\n> [number](https://www.geeksforgeeks.org/numbers/)\n> .\n\n\nBelow is the code implementation of the above idea:\n\n\n\nC++\n\n````\n// C++ program to find GCD of two numbers\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to return gcd of a and b\nint gcd(int a, int b)\n{\n    // Find Minimum of a and b\n    int result = min(a, b);\n    while (result > 0) {\n        if (a % result == 0 && b % result == 0) {\n            break;\n        }\n        result--;\n    }\n\n    // Return gcd of a and b\n    return result;\n}\n\n// Driver code\nint main()\n{\n    int a = 98, b = 56;\n    cout << \"GCD of \" << a << \" and \" << b << \" is \"\n         << gcd(a, b);\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find GCD of two numbers\n\n#include <math.h>\n#include <stdio.h>\n\n// Function to return gcd of a and b\nint gcd(int a, int b)\n{\n    // Find Minimum of a and b\n    int result = ((a < b) ? a : b);\n    while (result > 0) {\n        if (a % result == 0 && b % result == 0) {\n            break;\n        }\n        result--;\n    }\n\n    // Return gcd of a and b\n    return result;\n}\n\n// Driver code\nint main()\n{\n    int a = 98, b = 56;\n    printf(\"GCD of %d and %d is %d \", a, b, gcd(a, b));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find GCD of two numbers\nimport java.io.*;\n\npublic class GFG {\n\n    // Function to return gcd of a and b\n    static int gcd(int a, int b)\n    {\n        // Find Minimum of a and b\n        int result = Math.min(a, b);\n        while (result > 0) {\n            if (a % result == 0 && b % result == 0) {\n                break;\n            }\n            result--;\n        }\n\n        // Return gcd of a and b\n        return result;\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        int a = 98, b = 56;\n        System.out.print(\"GCD of \" + a + \" and \" + b\n                         + \" is \" + gcd(a, b));\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to find GCD of two numbers\n\n\n# Function to find gcd of two numbers\ndef gcd(a, b):\n\n    # Find minimum of a and b\n    result = min(a, b)\n\n    while result:\n        if a % result == 0 and b % result == 0:\n            break\n        result -= 1\n\n    # Return the gcd of a and b\n    return result\n\n\n# Driver Code\nif __name__ == '__main__':\n    a = 98\n    b = 56\n    print(f\"GCD of {a} and {b} is {gcd(a, b)}\")\n\n````\n\nC#\n\n````\n// C# program to find GCD of two numbers\n\nusing System;\npublic class GFG {\n\n    // Function to return gcd of a and b\n    static int gcd(int a, int b)\n    {\n        // Find Minimum of a and b\n        int result = Math.Min(a, b);\n        while (result > 0) {\n            if (a % result == 0 && b % result == 0) {\n                break;\n            }\n            result--;\n        }\n\n        // Return gcd of a and b\n        return result;\n    }\n\n    // Driver code\n    public static void Main(string[] args)\n    {\n        int a = 98, b = 56;\n        Console.WriteLine(\"GCD of \" + a + \" and \" + b\n                          + \" is \" + gcd(a, b));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Javascript program to find GCD of two numbers\n// Function to return gcd of a and b\nfunction gcd(a,b)\n{\n    // Find Minimum of a and b\n    let result = Math.min(a, b);\n    while (result > 0) {\n        if (a % result == 0 && b % result == 0) {\n            break;\n        }\n        result--;\n    }\n\n    // Return gcd of a and b\n    return result;\n}\n\n// Driver program to test above function\nlet a = 98;\nlet b = 56;\nconsole.log(\"GCD of \",a,\" and \",b,\" is \",gcd(a, b));\n\n````\n\n\n\n\n**Output**\n```\nGCD of 98 and 56 is 14\n```\n\n****Time Complexity:****\nO(min(a,b))\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n[Euclidean algorithm](https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended)\nfor GCD of two numbers:\n--------------------------------------------------------------------------------------------------------------------\n\n\nThe idea of this algorithm is, the GCD of two numbers doesn\u2019t change if the smaller number is subtracted from the bigger number. This is the\n\n****Euclidean algorithm by subtraction****\n. It is a process of repeat subtraction, carrying the result forward each time until the result is equal to any one number being subtracted.\n\n\n****Pseudo-code:****\n\n> gcd(a, b):\n>\n>\n>\n> if a = b:\n>\n>\n>\n> return a\n>\n>\n>\n> if a > b:\n>\n>\n>\n> return gcd(a \u2013 b, b)\n>\n>\n>\n> else:\n>\n>\n>\n> return gcd(a, b \u2013 a)\n\n\nBelow is the implementation of the above approach.\n\n\n\nC++\n\n````\n// C++ program to find GCD of two numbers\n// code is updated by himanshug9119 - linkedin URL -\n// https://www.linkedin.com/in/himanshug9119/\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Recursive function to return gcd of a and b\nint gcd(int a, int b)\n{\n    // Everything divides 0\n    if (a == 0)\n        return b;\n    if (b == 0)\n        return a;\n\n    // Base case\n    if (a == b)\n        return a;\n\n    // a is greater\n    if (a > b)\n        return gcd(a - b, b);\n    return gcd(a, b - a);\n}\n\n// Driver code\nint main()\n{\n    int a = 98, b = 56;\n    cout << \"GCD of \" << a << \" and \" << b << \" is \"\n         << gcd(a, b);\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find GCD of two numbers\n\n#include <stdio.h>\n\n// Recursive function to return gcd of a and b\nint gcd(int a, int b)\n{\n    // Everything divides 0\n    if (a == 0)\n        return b;\n    if (b == 0)\n        return a;\n\n    // Base case\n    if (a == b)\n        return a;\n\n    // a is greater\n    if (a > b)\n        return gcd(a - b, b);\n    return gcd(a, b - a);\n}\n\n// Driver code\nint main()\n{\n    int a = 98, b = 56;\n    printf(\"GCD of %d and %d is %d \", a, b, gcd(a, b));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find GCD of two numbers\n\nimport java.io.*;\n\nclass Test {\n\n    // Recursive function to return gcd of a and b\n    static int gcd(int a, int b)\n    {\n        // Everything divides 0\n        if (a == 0)\n            return b;\n        if (b == 0)\n            return a;\n\n        // Base case\n        if (a == b)\n            return a;\n\n        // a is greater\n        if (a > b)\n            return gcd(a - b, b);\n        return gcd(a, b - a);\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        int a = 98, b = 56;\n        System.out.println(\"GCD of \" + a + \" and \" + b\n                           + \" is \" + gcd(a, b));\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to find GCD of two numbers\n\n\n# Recursive function to return gcd of a and b\ndef gcd(a, b):\n\n    # Everything divides 0\n    if (a == 0):\n        return b\n    if (b == 0):\n        return a\n\n    # Base case\n    if (a == b):\n        return a\n\n    # a is greater\n    if (a > b):\n        return gcd(a-b, b)\n    return gcd(a, b-a)\n\n\n# Driver code\nif __name__ == '__main__':\n    a = 98\n    b = 56\n    if(gcd(a, b)):\n        print('GCD of', a, 'and', b, 'is', gcd(a, b))\n    else:\n        print('not found')\n\n# This code is contributed by Danish Raza\n\n````\n\nC#\n\n````\n// C# program to find GCD of two numbers\n\nusing System;\n\nclass GFG {\n\n    // Recursive function to return gcd of a and b\n    static int gcd(int a, int b)\n    {\n        // Everything divides 0\n        if (a == 0)\n            return b;\n        if (b == 0)\n            return a;\n\n        // Base case\n        if (a == b)\n            return a;\n\n        // a is greater\n        if (a > b)\n            return gcd(a - b, b);\n\n        return gcd(a, b - a);\n    }\n\n    // Driver code\n    public static void Main()\n    {\n        int a = 98, b = 56;\n        Console.WriteLine(\"GCD of \" + a + \" and \" + b\n                          + \" is \" + gcd(a, b));\n    }\n}\n\n// This code is contributed by anuj_67.\n\n````\n\nJavaScript\n\n````\n// Javascript program to find GCD of two numbers\n\n// Recursive function to return gcd of a and b\nfunction gcd(a, b)\n{\n    // Everything divides 0\n    if (a == 0)\n    return b;\n    if (b == 0)\n    return a;\n\n    // Base case\n    if (a == b)\n        return a;\n\n    // a is greater\n    if (a > b)\n        return gcd(a-b, b);\n    return gcd(a, b-a);\n}\n\n// Driver program to test above function\n\n    let a = 98, b = 56;\n    console.log(\"GCD of \"+ a + \" and \" + b + \" is \" + gcd(a, b));\n\n// This code is contributed by Mayank Tyagi\n\n````\n\nPHP\n\n````\n<?php\n// PHP program to find GCD\n// of two numbers\n\n// Recursive function to return gcd of a and b\nfunction gcd($a, $b)\n{\n    // Everything divides 0\n    if ($a == 0)\n       return $b;\n    if ($b == 0)\n       return $a;\n\n    // Base case\n    if($a == $b)\n        return $a ;\n\n    // a is greater\n    if($a > $b)\n        return gcd( $a-$b , $b ) ;\n\n    return gcd( $a , $b-$a ) ;\n}\n\n// Driver code\n$a = 98 ;\n$b = 56 ;\n\necho \"GCD of $a and $b is \", gcd($a , $b) ;\n\n// This code is contributed by Anivesh Tiwari\n?>\n\n````\n\n\n\n\n**Output**\n```\nGCD of 98 and 56 is 14\n```\n\n****Time Complexity:****\nO(min(a,b))\n\n\n\n****Auxiliary Space:****\nO(min(a,b)) because it uses internal stack data structure in recursion.\n\n\n****Optimization by checking divisibility:****\n----------------------------------------------\n\n\nThe above method can be optimized based on the following idea:\n\n\n> If we notice the previous approach, we can see at some point, one number becomes a factor of the other so instead of repeatedly subtracting till both become equal, we can check if it is a factor of the other.\n\n****Illustration:****\n\n\nSee the below illustration for a better understanding:\n\n\n> Consider a = 98 and b = 56\n>\n>\n> ****a = 98, b = 56:****\n>\n> * a > b so put a = a-b and b remains same. So  a = 98-56 = 42  & b= 56.\n>\n> ****a = 42, b = 56:****\n>\n> * Since b > a, we check if b%a=0. Since answer is no, we proceed further.\n> * Now b>a. So b = b-a and a remains same. So b = 56-42 = 14 & a= 42.\n>\n> ****a = 42, b = 14:****\n>\n> * Since a>b, we check if a%b=0. Now the answer is yes.\n> * So we print smaller among a and b as H.C.F . i.e. 42 is  3 times of 14.\n>\n>\n> So\n>\n> ****HCF****\n> is 14.\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n// C++ program to find GCD of two numbers\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Recursive function to return gcd of a and b\nint gcd(int a, int b)\n{\n    // Everything divides 0\n    if (a == 0)\n        return b;\n    if (b == 0)\n        return a;\n\n    // Base case\n    if (a == b)\n        return a;\n\n    // a is greater\n    if (a > b) {\n        if (a % b == 0)\n            return b;\n        return gcd(a - b, b);\n    }\n    if (b % a == 0)\n        return a;\n    return gcd(a, b - a);\n}\n\n// Driver code\nint main()\n{\n    int a = 98, b = 56;\n    cout << \"GCD of \" << a << \" and \" << b << \" is \"\n         << gcd(a, b);\n    return 0;\n}\n\n````\n\nJava\n\n````\npublic class GCD {\n    // Recursive function to return gcd of a and b\n    static int gcd(int a, int b) {\n        // Everything divides 0\n        if (a == 0)\n            return b;\n        if (b == 0)\n            return a;\n\n        // Base case\n        if (a == b)\n            return a;\n\n        // a is greater\n        if (a > b) {\n            if (a % b == 0)\n                return b;\n            return gcd(a - b, b);\n        }\n        if (b % a == 0)\n            return a;\n        return gcd(a, b - a);\n    }\n\n    // Driver code\n    public static void main(String[] args) {\n        int a = 98, b = 56;\n        System.out.println(\"GCD of \" + a + \" and \" + b + \" is \" + gcd(a, b));\n    }\n}\n// This code is contributed by rambabuguphka\n\n````\n\nPython\n\n````\ndef gcd(a, b):\n    # Everything divides 0\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n\n    # Base case\n    if a == b:\n        return a\n\n    # a is greater\n    if a > b:\n        if a % b == 0:\n            return b\n        return gcd(a - b, b)\n    if b % a == 0:\n        return a\n    return gcd(a, b - a)\n\n# Driver code\na = 98\nb = 56\nprint(f\"GCD of {a} and {b} is {gcd(a, b)}\")\n\n````\n\nC#\n\n````\nusing System;\n\npublic class GFG\n{\n    // Recursive function to return gcd of a and b\n    static int GCD(int a, int b)\n    {\n        // Everything divides 0\n        if (a == 0)\n            return b;\n        if (b == 0)\n            return a;\n\n        // Base case\n        if (a == b)\n            return a;\n\n        // a is greater\n        if (a > b)\n        {\n            if (a % b == 0)\n                return b;\n            return GCD(a - b, b);\n        }\n        if (b % a == 0)\n            return a;\n        return GCD(a, b - a);\n    }\n\n    // Main method\n    public static void Main(string[] args)\n    {\n        int a = 98, b = 56;\n        Console.WriteLine(\"GCD of \" + a + \" and \" + b + \" is \" + GCD(a, b));\n    }\n}\n\n// This code is add by Avinash Wani\n\n````\n\nJavaScript\n\n````\n// Recursive function to return gcd of a and b\nfunction gcd(a, b) {\n    // Everything divides 0\n    if (a === 0) {\n        return b;\n    }\n    if (b === 0) {\n        return a;\n    }\n\n    // Base case\n    if (a === b) {\n        return a;\n    }\n\n    // a is greater\n    if (a > b) {\n        if (a % b === 0) {\n            return b;\n        }\n        return gcd(a - b, b);\n    }\n    if (b % a === 0) {\n        return a;\n    }\n    return gcd(a, b - a);\n}\n\n// Driver code\nlet a = 98;\nlet b = 56;\nconsole.log(`GCD of ${a} and ${b} is ${gcd(a, b)}`);\n\n````\n\n\n\n\n**Output**\n```\nGCD of 98 and 56 is 14\n```\n\n****Time Complexity:****\nO(min(a, b))\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n****Optimization using division:****\n------------------------------------\n\n> Instead of the Euclidean algorithm by subtraction, a better approach can be used. We don\u2019t perform subtraction here. we continuously divide the bigger number by the smaller number. More can be learned about this\n>\n> ****efficient solution****\n> by using the modulo operator in\n>\n> [Euclidean algorithm](https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended)\n> .\n\n\nBelow is the implementation of the above approach.\n\n\nC++\n\n````\n// C++ program to find GCD of two numbers\n#include <iostream>\nusing namespace std;\n// Recursive function to return gcd of a and b in single line\nint gcd(int a, int b)\n{\n    return b == 0 ? a : gcd(b, a % b);\n}\n\n// Driver program to test above function\nint main()\n{\n    int a = 98, b = 56;\n    cout<<\"GCD of \"<<a<<\" and \"<<b<<\" is \"<<gcd(a, b);\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find GCD of two numbers\n#include <stdio.h>\n\n// Recursive function to return gcd of a and b\nint gcd(int a, int b)\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\n// Driver program to test above function\nint main()\n{\n    int a = 98, b = 56;\n    printf(\"GCD of %d and %d is %d \", a, b, gcd(a, b));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find GCD of two numbers\nimport java.io.*;\n\nclass Test\n{\n    // Recursive function to return gcd of a and b\n    static int gcd(int a, int b)\n    {\n      if (b == 0)\n        return a;\n      return gcd(b, a % b);\n    }\n\n    // Driver method\n    public static void main(String[] args)\n    {\n        int a = 98, b = 56;\n        System.out.println(\"GCD of \" + a +\" and \" + b + \" is \" + gcd(a, b));\n    }\n}\n\n````\n\nPython\n\n````\n# Recursive function to return gcd of a and b\ndef gcd(a,b):\n\n    # Everything divides 0\n    if (b == 0):\n         return a\n    return gcd(b, a%b)\n\n# Driver program to test above function\na = 98\nb = 56\nif(gcd(a, b)):\n    print('GCD of', a, 'and', b, 'is', gcd(a, b))\nelse:\n    print('not found')\n\n# This code is contributed by Danish Raza\n\n````\n\nC#\n\n````\n// C# program to find GCD of two\n// numbers\nusing System;\n\nclass GFG {\n\n    // Recursive function to return\n    // gcd of a and b\n    static int gcd(int a, int b)\n    {\n       if (b == 0)\n          return a;\n       return gcd(b, a % b);\n    }\n\n    // Driver method\n    public static void Main()\n    {\n        int a = 98, b = 56;\n        Console.WriteLine(\"GCD of \"\n          + a +\" and \" + b + \" is \"\n                      + gcd(a, b));\n    }\n}\n\n// This code is contributed by anuj_67.\n\n````\n\nJavaScript\n\n````\n<script>\n\n// Javascript program to find GCD of two number\n\n// Recursive function to return gcd of a and b\n\nfunction gcd(a, b){\n\n  // Everything divides 0\n  if(b == 0){\n    return a;\n  }\n\n  return gcd(b, a % b);\n}\n\n// Driver code\nlet a = 98;\nlet b = 56;\n\ndocument.write(`GCD of ${a} and ${b} is ${gcd(a, b)}`);\n\n// This code is contributed by _saurabh_jaiswal\n\n</script>\n\n````\n\nPHP\n\n````\n<?php\n// PHP program to find GCD\n// of two numbers\n\n// Recursive function to\n// return gcd of a and b\nfunction gcd($a, $b)\n{\n    // Everything divides 0\n    if($b==0)\n        return $a ;\n\n    return gcd( $b , $a % $b ) ;\n}\n\n// Driver code\n$a = 98 ;\n$b = 56 ;\n\necho \"GCD of $a and $b is \", gcd($a , $b) ;\n\n// This code is contributed by Anivesh Tiwari\n?>\n\n````\n\n\n\n\n**Output**\n```\nGCD of 98 and 56 is 14\n```\n\n****Complexity Analysis:****\n\n****Time Complexity:****\nO(log(min(a,b)))\n\n\n* The derivation for this is obtained from the analysis of the worst-case scenario.\n* What we do is we ask what are the 2 least numbers that take 1 step, those would be (1,1). If we want to increase the number of steps to 2 while keeping the numbers as low as possible as we can take the numbers to be (1,2). Similarly, for 3 steps, the numbers would be (2,3), 4 would be (3,5), 5 would be (5,8).\n* So we can notice a pattern here, for the nth step the numbers would be (fib(n), fib(n+1)). So the worst-case time complexity would be O(n) where\n\n  ****a ? fib(n)****\n  and\n\n  ****b ? fib(n+1)****\n  .\n* Now Fibonacci series is an exponentially growing series where the ratio of n\n\n  th\n  /(n-1)\n\n  th\n  term approaches (sqrt(5)+1)/2 which is also called the golden ratio. So we can see that the time complexity of the algorithm increases linearly as the terms grow exponentially hence the time complexity would be\n\n  ****log(min(a,b))****\n  .\n\n****Auxiliary Space:****\nO(log(min(a,b))\n\n\n****Iterative implementation for GCD of two numbers using Euclidean Algorithm:****\n----------------------------------------------------------------------------------\n\n\nBelow is the iterative way to find the GCD of two numbers using Euclidean algorithm.\n\n\nC++\n\n````\n// C++ program to find GCD of two numbers\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Iterative function to return gcd of a and b\nint gcd(int a, int b)\n{\n    while (a > 0 && b > 0) {\n        if (a > b) {\n            a = a % b;\n        }\n        else {\n            b = b % a;\n        }\n    }\n    if (a == 0) {\n        return b;\n    }\n    return a;\n}\n\n// Driver code\nint main()\n{\n    int a = 98, b = 56;\n    cout << \"GCD of \" << a << \" and \" << b << \" is \"\n         << gcd(a, b);\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find GCD of two numbers\n#include <stdio.h>\n\n// Iterative function to return gcd of a and b\nint gcd(int a, int b)\n{\n    while (a > 0 && b > 0) {\n        if (a > b) {\n            a = a % b;\n        }\n        else {\n            b = b % a;\n        }\n    }\n    if (a == 0) {\n        return b;\n    }\n    return a;\n}\n\n// Driver code\nint main()\n{\n    int a = 98, b = 56;\n    printf(\"GCD of %d and %d is %d \", a, b, gcd(a, b));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find GCD of two numbers\nimport java.io.*;\n\nclass Test {\n\n    // Iterative function to return gcd of a and b\n    static int gcd(int a, int b)\n    {\n        while (a > 0 && b > 0) {\n            if (a > b) {\n                a = a % b;\n            }\n            else {\n                b = b % a;\n            }\n        }\n        if (a == 0) {\n            return b;\n        }\n        return a;\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        int a = 98, b = 56;\n        System.out.println(\"GCD of \" + a + \" and \" + b\n                           + \" is \" + gcd(a, b));\n    }\n}\n\n````\n\nPython\n\n````\n# Itervative function to return gcd of a and b\n\n\ndef gcd(a, b):\n\n    # Everything divides 0\n    while(a > 0 and b > 0):\n        if (a > b):\n            a = a % b\n        else:\n            b = b % a\n\n    if (a == 0):\n        return b\n    return a\n\n\n# Driver code\nif __name__ == '__main__':\n    a = 98\n    b = 56\n    if(gcd(a, b)):\n        print('GCD of', a, 'and', b, 'is', gcd(a, b))\n    else:\n        print('not found')\n\n````\n\nC#\n\n````\n// C# program to find GCD of two numbers\nusing System;\n\nclass GFG {\n\n    // Iterative function to return gcd of a and b\n    static int gcd(int a, int b)\n    {\n        while (a > 0 && b > 0) {\n            if (a > b) {\n                a = a % b;\n            }\n            else {\n                b = b % a;\n            }\n        }\n        if (a == 0) {\n            return b;\n        }\n        return a;\n    }\n\n    // Driver code\n    public static void Main()\n    {\n        int a = 98, b = 56;\n        Console.WriteLine(\"GCD of \" + a + \" and \" + b\n                          + \" is \" + gcd(a, b));\n    }\n}\n\n// This code is contributed by anuj_67.\n\n````\n\nJavaScript\n\n````\n// Javascript program to find GCD of two number\n\n// Recursive function to return gcd of a and b\n\nfunction gcd(a, b){\n\n  // Everything divides 0\n      while (a > 0 && b > 0) {\n        if (a > b) {\n            a = a % b;\n        }\n        else {\n            b = b % a;\n        }\n    }\n    if (a == 0) {\n        return b;\n    }\n    return a;\n}\n\n// Driver code\nlet a = 98;\nlet b = 56;\n\nconsole.log(`GCD of ${a} and ${b} is ${gcd(a, b)}`);\n\n// This code is contributed by _saurabh_jaiswal\n\n````\n\n\n\n\n**Output**\n```\nGCD of 98 and 56 is 14\n```\n\n****Time Complexity:****\nO(log(min(a,b)))\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n### GCD of two numbers using inbuilt function:\n\n\nLanguages like C++ have inbuilt functions to calculate GCD of two numbers.\n\n\nBelow is the implementation using inbuilt functions.\n\n\nC++\n\n````\n// c++ program to find gcd using inbuilt functions\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int a = 98, b = 56;\n    cout << \"The gcd of a and b is \" << __gcd(a, b) << endl;\n    return 0;\n}\n\n````\n\nJava\n\n````\n// JAVA program to find gcd using inbuilt functions\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class GFG {\n    public static void main(String[] args)\n    {\n        int a = 98, b = 56;\n        int gcd = gcd(a, b);\n        System.out.println(\"The gcd of a and b is \" + gcd);\n    }\n\n    public static int gcd(int a, int b)\n    {\n        BigInteger bigA = BigInteger.valueOf(Math.abs(a));\n        BigInteger bigB = BigInteger.valueOf(Math.abs(b));\n        BigInteger gcd = bigA.gcd(bigB);\n        return gcd.intValue();\n    }\n}\n// This code is contributed by Taranpreet Singh.\n\n````\n\nPython\n\n````\n# Python program to find gcd using inbuilt function using math library\nimport math\n\n#Driver code\nif __name__ == '__main__':\n  a = 98\n  b = 56\n  gcd_result = math.gcd(a, b) # inbuilt function gcd() using math library\n\n  print(\"The gcd of a and b is\", gcd_result)\n\n# This code is contributed by guptapratik\n\n````\n\nC#\n\n````\nusing System;\n\nclass Program\n{\n    static void Main()\n    {\n        int a = 98, b = 56;\n        Console.WriteLine($\"The gcd of a and b is {GCD(a, b)}\");\n    }\n\n    static int GCD(int a, int b)\n    {\n        return Math.Abs(b == 0 ? a : GCD(b, a % b));\n    }\n}\n\n````\n\nJavaScript\n\n````\nfunction gcd(a, b) {\n    if (b === 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\n// Example usage\nconst a = 98;\nconst b = 56;\nconsole.log(\"The gcd of a and b is \" + gcd(a, b));\n\n\n// Contributed By Siddhesh22\n\n````\n\n\n\n\n**Output**\n```\nThe gcd of a and b is 14\n\n```\n\n****Time Complexity:****\nO(log(min(a, b)))\n\n\n\n****Auxiliary Space:****\nO(1)\n\n",
        "metadata": {
            "lesson_id": "995fe7e2-ea73-4f91-8cbc-00bcdc769c4d",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "Given a positive integer\n\n****n****\n, find its square root. If\n\n****n****\nis not a perfect square, then return\n\n****floor****\nof\n\n****\u221an****\n.\n\n\n****Examples :****\n\n\n> ****Input:****\n> n = 4\n>\n>\n>\n> ****Output:****\n> 2\n>\n>\n>\n> ****Explanation:****\n> The square root of 4 is 2.\n>\n>\n> ****Input:****\n> n = 11\n>\n>\n>\n> ****Output:****\n> 3\n>\n>\n>\n> ****Explanation:****\n> The square root of 11 lies in between 3 and 4 so floor of the square root is 3.\n\nTable of Content\n\n* [[Naive Approach] Using a loop \u2013 O(sqrt(n)) Time and O(1) Space](#approach-1-using-a-loop-on-time-and-o1-space)\n* [[Expected Approach] Using Binary Search \u2013 O(logn) Time and O(1) Space](#approach-2-using-binary-search-ologn-time-and-o1-space)\n* [[Alternate Approach] Using Built In functions \u2013 O(logn) Time and O(1) Space](#approach-3-using-built-in-functions-ologn-time-and-o1-space)\n* [[Alternate Approach] Using Formula Used by Pocket Calculators \u2013 O(1) Time and O(1) Space](#approach-4-using-formula-used-by-pocket-calculators-o1-time-and-o1-space)\n### [Naive Approach] Using a loop \u2013 O(sqrt(n)) Time and O(1) Space\n\n\nAs, we know that square root of a positive integer is always\n\n****greater****\nthan or\n\n****equal****\nto one. So we start iterating from\n\n****1****\nand calculate the square of each number. We continue the iteration until we reach to an\n\n****integer****\nwhose square is\n\n****greater****\nthan the given integer, then the integer just\n\n****before****\nit will be our answer.\n\n\nC++\n\n````\n// C++ program to find the square root of\n// given integer using a loop\n\n#include <iostream>\nusing namespace std;\n\nint floorSqrt(int n) {\n\n    // Start iteration from 1 until the\n    // square of a number exceeds n\n    int res = 1;\n    while(res*res <= n){\n        res++;\n    }\n\n    // return the largest integer whose\n    // square is less than or equal to n\n    return res - 1;\n}\n\nint main() {\n    int n = 11;\n    cout << floorSqrt(n);\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find the square root of\n// given integer using a loop\n\n#include <stdio.h>\n\nint floorSqrt(int n) {\n\n    // Start iteration from 1 until the\n    // square of a number exceeds n\n    int res = 1;\n    while (res * res <= n) {\n        res++;\n    }\n\n    // return the largest integer whose\n    // square is less than or equal to n\n    return res - 1;\n}\n\nint main() {\n    int n = 11;\n    printf(\"%d\", floorSqrt(n));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find the square root of\n// given integer using a loop\n\nclass GfG {\n\n    static int floorSqrt(int n) {\n\n        // Start iteration from 1 until the\n        // square of a number exceeds n\n        int res = 1;\n        while (res * res <= n) {\n            res++;\n        }\n\n        // return the largest integer whose\n        // square is less than or equal to n\n        return res - 1;\n    }\n\n    public static void main(String[] args) {\n        int n = 11;\n        System.out.println(floorSqrt(n));\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to find the square root of\n# given integer using a loop\n\ndef floorSqrt(n):\n\n    # Start iteration from 1 until the\n    # square of a number exceeds n\n    res = 1\n    while res * res <= n:\n        res += 1\n\n    # return the largest integer whose\n    # square is less than or equal to n\n    return res - 1\n\nif __name__ == \"__main__\":\n    n = 11\n    print(floorSqrt(n))\n\n````\n\nC#\n\n````\n// C# program to find the square root of\n// given integer using a loop\n\nusing System;\n\nclass GfG {\n\n    static int floorSqrt(int n) {\n\n        // Start iteration from 1 until the\n        // square of a number exceeds n\n        int res = 1;\n        while (res * res <= n) {\n            res++;\n        }\n\n        // return the largest integer whose\n        // square is less than or equal to n\n        return res - 1;\n    }\n\n    static void Main() {\n        int n = 11;\n        Console.WriteLine(floorSqrt(n));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// JavaScript program to find the square root of\n// given integer using a loop\n\nfunction floorSqrt(n) {\n\n    // Start iteration from 1 until the\n    // square of a number exceeds n\n    let res = 1;\n    while (res * res <= n) {\n        res++;\n    }\n\n    // return the largest integer whose\n    // square is less than or equal to n\n    return res - 1;\n}\n\n// Driver Code\nlet n = 11;\nconsole.log(floorSqrt(n));\n\n````\n\n\n\n\n**Output**\n```\n3\n```\n### [Expected Approach] Using Binary Search \u2013 O(logn) Time and O(1) Space\n\n> The square root of an integer follows a\n>\n> ****monotonic****\n> pattern, because as we\n>\n> ****increase****\n> any number, it\u2019s square also\n>\n> ****increases****\n> . If the square of a number is\n>\n> ****greater****\n> than given integer, then square root will definitely exist\n>\n> ****before****\n> this number. Conversely, if the square of a number is\n>\n> ****less****\n> than or\n>\n> ****equal****\n> to\n>\n> ****n****\n> , then either this number is the square root or it lies after this number.\n>\n>\n>\n> Therefore, we can use\n>\n> [binary search](https://www.geeksforgeeks.org/binary-search/)\n> to find the square root of n. I\n>\n> ****nitial search****\n> space will be 1 to the given integer itself, because square root of any positive integer always exists within this range.\n\n\n\n\n\n\n\n\n\n\n\n\nC++\n\n````\n// C++ program to find the square root of given integer\n// using binary search\n\n#include <iostream>\nusing namespace std;\n\nint floorSqrt(int n) {\n\n    // Initial search space\n    int lo = 1, hi = n;\n    int res = 1;\n\n    while(lo <= hi) {\n        int mid = lo + (hi - lo)/2;\n\n        // If square of mid is less than or equal to n\n        // update the result and search in upper half\n        if(mid*mid <= n) {\n            res = mid;\n            lo = mid + 1;\n        }\n\n        // If square of mid exceeds n,\n          // search in the lower half\n        else {\n            hi = mid - 1;\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    int n = 11;\n    cout << floorSqrt(n);\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find the square root of given integer\n// using binary search\n\n#include <stdio.h>\n\nint floorSqrt(int n) {\n\n    // Initial search space\n    int lo = 1, hi = n;\n    int res = 1;\n\n    while (lo <= hi) {\n        int mid = lo + (hi - lo) / 2;\n\n        // If square of mid is less than or equal to n\n        // update the result and search in upper half\n        if (mid * mid <= n) {\n            res = mid;\n            lo = mid + 1;\n        }\n\n        // If square of mid exceeds n,\n        // search in the lower half\n        else {\n            hi = mid - 1;\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    int n = 11;\n    printf(\"%d\", floorSqrt(n));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find the square root of given integer\n// using binary search\n\nclass GfG {\n\n    static int floorSqrt(int n) {\n\n        // Initial search space\n        int lo = 1, hi = n;\n        int res = 1;\n\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n\n            // If square of mid is less than or equal to n\n            // update the result and search in upper half\n            if (mid * mid <= n) {\n                res = mid;\n                lo = mid + 1;\n            }\n\n            // If square of mid exceeds n,\n            // search in the lower half\n            else {\n                hi = mid - 1;\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int n = 11;\n        System.out.println(floorSqrt(n));\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to find the square root of given integer\n# using binary search\n\ndef floorSqrt(n):\n\n    # Initial search space\n    lo = 1\n    hi = n\n    res = 1\n\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n\n        # If square of mid is less than or equal to n\n        # update the result and search in upper half\n        if mid * mid <= n:\n            res = mid\n            lo = mid + 1\n\n        # If square of mid exceeds n,\n        # search in the lower half\n        else:\n            hi = mid - 1\n\n    return res\n\nif __name__ == \"__main__\":\n    n = 11\n    print(floorSqrt(n))\n\n````\n\nC#\n\n````\n// C# program to find the square root of given integer\n// using binary search\n\nusing System;\n\nclass GfG {\n\n    static int floorSqrt(int n) {\n\n        // Initial search space\n        int lo = 1, hi = n;\n        int res = 1;\n\n        while (lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n\n            // If square of mid is less than or equal to n\n            // update the result and search in upper half\n            if (mid * mid <= n) {\n                res = mid;\n                lo = mid + 1;\n            }\n\n            // If square of mid exceeds n,\n            // search in the lower half\n            else {\n                hi = mid - 1;\n            }\n        }\n\n        return res;\n    }\n\n    static void Main() {\n        int n = 11;\n        Console.WriteLine(floorSqrt(n));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// JavaScript program to find the square root of given integer\n// using binary search\n\nfunction floorSqrt(n) {\n\n    // Initial search space\n    let lo = 1, hi = n;\n    let res = 1;\n\n    while (lo <= hi) {\n        let mid = lo + Math.floor((hi - lo) / 2);\n\n        // If square of mid is less than or equal to n\n        // update the result and search in upper half\n        if (mid * mid <= n) {\n            res = mid;\n            lo = mid + 1;\n        }\n\n        // If square of mid exceeds n,\n        // search in the lower half\n        else {\n            hi = mid - 1;\n        }\n    }\n\n    return res;\n}\n\nlet n = 11;\nconsole.log(floorSqrt(n));\n\n````\n\n\n\n\n**Output**\n```\n3\n```\n### [Alternate Approach] Using Built In functions \u2013 O(logn) Time and O(1) Space\n\n\nWe can directly use built in functions to find square root of an integer.\n\n\nC++\n\n````\n// C++ program to find the square root of given\n// integer using built in square root function\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint floorSqrt(int n) {\n\n      // Square root using sqrt function, it returns\n      // the double value, which is casted to integer\n      int res = sqrt(n);\n      return res;\n}\n\nint main() {\n    int n = 11;\n    cout << floorSqrt(n);\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find the square root of given\n// integer using built in square root function\n\n#include <stdio.h>\n#include <math.h>\n\nint floorSqrt(int n) {\n\n    // Square root using sqrt function, it returns\n    // the double value, which is casted to integer\n    int res = sqrt(n);\n    return res;\n}\n\nint main() {\n    int n = 11;\n    printf(\"%d\", floorSqrt(n));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find the square root of given\n// integer using built in square root function\n\nclass GfG {\n\n    static int floorSqrt(int n) {\n\n        // Square root using sqrt function, it returns\n        // the double value, which is casted to integer\n        int res = (int)Math.sqrt(n);\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int n = 11;\n        System.out.println(floorSqrt(n));\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to find the square root of given\n# integer using built in square root function\n\nimport math\n\ndef floorSqrt(n):\n\n    # Square root using sqrt function, it returns\n    # the double value, which is casted to integer\n    res = int(math.sqrt(n))\n    return res\n\nif __name__ == \"__main__\":\n    n = 11\n    print(floorSqrt(n))\n\n````\n\nC#\n\n````\n// C# program to find the square root of given\n// integer using built in square root function\n\nusing System;\n\nclass GfG {\n\n    static int floorSqrt(int n) {\n\n        // Square root using sqrt function, it returns\n        // the double value, which is casted to integer\n        int res = (int)Math.Sqrt(n);\n        return res;\n    }\n\n    static void Main() {\n        int n = 11;\n        Console.WriteLine(floorSqrt(n));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// JavaScript program to find the square root of given\n// integer using built in square root function\n\nfunction floorSqrt(n) {\n\n    // Square root using sqrt function, it returns\n    // the double value, which is casted to integer\n    let res = Math.floor(Math.sqrt(n));\n    return res;\n}\n\nlet n = 11;\nconsole.log(floorSqrt(n));\n\n````\n\n\n\n\n**Output**\n```\n3\n```\n### [Alternate Approach] Using Formula Used by Pocket Calculators \u2013 O(1) Time and O(1) Space\n\n[Pocket calculator](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Exponential_identity)\nuses the mathematical formula\n\n****\u221an = e****\n****1/2 \\* ln(n)****\nto compute the square root of an integer n. Below is mathematical proof of this formula:\n\n\n> Let\u2019s say square root of n is x:\n>\n>\n>\n> ****x = \u221an****\n>\n>\n> Squaring both the sides:\n>\n>\n>\n> x\n>\n> 2 =\n> n\n>\n>\n>\n> Taking log on both the sides:\n>\n>\n>\n> => ln(x\n>\n> 2\n> ) = ln(n)\n>\n>\n>\n> => 2\\*ln(x) = ln(n)\n>\n>\n>\n> => ln(x) = 1/2 \\* ln(n)\n>\n>\n>\n> To isolate x, exponentiate both sides with base e:\n>\n>\n>\n> => x = e\n>\n> 1/2 \\* ln(n)\n>\n>\n> x is the square root of n:\n>\n>\n>\n> ****\u221an****\n> = e\n>\n> 1/2 \\* ln(n)\n\n\nBecause of the way computations are done in computers in case of decimals, the result from the expression may be slightly less than the actual square root. Therefore, we will also consider the\n\n****next integer****\nafter the calculated result as a potential answer.\n\n\nC++\n\n````\n// C++ program to find the square root of given integer\n// using mathematical formula\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint floorSqrt(int n) {\n\n      // Calculating square root using mathematical formula\n    int res = exp(0.5 * log(n));\n\n    // If square of  res + 1 is less than or equal to n\n      // then, it will be our answer\n    if ((res + 1) * (res + 1) <= n) {\n        res++;\n    }\n\n    return res;\n}\n\nint main() {\n    int n = 11;\n    cout << floorSqrt(n);\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find the square root of given integer\n// using mathematical formula\n\n#include <stdio.h>\n#include <math.h>\n\nint floorSqrt(int n) {\n\n    // Calculating square root using mathematical formula\n    int res = exp(0.5 * log(n));\n\n    // If square of res + 1 is less than or equal to n\n    // then, it will be our answer\n    if ((res + 1) * (res + 1) <= n) {\n        res++;\n    }\n\n    return res;\n}\n\nint main() {\n    int n = 11;\n    printf(\"%d\", floorSqrt(n));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find the square root of given integer\n// using mathematical formula\n\nclass GfG {\n\n    static int floorSqrt(int n) {\n\n        // Calculating square root using mathematical formula\n        int res = (int)Math.exp(0.5 * Math.log(n));\n\n        // If square of res + 1 is less than or equal to n\n        // then, it will be our answer\n        if ((res + 1) * (res + 1) <= n) {\n            res++;\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int n = 11;\n        System.out.println(floorSqrt(n));\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to find the square root of given integer\n# using mathematical formula\n\nimport math\n\ndef floorSqrt(n):\n\n    # Calculating square root using mathematical formula\n    res = int(math.exp(0.5 * math.log(n)))\n\n    # If square of res + 1 is less than or equal to n\n    # then, it will be our answer\n    if (res + 1) ** 2 <= n:\n        res += 1\n\n    return res\n\nif __name__ == \"__main__\":\n    n = 11\n    print(floorSqrt(n))\n\n````\n\nC#\n\n````\n// C# program to find the square root of given integer\n// using mathematical formula\n\nusing System;\n\nclass GfG {\n\n    static int floorSqrt(int n) {\n\n        // Calculating square root using mathematical formula\n        int res = (int)Math.Exp(0.5 * Math.Log(n));\n\n        // If square of res + 1 is less than or equal to n\n        // then, it will be our answer\n        if ((long)(res + 1) * (res + 1) <= n) {\n            res++;\n        }\n\n        return res;\n    }\n\n    static void Main() {\n        int n = 11;\n        Console.WriteLine(floorSqrt(n));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// JavaScript program to find the square root of given integer\n// using mathematical formula\n\nfunction floorSqrt(n) {\n\n    // Calculating square root using mathematical formula\n    let res = Math.floor(Math.exp(0.5 * Math.log(n)));\n\n    // If square of res + 1 is less than or equal to n\n    // then, it will be our answer\n    if ((res + 1) * (res + 1) <= n) {\n        res++;\n    }\n\n    return res;\n}\n\nlet n = 11;\nconsole.log(floorSqrt(n));\n\n````\n\n\n\n\n**Output**\n```\n3\n\n```",
        "metadata": {
            "lesson_id": "ddbdf68b-6bcc-4c3f-8472-f24f5f5d1320",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "Given the number\n\n****n****\n(n >=0), find its\n\n[factorial](https://www.geeksforgeeks.org/factorial/)\n. Factorial of n is defined as 1 x 2 x \u2026 x n. For n = 0, factorial is 1. We are going to discuss iterative and recursive programs in this post.\n\n\n****Examples:****\n\n> ****Input****\n> : n = 5\n>\n>\n>\n> ****Output****\n> : 120\n>\n>\n>\n> ****Explanation****\n> : 5! = 5 \\* 4 \\* 3 \\* 2 \\* 1 = 120\n>\n>\n> ****Input****\n> : n = 4\n>\n>\n>\n> ****Output****\n> : 24\n>\n>\n>\n> ****Explanation****\n> : 4! = 4 \\* 3 \\* 2 \\* 1 = 24\n>\n>\n> ****Input****\n> : n = 0\n>\n>\n>\n> ****Output****\n> : 1\n>\n>\n> ****Input****\n> : n = 1\n>\n>\n>\n> ****Output****\n> : 1\n\n### ****Iterative Solution****\n\n\nThe idea is simple, we initialize result as 1. Then run a loop from 1 to n and multiply every number with n.\n\n\n\n> ****Illustration for n = 4****\n>\n>\n> Initialize res = 1\n>\n>\n>\n> Run a loop for i = 2 to 4\n>\n>\n>\n> i = 2 : res = res \\* 2 = 2\n>\n>\n>\n> i = 3 : res = res \\* 3 = 6\n>\n>\n>\n> i = 4 : res = res \\* 4 = 24\n\nC++\n\n````\n// C++ program for factorial of a number\n#include <iostream>\nusing namespace std;\n\n// function to find factorial of given number\nint factorial(int n)\n{\n    int res = 1;\n    for (int i = 2; i <= n; i++)\n        res *= i;\n    return res;\n}\n\n// Driver code\nint main()\n{\n    int num = 5;\n    cout << \"Factorial of \" << num << \" is \" << factorial(num) << endl;\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n\n// function to find factorial of given number\nint factorial(int n)\n{\n    int res = 1, i;\n    for (i = 2; i <= n; i++)\n        res *= i;\n    return res;\n}\n\nint main()\n{\n    int num = 5;\n    printf(\"Factorial of %d is %d\", num, factorial(num));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find factorial of given number\nclass GfG {\n\n    // Method to find factorial of the given number\n    static int factorial(int n)\n    {\n        int res = 1;\n        for (int i = 2; i <= n; i++)\n            res *= i;\n        return res;\n    }\n\n    // Driver method\n    public static void main(String[] args)\n    {\n        int num = 5;\n        System.out.println(\"Factorial of \" + num + \" is \"\n                           + factorial(5));\n    }\n}\n\n````\n\nPython\n\n````\n# Python 3 program to find\n# factorial of given number\ndef factorial(n):\n\n    res = 1\n\n    for i in range(2, n + 1):\n        res *= i\n    return res\n\n\n# Driver Code\nnum = 5\nprint(\"Factorial of\", num, \"is\", factorial(num))\n\n````\n\nC#\n\n````\n// C# program to find\n// factorial of given number\nusing System;\n\nclass Test {\n    // Method to find factorial\n    // of given number\n    static int factorial(int n)\n    {\n        int res = 1;\n\n        for (int i = 2; i <= n; i++)\n            res *= i;\n        return res;\n    }\n\n    // Driver method\n    public static void Main()\n    {\n        int num = 5;\n        Console.WriteLine(\"Factorial of \" + num + \" is \"\n                          + factorial(5));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// JavaScript program to find factorial of given number\n\n// Method to find factorial of the given number\nfunction factorial(n)\n{\n    let res = 1;\n    for (let i = 2; i <= n; i++)\n        res *= i;\n    return res;\n}\n\n// Driver method\nlet num = 5;\nconsole.log(\"Factorial of \" + num + \" is \" + factorial(5));\n\n````\n\nPHP\n\n````\n<?php\n// function to find factorial of given number\nfunction factorial($n)\n{\n    $res = 1;\n    for ($i = 2; $i <= $n; $i++) {\n        $res *= $i;\n    }\n    return $res;\n}\n\n// Driver code\n$num = 5;\necho \"Factorial of $num is \" . factorial($num) . \"\\n\";\n?>\n\n````\n\n\n\n\n**Output**\n```\nFactorial of 5 is 120\n\n```\n\n****Time Complexity:****\nO(n), since we are running a loop from 1 to n.\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n### ****Recursive Solution****\n\n\nLet us first see how we can break factorial(n) into smaller problem and then define recurrance.\n\n\n> * ****n!****\n>   = n \\* (n \u2013 1) \\* (n \u2013 2) \u2026. 2 \\* 1\n> * ****(n \u2013 1)!****\n>   = (n \u2013 1) \\* (n \u2013 2) \u2026 2 \\* 1\n>\n>\n> From the above two equations, we can say that n\n>\n> ****! = n \\* (n \u2013 1)!****\n>\n>\n>\n>\n> Since the problem can be broken down into The idea is to define a recursive function, say\n>\n> ****factorial(n)****\n> to calculate the\n>\n> [factorial](https://www.geeksforgeeks.org/factorial/)\n> of number\n>\n> ****n****\n> . According to the value of n, we can have two cases:\n>\n>\n> ****if****\n> n\n>\n> ****= 0 or n = 1 :****\n>\n>\n>\n> factorial(n) = 1\n>\n>\n>\n> ****Else****\n> :\n>\n>\n>\n> factorial(n) = n \\* factorial(n \u2013 1).\n\n****Illustration:****\n\n![factorial](https://media.geeksforgeeks.org/wp-content/uploads/20240924132748/factorial.webp)\n\n\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n// C++ program to find factorial of given number\n#include <iostream>\nusing namespace std;\n\n// Function to find factorial\n// of given number\nint factorial(int n)\n{\n    if (n == 0 || n == 1)\n        return 1;\n    return n * factorial(n - 1);\n}\n\n// Driver code\nint main()\n{\n    int num = 5;\n    cout << \"Factorial of \" << num << \" is \" << factorial(num) << endl;\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find factorial of given number\n#include <stdio.h>\n\n// function to find factorial of given number\nint factorial(int n)\n{\n    if (n == 0)\n        return 1;\n    return n * factorial(n - 1);\n}\n\nint main()\n{\n    int num = 5;\n    printf(\"Factorial of %d is %d\", num, factorial(num));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find factorial of given number\nclass Test {\n\n    // Method to find factorial of the given number\n    static int factorial(int n)\n    {\n        int res = 1, i;\n        for (i = 2; i <= n; i++)\n            res *= i;\n        return res;\n    }\n\n    // Driver method\n    public static void main(String[] args)\n    {\n        int num = 5;\n        System.out.println(\"Factorial of \" + num + \" is \"\n                           + factorial(5));\n    }\n}\n\n````\n\nPython\n\n````\n# Python 3 program to find\n# factorial of given number\ndef factorial(n):\n\n    if n == 0:\n        return 1\n\n    return n * factorial(n - 1)\n\n\n# Driver Code\nnum = 5\nprint(f\"Factorial of {num} is {factorial(num)}\")\n\n````\n\nC#\n\n````\n// C# program to find factorial\n// of given number\nusing System;\n\nclass Test {\n    // method to find factorial\n    // of given number\n    static int factorial(int n)\n    {\n        if (n == 0)\n            return 1;\n\n        return n * factorial(n - 1);\n    }\n\n    // Driver method\n    public static void Main()\n    {\n        int num = 5;\n        Console.WriteLine(\"Factorial of \" + num + \" is \"\n                          + factorial(5));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Javascript to find factorial\n// of given number\n\n// function to find factorial\n// of given number\nfunction factorial(n)\n{\n    if (n == 0)\n        return 1;\n    return n * factorial(n - 1);\n}\n\n// Driver Code\nlet num = 5;\nconsole.log(\"Factorial of \" + num + \" is \"\n            + factorial(num));\n\n````\n\nPHP\n\n````\n<?php\n// PHP program to find factorial\n// of given number\n\n// function to find factorial\n// of given number\nfunction factorial($n)\n{\n    if ($n == 0)\n        return 1;\n    return $n * factorial($n - 1);\n}\n\n    // Driver Code\n    $num = 5;\n    echo \"Factorial of \", $num, \" is \", factorial($num);\n\n?>\n\n````\n\n\n\n\n**Output**\n```\nFactorial of 5 is 120\n\n```\n\n****Time Complexity:****\nO(n), since the function is being called n times\n\n\n\n****Auxiliary Space:****\nO(n), In the worst case, the recursion stack space would be full with all the function calls waiting to get completed and that would make it an O(n) recursion stack space.\n\n\n****Which approach is better \u2013 iterative or recursive?****\n\n\nIterative approach is better as the recursive approach requires extra space for recursion call stack and overhead of recursion calls. However writing a recursive code is always a fun exercise.\n\n\n****How do we handle large numbers?****\n\n\nOne simple improvement that we can do is use long long in C/C++ and long in Java/C#, but that does not help much as factorials are really large numbers and causes overflow for small values. Please refer\n",
        "metadata": {
            "lesson_id": "d1958775-d3e0-4bf8-b656-d1136cdb0e05",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "\nGiven two positive numbers x and y, check if y is a power of x or not.\n\n\n**Examples :**\n\n> **Input:**\n> x = 10, y = 1\n>\n>\n> **Output:**\n> True\n>\n>\n> x^0 = 1\n>\n> **Input:**\n> x = 10, y = 1000\n>\n>\n> **Output:**\n> True\n>\n>\n> x^3 = 1\n>\n> **Input:**\n> x = 10, y = 1001\n>\n>\n> **Output:**\n> False\n\nRecommended Practice\n\n[Check if a number is power of another number](https://www.geeksforgeeks.org/problems/check-if-a-number-is-power-of-another-number5442/1/)\n\n\n[Try It!](https://www.geeksforgeeks.org/problems/check-if-a-number-is-power-of-another-number5442/1/)\n\n\nA simple solution is to repeatedly compute the powers of x. If a power becomes equal to y, then y is a power, else not.\n\nC++\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// C++ program to check if a number is power of\n// another number\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* Returns 1 if y is a power of x */\nbool isPower( int x, long int y)\n{\n// The only power of 1 is 1 itself\nif (x == 1)\nreturn (y == 1);\n\n// Repeatedly compute power of x\nlong int pow = 1;\nwhile ( pow < y)\npow *= x;\n\n// Check if power of x becomes y\nreturn ( pow == y);\n}\n\n/* Driver program to test above function */\nint main()\n{\ncout << isPower(10, 1) << endl;\ncout << isPower(1, 20) << endl;\ncout << isPower(2, 128) << endl;\ncout << isPower(2, 30) << endl;\nreturn 0;\n}\n```\n\n\n\n\n\nJava\n----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// Java program to check if a number is power of\n// another number\npublic class Test {\n// driver method to test power method\npublic static void main(String[] args)\n{\n// check the result for true/false and print.\nSystem.out.println(isPower( 10 , 1 ) ? 1 : 0 );\nSystem.out.println(isPower( 1 , 20 ) ? 1 : 0 );\nSystem.out.println(isPower( 2 , 128 ) ? 1 : 0 );\nSystem.out.println(isPower( 2 , 30 ) ? 1 : 0 );\n}\n/* Returns true if y is a power of x */\npublic static boolean isPower( int x, int y)\n{\n// The only power of 1 is 1 itself\nif (x == 1 )\nreturn (y == 1 );\n\n// Repeatedly compute power of x\nint pow = 1 ;\nwhile (pow < y)\npow = pow * x;\n\n// Check if power of x becomes y\nreturn (pow == y);\n}\n}\n\n// This code is contributed by Jyotsna.\n```\n\n\n\n\n\nPython3\n-------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n# python program to check\n# if a number is power of\n# another number\n\n# Returns true if y is a\n# power of x\ndef isPower (x, y):\n\n# The only power of 1\n# is 1 itself\nif (x = = 1 ):\nreturn (y = = 1 )\n\n# Repeatedly compute\n# power of x\npow = 1\nwhile ( pow < y):\npow = pow * x\n\n# Check if power of x\n# becomes y\nreturn ( pow = = y)\n\n\n# Driver Code\n# check the result for\n# true/false and print.\nif (isPower( 10 , 1 )):\nprint ( 1 )\nelse :\nprint ( 0 )\n\nif (isPower( 1 , 20 )):\nprint ( 1 )\nelse :\nprint ( 0 )\nif (isPower( 2 , 128 )):\nprint ( 1 )\nelse :\nprint ( 0 )\nif (isPower( 2 , 30 )):\nprint ( 1 )\nelse :\nprint ( 0 )\n\n# This code is contributed\n# by Sam007.\n```\n\n\n\n\n\nC#\n--\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// C# program to check if a number\n// is power of another number\nusing System;\n\nclass GFG\n{\n\n// Returns true if y is a power of x\npublic static bool isPower ( int x, int y)\n{\n// The only power of 1 is 1 itself\nif (x == 1)\nreturn (y == 1);\n\n// Repeatedly compute power of x\nint pow = 1;\nwhile (pow < y)\npow = pow * x;\n\n// Check if power of x becomes y\nreturn (pow == y);\n}\n\n// Driver Code\npublic static void Main ()\n{\n//check the result for true/false and print.\nConsole.WriteLine(isPower(10, 1) ? 1 : 0);\nConsole.WriteLine(isPower(1, 20) ? 1 : 0);\nConsole.WriteLine(isPower(2, 128) ? 1 : 0);\nConsole.WriteLine(isPower(2, 30) ? 1 : 0);\n}\n\n}\n\n// This code is contributed by Sam007\n```\n\n\n\n\n\nPHP\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n<?php\n// PHP program to check if a\n// number is power of another number\n\n/* Returns 1 if y is a power of x */\nfunction isPower( $x , $y )\n{\n// The only power of 1 is 1 itself\nif ( $x == 1)\nreturn ( $y == 1 ? 1 : 0);\n\n// Repeatedly comput power of x\n$pow = 1;\nwhile ( $pow < $y )\n$pow *= $x ;\n\n// Check if power of x becomes y\nreturn ( $pow == $y ? 1 : 0);\n}\n\n// Driver Code\necho isPower(10, 1) . \"\\n\" ;\necho isPower(1, 20) . \"\\n\" ;\necho isPower(2, 128) . \"\\n\" ;\necho isPower(2, 30) . \"\\n\" ;\n\n// This code is contributed by mits\n?>\n```\n\n\n\n\n\nJavascript\n----------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n<script>\n\n// JavaScript program to check if a number\n// is power of another number\n\n/* Returns true if y is a power of x */\nfunction isPower(x, y)\n{\n// The only power of 1 is 1 itself\nif (x == 1)\nreturn (y == 1);\n\n// Repeatedly compute power of x\nlet pow = 1;\nwhile (pow < y)\npow = pow * x;\n\n// Check if power of x becomes y\nreturn (pow == y);\n}\n\n\n// Driver Code\n\n//check the result for true/false and print.\ndocument.write((isPower(10, 1) ? 1 : 0) + \"<br/>\" );\ndocument.write((isPower(1, 20) ? 1 : 0) + \"<br/>\" );\ndocument.write((isPower(2, 128) ? 1 : 0) + \"<br/>\" );\ndocument.write((isPower(2, 30) ? 1 : 0) + \"<br/>\" );\n\n</script>\n```\n\n\n\n\n\n\n\n**Output**\n```\n1\n0\n1\n0\n```\n\n**Time complexity:**\nO(Log\nx\ny)\n\n\n**Auxiliary space:**\nO(1)\n\n**Optimization:**\n\n\nWe can optimize above solution to work in O(Log Log y). The idea is to do squaring of power instead of multiplying it with x, i.e., compare y with x^2, x^4, x^8, \u2026etc. If x becomes equal to y, return true. If x becomes more than y, then we do binary search for power of x between previous power and current power, i.e., between x^i and x^(i/2).\n\n\nFollowing are detailed step.\n\n```\n1) Initialize pow = x, i = 1\n2) while (pow < y)\n   {\n      pow = pow*pow\n      i *= 2\n   }\n3) If pow == y\n     return true;\n4) Else construct an array of powers\n   from x^i to x^(i/2)\n5) Binary Search for y in array constructed\n   in step 4. If not found, return false.\n   Else return true.\n```\n\n**Alternate Solution :**\n\n\nThe idea is to take log of y in base x. If it turns out to be an integer, we return true. Else false.\n\nC++\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// CPP program to check given number y\n// is power of x\n#include <iostream>\n#include <math.h>\nusing namespace std;\n\nbool isPower( int x, int y)\n{\n// logarithm function to calculate value\nfloat res1 = log (y) / log (x);\nreturn res1== floor (res1);\n}\n\n// Driven program\nint main()\n{\ncout << isPower(2, 128) << endl;\nreturn 0;\n}\n//This code is contributed by Anand Agarwal\n```\n\n\n\n\n\nJava\n----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// Java program to check given\n// number y is power of x\n\nclass GFG\n{\nstatic boolean isPower( int x,\nint y)\n{\n// logarithm function to\n// calculate value\nfloat res1 = ( float )(Math.log(y) /\nMath.log(x));\n\nreturn (res1% 1 == 0 );\n}\n\n// Driver Code\npublic static void main(String args[])\n{\nif (isPower( 2 , 128 ))\nSystem.out.println( \"1\" );\nelse\nSystem.out.println( \"0\" );\n}\n}\n\n// This code is contributed by Sam007\n// This code is Corrected by Anand Agarwal\n```\n\n\n\n\n\nPython3\n-------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n# Python program to check if given number y\n# is power of x\nimport math\n\ndef is_power(x, y):\n# logarithm function to calculate value\nres1 = math.log(y) / math.log(x)\nres2 = math.log(y) / math.log(x) # Note: this is float\n\n# compare to the result1 or result2 both are equal\nreturn res1 = = res2\n\n# Driven program\nif __name__ = = \"__main__\" :\nprint (is_power( 2 , 128 ))\n```\n\n\n\n\n\nC#\n--\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nusing System;\n\nnamespace ConsoleApp1\n{\nclass Program\n{\n\n// Function to check if a number is power of another number\nstatic bool IsPower( int x, int y)\n{\n\n// Use logarithm function to calculate the value\ndouble res1 = Math.Log(y) / Math.Log(x);\n\n// Note : this is double\ndouble res2 = Math.Log(y) / Math.Log(x);\n\n// Compare the result1 or result2, they should be equal\nreturn (res1 == res2);\n}\n\nstatic void Main( string [] args)\n{\n// Check if 128 is power of 2\nif (IsPower(2, 128))\nConsole.WriteLine( \"1\" );\nelse\nConsole.WriteLine( \"0\" );\n}\n}\n}\n\n// This code is contributed by vinayetbi1.\n```\n\n\n\n\n\nPHP\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n<?php\n// PHP program to check\n// given number y\nfunction isPower( $x , $y )\n{\n// logarithm function to\n// calculate value\n$res1 = log( $y ) / log( $x );\n\n// Note : this is double\n$res2 = log( $y ) / log( $x );\n\n// compare to the result1 or\n// result2 both are equal\nreturn ( $res1 == $res2 );\n}\n\n// Driver Code\necho isPower(2, 128) ;\n\n// This code is contributed by Sam007\n?>\n```\n\n\n\n\n\nJavascript\n----------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// JavaScript program to check given number y\n// is power of x\n\nfunction isPower(x, y) {\n// logarithm function to calculate value\nconst res1 = Math.log(y) / Math.log(x);\nconst res2 = Math.log(y) / Math.log(x);\n\n// compare to the result1 or result2 both are equal\nreturn (res1 === res2);\n}\n\n// Driven program\nconsole.log(isPower(2, 128));\n```\n\n\n\n\n\n\n\n**Output**\n```\n1\n```\n\n**Time complexity**\n: O(log Y)\n\n\n**Auxiliary space**\n: O(1)",
        "metadata": {
            "lesson_id": "770b0b45-edf6-4bc7-9880-e2727206798f",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "\nGiven a number\n\n****N****\n, print all numbers in the range from 1 to N having exactly 3 divisors.\n\n\n****Examples:****\n\n\n> ****Input:****\n> N = 16\n>\n>\n>\n> ****Output:****\n> 4 9\n>\n>\n>\n> ****Explanation****\n> : 4 and 9 have exactly three divisors.\n>\n>\n> ****Input:****\n> N = 49\n>\n>\n>\n> ****Output:****\n> 4 9 25 49\n>\n>\n>\n> ****Explanation:****\n> 4, 9, 25 and 49 have exactly three divisors.\n\nRecommended Practice\n\n[3 Divisors](https://practice.geeksforgeeks.org/problems/3-divisors3942/1)\n\n\n[Try It!](https://practice.geeksforgeeks.org/problems/3-divisors3942/1)\n\n\n****Mathematical approach to find Numbers with exactly 3 divisors:****\n----------------------------------------------------------------------\n\n\nTo solve the problem follow the below idea:\n\n\n> ****Idea:****\n> After having a close look at the examples mentioned above, you have noticed that all the required numbers are perfect squares and that too of only prime numbers.\n>\n>\n> ****Proof:****\n> Suppose the number is N, and it is a perfect square with square root X such that X is prime.\n>\n>\n> Now if we find the factors of N, it will always have following combinations:\n>\n>\n> * 1\\*N\n> * X\\*X\n>\n>\n> Therefore the required numbers will have only three numbers as their divisors:\n>\n>\n> * 1,\n> * that number itself, and\n> * just a single divisor in between 1 and the number.\n\n****Algorithm:****\nWe can generate all primes within a set using any sieve method efficiently and then we should take all primes i, such that\n\n****i\\*i <=N****\n.\n\n\nFollow the below steps to solve the problem:\n\n\n* Generate the prime numbers from 1 to N using any sieve method efficiently\n* Print all the prime numbers(X) between 1 to N, such as X\n\n  2\n  is less than or equal to N\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n// C++ program to print all\n// three-primes smaller than\n// or equal to N using Sieve\n// of Eratosthenes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Generates all primes upto N and\n// prints their squares\nvoid numbersWith3Divisors(int N)\n{\n    bool prime[N + 1];\n    memset(prime, true, sizeof(prime));\n    prime[0] = prime[1] = 0;\n\n    for (int p = 2; p * p <= N; p++) {\n        // If prime[p] is not changed,\n        // then it is a prime\n        if (prime[p] == true) {\n            // Update all multiples of p\n            for (int i = p * 2; i <= N; i += p)\n                prime[i] = false;\n        }\n    }\n\n    // Print squares of primes upto n.\n    cout << \"Numbers with 3 divisors :\\n\";\n    for (int i = 0; i * i <= N; i++)\n        if (prime[i])\n            cout << i * i << \" \";\n}\n\n// Driver code\nint main()\n{\n    int N = 96;\n\n    // Function call\n    numbersWith3Divisors(N);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to print all\n// three-primes smaller than\n// or equal to N using Sieve\n// of Eratosthenes\nimport java.io.*;\nimport java.util.*;\n\nclass GFG {\n\n    // Generates all primes upto N\n    // and prints their squares\n    static void numbersWith3Divisors(int N)\n    {\n        boolean[] prime = new boolean[N + 1];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n\n        for (int p = 2; p * p <= N; p++) {\n\n            // If prime[p] is not changed,\n            // then it is a prime\n            if (prime[p] == true) {\n                // Update all multiples of p\n                for (int i = p * 2; i <= N; i += p)\n                    prime[i] = false;\n            }\n        }\n\n        // print squares of primes upto n\n        System.out.println(\"Numbers with 3 divisors : \");\n        for (int i = 0; i * i <= N; i++)\n            if (prime[i])\n                System.out.print(i * i + \" \");\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        int N = 96;\n\n        // Function call\n        numbersWith3Divisors(N);\n    }\n}\n\n// Contributed by Pramod Kumar\n\n````\n\nPython\n\n````\n# Python3 program to print\n# all three-primes smaller than\n# or equal to n using Sieve\n# of Eratosthenes\n\n# Generates all primes upto n\n# and prints their squares\n\n\ndef numbersWith3Divisors(N):\n\n    prime = [True]*(N+1)\n    prime[0] = prime[1] = False\n    p = 2\n    while (p*p <= N):\n\n        # If prime[p] is not changed,\n        # then it is a prime\n        if (prime[p] == True):\n\n            # Update all multiples of p\n            for i in range(p*2, N+1, p):\n                prime[i] = False\n        p += 1\n\n    # print squares of primes upto n.\n    print(\"Numbers with 3 divisors :\")\n    i = 0\n    while (i*i <= N):\n        if (prime[i]):\n            print(i*i, end=\" \")\n        i += 1\n\n\n# Driver code\nif __name__ == \"__main__\":\n    N = 96\n\n    # Function call\n    numbersWith3Divisors(N)\n\n# This code is contributed by mits\n\n````\n\nC#\n\n````\n// C# program to print all\n// three-primes smaller than\n// or equal to n using Sieve\n// of Eratosthenes\n\nclass GFG {\n\n    // Generates all primes upto n\n    // and prints their squares\n    static void numbersWith3Divisors(int N)\n    {\n        bool[] prime = new bool[N + 1];\n        prime[0] = prime[1] = true;\n\n        for (int p = 2; p * p <= N; p++) {\n\n            // If prime[p] is not changed,\n            // then it is a prime\n            if (prime[p] == false) {\n                // Update all multiples of p\n                for (int i = p * 2; i <= N; i += p)\n                    prime[i] = true;\n            }\n        }\n\n        // print squares of primes upto n\n        System.Console.WriteLine(\n            \"Numbers with 3 divisors : \");\n        for (int i = 0; i * i <= N; i++)\n            if (!prime[i])\n                System.Console.Write(i * i + \" \");\n    }\n\n    // Driver code\n    public static void Main()\n    {\n        int N = 96;\n\n        // Function call\n        numbersWith3Divisors(N);\n    }\n}\n\n// This code is Contributed by mits\n\n````\n\nJavaScript\n\n````\n// Javascript program to print all\n    // three-primes smaller than\n    // or equal to n using Sieve\n    // of Eratosthenes\n\n    // Generates all primes upto n and\n    // prints their squares\n    function numbersWith3Divisors(n)\n    {\n        let prime = new Array(n+1);\n        prime.fill(true);\n        prime[0] = prime[1] = 0;\n\n        for (let p = 2; p*p <= n; p++)\n        {\n            // If prime[p] is not changed,\n            // then it is a prime\n            if (prime[p] == true)\n            {\n               // Update all multiples of p\n               for (let i = p*2; i <= n; i += p)\n                  prime[i] = false;\n            }\n        }\n\n        // print squares of primes upto n.\n        document.write(\"Numbers with 3 divisors :\" + \"</br>\");\n        for (let i = 0;  i*i <= n ; i++)\n            if (prime[i])\n              document.write(i*i + \" \");\n    }\n\n    // sieve();\n    let n = 96;\n    numbersWith3Divisors(n);\n\n     // This code is contributed by mukesh07.\n\n````\n\nPHP\n\n````\n<?php\n// PHP program to print all three-primes\n// smaller than or equal to n using Sieve\n// of Eratosthenes\n\n// Generates all primes upto n and\n// prints their squares\nfunction numbersWith3Divisors($N)\n{\n    $prime = array_fill(0, $N + 1, true);\n    $prime[0] = $prime[1] = false;\n\n    for ($p = 2; $p * $p <= $N; $p++)\n    {\n        // If prime[p] is not changed,\n        // then it is a prime\n        if ($prime[$p] == true)\n        {\n        // Update all multiples of p\n        for ($i = $p * 2; $i <= $N; $i += $p)\n            $prime[$i] = false;\n        }\n    }\n\n    // print squares of primes upto n.\n    echo \"Numbers with 3 divisors :\\n\";\n    for ($i = 0; $i * $i <= $N ; $i++)\n        if ($prime[$i])\n        echo $i * $i . \" \";\n}\n\n// Driver Code\n$N = 96;\n\n// Function call\nnumbersWith3Divisors($N);\n\n// This code is contributed by mits\n?>\n\n````\n\n\n\n\n**Output**\n```\nNumbers with 3 divisors :\n4 9 25 49\n```\n\n****Time Complexity:****\nO(N\\*log(log(N)))\n\n\n\n****Auxiliary Space:****\nO(N)\n\n\n****Numbers with exactly 3 divisors using constant space:****\n-------------------------------------------------------------\n\n> Run a loop from 2 to sqrt(N) and check if the current element is prime or not, if it is so then print that number, but this method will increase the time complexity of the solution\n\n\nFollow the below steps to solve the problem:\n\n\n* Start a loop for integer\n\n  ****i****\n  from\n\n  ****2****\n  to\n\n  ****N.****\n* Check if\n\n  ****i****\n  is prime or not, which can be done easily using the\n\n  [****isPrime(n)****](https://www.geeksforgeeks.org/prime-numbers)\n\n  method.\n* If\n\n  ****i****\n  is prime, check if its square is less than or equal to the given number. This will be reviewed only for squares of prime numbers, therefore reducing the number of checks.\n* If the above condition is satisfied, the number will be printed and the loop will continue till\n\n  ****i <= n.****\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n// C++ program to print all\n// three-primes smaller than\n// or equal to n without using\n// extra space\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid numbersWith3Divisors(int);\nbool isPrime(int);\n\n// Generates all primes upto n and\n// prints their squares\nvoid numbersWith3Divisors(int N)\n{\n    cout << \"Numbers with 3 divisors : \" << endl;\n\n    for (int i = 2; i * i <= N; i++) {\n\n        // Check prime\n        if (isPrime(i)) {\n                // Print numbers in\n                // the order of\n                // occurrence\n                cout << i * i << \" \";\n        }\n    }\n}\n\n// Check if a number is prime or not\nbool isPrime(int N)\n{\n    for (int i = 2; i * i <= N; i++) {\n        if (N % i == 0)\n            return false;\n    }\n    return true;\n}\n\n// Driver code\nint main()\n{\n    int N = 122;\n\n    // Function call\n    numbersWith3Divisors(N);\n\n    return 0;\n}\n\n// This code is contributed by vishu2908\n\n````\n\nJava\n\n````\n// Java program to print all\n// three-primes smaller than\n// or equal to N without using\n// extra space\nimport java.util.*;\n\nclass GFG {\n\n    // 3 divisor logic implementation\n    // check if a number is\n    // prime or not\n    // if it is a prime then\n    // check if its square\n    // is less than or equal to\n    // the given number\n    static void numbersWith3Divisors(int N)\n    {\n        System.out.println(\"Numbers with 3 divisors : \");\n\n        for (int i = 2; i * i <= N; i++) {\n\n            // Check prime\n            if (isPrime(i)) {\n                    // Print numbers in\n                    // the order of\n                    // occurrence\n                    System.out.print(i * i + \" \");\n            }\n        }\n    }\n\n    // Check if a number is prime or not\n    public static boolean isPrime(int N)\n    {\n        for (int i = 2; i * i <= N; i++) {\n            if (N % i == 0)\n                return false;\n        }\n        return true;\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        int N = 122;\n\n        // Function call\n        numbersWith3Divisors(N);\n    }\n}\n\n// Contributed by Parag Pallav Singh\n\n````\n\nPython\n\n````\n# Python3 program to print all\n# three-primes smaller than\n# or equal to N without using\n# extra space\n\n# 3 divisor logic implementation\n# check if a number is  prime or\n# not if it is a prime then check\n# if its square is less than or\n# equal to the given number\n\n\ndef numbersWith3Divisors(N):\n\n    print(\"Numbers with 3 divisors : \")\n\n    i = 2\n    while i * i <= N:\n\n        # Check prime\n        if (isPrime(i)):\n                # Print numbers in the order\n                # of occurrence\n                print(i * i, end=\" \")\n\n        i += 1\n\n# Check if a number is prime or not\n\n\ndef isPrime(N):\n\n    i = 2\n    while i * i <= N:\n        if N % i == 0:\n            return False\n\n        i += 1\n\n    return True\n\n\n# Driver code\nif __name__ == \"__main__\":\n    N = 122\n\n    # Function call\n    numbersWith3Divisors(N)\n\n# This code is contributed by divyesh072019\n\n````\n\nC#\n\n````\n// C# program to print all\n// three-primes smaller than\n// or equal to N without using\n// extra space\nusing System;\n\nclass GFG {\n\n    // 3 divisor logic implementation\n    // check if a number is prime or\n    // not if it is a prime then check\n    // if its square is less than or\n    // equal to the given number\n    static void numbersWith3Divisors(int N)\n    {\n        Console.WriteLine(\"Numbers with 3 divisors : \");\n\n        for (int i = 2; i * i <= N; i++) {\n\n            // Check prime\n            if (isPrime(i)) {\n                    // Print numbers in the order\n                    // of occurrence\n                    Console.Write(i * i + \" \");\n            }\n        }\n    }\n\n    // Check if a number is prime or not\n    public static bool isPrime(int N)\n    {\n        for (int i = 2; i * i <= N; i++) {\n            if (N % i == 0)\n                return false;\n        }\n        return true;\n    }\n\n    // Driver code\n    static void Main()\n    {\n        int N = 122;\n\n        // Function call\n        numbersWith3Divisors(N);\n    }\n}\n\n// This code is contributed by divyeshrabadiya07\n\n````\n\nJavaScript\n\n````\n// Javascript program to print all\n    // three-primes smaller than\n    // or equal to n without using\n    // extra space\n\n      // 3 divisor logic implementation\n    // check if a number is prime or\n    // not if it is a prime then check\n    // if its square is less than or\n    // equal to the given number\n    function numbersWith3Divisors(n)\n    {\n        document.write(\"Numbers with 3 divisors : \");\n\n        for(let i = 2; i * i <= n; i++)\n        {\n\n            // Check prime\n            if (isPrime(i))\n            {\n                    // Print numbers in the order\n                    // of occurrence\n                    document.write(i * i + \" \");\n            }\n        }\n    }\n\n    // Check if a number is prime or not\n    function isPrime(n)\n    {\n        if (n == 0 || n == 1)\n            return false;\n\n        for(let i = 2; i * i <= n; i++)\n        {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\n    let n = 122;\n\n    numbersWith3Divisors(n);\n\n// This code is contributed by suresh07.\n\n````\n\n\n\n\n**Output**\n```\nNumbers with 3 divisors :\n4 9 25 49 121\n```\n\n****Time Complexity:****\nO(sqrt N\n\n2\n)\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n",
        "metadata": {
            "lesson_id": "3346a2ba-c1c6-4b4f-bde7-37811686b1c0",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "\nA\n\n[****prime number****](https://www.geeksforgeeks.org/prime-numbers/)\nis a natural number greater than 1 that has exactly two factors:\n\n****1****\nand\n\n****itself****\n. This article explores the properties of prime numbers, various methods to check for primality, and related problems.\n\n\n> ****Input****\n> : n = 10\n>\n>\n>\n> ****Output****\n> : False\n>\n>\n>\n> 10 is divisible by 2 and 5\n>\n>\n> ****Input****\n> : n = 11\n>\n>\n>\n> ****Output****\n> : True\n>\n>\n>\n> 11 is divisible by 1 and 11 only\n>\n>\n> ****Input****\n> : n = 1\n>\n>\n>\n> ****Output****\n> : False\n>\n>\n>\n> [1 is neither composite nor prime](https://www.geeksforgeeks.org/is-1-a-prime-number-or-a-composite-number/)\n>\n> ****Input****\n> : n = 0\n>\n>\n>\n> ****Output****\n> : False\n>\n>\n>\n> [0 is neither composite nor prime](https://www.geeksforgeeks.org/is-0-a-prime-number/)\n\nTable of Content\n\n* [Different Methods to Check for Prime Number](#what-is-prime-number)\n\n+ [[Naive Approach] Basic Trial Division Method \u2013 O(n) time and O(1) space](#naive-approach-basic-trial-division-method)\n+ [[Efficient Approach \u2013 1] Trial Division Method \u2013 O(\u221an) time and O(1) space](#efficient-approach-1-trial-division-method)\n+ [[Expected Approach \u2013 2] Optimized Trial Division Method \u2013 O(\u221an) time and O(1) space](#expected-approach-2-optimized-trial-division-method)\n\n* [Primality Testing Methods](#primality-testing-methods)\n* [Sieve Algorithms for Prime Number Generation](#sieve-algorithms-for-prime-number-generation)\n* [Prime Number Algorithms and Related Problems](#prime-number-algorithms-and-related-problems)\n\nDifferent Methods to Check for Prime Number\n-------------------------------------------\n\n\nTo check if a number is prime, we can use the key property of prime numbers that is, a prime number has exactly two factors, 1 and itself. If a number has more than two factors, it is not considered prime. There are several approaches to check if a number is prime, each varying in complexity and efficiency. Lets explore these approaches one by one.\n\n\n\n### [Naive Approach] Basic Trial Division Method \u2013 O(n) time and O(1) space\n\n> The simplest method to check if a number\n>\n> ****n****\n> is prime by checking every number from\n>\n> ****2****\n> to\n>\n> ****n-1.****\n> If the number\n>\n> ****n****\n> is divisible by any of these, it\u2019s not prime.\n\n\nStep-by-step approach:\n\n\n* If\n\n  ****n****\n  is less than 2, return\n\n  ****false****\n  (0 and 1 are not prime).\n* Loop through numbers from\n\n  ****2****\n  to\n\n  ****n-1.****\n  + If\n\n    ****n****\n    is divisible by any of these numbers, return\n\n    ****false****\n    .\n* If no divisors are found, return\n\n  ****true****\n  .\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n#include <iostream>\nusing namespace std;\n\n// Function to check whether a number is prime or not\nbool isPrime(int n) {\n    if (n <= 1)\n        return false;\n\n    // Check divisibility from 2 to n-1\n    for (int i = 2; i < n; i++)\n        if (n % i == 0)\n            return false;\n\n    return true;\n}\n\nint main() {\n    int n = 11;\n    cout << isPrime(n);\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdbool.h>\n\n// Function to check whether a number is prime or not\nbool isPrime(int n) {\n    if (n <= 1)\n        return false;\n\n    // Check divisibility from 2 to n-1\n    for (int i = 2; i < n; i++)\n        if (n % i == 0)\n            return false;\n\n    return true;\n}\n\nint main() {\n    int n = 11;\n    printf(\"%d\", isPrime(n));\n    return 0;\n}\n\n````\n\nJava\n\n````\npublic class GfG {\n\n    // Function to check whether a number is prime or not\n    static boolean isPrime(int n) {\n        if (n <= 1)\n            return false;\n\n        // Check divisibility from 2 to n-1\n        for (int i = 2; i < n; i++)\n            if (n % i == 0)\n                return false;\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int n = 11;\n        System.out.println(isPrime(n));\n    }\n}\n\n````\n\nPython\n\n````\n# Function to check whether a number is prime or not\ndef is_prime(n):\n    if n <= 1:\n        return False\n\n    # Check divisibility from 2 to n-1\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n\n    return True\n\nn = 11\nprint(is_prime(n))\n\n````\n\nC#\n\n````\nusing System;\n\nclass GfG {\n    // Function to check whether a number is prime or not\n    static bool IsPrime(int n) {\n        if (n <= 1)\n            return false;\n\n        // Check divisibility from 2 to n-1\n        for (int i = 2; i < n; i++)\n            if (n % i == 0)\n                return false;\n\n        return true;\n    }\n\n    static void Main(string[] args) {\n        int n = 11;\n        Console.WriteLine(IsPrime(n));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Function to check whether a number is prime or not\nfunction isPrime(n) {\n    if (n <= 1)\n        return false;\n\n    // Check divisibility from 2 to n-1\n    for (let i = 2; i < n; i++)\n        if (n % i === 0)\n            return false;\n\n    return true;\n}\n\nlet n = 11;\nconsole.log(isPrime(n));\n\n````\n\n\n\n\n**Output**\n```\n1\n```\n\n****Time Complexity:****\nO(n)\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n### [Efficient Approach \u2013 1] Trial Division Method \u2013 O(\u221an) time and O(1) space\n\n> There is an observation that if we take any number\n>\n> ****n****\n> and find its divisors then divisors would appear in pairs. For example, if\n>\n> ****4****\n> is a divisor of\n>\n> ****28****\n> , then\n>\n> ****28/4=7****\n> is also a divisor. So we have the pair (4,7).\n>\n>\n> This means that for any divisor\n>\n> ****d****\n> of\n>\n> ****n****\n> , there is a corresponding divisor\n>\n> ****n/d****\n> . If\n>\n> ****d****\n> is less than or equal to the\n>\n> ****\u221an****\n> , then\n>\n> ****n/d****\n> will be greater than or equal to the\n>\n> ****\u221an****\n> . Therefore, we only need to check for divisors up to the\n>\n> ****\u221an****\n> . If\n>\n> ****n****\n> has a divisor larger than its square root, the paired divisor must be smaller than the square root, which we would have already checked.\n\n\nFor example, if\n\n****n = 36****\n, its square root is\n\n****6****\n. The divisors are\n\n****1,2,3,4,6,9,12,18,36****\n. We only need to check\n\n****1,2,3,4,6****\nbecause any larger divisor will have a smaller paired divisor that we\u2019ve already checked.\n\n\nBelow is the implementation of the above approach:\n\n\nC++14\n\n````\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n// Function to check whether a number is prime or not\nbool isPrime(int n) {\n\n    // Numbers less than or equal to 1 are not prime\n    if (n <= 1)\n        return false;\n\n    // Check divisibility from 2 to the square root of n\n    for (int i = 2; i <= sqrt(n); i++)\n        if (n % i == 0)\n            return false;\n\n    // If no divisors were found, n is prime\n    return true;\n}\n\nint main() {\n    int n = 11;\n    cout << isPrime(n);\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n\n// Function to check whether a number is prime or not\nbool isPrime(int n) {\n    // Numbers less than or equal to 1 are not prime\n    if (n <= 1)\n        return false;\n\n    // Check divisibility from 2 to the square root of n\n    for (int i = 2; i <= sqrt(n); i++)\n        if (n % i == 0)\n            return false;\n\n    // If no divisors were found, n is prime\n    return true;\n}\n\nint main() {\n    int n = 11;\n    printf(\"%d\", isPrime(n));\n    return 0;\n}\n\n````\n\nJava\n\n````\nclass Main {\n\n    // Function to check whether a number is prime or not\n    static boolean isPrime(int n) {\n\n        // Numbers less than or equal to 1 are not prime\n        if (n <= 1)\n            return false;\n\n        // Check divisibility from 2 to the square root of n\n        for (int i = 2; i <= Math.sqrt(n); i++)\n            if (n % i == 0)\n                return false;\n\n        // If no divisors were found, n is prime\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int n = 11;\n        System.out.println(isPrime(n));\n    }\n}\n\n````\n\nPython\n\n````\nimport math\n\n# Function to check whether a number is prime or not\ndef is_prime(n):\n\n    # Numbers less than or equal to 1 are not prime\n    if n <= 1:\n        return False\n\n    # Check divisibility from 2 to the square root of n\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n\n    # If no divisors were found, n is prime\n    return True\n\nn = 11\nprint(is_prime(n))\n\n````\n\nC#\n\n````\nusing System;\n\nclass GfG {\n    // Function to check whether a number is prime or not\n    static bool IsPrime(int n) {\n\n        // Numbers less than or equal to 1 are not prime\n        if (n <= 1)\n            return false;\n\n        // Check divisibility from 2 to the square root of n\n        for (int i = 2; i <= Math.Sqrt(n); i++)\n            if (n % i == 0)\n                return false;\n\n        // If no divisors were found, n is prime\n        return true;\n    }\n\n    static void Main(string[] args) {\n        int n = 11;\n        Console.WriteLine(IsPrime(n));\n    }\n}\n\n````\n\nJavascript\n\n````\n// Function to check whether a number is prime or not\nfunction isPrime(n) {\n\n    // Numbers less than or equal to 1 are not prime\n    if (n <= 1)\n        return false;\n\n    // Check divisibility from 2 to the square root of n\n    for (let i = 2; i <= Math.sqrt(n); i++)\n        if (n % i === 0)\n            return false;\n\n    // If no divisors were found, n is prime\n    return true;\n}\n\nlet n = 11;\nconsole.log(isPrime(n));\n\n````\n\n\n\n\n**Output**\n```\n1\n```\n\n****Time Complexity:****\nO(sqrt(n))\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n### [Expected Approach \u2013 2] Optimized Trial Division Method \u2013 O(\u221an) time and O(1) space\n\n> We know that any integer number can be written in the form of\n>\n> ****6k+i,****\n> where\n>\n> ****k****\n> is a nonnegative integer (like 0, 1, 2, 3,\u2026) and\n>\n> ****i****\n> is a number between 0 and 5 (so i can be 0, 1, 2, 3, 4, or 5). If we look closely, we\u2019ll notice that when\n>\n> ****i****\n> is 0, 2, 3, or 4, the numbers\n>\n> ****6k, 6k+2, 6k+3,****\n> and\n>\n> ****6k+4****\n> are all divisible by either 2 or 3. But prime numbers greater than\n>\n> ****3****\n> can\u2019t be divisible by\n>\n> ****2****\n> or\n>\n> ****3****\n> . Therefore, the only forms left that a prime number can have are\n>\n> ****6k+1****\n> or\n>\n> ****6k+5****\n> (since these forms are not divisible by 2 or 3).\n>\n>\n> Instead of checking every number up to the \u221an to see if it divides\n>\n> ****n****\n> , we only check numbers of the form\n>\n> ****6k+1****\n> and\n>\n> ****6k+5.****\n> This reduces the number of checks needed.\n\n\nStep-by-step approach:\n\n\n* Check if\n\n  ****n == 1****\n  or\n\n  ****n == 0****\n  then return\n\n  ****false****\n  .\n* Check if\n\n  ****n****\n  is\n\n  ****2****\n  or\n\n  ****3****\n  and return\n\n  ****true****\n  .\n* Check if\n\n  ****n****\n  is divisible by\n\n  ****2****\n  or\n\n  ****3****\n  and return\n\n  ****false****\n  .\n* Loop from\n\n  ****5****\n  to\n\n  ****\u221an****\n  \u200b, incrementing by\n\n  ****6****\n  .\n  + Checks if\n\n    ****n****\n    is divisible by\n\n    ****i****\n    (which corresponds to\n\n    ****6k+1****\n    ) or by\n\n    ****i+2****\n    (which corresponds to\n\n    ****6k+5****\n    ).\n* If no divisors are found, return\n\n  ****true****\n  .\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n// Function to check whether a number is prime or not\nbool isPrime(int n) {\n    // Check if n is 1 or 0\n    if (n <= 1)\n        return false;\n\n    // Check if n is 2 or 3\n    if (n == 2 || n == 3)\n        return true;\n\n    // Check whether n is divisible by 2 or 3\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n\n    // Check from 5 to square root of n\n    // Iterate i by (i+6)\n    for (int i = 5; i <= sqrt(n); i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;\n}\n\nint main() {\n    int n = 11;\n    cout << isPrime(n);\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n\n// Function to check whether a number is prime or not\nbool isPrime(int n) {\n    // Check if n is 1 or 0\n    if (n <= 1)\n        return false;\n\n    // Check if n is 2 or 3\n    if (n == 2 || n == 3)\n        return true;\n\n    // Check whether n is divisible by 2 or 3\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n\n    // Check from 5 to square root of n\n    // Iterate i by (i+6)\n    for (int i = 5; i <= sqrt(n); i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n\n    return true;\n}\n\nint main() {\n    int n = 11;\n    printf(\"%d\", isPrime(n));\n    return 0;\n}\n\n````\n\nJava\n\n````\nclass GfG {\n\n    // Function to check whether a number is prime or not\n    static boolean isPrime(int n) {\n        // Check if n is 1 or 0\n        if (n <= 1)\n            return false;\n\n        // Check if n is 2 or 3\n        if (n == 2 || n == 3)\n            return true;\n\n        // Check whether n is divisible by 2 or 3\n        if (n % 2 == 0 || n % 3 == 0)\n            return false;\n\n        // Check from 5 to square root of n\n        // Iterate i by (i+6)\n        for (int i = 5; i <= Math.sqrt(n); i = i + 6)\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int n = 11;\n        System.out.println(isPrime(n));\n    }\n}\n\n````\n\nPython\n\n````\nimport math\n\n# Function to check whether a number is prime or not\ndef is_prime(n):\n    # Check if n is 1 or 0\n    if n <= 1:\n        return False\n\n    # Check if n is 2 or 3\n    if n == 2 or n == 3:\n        return True\n\n    # Check whether n is divisible by 2 or 3\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    # Check from 5 to square root of n\n    # Iterate i by (i+6)\n    i = 5\n    while i <= math.sqrt(n):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n\n    return True\n\nn = 11\nprint(is_prime(n))\n\n````\n\nC#\n\n````\nusing System;\n\nclass Program {\n    // Function to check whether a number is prime or not\n    static bool IsPrime(int n) {\n        // Check if n is 1 or 0\n        if (n <= 1)\n            return false;\n\n        // Check if n is 2 or 3\n        if (n == 2 || n == 3)\n            return true;\n\n        // Check whether n is divisible by 2 or 3\n        if (n % 2 == 0 || n % 3 == 0)\n            return false;\n\n        // Check from 5 to square root of n\n        // Iterate i by (i+6)\n        for (int i = 5; i <= Math.Sqrt(n); i += 6)\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n\n        return true;\n    }\n\n    static void Main(string[] args) {\n        int n = 11;\n        Console.WriteLine(IsPrime(n));\n    }\n}\n\n````\n\nJavascript\n\n````\n// Function to check whether a number is prime or not\nfunction isPrime(n) {\n    // Check if n is 1 or 0\n    if (n <= 1)\n        return false;\n\n    // Check if n is 2 or 3\n    if (n === 2 || n === 3)\n        return true;\n\n    // Check whether n is divisible by 2 or 3\n    if (n % 2 === 0 || n % 3 === 0)\n        return false;\n\n    // Check from 5 to square root of n\n    // Iterate i by (i+6)\n    for (let i = 5; i <= Math.sqrt(n); i += 6)\n        if (n % i === 0 || n % (i + 2) === 0)\n            return false;\n\n    return true;\n}\n\nlet n = 11;\nconsole.log(isPrime(n));\n\n````\n\n\n\n\n**Output**\n```\n1\n```\n\n****Time Complexity:****\nO(sqrt(n))\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n****Primality Testing Methods****\n---------------------------------\n\n* [Primality Test | Set 1 (Introduction and School Method)](https://www.geeksforgeeks.org/primality-test-set-1-introduction-and-school-method/)\n* [Primality Test | Set 2 (Fermat Method)](https://www.geeksforgeeks.org/primality-test-set-2-fermet-method/)\n* [Primality Test | Set 3 (Miller\u2013Rabin)](https://www.geeksforgeeks.org/primality-test-set-3-miller-rabin/)\n* [Primality Test | Set 4 (Solovay-Strassen)](https://www.geeksforgeeks.org/primality-test-set-4-solovay-strassen/)\n* [Lucas Primality Test](https://www.geeksforgeeks.org/lucas-primality-test/)\n\nSieve Algorithms for Prime Number Generation\n--------------------------------------------\n\n* [Sieve of Eratosthenes](https://www.geeksforgeeks.org/sieve-of-eratosthenes/)\n* [Sieve of Eratosthenes in O(n) time complexity](https://www.geeksforgeeks.org/sieve-eratosthenes-0n-time-complexity/)\n* [Segmented Sieve](https://www.geeksforgeeks.org/segmented-sieve/)\n* [Sieve of Sundaram](https://www.geeksforgeeks.org/sieve-sundaram-print-primes-smaller-n/)\n* [Bitwise Sieve](https://www.geeksforgeeks.org/bitwise-sieve/)\n\n\nFor more related article on Sieve algorithms , please refer to\n\n[Recent Articles on Sieve](https://www.geeksforgeeks.org/tag/sieve/)\n\n\n****Prime Number Algorithms and Related Problems****\n----------------------------------------------------\n\n* [Find two distinct prime numbers with](https://www.geeksforgeeks.org/find-two-distinct-prime-numbers-with-given-product/)\n  a\n\n  [given product](https://www.geeksforgeeks.org/find-two-distinct-prime-numbers-with-given-product/)\n* [Print all prime numbers less than or equal to N](https://www.geeksforgeeks.org/print-all-prime-numbers-less-than-or-equal-to-n/)\n* [Recursive program for prime number](https://www.geeksforgeeks.org/recursive-program-prime-number/)\n* [Find two prime numbers with](https://www.geeksforgeeks.org/find-two-prime-numbers-with-given-sum/)\n  a\n\n  [given sum](https://www.geeksforgeeks.org/find-two-prime-numbers-with-given-sum/)\n* [Find the highest occurring digit in prime numbers in a range](https://www.geeksforgeeks.org/find-highest-occurring-digit-prime-numbers-range/)\n* [Prime Factorization using Sieve O(log n) for multiple queries](https://www.geeksforgeeks.org/prime-factorization-using-sieve-olog-n-multiple-queries/)\n* [Program to print all prime factors of a given number](https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/)\n* [Least prime factor of numbers till n](https://www.geeksforgeeks.org/least-prime-factor-of-numbers-till-n/)\n* [Prime factors of LCM of array elements](https://www.geeksforgeeks.org/prime-factors-lcm-array-elements/)\n* [Program for Goldbach\u2019s Conjecture](https://www.geeksforgeeks.org/program-for-goldbachs-conjecture-two-primes-with-given-sum/)\n* [Prime numbers and Fibonacci](https://www.geeksforgeeks.org/prime-numbers-fibonacci/)\n* [Composite Number](https://www.geeksforgeeks.org/composite-number/)\n\n\nFor more related problems on prime number, please refer to\n\n\n[Recent Articles on Prime Numbers](https://www.geeksforgeeks.org/tag/prime-number/)\n\n  ",
        "metadata": {
            "lesson_id": "723f7734-7503-4850-8863-e4f4887152a7",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "Given a number\n\n****n****\n, find the sum of its digits.\n\n\n****Examples :****\n\n> ****Input:****\n> n = 687\n>\n>\n>\n> ****Output:****\n> 21\n>\n>\n>\n> ****Explanation:****\n> **The sum of its digits are: 6 + 8 + 7 = 21**\n>\n> ****Input:****\n> n = 12\n>\n>\n>\n> ****Output:****\n> 3\n>\n>\n>\n> ****Explanation:****\n> **The sum of its digits are: 1 + 2 = 3**\n\nTable of Content\n\n* [[Expected Approach] Sum of the digits of a given number using recursion](#expected-approach-sum-of-the-digits-of-a-given-number-using-recursion)\n* [[Alternate Approach] Sum of the digits of a given number using tail recursion](#alternate-approach-sum-of-the-digits-of-a-given-number-using-tail-recursion)\n* [[Alternate Approach] Converting Number to String](#sum-of-the-digits-of-a-given-number-with-input-as-string)\n### ****[Expected Approach] Sum of the digits using recursion****\n\n> **The idea is to count the digits by removing the digits from the input number starting from**\n> ****right(least significant digit)****\n> **to**\n> ****left(most significant digit)****\n> **till the number is reduced to 0 because the rightmost digit can be removed simply by performing**\n> ****integer division by 10****\n> **. For eg: n = 1567, then 1567 / 10 = 156.7 = 156(Integer Division).**\n\nC++\n\n````\n#include <iostream>\nusing namespace std;\n\nint sumDigits(int no) {\n    if (no == 0) {\n        return 0;\n    }\n\n    return (no % 10) + sumDigits(no / 10);\n}\n\nint main(void) {\n    cout << sumDigits(687);\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n\nint sumDigits(int no) {\n    if (no == 0) {\n        return 0;\n    }\n\n    return (no % 10) + sumDigits(no / 10);\n}\n\nint main() {\n    printf(\"%d\", sumDigits(687));\n    return 0;\n}\n\n````\n\nJava\n\n````\nimport java.io.*;\n\nclass GfG {\n    static int sumDigits(int no) {\n        if (no == 0) {\n            return 0;\n        }\n\n        return (no % 10) + sumDigits(no / 10);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(sumDigits(687));\n    }\n}\n\n````\n\nPython\n\n````\ndef sumDigits(no):\n\n    return 0 if no == 0 else int(no % 10) + sumDigits(int(no/10))\n\nif __name__ == \"__main__\":\n\n    print(sumDigits(687))\n\n````\n\nC#\n\n````\nusing System;\n\n class GfG {\n\n    static int sumDigits(int n) {\n        return n == 0 ? 0 : n % 10 + sumDigits(n / 10);\n    }\n\n  static void  Main() {\n        Console.Write(sumDigits(687));\n    }\n}\n\n````\n\nJavaScript\n\n````\n\n  function sumDigits(no) {\n       if(no == 0){\n         return 0 ;\n       }\n\n      return (no % 10) + sumDigits(parseInt(no/10)) ;\n  }\n\n// Driver code\n      console.log(sumDigits(687));\n\n\n````\n\n\n\n\n**Output**\n```\n21\n```\n\n****Time Complexity:****\nO(log n)\n\n\n\n****Auxiliary Space:****\nO(log n)\n\n\n### ****[Alternate Approach] Using tail recursion****\n\n> This approach ensures that the recursive call is the last operation, allowing for better memory efficiency and preventing stack overflow.\n\nC++\n\n````\n// C++ program for the above approach\n#include <bits/stdc++.h>\nusing namespace std;\n\nint sumOfDigit(int n, int val) {\n    if (n < 10) {\n        val = val + n;\n        return val;\n    }\n    return sumOfDigit(n / 10, (n % 10) + val);\n}\n\nint main() {\n    int num = 12345;\n\n    int result = sumOfDigit(num, 0);\n    cout <<  result;\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program for the above approach\n#include <stdio.h>\n\nint sumOfDigit(int n, int val)\n{\n    if (n < 10) {\n        val = val + n;\n        return val;\n    }\n    return sumOfDigit(n / 10, (n % 10) + val);\n}\n\nint main() {\n    int num = 12345;\n    int result = sumOfDigit(num, 0);\n    printf(\"%d\", result);\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program for the above approach\nimport java.io.*;\nimport java.lang.*;\nimport java.util.*;\n\nclass GfG {\n\n    static int sumOfDigit(int n, int val)  {\n        if (n < 10) {\n            val = val + n;\n            return val;\n        }\n        return sumOfDigit(n / 10, (n % 10) + val);\n    }\n\n    public static void main(String args[]) {\n        int num = 12345;\n        int result = sumOfDigit(num, 0);\n        System.out.println( result);\n    }\n}\n\n````\n\nPython\n\n````\n# Python3 program for the above approach\n\ndef sumOfDigit(n, val):\n\n    if (n < 10):\n        val = val + n\n        return val\n\n    return sumOfDigit(n // 10, (n % 10) + val)\n\n\nif __name__ == \"__main__\":\n    num = 12345\n\n    result = sumOfDigit(num, 0)\n\n    print(result)\n\n````\n\nC#\n\n````\n// C# program for the above approach\nusing System;\n\nclass GfG {\n\n    static int sumOfDigit(int n, int val) {\n        if (n < 10) {\n            val = val + n;\n            return val;\n        }\n        return sumOfDigit(n / 10, (n % 10) + val);\n    }\n\n    public static void Main() {\n        int num = 12345;\n\n        int result = sumOfDigit(num, 0);\n        Console.Write( result);\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Javascript program for the above approach\n\nfunction sumOfDigit(n, val)\n{\n    if (n < 10)\n    {\n        val = val + n;\n        return val;\n    }\n    return sumOfDigit(parseInt(n / 10),\n    (n % 10) + val);\n}\n\n// Driver code\n    let num = 12345;\n    let result = sumOfDigit(num, 0);\n\n    console.log( result);\n\n````\n\n\n\n\n**Output**\n```\n15\n```\n\n****Time Complexity:****\nO(log n)\n\n\n\n****Auxiliary Space:****\nO(log n)\n\n\n### ****[Alternate Approach]**** Converting Number to String\n\n> When the number of digits of that number exceeds 10\n>\n> 19\n> , we can\u2019t take that number as an integer since the range of long long int doesn\u2019t satisfy the given number. So take input as a string, run a loop from start to the length of the string and increase the sum with that character(in this case it is numeric)\n\nC++14\n\n````\n// C++ implementation of the above approach\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getSum(string s) {\n    int sum = 0;\n\n    // Traversing through the string\n    for (int i = 0; i < s.length(); i++) {\n        // Since ascii value of  numbers starts\n        // from 48 so we subtract it from sum\n        sum = sum + s[i] - 48;\n    }\n    return sum;\n}\n\nint main() {\n    string s = \"123456789123456789123422\";\n\n    cout << getSum(s);\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java implementation of the above approach\nimport java.io.*;\nclass GfG {\n\n    static int getSum(String s) {\n        int sum = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n\n            // Since ascii value of numbers starts\n            //  from 48 so we subtract it from sum\n            sum = sum + s.charAt(i) - 48;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args)  {\n        String s = \"123456789123456789123422\";\n\n        System.out.print(getSum(s));\n    }\n}\n\n````\n\nPython\n\n````\n# Python3 implementation of the above approach\ndef getSum(n):\n    sum = 0\n\n    # Traversing through string\n    for i in n:\n\n        # Converting char to int\n        sum = sum + int(i)\n\n    return sum\n\nif __name__ == \"__main__\":\n    n = \"123456789123456789123422\"\n\n    print(getSum(n))\n\n````\n\nC#\n\n````\n// C# implementation of the above approach\nusing System;\nclass GfG {\n    static int getSum(String s) {\n        int sum = 0;\n\n        for (int i = 0; i < s.Length; i++) {\n\n            // Since ascii value of numbers starts\n            //  from 48 so we subtract it from sum\n            sum = sum + s[i] - 48;\n        }\n        return sum;\n    }\n\n    static public void Main()  {\n        String st = \"123456789123456789123422\";\n        Console.Write(getSum(st));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Javascript implementation of the above approach\n\nfunction getSum(s)\n{\n    let sum = 0;\n\n    // Traversing through the string\n    for (let i = 0; i < s.length; i++)\n    {\n\n        // Since ascii value of  numbers starts from\n        //48 so we subtract it from sum\n        sum = sum + parseInt(s[i]);\n    }\n    return sum;\n}\n\n// Driver Code\nlet st = \"123456789123456789123422\";\nconsole.log(getSum(st));\n\n````\n\n\n\n\n**Output**\n```\n104\n```\n\n****Time Complexity:****\nO(n)\n\n\n\n****Auxiliary Space:****\nO(1)\n\n",
        "metadata": {
            "lesson_id": "e463ed6b-9b9c-4b7f-aaa9-d9607492b53e",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "Table of Content\n\n* [Applications of Array Data Structure:](#applications-of-array-data-structure)\n* [Advantages of Array Data Structure:](#advantages-of-array-data-structure)\n* [Disadvantages of Array Data Structure:](#disadvantages-of-array-data-structure)\n### ****Applications of Array Data Structure:****\n\nArrays mainly have advantages like random access and cache friendliness\nover other data structures that make them useful.\n\nBelow are some applications of arrays.\n\n* ****Storing and accessing data****: Arrays store elements in a specific order and allow constant-time\n  O(1) access to any element.\n* ****Searching****: If data in array is sorted, we can search an item in O(log n) time.\n  We can also find floor(), ceiling(), kth smallest, kth largest, etc\n  efficiently.\n* ****Matrices****: Two-dimensional arrays are used for matrices in computations like\n  graph algorithms and image processing.\n* ****Implementing other data structures:****\n  Arrays are used as the underlying data structure for implementing\n  stacks and queues.\n* ****Dynamic programming****: Dynamic programming algorithms often use arrays to store\n  intermediate results of subproblems in order to solve a larger\n  problem.\n* ****Data Buffers:****\n  Arrays serve as data buffers and queues, temporarily storing incoming\n  data like network packets, file streams, and database results before\n  processing.\n\n### ****Advantages of Array Data Structure:****\n\n* ****Efficient and Fast Access:****\n  Arrays allow direct and efficient access to any element in the\n  collection with constant access time, as the data is stored in\n  contiguous memory locations.\n* ****Memory Efficiency:****\n  Arrays store elements in contiguous memory, allowing efficient\n  allocation in a single block and reducing memory fragmentation.\n* ****Versatility:****\n  Arrays can be used to store a wide range of data types, including\n  integers, floating-point numbers, characters, and even complex data\n  structures such as objects and pointers.\n* ****Compatibility with hardware:**** The array data structure is compatible with most hardware\n  architectures, making it a versatile tool for programming in a wide\n  range of environments.\n\n### ****Disadvantages of Array Data Structure:****\n\n* ****Fixed Size:****\n  Arrays have a fixed size set at creation. Expanding an array requires\n  creating a new one and copying elements, which is time-consuming and\n  memory-intensive.\n* ****Memory Allocation Issues:****\n  Allocating large arrays can cause memory exhaustion, leading to\n  crashes, especially on systems with limited resources.\n* ****Insertion and Deletion Challenges:****\n  Adding or removing elements requires shifting subsequent elements,\n  making these operations inefficient.\n* ****Limited Data Type Support:****\n  Arrays support only elements of the same type, limiting their use with\n  complex data types.\n* ****Lack of Flexibility:****\n  Fixed size and limited type support make arrays less adaptable than\n  structures like linked lists or trees.",
        "metadata": {
            "lesson_id": "ec26f50a-f134-4978-b817-3084496c9feb",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "Array is a linear data structure that is a collection of data elements of same\ntypes. Arrays are stored in contiguous memory locations. It is a static\ndata structure with a fixed size.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "\nGiven the radius of a circle, find the area of that circle.\n\n\n![Area-of-circle](https://media.geeksforgeeks.org/wp-content/cdn-uploads/Area-of-circle-300x283.png)\n> The area of a circle can simply be evaluated using the following formula.\n>\n>\n> [Tex]Area = \\pi r^2[/Tex]\n>\n>\n> where r is radius of circle and it maybe in float because value of pie is 3.14\n\n****Approach****\n: Using the given radius, find the area using the above formula: (pi \\* r \\* r) and print the result in float.\n\n\n\n\n\nC++\n\n````\n// C++ program to find area\n// of circle\n#include <iostream>\nconst double pi = 3.14159265358979323846;\nusing namespace std;\n\n// function to calculate the area of circle\nfloat findArea(float r)\n{\n    return (pi * r * r);\n}\n// driver code\nint main()\n{\n    float r, Area;\n    r = 5;\n\n    // function calling\n    Area = findArea(r);\n    // displaying the area\n    cout << \"Area of Circle is :\" << Area;\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find area\n// of circle\n#include <stdio.h>\n#include <math.h>\n#define PI 3.142\n\ndouble findArea(int r)\n{\n   return PI * pow(r, 2);\n}\n\nint main()\n{\n    printf(\"Area is %f\", findArea(5));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find area\n// of circle\n\nclass Test\n{\n    static final double PI = Math.PI;\n\n    static double findArea(int r)\n    {\n       return PI * Math.pow(r, 2);\n    }\n\n    // Driver method\n    public static void main(String[] args)\n    {\n        System.out.println(\"Area is \" +  findArea(5));\n    }\n}\n\n````\n\nPython\n\n````\n# Python3 program to find Area of a circle\n\ndef findArea(r):\n    PI = 3.142\n    return PI * (r*r);\n\n# Driver method\nprint(\"Area is %.6f\" % findArea(5));\n\n# This code is contributed by Chinmoy Lenka\n\n````\n\nC#\n\n````\n// C# program to find area of circle\nusing System;\n\nclass GFG\n{\n    static double PI = Math.PI;\n\n    static double findArea(int r)\n    {\n    return PI * Math.Pow(r, 2);\n    }\n\n    // Driver method\n    static void Main()\n    {\n        Console.Write(\"Area is \" + findArea(5));\n    }\n}\n\n// This code is contributed by Sam007.\n\n````\n\nJavaScript\n\n````\n<script>\n\n// Javascript program to find area\n// of circle\n\nlet pi = 3.14159265358979323846;\n\n// function to calculate the area of circle\nfunction findArea(r)\n{\n    return (pi * r * r);\n}\n\n// Driver code\n    let r, Area;\n    r = 5;\n\n    // function calling\n    Area = findArea(r);\n\n    // displaying the area\n    document.write(\"Area of Circle is :\" + Area);\n\n// This code is contributed by Mayank Tyagi\n\n</script>\n\n````\n\nPHP\n\n````\n<?php\n// PHP program to find area\n// of circle\n\nfunction findArea( $r)\n{\n    $PI =3.142;\n    return $PI * pow($r, 2);\n}\n\n// Driver Code\necho(\"Area is \");\necho(findArea(5));\nreturn 0;\n\n// This code is contributed by vt_m.\n?>\n\n````\n\n\n\n\n**Output**\n```\nArea of Circle is :78.5398\n```\n\n****Time Complexity:****\nO(1)\n\n\n\n****Auxiliary Space:****\nO(1), since no extra space has been taken.\n",
        "metadata": {
            "lesson_id": "96fc2a66-d810-48cb-9c86-1f28415e1e5b",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "Given Principal\n\n****p****\n, Rate\n\n****r****\nand Time\n\n****t,****\nthe task is to calculate Simple Interest.\n\n\n****Examples :****\n\n> ****Input****\n> : p = 10000, r = 5, t = 5\n>\n>\n>\n> ****Output****\n> :2500\n>\n>\n>\n> ****Explanation****\n> : We need to find simple interest on Rs. 10,000 at the rate of 5% for 5 units of time.\n>\n>\n> ****Input****\n> : p = 3000, r = 7, t = 1\n>\n>\n>\n> ****Output****\n> :210\n\n\nThe basic idea is to calculate by applying the formula\n\n****SI = (p x t x r)/100****\n\nC++\n\n````\n// CPP program to find simple interest for\n// given principal amount, time and rate of interest\n#include<iostream>\nusing namespace std;\n\nfloat simpleInterest(float p, float t, float r){\n    /* Calculate simple interest  */\n    float ans = (p * t * r) / 100;\n    return ans;\n}\n\nint main() {\n\n    float p = 1, r = 1, t = 1;\n    cout <<simpleInterest(p,r,t);\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n\nfloat simpleInterest(float p, float t, float r) {\n    /* Calculate simple interest  */\n    float ans = (p * t * r) / 100;\n    return ans;\n}\n\nint main() {\n    float p = 1, r = 1, t = 1;\n    printf(\"%f\", simpleInterest(p, r, t));\n    return 0;\n}\n\n````\n\nJava\n\n````\nclass GfG {\n    static float simpleInterest(float p, float t, float r) {\n        /* Calculate simple interest  */\n        return (p * t * r) / 100;\n    }\n\n    public static void main(String[] args) {\n        float p = 1, r = 1, t = 1;\n        System.out.println(simpleInterest(p, r, t));\n    }\n}\n\n````\n\nPython\n\n````\ndef simpleInterest(p, t, r):\n    /* Calculate simple interest  */\n    return (p * t * r) / 100\n\nif __name__ == \"__main__\":\n  p = 1\n  r = 1\n  t = 1\n  print(simpleInterest(p, r, t))\n\n````\n\nC#\n\n````\nusing System;\n\nclass GfG {\n    public static float SimpleInterest(float p, float t, float r) {\n        /* Calculate simple interest  */\n        return (p * t * r) / 100;\n    }\n\n    static void Main() {\n        float p = 1, r = 1, t = 1;\n        Console.WriteLine(SimpleInterest(p, r, t));\n    }\n}\n\n````\n\nJavaScript\n\n````\nfunction simpleInterest(p, t, r) {\n    /* Calculate simple interest  */\n    return (p * t * r) / 100;\n}\n\n//driver code\nlet p = 1, r = 1, t = 1;\nconsole.log(simpleInterest(p, r, t));\n\n````\n\n\n\n\n**Output**\n```\n0.01\n```\n\n****Time complexity****\n: O(1)\n\n\n\n****Auxiliary Space****\n: O(1)\n",
        "metadata": {
            "lesson_id": "1b6d1c4b-b27f-48f6-a074-6891bfbd3ab6",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "\nTable of Content\n\n* [Operations on Circular Queue](#operations-on-circular-queue)\n* [Implement Circular Queue using Array](#implement-circular-queue-using-array)\n* [Complexity Analysis of Circular Queue Operations](#complexity-analysis-of-circular-queue-operations)\n### Operations on Circular Queue\n\n* ****getFront:****\n  Get the front item from the queue.\n* ****getRear:****\n  Get the last item from the queue.\n* ****enqueue(value):****\n  To\n\n  ****insert****\n  an element into the circular queue. In a circular queue, the new element is always inserted at the rear position.\n* ****dequeue()****\n  : To\n\n  ****delete****\n  an element from the circular queue. In a circular queue, the element is always deleted from the front position.\n\n### Implement Circular Queue using Array\n\n1. Initialize an\n\n   ****array****\n   of\n\n   ****size n****\n   , where\n\n   ****n is the maximum number of element****\n   s that the queue can hold.\n2. Initialize\n\n   ****three variables (size, capacity, and front.)****\n3. ****Enqueue:****\n   To enqueue an\n\n   ****element x****\n   into the queue, do the following:\n   1. Check if\n\n      ****size == capacity****\n      (queue is full), display\n\n      ****\u201cQueue is full\u201d.****\n   2. If not full: calculate\n\n      ****rear = (front + size) % capacity****\n      and\n\n      ****Insert****\n      value at the rear index.\n\n      ****Increment****\n      size by 1.\n4. ****Dequeue:****\n   To dequeue an element from the queue, do the following:\n   1. Check if\n\n      ****size == 0 (****\n      queue is empty), display\n\n      ****\u201cQueue is empty\u201d.****\n   2. If not empty:\n\n      ****retrieve****\n      the element at the\n\n      ****front index****\n      and\n\n      ****move front = (front + 1) % capacity****\n      . Also,\n\n      ****decrement****\n      size by 1 and\n\n      ****return the removed element.****\n\n****Illustration of Circular Queue****\n:\n\n\n\n\n\n\n\n\n\n****Below is the implementation of above approach:****\n\nC++\n\n````\n// C++ program for insertion and\n// deletion in Circular Queue\n#include <iostream>\nusing namespace std;\n\nclass MyQueue {\nprivate:\n    int *arr;\n    int front, size;\n    int capacity;\n\npublic:\n\n    // Constructor to initialize the queue\n    MyQueue(int c) {\n        arr = new int[c];\n        capacity = c;\n        size = 0;\n        front = 0;\n    }\n\n    // Get the front element\n    int getFront() {\n\n        // Queue is empty\n        if (size == 0)\n            return -1;\n        return arr[front];\n    }\n\n    // Get the rear element\n    int getRear() {\n\n        // Queue is empty\n        if (size == 0)\n            return -1;\n        int rear = (front + size - 1) % capacity;\n        return arr[rear];\n    }\n\n    // Insert an element at the rear\n    void enqueue(int x) {\n\n        // Queue is full\n        if (size == capacity)\n            return;\n        int rear = (front + size) % capacity;\n        arr[rear] = x;\n        size++;\n    }\n\n    // Remove an element from the front\n    int dequeue() {\n\n        // Queue is empty\n        if (size == 0)\n            return -1;\n        int res = arr[front];\n        front = (front + 1) % capacity;\n        size--;\n        return res;\n    }\n};\n\nint main() {\n    MyQueue q(4);\n    q.enqueue(10);\n    cout << q.getFront() << \" \" << q.getRear() << endl;\n    q.enqueue(20);\n    cout << q.getFront() << \" \" << q.getRear() << endl;\n    q.enqueue(30);\n    cout << q.getFront() << \" \" << q.getRear() << endl;\n    q.enqueue(40);\n    cout << q.getFront() << \" \" << q.getRear() << endl;\n    q.dequeue();\n    cout << q.getFront() << \" \" << q.getRear() << endl;\n    q.dequeue();\n    cout << q.getFront() << \" \" << q.getRear() << endl;\n    q.enqueue(50);\n    cout << q.getFront() << \" \" << q.getRear() << endl;\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program for insertion and\n// deletion in Circular Queue\nclass MyQueue {\n    private int[] arr;\n    private int front;\n    private int size;\n    private int capacity;\n\n    // Constructor to initialize the queue\n    public MyQueue(int c) {\n        arr = new int[c];\n        capacity = c;\n        size = 0;\n        front = 0;\n    }\n\n    // Get the front element\n    public int getFront() {\n\n        // Queue is empty\n        if (size == 0)\n            return -1;\n        return arr[front];\n    }\n\n    // Get the rear element\n    public int getRear() {\n\n        // Queue is empty\n        if (size == 0)\n            return -1;\n        int rear = (front + size - 1) % capacity;\n        return arr[rear];\n    }\n\n    // Insert an element at the rear\n    public void enqueue(int x) {\n\n        // Queue is full\n        if (size == capacity)\n            return;\n        int rear = (front + size) % capacity;\n        arr[rear] = x;\n        size++;\n    }\n\n    // Remove an element from the front\n    public int dequeue() {\n\n        // Queue is empty\n        if (size == 0)\n            return -1;\n        int res = arr[front];\n        front = (front + 1) % capacity;\n        size--;\n        return res;\n    }\n}\n\nclass GfG {\n\n    public static void main(String[] args) {\n        MyQueue q = new MyQueue(4);\n        q.enqueue(10);\n        System.out.println(q.getFront() + \" \" + q.getRear());\n        q.enqueue(20);\n        System.out.println(q.getFront() + \" \" + q.getRear());\n        q.enqueue(30);\n        System.out.println(q.getFront() + \" \" + q.getRear());\n        q.enqueue(40);\n        System.out.println(q.getFront() + \" \" + q.getRear());\n        q.dequeue();\n        System.out.println(q.getFront() + \" \" + q.getRear());\n        q.dequeue();\n        System.out.println(q.getFront() + \" \" + q.getRear());\n        q.enqueue(50);\n        System.out.println(q.getFront() + \" \" + q.getRear());\n    }\n}\n\n````\n\nPython\n\n````\n# python3 program for insertion and\n# deletion in Circular Queue\nclass MyQueue:\n    def __init__(self, c):\n        self.l = [None] * c\n        self.cap = c\n        self.size = 0\n        self.front = 0\n\n    def getFront(self):\n\n        # Check if queue is empty\n        if self.size == 0:\n            return None\n        return self.l[self.front]\n\n    def getRear(self):\n\n        # Check if queue is empty\n        if self.size == 0:\n            return None\n\n        # Calculate rear index\n        rear = (self.front + self.size - 1) % self.cap\n        return self.l[rear]\n\n    def enqueue(self, x):\n\n        # Check if queue is full\n        if self.size == self.cap:\n            return\n\n        # Calculate rear index\n        rear = (self.front + self.size) % self.cap\n        self.l[rear] = x\n        self.size += 1\n\n    def dequeue(self):\n\n        # Check if queue is empty\n        if self.size == 0:\n            return None\n        res = self.l[self.front]\n\n        # Move front index circularly\n        self.front = (self.front + 1) % self.cap\n        self.size -= 1\n        return res\n\nq = MyQueue(4)\nq.enqueue(10)\nprint(q.getFront(), q.getRear())\nq.enqueue(20)\nprint(q.getFront(), q.getRear())\nq.enqueue(30)\nprint(q.getFront(), q.getRear())\nq.enqueue(40)\nprint(q.getFront(), q.getRear())\nq.dequeue()\nprint(q.getFront(), q.getRear())\nq.dequeue()\nprint(q.getFront(), q.getRear())\nq.enqueue(50)\nprint(q.getFront(), q.getRear())\n\n````\n\nC#\n\n````\n// C# program for insertion and\n// deletion in Circular Queue\nusing System;\n\nclass MyQueue {\n    private int[] arr;\n    private int front;\n    private int size;\n    private int capacity;\n\n    // Constructor to initialize the queue\n    public MyQueue(int c) {\n        arr = new int[c];\n        capacity = c;\n        size = 0;\n        front = 0;\n    }\n\n    // Get the front element\n    public int getFront() {\n\n        // Queue is empty\n        if (size == 0)\n          return -1;\n        return arr[front];\n    }\n\n    // Get the rear element\n    public int getRear() {\n\n        // Queue is empty\n        if (size == 0)\n          return -1;\n        int rear = (front + size - 1) % capacity;\n        return arr[rear];\n    }\n\n    // Insert an element at the rear\n    public void enqueue(int x) {\n\n        // Queue is full\n        if (size == capacity) return;\n        int rear = (front + size) % capacity;\n        arr[rear] = x;\n        size++;\n    }\n\n    // Remove an element from the front\n    public int dequeue() {\n\n        // Queue is empty\n        if (size == 0) return -1;\n        int res = arr[front];\n        front = (front + 1) % capacity;\n        size--;\n        return res;\n    }\n}\nclass GfG {\n\n        static void Main(string[] args) {\n        MyQueue q = new MyQueue(4);\n        q.enqueue(10);\n        Console.WriteLine(q.getFront() + \" \" + q.getRear());\n        q.enqueue(20);\n        Console.WriteLine(q.getFront() + \" \" + q.getRear());\n        q.enqueue(30);\n        Console.WriteLine(q.getFront() + \" \" + q.getRear());\n        q.enqueue(40);\n        Console.WriteLine(q.getFront() + \" \" + q.getRear());\n        q.dequeue();\n        Console.WriteLine(q.getFront() + \" \" + q.getRear());\n        q.dequeue();\n        Console.WriteLine(q.getFront() + \" \" + q.getRear());\n        q.enqueue(50);\n        Console.WriteLine(q.getFront() + \" \" + q.getRear());\n    }\n}\n\n````\n\nJavaScript\n\n````\n// JS program for insertion and\n// deletion in Circular Queue\nclass MyQueue {\n    constructor(c) {\n        this.arr = new Array(c).fill(null);\n        this.capacity = c;\n        this.size = 0;\n        this.front = 0;\n    }\n\n    // Get the front element\n    getFront() {\n\n        // Queue is empty\n        if (this.size === 0) return null;\n        return this.arr[this.front];\n    }\n\n    // Get the rear element\n    getRear() {\n\n        // Queue is empty\n        if (this.size === 0) return null;\n        let rear = (this.front + this.size - 1) % this.capacity;\n        return this.arr[rear];\n    }\n\n    // Insert an element at the rear\n    enqueue(x) {\n\n        // Queue is full\n        if (this.size === this.capacity) return;\n        let rear = (this.front + this.size) % this.capacity;\n        this.arr[rear] = x;\n        this.size++;\n    }\n\n    // Remove an element from the front\n    dequeue() {\n\n        // Queue is empty\n        if (this.size === 0) return null;\n        let res = this.arr[this.front];\n        this.front = (this.front + 1) % this.capacity;\n        this.size--;\n        return res;\n    }\n}\n\nconst q = new MyQueue(4);\nq.enqueue(10);\nconsole.log(q.getFront(), q.getRear());\nq.enqueue(20);\nconsole.log(q.getFront(), q.getRear());\nq.enqueue(30);\nconsole.log(q.getFront(), q.getRear());\nq.enqueue(40);\nconsole.log(q.getFront(), q.getRear());\nq.dequeue();\nconsole.log(q.getFront(), q.getRear());\nq.dequeue();\nconsole.log(q.getFront(), q.getRear());\nq.enqueue(50);\nconsole.log(q.getFront(), q.getRear());\n\n````\n\n\n\n\n**Output**\n```\n10 10\n10 20\n10 30\n10 40\n20 40\n30 40\n30 50\n\n```\n### Complexity Analysis of Circular Queue Operations\n\n****Time Complexity:****\n\n****Auxiliary Space:****\nO(size), where\n\n****size****\nis the number of elements in the circular queue.\n",
        "metadata": {
            "lesson_id": "1c9888f0-5d92-4cf6-b41a-deff87b117b1",
            "course_id": "8ff4ea92-41f2-4d49-b230-0281874efb2d",
            "course_name": "Introduction to DSA II",
            "lesson_description": "A Circular Queue is another way of implementing a normal queue\nwhere the last element of the queue is connected\nto the first element of the queue forming a circle.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "****Stack Operations:****\n-------------------------\n\n* [****push()****](https://www.geeksforgeeks.org/stack-push-and-pop-in-c-stl/)****:****\n  Insert a new element into the stack i.e just insert a new element at\n  the beginning of the linked list.\n* [****pop()****](https://www.geeksforgeeks.org/stack-push-and-pop-in-c-stl/)****:****\n  Return the top element of the Stack i.e simply delete the first\n  element from the linked list.\n* [****peek()****](https://www.geeksforgeeks.org/stack-peek-method-in-java/)****:**** Return the top element.\n* ****display():**** Print all elements in Stack.\n\nPush Operation:\n---------------\n\n> * Initialise a node\n> * Update the value of that node by data i.e. ****node->data = data****\n> * Now link this node to the top of the linked list\n> * And update top pointer to the current node\n\nPop Operation:\n--------------\n\n> * First Check whether there is any node present in the linked list or\n>   not, if not then return\n> * Otherwise make pointer let say ****temp**** to the top node and move forward the top node by 1 step\n> * Now free this temp node\n\nPeek Operation:\n---------------\n\n> * Check if there is any node present or not, if not then\n>   return.\n> * Otherwise return the value of top node of the linked list\n\nDisplay Operation:\n------------------\n\n> * Take a ****temp**** node and initialize it with top pointer\n> * Now start traversing temp till it encounters NULL\n> * Simultaneously print the value of the temp node\n\n\n\nBelow is the implementation of the above operations\n\nC++\n````\n// C++ program to implement a stack using singly linked list\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Class representing a node in the linked list\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node(int new_data) {\n        this->data = new_data;\n        this->next = nullptr;\n    }\n};\n\n// Class to implement stack using a singly linked list\nclass Stack {\n\n    // head of the linked list\n    Node* head;\n\npublic:\n    // Constructor to initialize the stack\n    Stack() { this->head = nullptr; }\n\n    // Function to check if the stack is empty\n    bool isEmpty() {\n\n        // If head is nullptr, the stack is empty\n        return head == nullptr;\n    }\n\n    // Function to push an element onto the stack\n    void push(int new_data) {\n\n        // Create a new node with given data\n        Node* new_node = new Node(new_data);\n\n        // Check if memory allocation for the new node\n        // failed\n        if (!new_node) {\n            cout << \"\\nStack Overflow\";\n        }\n\n        // Link the new node to the current top node\n        new_node->next = head;\n\n        // Update the top to the new node\n        head = new_node;\n    }\n\n    // Function to remove the top element from the stack\n    void pop() {\n\n        // Check for stack underflow\n        if (this->isEmpty()) {\n            cout << \"\\nStack Underflow\" << endl;\n        }\n        else {\n            // Assign the current top to a temporary\n            // variable\n            Node* temp = head;\n\n            // Update the top to the next node\n            head = head->next;\n\n            // Deallocate the memory of the old top node\n            delete temp;\n        }\n    }\n\n    // Function to return the top element of the stack\n    int peek() {\n\n        // If stack is not empty, return the top element\n        if (!isEmpty())\n            return head->data;\n        else {\n            cout << \"\\nStack is empty\";\n            return INT_MIN;\n        }\n    }\n};\n\n// Driver program to test the stack implementation\nint main() {\n    // Creating a stack\n    Stack st;\n\n    // Push elements onto the stack\n    st.push(11);\n    st.push(22);\n    st.push(33);\n    st.push(44);\n\n    // Print top element of the stack\n    cout << \"Top element is \" << st.peek() << endl;\n\n    // removing two elemements from the top\n      cout << \"Removing two elements...\" << endl;\n    st.pop();\n    st.pop();\n\n    // Print top element of the stack\n    cout << \"Top element is \" << st.peek() << endl;\n\n    return 0;\n}\n\n````\n\nC\n````\n// C program to implement a stack using singly linked list\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// Struct representing a node in the linked list\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\nNode* createNode(int new_data) {\n    Node* new_node = (Node*)malloc(sizeof(Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\n\n// Struct to implement stack using a singly linked list\ntypedef struct Stack {\n    Node* head;\n} Stack;\n\n// Constructor to initialize the stack\nvoid initializeStack(Stack* stack) { stack->head = NULL; }\n\n// Function to check if the stack is empty\nint isEmpty(Stack* stack) {\n\n    // If head is NULL, the stack is empty\n    return stack->head == NULL;\n}\n\n// Function to push an element onto the stack\nvoid push(Stack* stack, int new_data) {\n\n    // Create a new node with given data\n    Node* new_node = createNode(new_data);\n\n    // Check if memory allocation for the new node failed\n    if (!new_node) {\n        printf(\"\\nStack Overflow\");\n        return;\n    }\n\n    // Link the new node to the current top node\n    new_node->next = stack->head;\n\n    // Update the top to the new node\n    stack->head = new_node;\n}\n\n// Function to remove the top element from the stack\nvoid pop(Stack* stack) {\n\n    // Check for stack underflow\n    if (isEmpty(stack)) {\n        printf(\"\\nStack Underflow\\n\");\n        return;\n    }\n    else {\n\n        // Assign the current top to a temporary variable\n        Node* temp = stack->head;\n\n        // Update the top to the next node\n        stack->head = stack->head->next;\n\n        // Deallocate the memory of the old top node\n        free(temp);\n    }\n}\n\n// Function to return the top element of the stack\nint peek(Stack* stack) {\n\n    // If stack is not empty, return the top element\n    if (!isEmpty(stack))\n        return stack->head->data;\n    else {\n        printf(\"\\nStack is empty\");\n        return INT_MIN;\n    }\n}\n\n// Driver program to test the stack implementation\nint main() {\n\n    // Creating a stack\n    Stack stack;\n    initializeStack(&stack);\n\n    // Push elements onto the stack\n    push(&stack, 11);\n    push(&stack, 22);\n    push(&stack, 33);\n    push(&stack, 44);\n\n    // Print top element of the stack\n    printf(\"Top element is %d\\n\", peek(&stack));\n\n\n      // removing two elemements from the top\n      printf(\"Removing two elements...\\n\");\n    pop(&stack);\n    pop(&stack);\n\n    // Print top element of the stack\n    printf(\"Top element is %d\\n\", peek(&stack));\n\n    return 0;\n}\n\n````\n\nJava\n````\n// Java program to implement a stack using singly linked\n// list\n\n// Class representing a node in the linked list\nclass Node {\n    int data;\n    Node next;\n    Node(int new_data) {\n        this.data = new_data;\n        this.next = null;\n    }\n}\n\n// Class to implement stack using a singly linked list\nclass Stack {\n\n    // Head of the linked list\n    Node head;\n\n    // Constructor to initialize the stack\n    Stack() { this.head = null; }\n\n    // Function to check if the stack is empty\n    boolean isEmpty() {\n\n        // If head is null, the stack is empty\n        return head == null;\n    }\n\n    // Function to push an element onto the stack\n    void push(int new_data) {\n\n        // Create a new node with given data\n        Node new_node = new Node(new_data);\n\n        // Check if memory allocation for the new node\n        // failed\n        if (new_node == null) {\n            System.out.println(\"\\nStack Overflow\");\n            return;\n        }\n\n        // Link the new node to the current top node\n        new_node.next = head;\n\n        // Update the top to the new node\n        head = new_node;\n    }\n\n    // Function to remove the top element from the stack\n    void pop() {\n\n        // Check for stack underflow\n        if (isEmpty()) {\n            System.out.println(\"\\nStack Underflow\");\n            return;\n        }\n        else {\n\n            // Assign the current top to a temporary\n            // variable\n            Node temp = head;\n\n            // Update the top to the next node\n            head = head.next;\n\n            // Deallocate the memory of the old top node\n            temp = null;\n        }\n    }\n\n    // Function to return the top element of the stack\n    int peek() {\n\n        // If stack is not empty, return the top element\n        if (!isEmpty())\n            return head.data;\n        else {\n            System.out.println(\"\\nStack is empty\");\n            return Integer.MIN_VALUE;\n        }\n    }\n}\n\n// Driver code\npublic class Main {\n    public static void main(String[] args)\n    {\n        // Creating a stack\n        Stack st = new Stack();\n\n        // Push elements onto the stack\n        st.push(11);\n        st.push(22);\n        st.push(33);\n        st.push(44);\n\n        // Print top element of the stack\n        System.out.println(\"Top element is \" + st.peek());\n\n        // removing two elemements from the top\n          System.out.println(\"Removing two elements...\");\n        st.pop();\n        st.pop();\n\n        // Print top element of the stack\n        System.out.println(\"Top element is \" + st.peek());\n    }\n}\n\n````\n\nPython\n````\n# Java program to implement a stack using singly linked\n# list\n\n# Class representing a node in the linked list\nclass Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n\n# Class to implement stack using a singly linked list\nclass Stack:\n    def __init__(self):\n\n        # head of the linked list\n        self.head = None\n\n    # Function to check if the stack is empty\n    def is_empty(self):\n\n        # If head is None, the stack is empty\n        return self.head is None\n\n    # Function to push an element onto the stack\n    def push(self, new_data):\n\n        # Create a new node with given data\n        new_node = Node(new_data)\n\n        # Check if memory allocation for the new node failed\n        if not new_node:\n            print(\"\\nStack Overflow\")\n            return\n\n        # Link the new node to the current top node\n        new_node.next = self.head\n\n        # Update the top to the new node\n        self.head = new_node\n\n    # Function to remove the top element from the stack\n    def pop(self):\n\n        # Check for stack underflow\n        if self.is_empty():\n            print(\"\\nStack Underflow\")\n        else:\n\n            # Assign the current top to a temporary variable\n            temp = self.head\n\n            # Update the top to the next node\n            self.head = self.head.next\n\n            # Deallocate the memory of the old top node\n            del temp\n\n    # Function to return the top element of the stack\n    def peek(self):\n\n        # If stack is not empty, return the top element\n        if not self.is_empty():\n            return self.head.data\n        else:\n            print(\"\\nStack is empty\")\n            return float('-inf')\n\n\n# Creating a stack\nst = Stack()\n\n# Push elements onto the stack\nst.push(11)\nst.push(22)\nst.push(33)\nst.push(44)\n\n# Print top element of the stack\nprint(\"Top element is\", st.peek())\n\n# removing two elemements from the top\nprint(\"Removing two elements...\");\nst.pop()\nst.pop()\n\n# Print top element of the stack\nprint(\"Top element is\", st.peek())\n\n````\n\nC#\n````\n// C# program to implement a stack using singly linked list\nusing System;\n\n// Class representing a node in the linked list\nclass Node {\n    public int data;\n    public Node next;\n    public Node(int new_data)\n    {\n        this.data = new_data;\n        this.next = null;\n    }\n}\n\n// Class to implement stack using a singly linked list\nclass Stack {\n\n    // head of the linked list\n    private Node head;\n\n    // Constructor to initialize the stack\n    public Stack() { this.head = null; }\n\n    // Function to check if the stack is empty\n    public bool isEmpty()\n    {\n\n        // If head is null, the stack is empty\n        return head == null;\n    }\n\n    // Function to push an element onto the stack\n    public void push(int new_data)\n    {\n\n        // Create a new node with given data\n        Node new_node = new Node(new_data);\n\n        // Check if memory allocation for the new node\n        // failed\n        if (new_node == null) {\n            Console.WriteLine(\"\\nStack Overflow\");\n            return;\n        }\n\n        // Link the new node to the current top node\n        new_node.next = head;\n\n        // Update the top to the new node\n        head = new_node;\n    }\n\n    // Function to remove the top element from the stack\n    public void pop()\n    {\n\n        // Check for stack underflow\n        if (this.isEmpty()) {\n            Console.WriteLine(\"\\nStack Underflow\");\n        }\n        else {\n\n            // Update the top to the next node\n            head = head.next;\n            /* No need to manually free the memory of the\n             * old head in C# */\n        }\n    }\n\n    // Function to return the top element of the stack\n    public int peek()\n    {\n\n        // If stack is not empty, return the top element\n        if (!isEmpty())\n            return head.data;\n        else {\n            Console.WriteLine(\"\\nStack is empty\");\n            return int.MinValue;\n        }\n    }\n}\n\n// Driver program to test the stack implementation\nclass GfG {\n    static void Main(string[] args)\n    {\n\n        // Creating a stack\n        Stack st = new Stack();\n\n        // Push elements onto the stack\n        st.push(11);\n        st.push(22);\n        st.push(33);\n        st.push(44);\n\n        // Print top element of the stack\n        Console.WriteLine(\"Top element is \" + st.peek());\n\n        // removing two elemements from the top\n          Console.WriteLine(\"Removing two elements...\");\n        st.pop();\n        st.pop();\n\n        // Print top element of the stack\n        Console.WriteLine(\"Top element is \" + st.peek());\n    }\n}\n\n````\n\nJavaScript\n````\n// Javascript program to implement a stack using singly\n// linked list\n\n// Class representing a node in the linked list\nclass Node {\n    constructor(new_data) {\n        this.data = new_data;\n        this.next = null;\n    }\n}\n\n// Class to implement stack using a singly linked list\nclass Stack {\n\n    // Constructor to initialize the stack\n    constructor() { this.head = null; }\n\n    // Function to check if the stack is empty\n    isEmpty() {\n\n        // If head is null, the stack is empty\n        return this.head === null;\n    }\n\n    // Function to push an element onto the stack\n    push(new_data) {\n\n        // Create a new node with given data\n        const new_node = new Node(new_data);\n\n        // Check if memory allocation for the new node\n        // failed\n        if (!new_node) {\n            console.log(\"\\nStack Overflow\");\n            return;\n        }\n\n        // Link the new node to the current top node\n        new_node.next = this.head;\n\n        // Update the top to the new node\n        this.head = new_node;\n    }\n\n    // Function to remove the top element from the stack\n    pop() {\n\n        // Check for stack underflow\n        if (this.isEmpty()) {\n            console.log(\"\\nStack Underflow\");\n        }\n        else {\n\n            // Assign the current top to a temporary\n            // variable\n            let temp = this.head;\n\n            // Update the top to the next node\n            this.head = this.head.next;\n\n            // Deallocate the memory of the old top node\n            temp = null;\n        }\n    }\n\n    // Function to return the top element of the stack\n    peek() {\n\n        // If stack is not empty, return the top element\n        if (!this.isEmpty())\n            return this.head.data;\n        else {\n            console.log(\"\\nStack is empty\");\n            return Number.MIN_VALUE;\n        }\n    }\n}\n\n// Driver program to test the stack implementation\nconst st = new Stack();\n\n// Push elements onto the stack\nst.push(11);\nst.push(22);\nst.push(33);\nst.push(44);\n\n// Print top element of the stack\nconsole.log(\"Top element is \" + st.peek());\n\n// removing two elemements from the top\nconsole.log(\"Removing two elements...\");\nst.pop();\nst.pop();\n\n// Print top element of the stack\nconsole.log(\"Top element is \" + st.peek());\n\n````\n\n\n**Output**\n```\n\nTop element is 44\nTop element is 22\n\n```\n\n****Time Complexity:****\nO(1), for all push(), pop(), and peek(), as we are not performing any\nkind of traversal over the list. We perform all the operations through\nthe current pointer only.\n****Auxiliary Space:**** O(N), where N is the size of the stack\n\n\nIn this implementation, we define a Node class that represents a node\nin the linked list, and a Stack class that uses this node class to\nimplement the stack. The head attribute of the Stack class points to the\ntop of the stack (i.e., the first node in the linked list).\n\nTo push an item onto the stack, we create a new node with the given\nitem and set its next pointer to the current head of the stack. We then\nset the head of the stack to the new node, effectively making it the new\ntop of the stack.\n\nTo pop an item from the stack, we simply remove the first node from the\nlinked list by setting the head of the stack to the next node in the\nlist (i.e., the node pointed to by the next pointer of the current\nhead). We return the data stored in the original head node, which is the\nitem that was removed from the top of the stack.\n\n### Benefits of implementing a stack using a singly linked list include:\n\n****Dynamic memory allocation****: The size of the stack can be increased or decreased dynamically by\nadding or removing nodes from the linked list, without the need to\nallocate a fixed amount of memory for the stack upfront.\n\n****Efficient memory usage:**** Since nodes in a singly linked list only have a next pointer and not a\nprev pointer, they use less memory than nodes in a doubly linked\nlist.\n\n****Easy implementation****: Implementing a stack using a singly linked list is straightforward\nand can be done using just a few lines of code.\n\n****Versatile****: Singly linked lists can be used to implement other data structures\nsuch as queues, linked lists, and trees.\n\nIn summary, implementing a stack using a singly linked list is a simple\nand efficient way to create a dynamic stack data structure in\nPython.\n\n### Real time examples of stack:\n\nStacks are used in various real-world scenarios where a last-in,\nfirst-out (LIFO) data structure is required. Here are some examples of\nreal-time applications of stacks:\n\n****Function call stack****: When a function is called in a program, the return address and all\nthe function parameters are pushed onto the function call stack. The\nstack allows the function to execute and return to the caller function\nin the reverse order in which they were called.\n\n****Undo/Redo operations:****\nIn many applications, such as text editors, image editors, or web\nbrowsers, the undo and redo functionalities are implemented using a\nstack. Every time an action is performed, it is pushed onto the stack.\nWhen the user wants to undo the last action, the top element of the\nstack is popped and the action is reversed.\n\n****Browser history:**** Web browsers use stacks to keep track of the pages visited by the user.\nEvery time a new page is visited, its URL is pushed onto the stack. When\nthe user clicks the \u201cBack\u201d button, the last visited URL is popped from\nthe stack and the user is directed to the previous page.\n\n****Expression evaluation****: Stacks are used in compilers and interpreters to evaluate\nexpressions. When an expression is parsed, it is converted into postfix\nnotation and pushed onto a stack. The postfix expression is then\nevaluated using the stack.\n\n****Call stack in recursion:****\nWhen a recursive function is called, its call is pushed onto the stack.\nThe function executes and calls itself, and each subsequent call is\npushed onto the stack. When the recursion ends, the stack is popped, and\nthe program returns to the previous function call.\n\nIn summary, stacks are widely used in many applications where LIFO\nfunctionality is required, such as function calls, undo/redo operations,\nbrowser history, expression evaluation, and recursive function\ncalls.\n",
        "metadata": {
            "lesson_id": "39944df7-8db0-4d3d-a12d-e09eebfacaaa",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "To implement a stack using the singly linked list concept, all the singly linked list operations should be performed based on Stack operations LIFO(last in first out) and with the help of that knowledge, we are going to implement a stack using a singly linked list.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "\nYou are given a\n\n****cubic dice****\nwith\n\n****6****\nfaces. All the individual faces have a number printed on them. The numbers are in the range of\n\n****1 to 6****\n, like any ordinary dice. You will be provided with a face of this cube, your task is to guess the number on the opposite face of the cube.\n\n\n****Examples:****\n\n> ****Input:****\n> n = 2\n>\n>\n>\n> ****Output:****\n> 5\n>\n>\n>\n> ****Explanation:****\n> For dice facing number 5 opposite face will have the number 2.\n>\n>\n> ****Input:****\n> 6 = 6\n>\n>\n>\n> ****Output:****\n> 1\n\nTable of Content\n\n* [[Naive Approach] Using if-else \u2013 O(1) Time and O(1) Space](#naive-approach-using-ifelse-o1-time-and-o1-space)\n* [[Expected Approach] Using Sum of two sides \u2013 O(1) Time and O(1) Space](#expected-approach-using-sum-of-two-sides-o1-time-and-o1-space)\n### ****[Naive Approach] Using if-else \u2013 O(1) Time and O(1) Space****\n\n> In a normal 6-faced dice, 1 is opposite to 6, 2 is opposite to 5, and 3 is opposite to 4. Hence a normal if-else-if block can be placed\n\nC++\n\n````\n// C++ program for the above approach\n#include<bits/stdc++.h>\nusing namespace std;\n\nint oppositeFaceOfDice(int n) {\n\n  if(n==1){\n    cout<<6;\n  }else if(n==2){\n    cout<<5;\n  }else if(n==3){\n    cout<<4;\n  }else if(n==4){\n    cout<<3;\n  }else if(n==5){\n    cout<<2;\n  }else{\n    cout<<1;\n  }\n}\n\nint main() {\n\n    int n = 2;\n    oppositeFaceOfDice(n);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find opposite face of dice\nclass Dice {\n    static int oppositeFaceOfDice(int n) {\n        if (n == 1) {\n            System.out.println(6);\n        } else if (n == 2) {\n            System.out.println(5);\n        } else if (n == 3) {\n            System.out.println(4);\n        } else if (n == 4) {\n            System.out.println(3);\n        } else if (n == 5) {\n            System.out.println(2);\n        } else {\n            System.out.println(1);\n        }\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        int n = 2;\n        oppositeFaceOfDice(n);\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to find opposite face of dice\ndef opposite_face_of_dice(n):\n    if n == 1:\n        print(6)\n    elif n == 2:\n        print(5)\n    elif n == 3:\n        print(4)\n    elif n == 4:\n        print(3)\n    elif n == 5:\n        print(2)\n    else:\n        print(1)\n\nif __name__ == \"__main__\":\n  n = 2\n  opposite_face_of_dice(n)\n\n````\n\nC#\n\n````\n// C# program to find opposite face of dice\nusing System;\n\nclass Program {\n    static void OppositeFaceOfDice(int n) {\n        if (n == 1) {\n            Console.WriteLine(6);\n        } else if (n == 2) {\n            Console.WriteLine(5);\n        } else if (n == 3) {\n            Console.WriteLine(4);\n        } else if (n == 4) {\n            Console.WriteLine(3);\n        } else if (n == 5) {\n            Console.WriteLine(2);\n        } else {\n            Console.WriteLine(1);\n        }\n    }\n\n    static void Main() {\n        int n = 2;\n        OppositeFaceOfDice(n);\n    }\n}\n\n````\n\nJavaScript\n\n````\n// JavaScript program to find opposite face of dice\nfunction oppositeFaceOfDice(n) {\n    if (n === 1) {\n        console.log(6);\n    } else if (n === 2) {\n        console.log(5);\n    } else if (n === 3) {\n        console.log(4);\n    } else if (n === 4) {\n        console.log(3);\n    } else if (n === 5) {\n        console.log(2);\n    } else {\n        console.log(1);\n    }\n}\n\n//driver code\nlet n = 2;\noppositeFaceOfDice(n);\n\n````\n\n\n\n\n**Output**\n```\n5\n```\n### [Expected Approach] Using Sum of two sides \u2013 O(1) Time and O(1) Space\n\n> The idea is based on the observation that the sum of two opposite sides of a cubical dice is equal to\n>\n> ****7****\n> . So, just subtract the given\n>\n> ****n****\n> from\n>\n> ****7****\n> and print the answer.\n\nC++\n\n````\n// C++ program for the above approach\n#include<bits/stdc++.h>\nusing namespace std;\n\nint oppositeFaceOfDice(int n) {\n\n    // Stores number on opposite face\n    // of dice\n    int ans = 7 - n;\n    cout << ans;\n}\n\nint main() {\n\n    int n = 2;\n    oppositeFaceOfDice(n);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program for the above approach\nimport java.io.*;\n\nclass GfG {\n\n    static void oppositeFaceOfDice(int n)  {\n\n        // Stores number on opposite face\n        // of dice\n        int ans = 7 - n;\n        System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n\n        int n = 2;\n        oppositeFaceOfDice(n);\n    }\n}\n\n````\n\nPython\n\n````\n# Python3 program for the above approach\ndef oppositeFaceOfDice(n):\n\n    # Stores number on opposite face\n    # of dice\n    ans = 7 - n\n    print(ans)\n\nif __name__ == \"__main__\":\n  n = 2\n  oppositeFaceOfDice(n)\n\n````\n\nC#\n\n````\n// C# program for the above approach\nusing System;\nusing System.Collections.Generic;\n\nclass GfG{\n\nstatic void oppositeFaceOfDice(int n) {\n\n    // Stores number on opposite face\n    // of dice\n    int ans = 7 - n;\n    Console.Write(ans);\n}\n\npublic static void Main() {\n\n    int n = 2;\n    oppositeFaceOfDice(n);\n}\n}\n\n````\n\nJavaScript\n\n````\n// JavaScript program for the above approach\n\nfunction oppositeFaceOfDice(n) {\n  // Stores number on opposite face\n  // of dice\n  let ans = 7 - n;\n  console.log(ans);\n}\n\n// Driver Code\nlet n = 2;\noppositeFaceOfDice(n);\n\n````\n\n\n\n\n**Output**\n```\n5\n```\n\n*****Time Complexity:*****\n**O(1)**\n\n\n*****Auxiliary Space:*****\n**O(1)**\n",
        "metadata": {
            "lesson_id": "82a0d245-a665-4ec2-a2fe-145f7e841ef1",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "\nGiven two integers\n\n****n****\nand\n\n****m (m != 0)****\n. Find the number closest to\n\n****n****\nand divisible by\n\n****m****\n. If there is more than one such number, then output the one having maximum absolute value.\n\n\n****Examples:****\n\n\n> Input: n = 13, m = 4\n>\n>\n>\n> Output: 12\n>\n>\n>\n> Explanation: 12 is the closest to 13, divisible by 4.\n>\n>\n> Input: n = -15, m = 6\n>\n>\n>\n> Output: -18\n>\n>\n>\n> Explanation: Both -12 and -18 are closest to -15, but-18 has the maximum absolute value.\n\nTable of Content\n\n* [[Naive Approach] \u2013 O(m) Time and O(1) Space](#naive-approach-om-time-and-o1-space)\n* [[Expected Approach] By finding Quotient \u2013 O(1) Time and O(1) Space](#expected-approach-by-finding-quotient-o1-time-and-o1-space)\n### [Naive Approach] \u2013 O(m) Time and O(1) Space\n\n> The basic idea is to start checking from n \u2013 m to n + m one by one and tack the closest number.\n\nC++\n\n````\n// C++ implementation to find the number closest to n\n// and divisible by m\n#include <bits/stdc++.h>\nusing namespace std;\n\nint closestNumber(int n, int m) {\n    // find the quotient\n   int closest = 0;\n    int minDifference = INT_MAX;\n\n    // Check numbers around n\n    for (int i = n - abs(m); i <= n + abs(m); ++i) {\n        if (i % m == 0) {\n            int difference = abs(n - i);\n\n            if (difference < minDifference ||\n               (difference == minDifference && abs(i) > abs(closest))) {\n                closest = i;\n                minDifference = difference;\n            }\n        }\n    }\n    return closest;\n}\n\nint main() {\n    int n = 13, m = 4;\n    cout << closestNumber(n, m) << endl;\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint closestNumber(int n, int m) {\n    // find the quotient\n    int closest = 0;\n    int minDifference = INT_MAX;\n\n    // Check numbers around n\n    for (int i = n - abs(m); i <= n + abs(m); ++i) {\n        if (i % m == 0) {\n            int difference = abs(n - i);\n\n            if (difference < minDifference ||\n               (difference == minDifference && abs(i) > abs(closest))) {\n                closest = i;\n                minDifference = difference;\n            }\n        }\n    }\n    return closest;\n}\n\nint main() {\n    int n = 13, m = 4;\n    printf(\"%d\\n\", closestNumber(n, m));\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java implementation to find the number closest to n\n// and divisible by m\nclass Main {\n    static int closestNumber(int n, int m) {\n        // find the quotient\n        int closest = 0;\n        int minDifference = Integer.MAX_VALUE;\n\n        // Check numbers around n\n        for (int i = n - Math.abs(m); i <= n + Math.abs(m); ++i) {\n            if (i % m == 0) {\n                int difference = Math.abs(n - i);\n\n                if (difference < minDifference ||\n                   (difference == minDifference && Math.abs(i) > Math.abs(closest))) {\n                    closest = i;\n                    minDifference = difference;\n                }\n            }\n        }\n        return closest;\n    }\n\n    public static void main(String[] args) {\n        int n = 13, m = 4;\n        System.out.println(closestNumber(n, m));\n    }\n}\n\n````\n\nPython\n\n````\n# Python implementation to find the number closest to n\n# and divisible by m\ndef closest_number(n, m):\n    # find the quotient\n    closest = 0\n    min_difference = float('inf')\n\n    # Check numbers around n\n    for i in range(n - abs(m), n + abs(m) + 1):\n        if i % m == 0:\n            difference = abs(n - i)\n\n            if difference < min_difference or \\\n                        (difference == min_difference and abs(i) > abs(closest)):\n                closest = i\n                min_difference = difference\n    return closest\n\n\nif __name__ == \"__main__\":\n  n = 13\n  m = 4\n  print(closest_number(n, m))\n\n````\n\nC#\n\n````\n// C# implementation to find the number closest to n\n// and divisible by m\nusing System;\n\nclass GfG {\n    static int ClosestNumber(int n, int m) {\n\n        // find the quotient\n        int closest = 0;\n        int minDifference = int.MaxValue;\n\n        // Check numbers around n\n        for (int i = n - Math.Abs(m); i <= n + Math.Abs(m); ++i) {\n            if (i % m == 0) {\n                int difference = Math.Abs(n - i);\n\n                if (difference < minDifference ||\n                   (difference == minDifference && Math.Abs(i) > Math.Abs(closest))) {\n                    closest = i;\n                    minDifference = difference;\n                }\n            }\n        }\n        return closest;\n    }\n\n    static void Main() {\n        int n = 13, m = 4;\n        Console.WriteLine(ClosestNumber(n, m));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// JavaScript implementation to find the number closest to n\n// and divisible by m\nfunction closestNumber(n, m) {\n\n    // find the quotient\n    let closest = 0;\n    let minDifference = Infinity;\n\n    // Check numbers around n\n    for (let i = n - Math.abs(m); i <= n + Math.abs(m); i++) {\n        if (i % m === 0) {\n            let difference = Math.abs(n - i);\n\n            if (difference < minDifference ||\n               (difference === minDifference && Math.abs(i) > Math.abs(closest))) {\n                closest = i;\n                minDifference = difference;\n            }\n        }\n    }\n    return closest;\n}\n\n//driver code\nlet n = 13, m = 4;\nconsole.log(closestNumber(n, m));\n\n````\n\n\n\n\n**Output**\n```\n12\n\n```\n### [Expected Approach] By finding Quotient \u2013 O(1) Time and O(1) Space\n\n> We find the value of n/m. Then we find closest of two possibilities. One is q \\* m other is (m \\* (q + 1)) or (m \\* (q \u2013 1)) depending on whether one of the given two numbers is negative or not.\n\nC++\n\n````\n// C++ implementation to find the number closest to n\n// and divisible by m\n#include <bits/stdc++.h>\nusing namespace std;\n\nint closestNumber(int n, int m) {\n    // find the quotient\n    int q = n / m;\n\n    // 1st possible closest number\n    int n1 = m * q;\n\n    // 2nd possible closest number\n    int n2 = (n * m) > 0 ? (m * (q + 1)) : (m * (q - 1));\n\n    // if true, then n1 is the required closest number\n    if (abs(n - n1) < abs(n - n2))\n        return n1;\n\n    // else n2 is the required closest number\n    return n2;\n}\n\nint main() {\n    int n = 13, m = 4;\n    cout << closestNumber(n, m) << endl;\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\nint closestNumber(int n, int m) {\n    // find the quotient\n    int q = n / m;\n\n    // 1st possible closest number\n    int n1 = m * q;\n\n    // 2nd possible closest number\n    int n2 = (n * m) > 0 ? (m * (q + 1)) : (m * (q - 1));\n\n    // if true, then n1 is the required closest number\n    if (abs(n - n1) < abs(n - n2))\n        return n1;\n\n    // else n2 is the required closest number\n    return n2;\n}\n\nint main() {\n    int n = 13, m = 4;\n    printf(\"%d\\n\", closestNumber(n, m));\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java implementation to find the number closest to n\n// and divisible by m\nclass GfG {\n\n    static int closestNumber(int n, int m)  {\n        // find the quotient\n        int q = n / m;\n\n        // 1st possible closest number\n        int n1 = m * q;\n\n        // 2nd possible closest number\n        int n2 = (n * m) > 0 ? (m * (q + 1)) : (m * (q - 1));\n\n        // if true, then n1 is the required closest number\n        if (Math.abs(n - n1) < Math.abs(n - n2))\n            return n1;\n\n        // else n2 is the required closest number\n        return n2;\n    }\n\n    public static void main(String args[]) {\n        int n = 13, m = 4;\n        System.out.println(closestNumber(n, m));\n\n    }\n}\n\n````\n\nPython\n\n````\n# Python 3 implementation to find\n# the number closest to n\n\ndef closestNumber(n, m) :\n    # Find the quotient\n    q = int(n / m)\n\n    # 1st possible closest number\n    n1 = m * q\n\n    # 2nd possible closest number\n    if((n * m) > 0) :\n        n2 = (m * (q + 1))\n    else :\n        n2 = (m * (q - 1))\n\n    # if true, then n1 is the required closest number\n    if (abs(n - n1) < abs(n - n2)) :\n        return n1\n\n    # else n2 is the required closest number\n    return n2\n\n\nif __name__ == \"__main__\":\n  n = 13; m = 4\n  print(closestNumber(n, m))\n\n````\n\nC#\n\n````\n// C# implementation to find the\n// number closest to n and divisible by m\nusing System;\n\nclass GfG {\n\n    static int closestNumber(int n, int m) {\n        // find the quotient\n        int q = n / m;\n\n        // 1st possible closest number\n        int n1 = m * q;\n\n        // 2nd possible closest number\n        int n2 = (n * m) > 0 ? (m * (q + 1)) : (m * (q - 1));\n\n        // if true, then n1 is the required closest number\n        if (Math.Abs(n - n1) < Math.Abs(n - n2))\n            return n1;\n\n        // else n2 is the required closest number\n        return n2;\n    }\n\n    public static void Main()  {\n        int n = 13, m = 4;\n        Console.WriteLine(closestNumber(n, m));\n\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Javascript implementation to find\n// the number closest to n and\n// divisible by m\n\nfunction closestNumber(n, m) {\n\n    // find the quotient\n    let q = parseInt(n / m);\n\n    // 1st possible closest number\n    let n1 = m * q;\n\n    // 2nd possible closest number\n    let n2 = (n * m) > 0 ?\n        (m * (q + 1)) : (m * (q - 1));\n\n    // if true, then n1 is the\n    // required closest number\n    if (Math.abs(n - n1) < Math.abs(n - n2))\n        return n1;\n\n    // else n2 is the required\n    // closest number\n    return n2;\n}\n\n// Driver Code\nlet n = 13;\nlet m = 4;\nconsole.log(closestNumber(n, m));\n\n````\n\n\n\n\n**Output**\n```\n12\n\n```\n\n****Time Complexity:****\nO(1)\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n",
        "metadata": {
            "lesson_id": "ddd30ce5-7b19-476e-ab39-8ea4f71a40f6",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "\n\nGiven two variables, x, and y, swap two variables without using a third variable.\n\n\n![](https://www.geeksforgeeks.org/wp-content/uploads/CommonArticleDesign16.png)\n\n\n\n****Method 1 (Using Addition and subtraction)****\n\n\nThe idea is to get a sum in one of the two given\n\n[numbers](https://www.geeksforgeeks.org/numbers/)\n. The numbers can then be swapped using the sum and subtraction from the sum.\n\n\nC++\n\n````\n// C++ Program to swap two numbers  without\n// using temporary variable\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int x = 10, y = 5;\n\n    // Code to swap 'x' and 'y'\n    x = x + y; // x now becomes 15\n    y = x - y; // y becomes 10\n    x = x - y; // x becomes 5\n    cout << \"After Swapping: x =\" << x << \", y=\" << y;\n}\n\n// This code is contributed by mohit kumar.\n\n````\n\nC\n\n````\n#include <stdio.h>\nint main()\n{\n    int x = 10, y = 5;\n\n    // Code to swap 'x' and 'y'\n    x = x + y; // x now becomes 15\n    y = x - y; // y becomes 10\n    x = x - y; // x becomes 5\n\n    printf(\"After Swapping: x = %d, y = %d\", x, y);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java Program to swap two numbers  without\n// using temporary variable\nimport java.io.*;\n\nclass Geeks {\n\n    public static void main(String a[])\n    {\n        int x = 10;\n        int y = 5;\n        x = x + y;\n        y = x - y;\n        x = x - y;\n        System.out.println(\"After swapping:\"\n                           + \" x = \" + x + \", y = \" + y);\n    }\n}\n\n// This code is contributed by Mayank Tyagi\n\n````\n\nPython\n\n````\nx = 10\ny = 5\n\n# Code to swap 'x' and 'y'\n\n# x now becomes 15\nx = x + y\n\n# y becomes 10\ny = x - y\n\n# x becomes 5\nx = x - y\nprint(\"After Swapping: x =\", x, \" y =\", y)\n\n# This code is contributed\n# by Sumit Sudhakar\n\n````\n\nC#\n\n````\n// Program to swap two numbers  without\n// using temporary variable\nusing System;\n\nclass GFG {\n    public static void Main()\n    {\n        int x = 10;\n        int y = 5;\n\n        x = x + y;\n        y = x - y;\n        x = x - y;\n        Console.WriteLine(\"After swapping: x = \" + x\n                          + \", y = \" + y);\n    }\n}\n\n// This code is contributed by Sam007\n\n````\n\nJavaScript\n\n````\n<script>\n\n// Javascript program to swap two\n// numbers without using temporary\n// variable\n\nlet x = 10, y = 5;\n\n// Code to swap 'x' and 'y'\n\n// x now becomes 15\nx = x + y;\n\n// y becomes 10\ny = x - y;\n\n// x becomes 5\nx = x - y;\n\ndocument.write(\"After Swapping: x =\" + x + \", y=\" + y);\n\n// This code is contributed by mukesh07\n\n</script>\n\n````\n\nPHP\n\n````\n<?php\n// PHP Program to swap two\n// numbers without using\n// temporary variable\n$x = 10; $y = 5;\n\n// Code to swap 'x' and 'y'\n$x = $x + $y; // x now becomes 15\n$y = $x - $y; // y becomes 10\n$x = $x - $y; // x becomes 5\n\necho \"After Swapping: x = \",\n       $x, \", \", \"y = \", $y;\n\n// This code is contributed by m_kit\n?>\n\n````\n\n\n\n\n**Output**\n```\nAfter Swapping: x =5, y=10\n\n```\n\n****Time Complexity:****\nO(1).\n\n\n\n****Auxiliary Space:****\nO(1).\n\n\n****Method 2: (Using Multiplication and division)****\n\n\nMultiplication and division can also be used for swapping.\n\n\n\n\nC++\n\n````\n// C++ Program to swap two numbers without using temporary\n// variable\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{ // NOTE - for this code to work in a generalised sense, y\n  // !- 0 to prevent zero division\n    int x = 10, y = 5;\n\n    if (y == 0) {\n        y = x;\n        x = 0;\n    }\n    else if (x == 0) {\n        x = y;\n        y = 0;\n    }\n    // Code to swap 'x' and 'y'\n    else {\n        x = x * y; // x now becomes 50\n        y = x / y; // y becomes 10\n        x = x / y; // x becomes 5\n    }\n    cout << \"After Swapping: x =\" << x << \", y=\" << y;\n}\n\n// This code is contributed by Aditya Kumar (adityakumar129)\n\n````\n\nC\n\n````\n// C Program to swap two numbers without using temporary\n// variable\n#include <stdio.h>\nint main()\n{\n    int x = 10, y = 5;\n\n    if (y == 0) {\n        y = x;\n        x = 0;\n    }\n    else if (x == 0) {\n        x = y;\n        y = 0;\n    }\n    // Code to swap 'x' and 'y'\n    else {\n        x = x * y; // x now becomes 50\n        y = x / y; // y becomes 10\n        x = x / y; // x becomes 5\n    }\n\n    printf(\"After Swapping: x = %d, y = %d\", x, y);\n\n    return 0;\n}\n\n// This code is contributed by Aditya Kumar (adityakumar129)\n\n````\n\nJava\n\n````\n// Java Program to swap two numbers without using temporary\n// variable\nimport java.io.*;\n\nclass GFG {\n    public static void main(String[] args)\n    {\n        int x = 10;\n        int y = 5;\n\n        if (y == 0) {\n            y = x;\n            x = 0;\n        }\n        else if (x == 0) {\n            x = y;\n            y = 0;\n        }\n        // Code to swap 'x' and 'y'\n        else {\n            x = x * y; // x now becomes 50\n            y = x / y; // y becomes 10\n            x = x / y; // x becomes 5\n        }\n\n        System.out.println(\"After swapping:\"\n                           + \" x = \" + x + \", y = \" + y);\n    }\n}\n\n// This code is contributed by Aditya Kumar (adityakumar129)\n\n````\n\nPython\n\n````\n# Python3 program to\n# swap two numbers\n# without using\n# temporary variable\nx = 10\ny = 5\n\n# code to swap\n# 'x' and 'y'\n\nif y == 0:\n    y = x\n    x = 0\nelif x == 0:\n    x = y\n    y = 0\nelse:\n    x = x * y\n    y = x // y\n    x = x // y\n\n\nprint(\"After Swapping: x =\",\n      x, \" y =\", y)\n\n# This code is contributed\n# by @ajit\n\n````\n\nC#\n\n````\n// C# Program to swap two\n// numbers without using\n// temporary variable\nusing System;\n\nclass GFG {\n    static public void Main()\n    {\n        int x = 10;\n        int y = 5;\n\n        if (y == 0) {\n            y = x;\n            x = 0;\n        }\n        else if (x == 0) {\n            x = y;\n            y = 0;\n        }\n        // Code to swap 'x' and 'y'\n        else {\n            x = x * y; // x now becomes 50\n            y = x / y; // y becomes 10\n            x = x / y; // x becomes 5\n        }\n\n        Console.WriteLine(\"After swapping:\"\n                          + \" x = \" + x + \", y = \" + y);\n    }\n}\n\n// This code is contributed by ajit.\n\n````\n\nJavaScript\n\n````\n<script>\n\n// Javascript program to swap two numbers\n// without using temporary variable\nvar x = 10;\nvar y = 5;\n\n// Code to swap 'x' and 'y'\nif (y == 0)\n{ y = x; x = 0; }\nelse if (x == 0) { x = y; y = 0; }\n    // Code to swap 'x' and 'y'\n  else\n  {x = x * y; // x now becomes 50\n    y = x / y; // y becomes 10\n    x = x / y; // x becomes 5\n    }\n\ndocument.write(\"After swapping:\" + \" x = \" +\n               x + \", y = \" + y);\n\n// This code is contributed by shikhasingrajput\n\n</script>\n\n````\n\n\n\n\n**Output**\n```\nAfter Swapping: x =5, y=10\n\n```\n\n****Time Complexity:****\nO(1).\n\n\n\n****Auxiliary Space:****\nO(1).\n\n\n****Method 3: (Using Bitwise XOR)****\n\n\n\nThe bitwise XOR operator can be used to swap two variables. The XOR of two numbers x and y returns a number that has all the bits as 1 wherever bits of x and y differ. For example, XOR of 10 (In Binary 1010) and 5 (In Binary 0101) is 1111, and XOR of 7 (0111) and 5 (0101) is (0010).\n\n\nC++\n\n````\n// C++ code to swap using XOR\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int x = 10, y = 5;\n    // Code to swap 'x' (1010) and 'y' (0101)\n    x = x ^ y; // x now becomes 15 (1111)\n    y = x ^ y; // y becomes 10 (1010)\n    x = x ^ y; // x becomes 5 (0101)\n    cout << \"After Swapping: x =\" << x << \", y=\" << y;\n    return 0;\n}\n\n// This code is contributed by mohit kumar.\n\n````\n\nC\n\n````\n// C code to swap using XOR\n#include <stdio.h>\nint main()\n{\n    int x = 10, y = 5;\n\n    // Code to swap 'x' (1010) and 'y' (0101)\n    x = x ^ y; // x now becomes 15 (1111)\n    y = x ^ y; // y becomes 10 (1010)\n    x = x ^ y; // x becomes 5 (0101)\n\n    printf(\"After Swapping: x = %d, y = %d\", x, y);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java code to swap using XOR\nimport java.io.*;\n\npublic class GFG {\n\n    public static void main(String a[])\n    {\n        int x = 10;\n        int y = 5;\n\n        // Code to swap 'x' (1010) and 'y' (0101)\n        x = x ^ y; // x now becomes 15 (1111)\n        y = x ^ y; // y becomes 10 (1010)\n        x = x ^ y; // x becomes 5 (0101)\n\n        System.out.println(\"After swap: x = \"\n                           + x + \", y = \" + y);\n    }\n}\n\n// This code is contributed by Mayank Tyagi\n\n````\n\nPython\n\n````\n# Python3 code to swap using XOR\n\nx = 10\ny = 5\n\n# Code to swap 'x' and 'y'\nx = x ^ y; # x now becomes 15 (1111)\ny = x ^ y; # y becomes 10 (1010)\nx = x ^ y; # x becomes 5 (0101)\n\nprint (\"After Swapping: x = \", x, \" y =\", y)\n\n# This code is contributed by\n# Sumit Sudhakar\n\n````\n\nC#\n\n````\n// C# program to swap using XOR\nusing System;\n\nclass GFG {\n    public static void Main()\n    {\n        int x = 10;\n        int y = 5;\n\n        // Code to swap 'x' (1010)\n        // and 'y' (0101)\n\n        // x now becomes 15 (1111)\n        x = x ^ y;\n\n        // y becomes 10 (1010)\n        y = x ^ y;\n\n        // x becomes 5 (0101)\n        x = x ^ y;\n\n        Console.WriteLine(\"After swap: x = \" + x + \", y = \" + y);\n    }\n}\n\n// This code is contributed by ajit\n\n````\n\nJavaScript\n\n````\n<script>\n\n// Javascript code to swap using XOR\n\nlet x = 10, y = 5;\n\n// Code to swap 'x' (1010) and 'y' (0101)\nx = x ^ y; // x now becomes 15 (1111)\ny = x ^ y; // y becomes 10 (1010)\nx = x ^ y; // x becomes 5 (0101)\n\ndocument.write(\"After Swapping: x =\" +\n               x + \", y=\" + y);\n\n// This code is contributed by Mayank Tyagi\n\n</script>\n\n````\n\nPHP\n\n````\n<?php\n\n// Driver Code\n$x = 10;\n$y = 5;\n\n// Code to swap 'x' (1010)\n// and 'y' (0101)\n\n// x now becomes 15 (1111)\n$x = $x ^ $y;\n\n// y becomes 10 (1010)\n$y = $x ^ $y;\n\n// x becomes 5 (0101)\n$x = $x ^ $y;\n\necho \"After Swapping: x = \", $x,\n                \", \", \"y = \", $y;\n\n// This code is contributed by aj_36\n?>\n\n````\n\n\n\n\n**Output**\n```\nAfter Swapping: x =5, y=10\n\n```\n\n****Time Complexity:****\nO(1).\n\n\n\n****Auxiliary Space:****\nO(1).\n\n\n****Problems with the above methods****\n\n\n\n****1)****\nThe multiplication and division-based approach doesn\u2019t work if one of the numbers is 0 as the product becomes 0 irrespective of the other number.\n\n\n\n****2)****\nBoth Arithmetic solutions may cause an arithmetic overflow. If x and y are too large, addition and multiplication may go out of the integer range.\n\n\n\n****3)****\nWhen we use pointers to variable and make a function swap, all the above methods fail when both pointers point to the same variable. Let\u2019s take a look at what will happen in this case if both are pointing to the same variable.\n\n\n// Bitwise XOR based method\n\n\n\nx = x ^ x; // x becomes 0\n\n\n\nx = x ^ x; // x remains 0\n\n\n\nx = x ^ x; // x remains 0\n\n\n\n// Arithmetic based method\n\n\n\nx = x + x; // x becomes 2x\n\n\n\nx = x \u2013 x; // x becomes 0\n\n\n\nx = x \u2013 x; // x remains 0\n\n\nLet us see the following program.\n\n\n\nC++\n\n````\n#include <bits/stdc++.h>\nusing namespace std;\nvoid swap(int* xp, int* yp)\n{\n    *xp = *xp ^ *yp;\n    *yp = *xp ^ *yp;\n    *xp = *xp ^ *yp;\n}\n\n// Driver code\nint main()\n{\n    int x = 10;\n    swap(&x, &x);\n    cout << \"After swap(&x, &x): x = \" << x;\n    return 0;\n}\n\n// This code is contributed by rathbhupendra\n\n````\n\nC\n\n````\n#include <stdio.h>\nvoid swap(int* xp, int* yp)\n{\n    *xp = *xp ^ *yp;\n    *yp = *xp ^ *yp;\n    *xp = *xp ^ *yp;\n}\n\nint main()\n{\n    int x = 10;\n    swap(&x, &x);\n    printf(\"After swap(&x, &x): x = %d\", x);\n    return 0;\n}\n\n````\n\nJava\n\n````\nclass GFG {\n    static void swap(int[] xp, int[] yp)\n    {\n        xp[0] = xp[0] ^ yp[0];\n        yp[0] = xp[0] ^ yp[0];\n        xp[0] = xp[0] ^ yp[0];\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        int[] x = { 10 };\n        swap(x, x);\n        System.out.println(\"After swap(&x, &x): x = \" + x[0]);\n    }\n}\n\n// This code is contributed by Aditya Kumar (adityakumar129)\n\n````\n\nPython\n\n````\ndef swap(xp, yp):\n\n    xp[0] = xp[0] ^ yp[0]\n    yp[0] = xp[0] ^ yp[0]\n    xp[0] = xp[0] ^ yp[0]\n\n\n# Driver code\nx = [10]\nswap(x, x)\nprint(\"After swap(&x, &x): x = \", x[0])\n\n# This code is contributed by SHUBHAMSINGH10\n\n````\n\nC#\n\n````\n// C# program to implement\n// the above approach\nusing System;\nclass GFG {\n\n    static void swap(int[] xp, int[] yp)\n    {\n        xp[0] = xp[0] ^ yp[0];\n        yp[0] = xp[0] ^ yp[0];\n        xp[0] = xp[0] ^ yp[0];\n    }\n\n    // Driver code\n    static void Main()\n    {\n        int[] x = { 10 };\n        swap(x, x);\n        Console.WriteLine(\"After swap(&x,\"\n                          + \"&x): x = \" + x[0]);\n    }\n}\n\n// This code is contributed by divyeshrabadiya07\n\n````\n\nJavaScript\n\n````\n<script>\n\n    function swap(xp,yp)\n    {\n        xp[0] = xp[0] ^ yp[0];\n        yp[0] = xp[0] ^ yp[0];\n        xp[0] = xp[0] ^ yp[0];\n    }\n\n    // Driver code\n\n    let x=[10];\n    swap(x, x);\n    document.write(\"After swap(&x, &x): x = \"\n                           + x[0]);\n\n\n    // This code is contributed by unknown2108\n\n</script>\n\n````\n\nPHP\n\n````\n<?php\nfunction swap(&$xp, &$yp)\n{\n    $xp = $xp ^ $yp;\n    $yp = $xp ^ $yp;\n    $xp = $xp ^ $yp;\n}\n\n// Driver Code\n$x = 10;\nswap($x, $x);\nprint(\"After swap(&x, &x): x = \" . $x);\n\n// This code is contributed\n// by chandan_jnu\n?>\n\n````\n\n\n\n\n**Output**\n```\nAfter swap(&x, &x): x = 0\n\n```\n\n****Time Complexity:****\nO(1).\n\n\n\n****Auxiliary Space:****\nO(1).\n\n\nSwapping a variable with itself may be needed in many standard algorithms. The above problem can be avoided by putting a condition before swapping.\n\n\nC++\n\n````\n#include <bits/stdc++.h>\nusing namespace std;\nvoid swap(int* xp, int* yp)\n{\n\n    // Check if the two addresses are same\n    if (xp == yp)\n        return;\n    *xp = *xp + *yp;\n    *yp = *xp - *yp;\n    *xp = *xp - *yp;\n}\n\n// Driver Code\nint main()\n{\n    int x = 10;\n    swap(&x, &x);\n    cout << \"After swap(&x, &x): x = \" << x;\n    return 0;\n}\n\n// This code is contributed by rathbhupendra\n\n````\n\nC\n\n````\n#include <stdio.h>\nvoid swap(int* xp, int* yp)\n{\n    if (xp == yp) // Check if the two addresses are same\n        return;\n    *xp = *xp + *yp;\n    *yp = *xp - *yp;\n    *xp = *xp - *yp;\n}\nint main()\n{\n    int x = 10;\n    swap(&x, &x);\n    printf(\"After swap(&x, &x): x = %d\", x);\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program of above approach\nclass GFG {\n\n    static void swap(int xp, int yp)\n    {\n        if (xp == yp) // Check if the two addresses are same\n            return;\n        xp = xp + yp;\n        yp = xp - yp;\n        xp = xp - yp;\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        int x = 10;\n        swap(x, x);\n        System.out.println(\"After swap(&x, &x): x = \" + x);\n    }\n}\n\n// This code is Contributed by Code_Mech.\n\n````\n\nPython\n\n````\n# Python3 program of above approach\ndef swap(xp, yp):\n\n    # Check if the two addresses are same\n    if (xp[0] == yp[0]):\n        return\n    xp[0] = xp[0] + yp[0]\n    yp[0] = xp[0] - yp[0]\n    xp[0] = xp[0] - yp[0]\n\n\n# Driver Code\nx = [10]\nswap(x, x)\nprint(\"After swap(&x, &x): x = \", x[0])\n\n# This code is contributed by SHUBHAMSINGH10\n\n````\n\nC#\n\n````\n// C# program of above approach\nusing System;\nclass GFG {\n\n    static void swap(int xp, int yp)\n    {\n        if (xp == yp) // Check if the two addresses are same\n            return;\n        xp = xp + yp;\n        yp = xp - yp;\n        xp = xp - yp;\n    }\n\n    // Driver code\n    public static void Main()\n    {\n        int x = 10;\n        swap(x, x);\n        Console.WriteLine(\"After swap(&x, &x): x = \" + x);\n    }\n}\n\n// This code is Contributed by Code_Mech.\n\n````\n\nJavaScript\n\n````\n<script>\n   function swap(xp, yp)\n{\n\n    // Check if the two addresses are same\n    if (xp == yp)\n        return;\n    xp[0] = xp[0] + yp[0];\n    yp[0] = xp[0] - yp[0];\n    xp[0]= xp[0] - yp[0];\n}\n\n// Driver Code\n     x = 10;\n    swap(x, x);\n    document.write(\"After swap(&x , &x) : x = \" + x);\n//This code is contributed by simranarora5sos\n</script>\n\n````\n\nPHP\n\n````\n<?php\nfunction swap($xp, $yp)\n{\n    // Check if the two addresses\n    // are same\n    if ($xp == $yp)\n        return;\n    $xp = $xp + $yp;\n    $yp = $xp - $yp;\n    $xp = $xp - $yp;\n}\n\n// Driver Code\n$x = 10;\nswap($x, $x);\necho(\"After swap(&x, &x): x = \" . $x);\nreturn 0;\n\n// This code is contributed\n// by Code_Mech.\n\n````\n\n\n\n\n**Output**\n```\nAfter swap(&x, &x): x = 10\n\n```\n\n****Time Complexity:****\nO(1).\n\n\n\n****Auxiliary Space:****\nO(1).\n\n\n****Method 4 (A mixture of bitwise operators and arithmetic operators)****\n\n\n\nThe idea is the same as discussed in\n\n****Method 1****\nbut uses Bitwise addition and subtraction for swapping.\n\n\nBelow is the implementation of the above approach.\n\n\nC++\n\n````\n// C++ program to swap two numbers\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to swap the numbers.\nvoid swap(int& a, int& b)\n{\n    // same as a = a + b\n    a = (a & b) + (a | b);\n    // same as b = a - b\n    b = a + (~b) + 1;\n    // same as a = a - b\n    a = a + (~b) + 1;\n}\n\n// Driver Code\nint main()\n{\n    int a = 5, b = 10;\n    // Function Call\n    swap(a, b);\n    cout << \"After swapping: a = \" << a << \", b = \" << b;\n    return 0;\n}\n\n// This code is contributed by Aditya Kumar (adityakumar129)\n\n````\n\nC\n\n````\n// C program to swap two numbers\n#include <stdio.h>\n\n// Function to swap the numbers.\nvoid swap(int a, int b)\n{\n    // same as a = a + b\n    a = (a & b) + (a | b);\n    // same as b = a - b\n    b = a + (~b) + 1;\n    // same as a = a - b\n    a = a + (~b) + 1;\n      printf(\"After swapping: a = %d , b = %d \",a,b);\n}\n\n// Driver Code\nint main()\n{\n    int a = 5, b = 10;\n    // Function Call\n    swap(a, b);\n    return 0;\n}\n\n// This code is contributed by Aditya Kumar (adityakumar129)\n\n````\n\nJava\n\n````\n// Java program to swap two numbers\nimport java.io.*;\n\nclass GFG {\n    public static void swap(int a, int b)\n    {\n        // same as a = a + b\n        a = (a & b) + (a | b);\n        // same as b = a - b\n        b = a + (~b) + 1;\n        // same as a = a - b\n        a = a + (~b) + 1;\n        System.out.print(\"After swapping: a = \" + a + \", b = \" + b);\n    }\n    public static void main(String[] args)\n    {\n        int a = 5, b = 10;\n        // Function Call\n        swap(a, b);\n    }\n}\n\n// This code is contributed by Aditya Kumar (adityakumar129)\n\n````\n\nPython\n\n````\n# Python3 program to swap two numbers\n\n# Function to swap the numbers\n\n\ndef swap(a, b):\n\n    # Same as a = a + b\n    a = (a & b) + (a | b)\n\n    # Same as b = a - b\n    b = a + (~b) + 1\n\n    # Same as a = a - b\n    a = a + (~b) + 1\n\n    print(\"After Swapping: a = \", a, \", b = \", b)\n\n\n# Driver code\na = 5\nb = 10\n\n# Function call\nswap(a, b)\n\n# This code is contributed by bunnyram19\n\n````\n\nC#\n\n````\n// C# program to swap two numbers\nusing System;\nclass GFG {\n\n    static void swap(int a, int b)\n    {\n        // same as a = a + b\n        a = (a & b) + (a | b);\n\n        // same as b = a - b\n        b = a + (~b) + 1;\n\n        // same as a = a - b\n        a = a + (~b) + 1;\n\n        Console.Write(\"After swapping: a = \" + a\n                      + \", b = \" + b);\n    }\n\n    static void Main()\n    {\n        int a = 5, b = 10;\n\n        // Function Call\n        swap(a, b);\n    }\n}\n\n// This code is contributed by divyesh072019\n\n````\n\nJavaScript\n\n````\n<script>\n    // Javascript program to swap two numbers\n\n    function swap(a, b)\n    {\n        // same as a = a + b\n        a = (a & b) + (a | b);\n\n        // same as b = a - b\n        b = a + (~b) + 1;\n\n        // same as a = a - b\n        a = a + (~b) + 1;\n\n        document.write(\"After swapping: a = \" + a + \", b = \" + b);\n    }\n\n    let a = 5, b = 10;\n\n    // Function Call\n    swap(a, b);\n\n    // This code is contributed by suresh07.\n</script>\n\n````\n\nPHP\n\n````\n<?php\n\n\n// Driver Code\n$a = 5;\n$b = 10;\n\necho(\"Before swap(a and b) \" . $a . \"and\". $b.\"<br>\");\n// same as a = a + b\n    $a = ($a & $b) + ($a | $b);\n\n    // same as b = a - b\n    $b = $a + (~$b) + 1;\n\n    // same as a = a - b\n    $a = $a + (~$b) + 1;\n\necho(\"After swap(a and b) \" . $a. \"and\". $b);\nreturn 0;\n\n?>\n\n````\n\n\n\n\n**Output**\n```\nAfter swapping: a = 10, b = 5\n\n```\n\n****Time Complexity:****\nO(1)\n\n\n\n****Auxiliary Space:****\nO(1), since no extra space has been taken.\n\n\n****Method 5 (One Line Expression)****\n\n\nWe can write only one line to swap two numbers.\n\n\n* x = x ^ y ^ (y = x);\n* x = x + y \u2013 (y = x);\n* x = (x \\* y) / (y = x);\n* x , y = y, x (In Python)\n\nC++\n\n````\n#include <iostream>\nusing namespace std;\n\nint main(){\n    int x = 10, y = 5;\n    x = (x * y) / (y = x);\n    cout << x << \" \" << y;\n    return 0;\n}\n\n// This code is contributed by isha307\n\n````\n\nC\n\n````\n#include <stdio.h>\n\nint main() {\n    int x = 10, y = 5;\n    x = (x * y) / (y = x);\n    printf(\"After Swapping: x = %d, y = %d\", x, y);\n    return 0;\n}\n\n// This code is contributed by isha307\n\n````\n\nJava\n\n````\n/*package whatever //do not write package name here */\nimport java.io.*;\n\nclass GFG {\n    public static void main(String[] args)\n    {\n        int x = 10;\n        int y = 5;\n        x = (x * y) / (y = x);\n        System.out.println(\"After swapping:\"\n                           + \" x = \" + x + \", y = \" + y);\n    }\n}\n\n// This code is contributed by isha307\n\n````\n\nPython\n\n````\n# Python3 program to swap two numbers\n\n# Function to swap the numbers\ndef swap(x, y):\n  x , y = y, x\n  print(\"After Swapping: x = \", x, \", y = \", y)\n\n# Driver code\nx = 10\ny = 5\n\n# Function call\nswap(x, y)\n\n# This code is contributed by kothavvsaakash\n\n````\n\nC#\n\n````\n// C# program to swap two numbers\n\nusing System;\n\npublic class GFG\n{\n    static public void Main ()\n    {\n        int x = 10;\n        int y = 5;\n        x = (x * y) / (y = x);\n        Console.Write(\"After swapping:\"  + \" x = \" + x + \", y = \" + y);\n    }\n}\n\n// This code is contributed by kothavvsaakash\n\n````\n\nJavaScript\n\n````\n<script>\n\n// Javascript program to swap two\n// numbers without using temporary\n// variable\n\nlet x = 10, y = 5;\n\n// Code to swap 'x' and 'y'\nx = (x * y)/(x = y);\n\ndocument.write(\"After Swapping: x =\" + x + \", y=\" + y);\n\n// This code is contributed by Abhijeet Kumar(abhijeet19403)\n\n</script>\n\n````\n\n\n\n\n**Output**\n```\n5 10\n\n```\n\n****Time Complexity:****\nO(1)\n\n\n\n****Auxiliary Space:****\nO(1)\n",
        "metadata": {
            "lesson_id": "7e9a63b3-707f-46f9-a983-79eab80f9bce",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "\nGiven a number n, find the sum of the first natural numbers.\n\n\n****Examples :****\n\n\n> ****Input:****\n> n = 3\n>\n>\n>\n> ****Output:****\n> 6\n>\n>\n>\n> ****Explanation****\n> : Note that 1 + 2 + 3 = 6\n>\n>\n>\n>\n>\n> ****Input****\n> : 5\n>\n>\n>\n> ****Output****\n> : 15\n>\n>\n>\n> ****Explanation****\n> : Note that 1 + 2 + 3 + 4 + 5 = 15\n\n### Naive Solution \u2013 O(n) Time and O(1) Space\n\n\nCalculate the sum of all integers from 1 to\n\n`n`\nby iterating through a loop.\n\n\nC++\n\n````\n// CPP program to find sum of first\n// n natural numbers.\n#include <iostream>\nusing namespace std;\n\nint findSum(int n)\n{\n    int sum = 0;\n    for (int x = 1; x <= n; x++)\n        sum = sum + x;\n    return sum;\n}\n\n// Driver code\nint main()\n{\n    int n = 5;\n    cout << findSum(n);\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find sum of first\n// n natural numbers.\n#include <stdio.h>\n\nint findSum(int n)\n{\n    int sum = 0;\n    for (int x = 1; x <= n; x++)\n        sum = sum + x;\n    return sum;\n}\n\n// Driver code\nint main()\n{\n    int n = 5;\n    printf(\"%d\", findSum(n));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// JAVA program to find sum of first\n// n natural numbers.\nimport java.io.*;\n\nclass GfG{\n    static int findSum(int n)\n    {\n        int sum = 0;\n        for (int x = 1; x <= n; x++)\n            sum = sum + x;\n        return sum;\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        int n = 5;\n        System.out.println(findSum(n));\n    }\n}\n\n// This code is contributed by Nikita Tiwari.\n\n````\n\nPython\n\n````\n# PYTHON program to find sum of first\n# n natural numbers.\n\ndef findSum(n):\n    sum = 0\n    x = 1\n    while x <= n:\n        sum = sum + x\n        x = x + 1\n    return sum\n\n\n# Driver code\nn = 5\nprint findSum(n)\n\n````\n\nC#\n\n````\n// C# program to find sum of first\n// n natural numbers.\nusing System;\n\nclass GfG{\n\n    static int findSum(int n)\n    {\n        int sum = 0;\n        for (int x = 1; x <= n; x++)\n            sum = sum + x;\n        return sum;\n    }\n\n    // Driver code\n    public static void Main()\n    {\n        int n = 5;\n        Console.Write(findSum(n));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Javascript program to find sum of first n natural numbers.\n\nfunction findSum(n)\n{\n   let sum = 0;\n   for (let x = 1; x <= n; x++)\n     sum = sum + x;\n   return sum;\n}\n\nlet n = 5;\nconsole.log(findSum(n));\n\n````\n\nPHP\n\n````\n<?php\n// PHP program to find sum of first\n// n natural numbers.\n\nfunction findSum($n)\n{\n$sum = 0;\nfor ($x = 1; $x <= $n; $x++)\n    $sum = $sum + $x;\nreturn $sum;\n}\n\n// Driver code\n$n = 5;\necho findSum($n);\n\n?>\n\n````\n\n\n\n\n**Output**\n```\n15\n```\n### Expected Approach \u2013 O(1) Time and O(1) Space\n\n\nAn\n\n****efficient solution****\nis to use the below formula.\n\n\n> ****Sum of first n natural numbers = (n \\* (n+1)) / 2****\n>\n>\n> For example: n = 5\n>\n>\n>\n> Sum = (5 \\* (5 + 1)) / 2 = (5 \\* 6) / 2 = 30 / 2 = 15\n\n****How does this work?****\n\n> ****We can prove this formula using induction.****\n>\n>\n>\n>\n> It is true for n = 1 and n = 2\n>\n>\n>\n> For n = 1, sum = 1 \\* (1 + 1)/2 = 1\n>\n>\n>\n> For n = 2, sum = 2 \\* (2 + 1)/2 = 3\n>\n>\n>\n>\n>\n> Let it be true for k = n-1.\n>\n>\n>\n>\n>\n> Sum of k numbers = (k \\* (k+1))/2\n>\n>\n>\n> Putting k = n-1, we get\n>\n>\n>\n> Sum of k numbers = ((n-1) \\* (n-1+1))/2\n>\n>\n>\n> = (n \u2013 1) \\* n / 2\n>\n>\n>\n>\n>\n> If we add n, we get,\n>\n>\n>\n> Sum of n numbers = n + (n \u2013 1) \\* n / 2\n>\n>\n>\n> = (2n + n\n>\n> 2\n> \u2013 n)/2\n>\n>\n>\n> = n \\* (n + 1)/2\n\nC++\n\n````\n// Efficient CPP program to find sum of first\n// n natural numbers.\n#include<iostream>\nusing namespace std;\n\nint findSum(int n)\n{\n   return n * (n + 1) / 2;\n}\n\n// Driver code\nint main()\n{\n  int n = 5;\n  cout << findSum(n);\n  return 0;\n}\n\n````\n\nC\n\n````\n// Efficient C program to find\n// sum of first n natural numbers.\n#include<stdio.h>\n\nint findSum(int n)\n{\n   return n * (n + 1) / 2;\n}\n\n// Driver code\nint main()\n{\n  int n = 5;\n  printf(\"%d\", findSum(n));\n  return 0;\n}\n\n````\n\nJava\n\n````\n// Efficient JAVA program to find sum\n// of first n natural numbers.\nimport java.io.*;\n\nclass GfG{\n\n    static int findSum(int n)\n    {\n        return n * (n + 1) / 2;\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        int n = 5;\n        System.out.println(findSum(n));\n    }\n}\n\n````\n\nPython\n\n````\n# Efficient CPP program to find sum\n# of first n natural numbers.\n\ndef findSum(n) :\n    return n * (n + 1) / 2\n\n# Driver code\nn = 5\nprint findSum(n)\n\n````\n\nC#\n\n````\n// Efficient C# program to find sum\n// of first n natural numbers.\nusing System;\n\nclass GFG{\n\n    static int findSum(int n)\n    {\n        return n * (n + 1) / 2;\n    }\n\n    // Driver code\n    public static void Main()\n    {\n        int n = 5;\n        Console.Write(findSum(n));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// javascript Program to find the average\n// of sum of first n natural numbers\n\nfunction findSum(n)\n{\n    return n * (n + 1) / 2;\n}\nvar n = 5;\nconsole.log(findSum(n));\n\n````\n\nphp\n\n````\n<?php\n// Efficient PHP program to find sum\n// of first n natural numbers.\n\nfunction findSum($n)\n{\n    return ($n * ($n + 1) / 2);\n}\n\n// Driver code\n$n = 5;\necho findSum($n);\n\n?>\n\n````\n\n\n\n\n**Output**\n```\n15\n```\n\n****Note:****\nThe above program causes\n\n****overflow,****\neven if the\n\n****result****\nis not beyond the\n\n****integer limit****\n. We can avoid overflow up to some extent by\n\n****dividing first****\n.\n\n\nC++\n\n````\n// n natural numbers that avoids overflow if\n// result is going to be within limits.\n#include<iostream>\nusing namespace std;\n\nint findSum(int n)\n{\n   if (n % 2 == 0)\n\n      // Here multiplying by 1LL help to\n      // perform calculations in long long,\n      // so that answer should not be overflowed\n      return (n / 2) * 1LL * (n + 1);\n\n   // If n is odd, (n+1) must be even\n   else\n\n      // Here multiplying by 1LL help to\n      // perform calculations in long long,\n      // so that answer should not be overflowed\n      return  ((n + 1) / 2) * 1LL * n;\n}\n\n// Driver code\nint main()\n{\n  int n = 5;\n  cout << findSum(n);\n  return 0;\n}\n\n````\n\nC\n\n````\n// Efficient C program to find\n// sum of first n natural numbers\n// that avoids overflow if result\n// is going to be within limits.\n#include<stdio.h>\n\nint findSum(int n)\n{\n   if (n % 2 == 0)\n\n      // Here multiplying by 1LL help to\n      // perform calculations in long long,\n      // so that answer should not be overflowed\n      return (n / 2) * 1LL * (n + 1);\n\n   // If n is odd, (n+1) must be even\n   else\n\n      // Here multiplying by 1LL help to\n      // perform calculations in long long,\n      // so that answer should not be overflowed\n      return  ((n + 1) / 2) * 1LL * n;\n}\n\n// Driver code\nint main()\n{\n  int n = 5;\n  printf(\"%d\", findSum(n));\n  return 0;\n}\n\n````\n\nJava\n\n````\n// n natural numbers that avoids overflow if\n// result is going to be within limits.\nimport java.io.*;\n\nclass GfG{\n\n    // Returns sum of first n natural\n    // numbers\n    static int findSum(int n)\n    {\n        if (n % 2 == 0)\n            return (n / 2) * (n + 1);\n\n        // If n is odd, (n+1) must be even\n        else\n            return ((n + 1) / 2) * n;\n    }\n\n    // Driver code\n    public static void main(String args[])\n    {\n        int n = 5;\n        System.out.println(findSum(n));\n    }\n}\n\n````\n\nPython\n\n````\n# Efficient Python program to find the sum\n# of first n natural numbers that avoid\n# overflow if the result is going to be\n# within limits.\n\n# Returns sum of first n natural\n# numbers\ndef findSum(n):\n    if (n % 2 == 0):\n        return (n / 2) * (n + 1)\n\n   # If n is odd, (n+1) must be even\n    else:\n        return ((n + 1) / 2) * n\n\n\n# Driver code\nn = 5\nprint findSum(n)\n\n````\n\nC#\n\n````\n// Efficient C# program to find the sum of first\n// n natural numbers that avoid overflow if\n// result is going to be within limits.\nusing System;\n\nclass GfG{\n\n    static int findSum(int n)\n    {\n        if (n % 2 == 0)\n            return (n / 2) * (n + 1);\n\n        // If n is odd, (n+1) must be even\n        else\n            return ((n + 1) / 2) * n;\n    }\n\n    // Driver code\n    public static void Main()\n    {\n        int n = 5;\n        Console.Write(findSum(n));\n    }\n}\n\n````\n\nJavaScript\n\n````\n//efficient approach using  javascript to find the average\n// of sum of first n natural numbers\n\n// Return the average of sum\n// of first n even numbers\nfunction findSum(n)\n{\n    if (n % 2 == 0)\n        return (n / 2) * (n + 1)\n\n// If n is odd, (n+1) must be even\n    else\n    return ((n + 1) / 2) * n\n\n}\nvar n = 5;\nconsole.log(findSum(n));\n\n````\n\nPHP\n\n````\n<?php\n// Efficient php program to find sum of first\n// n natural numbers that avoids overflow if\n// result is going to be within limits.\n\nfunction findSum($n)\n{\n    if ($n % 2 == 0)\n        return ($n / 2) *\n               ($n + 1);\n\n    // If n is odd, (n+1) must be even\n    else\n        return (($n + 1) / 2) * $n;\n}\n\n// Driver code\n$n = 5;\necho findSum($n);\n?>\n\n````\n\n\n\n\n**Output**\n```\n15\n```\n",
        "metadata": {
            "lesson_id": "52069685-2d95-4f5f-9678-294844ede87b",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "****Learn Basics of Singly Linked List:****\n-------------------------------------------\n\n1. [Basic Terminologies in Linked List](https://www.geeksforgeeks.org/what-is-linked-list/)\n2. [Singly Linked List Tutorial](https://www.geeksforgeeks.org/singly-linked-list-tutorial/)\n3. [Linked List vs Array](https://www.geeksforgeeks.org/linked-list-vs-array/)\n\n****Basic Operations of Singly Linked List:****\n-----------------------------------------------\n\n1. [Linked List Insertion](https://www.geeksforgeeks.org/linked-list-set-2-inserting-a-node/)\n2. [Search an element in a Linked List (Iterative and Recursive)](https://www.geeksforgeeks.org/search-an-element-in-a-linked-list-iterative-and-recursive/)\n3. [Find Length of a Linked List (Iterative and Recursive)](https://www.geeksforgeeks.org/find-length-of-a-linked-list-iterative-and-recursive/)\n4. [Reverse a linked list](https://www.geeksforgeeks.org/write-a-function-to-reverse-the-nodes-of-a-linked-list/)\n5. [Linked List Deletion (Deleting a given key)](https://www.geeksforgeeks.org/linked-list-set-3-deleting-node/)\n6. [Linked List Deletion (Deleting a key at given position)](https://www.geeksforgeeks.org/delete-a-linked-list-node-at-a-given-position/)\n7. [Write a function to delete a Linked List](https://www.geeksforgeeks.org/write-a-function-to-delete-a-linked-list/)\n\n****Easy Problems on Singly Linked List:****\n--------------------------------------------\n\n* [Identical Linked Lists](https://www.geeksforgeeks.org/identical-linked-lists/)\n* [Print the middle of a given linked list](https://www.geeksforgeeks.org/write-a-c-function-to-print-the-middle-of-the-linked-list/)\n* [Write a function to get Nth node in a Linked List](https://www.geeksforgeeks.org/write-a-function-to-get-nth-node-in-a-linked-list/)\n* [Nth node from the end of a Linked List](https://www.geeksforgeeks.org/nth-node-from-the-end-of-a-linked-list/)\n* [Move last element to front of a given Linked List](https://www.geeksforgeeks.org/move-last-element-to-front-of-a-given-linked-list/)\n* [Make middle node head in a linked list](https://www.geeksforgeeks.org/make-middle-node-head-linked-list/)\n* [Delete alternate nodes of a Linked List](https://www.geeksforgeeks.org/delete-alternate-nodes-of-a-linked-list/)\n* [Add 1 to a number represented as linked list](https://www.geeksforgeeks.org/add-1-number-represented-linked-list/)\n* [Add two numbers represented by linked lists](https://www.geeksforgeeks.org/add-two-numbers-represented-by-linked-list/)\n* [Subtract Two Numbers represented as Linked Lists](https://www.geeksforgeeks.org/subtract-two-numbers-represented-as-linked-lists/)\n* [Find the sum of last n nodes of the given Linked List](https://www.geeksforgeeks.org/find-sum-last-n-nodes-given-linked-list/)\n* [Pairwise swap elements of a given linked list](https://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list/)\n* [Remove every k-th node of the linked list](https://www.geeksforgeeks.org/remove-every-k-th-node-linked-list/)\n* [Remove duplicates from a sorted linked list](https://www.geeksforgeeks.org/remove-duplicates-from-a-sorted-linked-list/)\n\n****Intermediate Problems on Singly Linked List:****\n----------------------------------------------------\n\n* [Detect loop in a linked list](https://www.geeksforgeeks.org/write-a-c-function-to-detect-loop-in-a-linked-list/)\n* [Find length of loop in linked list](https://www.geeksforgeeks.org/find-length-of-loop-in-linked-list/)\n* [Function to check if a singly linked list is palindrome](https://www.geeksforgeeks.org/function-to-check-if-a-singly-linked-list-is-palindrome/)\n* [Remove duplicates from an unsorted linked list](https://www.geeksforgeeks.org/remove-duplicates-from-an-unsorted-linked-list/)\n* [Remove all occurrences of duplicates from a sorted Linked List](https://www.geeksforgeeks.org/remove-occurrences-duplicates-sorted-linked-list/)\n* [Swap nodes in a linked list without swapping data](https://www.geeksforgeeks.org/swap-nodes-in-a-linked-list-without-swapping-data/)\n* [Intersection point of two Linked Lists.](https://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/)\n* [Iteratively Reverse a linked list using only 2 pointers (An Interesting Method)](https://www.geeksforgeeks.org/iteratively-reverse-a-linked-list-using-only-2-pointers/)\n* [Segregate even and odd nodes in a Linked List](https://www.geeksforgeeks.org/segregate-even-and-odd-elements-in-a-linked-list/)\n* [Alternate Odd and Even Nodes in a Singly Linked List](https://www.geeksforgeeks.org/alternate-odd-even-nodes-singly-linked-list/)\n* [Rearrange a Linked List in Zig-Zag fashion](https://www.geeksforgeeks.org/linked-list-in-zig-zag-fashion/)\n* [Adding two polynomials using Linked List](https://www.geeksforgeeks.org/adding-two-polynomials-using-linked-list/)\n* [Union and Intersection of two Linked Lists](https://www.geeksforgeeks.org/union-and-intersection-of-two-linked-lists/)\n* [Sort linked list which is already sorted on absolute values](https://www.geeksforgeeks.org/sort-linked-list-already-sorted-absolute-values/)\n\n****Hard Problems on Singly Linked List:****\n--------------------------------------------\n\n* [Reverse a Linked List in groups of given size](https://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/)\n* [Flattening a Linked List](https://www.geeksforgeeks.org/flattening-a-linked-list/)\n* [Reverse alternate K nodes in a Singly Linked List](https://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/)\n* [Alternating split of a given Singly Linked List](https://www.geeksforgeeks.org/alternating-split-of-a-given-singly-linked-list/)\n* [Delete nodes which have a greater value on right side](https://www.geeksforgeeks.org/delete-nodes-which-have-a-greater-value-on-right-side/)\n* [Given a linked list of line segments, remove middle points](https://www.geeksforgeeks.org/given-linked-list-line-segments-remove-middle-points/)\n* [Clone a linked list with next and random pointer](https://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/)\n* [Rearrange a given linked list in-place.](https://www.geeksforgeeks.org/rearrange-a-given-linked-list-in-place/)\n* [Select a Random Node from a Singly Linked List](https://www.geeksforgeeks.org/select-a-random-node-from-a-singly-linked-list/)\n* [In-place Merge two linked lists without changing links of first list](https://www.geeksforgeeks.org/in-place-merge-two-linked-list-without-changing-links-of-first-list/)\n* [Length of longest palindrome list in a linked list using O(1) extra space](https://www.geeksforgeeks.org/length-longest-palindrome-list-linked-list-using-o1-extra-space/)\n* [Rotate Linked List block wise](https://www.geeksforgeeks.org/rotate-linked-list-block-wise/)\n* [Count rotations in sorted and rotated linked list](https://www.geeksforgeeks.org/count-rotations-sorted-rotated-linked-list/)\n\n****Quick Links:****\n--------------------\n\n* ['Practice Problems' on Linked List](https://www.geeksforgeeks.org/explore?page=2&category=Linked%20List&sortBy=difficulty&itm_source=geeksforgeeks&itm_medium=main_header&itm_campaign=practice_header)\n    * ['Videos' on Linked List](https://www.youtube.com/playlist?list=PLqM7alHXFySH41ZxzrPNj2pAYPOI8ITe7)\n* ['Quizzes' on Linked List](https://www.geeksforgeeks.org/data-structure-gq/linked-list-gq/)\n",
        "metadata": {
            "lesson_id": "0aeea379-45ac-4886-bc6e-ebee7abcae78",
            "course_id": "8ff4ea92-41f2-4d49-b230-0281874efb2d",
            "course_name": "Introduction to DSA II",
            "lesson_description": "Singly linked list is a linear data structure in which the elements are not stored in contiguous memory locations and each element is connected only to its next element using a pointer.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Properties of Heap:\n-------------------\n\n* The minimum or maximum element is always at the root of the heap, allowing constant-time access.\n* The relationship between a parent node at index\n\n  ****\u2018i\u2019****\n  and its children is given by the formulas: left child at index\n\n  ****2i+1****\n  and right child at index\n\n  ****2i+2****\n  for 0-based indexing of node numbers.\n* As the tree is complete binary, all levels are filled except possibly the last level. And the last level is filled from left to right.\n* When we insert an item, we insert it at the last available slot and then rearrange the nodes so that the heap property is maintained.\n* When we remove an item, we swap root with the last node to make sure either the max or min item is removed. Then we rearrange the remaining nodes to ensure heap property (max or min)\n\nOperations Supported by Heap:\n-----------------------------\n\n\nOperations supported by\n\n****min \u2013 heap****\nand\n\n****max \u2013 heap****\nare same. The difference is just that min-heap contains minimum element at root of the tree and max \u2013 heap contains maximum element at the root of the tree.\n\n\n****Heapify:****\nIt is the process to rearrange the elements to maintain the property of heap data structure. It is done when root is removed (we replace root with the last node and then call heapify to ensure that heap property is maintained) or heap is built (we call heapify from the last internal node to root) to make sure that the heap property is maintained. This operation also takes\n\n****O(log n)****\ntime.\n\n\n* For\n\n  ****max-heap,****\n  it\n\n\n  makes sure the maximum element is the root of that binary tree and all descendants also follow the same property.\n* For\n\n  ****min-heap,****\n  it balances in such a way that the minimum element is the root and all descendants also follow the same property.\n\n****Insertion****\n: When a new element is inserted into the heap, it can disrupt the heap\u2019s properties. To restore and maintain the heap structure, a heapify operation is performed. This operation ensures the heap properties are preserved and has a time complexity of\n\n****O(log n)****\n.\n\n\n\n****Examples:****\n\n> Assume initially heap(taking\n>\n> ****max-heap****\n> ) is as follows\n>\n>\n> 8\n>\n>\n>\n> /   \\\n>\n>\n>\n> 4     5\n>\n>\n>\n> / \\\n>\n>\n>\n> 1   2\n>\n>\n> Now if we insert 10 into the heap\n>\n>\n>\n> 8\n>\n>\n>\n> /      \\\n>\n>\n>\n> 4       5\n>\n>\n>\n> /  \\      /\n>\n>\n>\n> 1     2  10\n>\n>\n> After repeatedly comparing with the parent nodes and swapping if required, the final heap will be look like this\n>\n>\n>\n> 10\n>\n>\n>\n> /    \\\n>\n>\n>\n> 4      8\n>\n>\n>\n> /  \\     /\n>\n>\n>\n> 1     2 5\n\n### Deletion:\n\n* If we delete the element from the heap it always deletes the root element of the tree and replaces it with the last element of the tree.\n* Since we delete the root element from the heap it will distort the properties of the heap so we need to perform heapify operations so that it maintains the property of the heap.\n\n\nIt takes\n\n****O(log n)****\ntime.\n\n\n****Example:****\n\n> Assume initially heap(taking max-heap) is as follows\n>\n>\n>\n> 15\n>\n>\n>\n> /   \\\n>\n>\n>\n> 5     7\n>\n>\n>\n> /  \\\n>\n>\n>\n> 2     3\n>\n>\n> Now if we delete 15 into the heap it will be replaced by leaf node of the tree for temporary.\n>\n>\n>\n> 3\n>\n>\n>\n> /   \\\n>\n>\n>\n> 5     7\n>\n>\n>\n> /\n>\n>\n>\n> 2\n>\n>\n> After heapify operation final heap will be look like this\n>\n>\n>\n> 7\n>\n>\n>\n> /   \\\n>\n>\n>\n> 5     3\n>\n>\n>\n> /\n>\n>\n>\n> 2\n\n### getMax (For max-heap) or getMin (For min-heap):\n\n\nIt finds the maximum element or minimum element for\n\n****max-heap****\nand\n\n****min-heap****\nrespectively and as we know minimum and maximum elements will always be the root node itself for min-heap and max-heap respectively. It takes\n\n****O(1)****\ntime.\n\n\n### removeMin or removeMax:\n\n\nThis operation returns and deletes the maximum element and minimum element from the max-heap and min-heap respectively. In short, it deletes the root element of the heap binary tree.\n\n\nImplementation of Heap Data Structure:-\n---------------------------------------\n\n\nThe following code shows the implementation of a\n\n****max-heap****\n.\n\n\nLet\u2019s understand the\n\n****maxHeapify****\nfunction in detail:-\n\n\n****maxHeapify****\nis the function responsible for restoring the property of the Max Heap. It arranges the node\n\n****i****\n, and its subtrees accordingly so that the heap property is maintained.\n\n\n1. Suppose we are given an array,\n\n   ****arr[]****\n   representing the complete binary tree. The left and the right child of\n\n   ****i****\n   ****th****\n   node are in indices\n\n   ****2\\*i+1****\n   and\n\n   ****2\\*i+2****\n   .\n2. We set the index of the current element,\n\n   ****i****\n   , as the \u2018MAXIMUM\u2019.\n3. If\n\n   ****arr[2 \\* i + 1] > arr[i]****\n   , i.e., the left child is larger than the current value, it is set as \u2018MAXIMUM\u2019.\n4. Similarly if\n\n   ****arr[2 \\* i + 2] > arr[i]****\n   , i.e., the right child is larger than the current value, it is set as \u2018MAXIMUM\u2019.\n5. Swap the \u2018MAXIMUM\u2019 with the current element.\n6. Repeat steps\n\n   ****2 to 5****\n   till the property of the heap is restored.\n\nC++\n\n````\n// C++ code to depict\n// the implementation of a max heap.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// A class for Max Heap.\nclass MaxHeap {\n    // A pointer pointing to the elements\n    // in the array in the heap.\n    int* arr;\n\n// Maximum possible size of\n    // the Max Heap.\n    int maxSize;\n\n// Number of elements in the\n    // Max heap currently.\n    int heapSize;\n\npublic:\n    // Constructor function.\n    MaxHeap(int maxSize);\n\n// Heapifies a sub-tree taking the\n    // given index as the root.\n    void MaxHeapify(int);\n\n// Returns the index of the parent\n    // of the element at ith index.\n    int parent(int i)\n    {\n        return (i - 1) / 2;\n}\n\n    // Returns the index of the left child.\n    int lChild(int i)\n    {\n        return (2 * i + 1);\n}\n\n    // Returns the index of the\n    // right child.\n    int rChild(int i)\n    {\n        return (2 * i + 2);\n}\n\n    // Removes the root which in this\n    // case contains the maximum element.\n    int removeMax();\n\n// Increases the value of the key\n    // given by index i to some new value.\n    void increaseKey(int i, int newVal);\n\n// Returns the maximum key\n    // (key at root) from max heap.\n    int getMax()\n    {\n        return arr[0];\n}\n\n    int curSize()\n    {\n        return heapSize;\n}\n\n    // Deletes a key at given index i.\n    void deleteKey(int i);\n\n// Inserts a new key 'x' in the Max Heap.\n    void insertKey(int x);\n};\n\n// Constructor function builds a heap\n// from a given array a[]\n// of the specified size.\nMaxHeap::MaxHeap(int totSize)\n{\n    heapSize = 0;\n    maxSize = totSize;\n    arr = new int[totSize];\n}\n\n// Inserting a new key 'x'.\nvoid MaxHeap::insertKey(int x)\n{\n    // To check whether the key\n    // can be inserted or not.\n    if (heapSize == maxSize) {\n        cout << \"\\nOverflow: Could not insertKey\\n\";\n        return;\n}\n\n    // The new key is initially\n    // inserted at the end.\n    heapSize++;\nint i = heapSize - 1;\n    arr[i] = x;\n\n// The max heap property is checked\n    // and if violation occurs,\n    // it is restored.\n    while (i != 0 && arr[parent(i)] < arr[i]) {\n        swap(arr[i], arr[parent(i)]);\n        i = parent(i);\n}\n}\n\n// Increases value of key at\n// index 'i' to new_val.\nvoid MaxHeap::increaseKey(int i, int newVal)\n{\n    arr[i] = newVal;\n    while (i != 0 && arr[parent(i)] < arr[i]) {\n        swap(arr[i], arr[parent(i)]);\n        i = parent(i);\n}\n}\n\n// To remove the root node which contains\n// the maximum element of the Max Heap.\nint MaxHeap::removeMax()\n{\n    // Checking whether the heap array\n    // is empty or not.\n    if (heapSize <= 0)\n        return INT_MIN;\n    if (heapSize == 1) {\n        heapSize--;\n        return arr[0];\n}\n\n    // Storing the maximum element\n    // to remove it.\n    int root = arr[0];\n    arr[0] = arr[heapSize - 1];\n    heapSize--;\n\n// To restore the property\n    // of the Max heap.\n    MaxHeapify(0);\n\nreturn root;\n}\n\n// In order to delete a key\n// at a given index i.\nvoid MaxHeap::deleteKey(int i)\n{\n    // It increases the value of the key\n    // to infinity and then removes\n    // the maximum value.\n    increaseKey(i, INT_MAX);\n    removeMax();\n}\n\n// To heapify the subtree this method\n// is called recursively\nvoid MaxHeap::MaxHeapify(int i)\n{\n    int l = lChild(i);\nint r = rChild(i);\nint largest = i;\n    if (l < heapSize && arr[l] > arr[i])\n        largest = l;\n    if (r < heapSize && arr[r] > arr[largest])\n        largest = r;\n    if (largest != i) {\n        swap(arr[i], arr[largest]);\n        MaxHeapify(largest);\n}\n}\n\n// Driver program to test above functions.\nint main()\n{\n    // Assuming the maximum size of the heap to be 15.\n    MaxHeap h(15);\n\n// Asking the user to input the keys:\n    int k, i, n = 6, arr[10];\n    cout << \"Entered 6 keys:- 3, 10, 12, 8, 2, 14 \\n\";\n    h.insertKey(3);\n    h.insertKey(10);\n    h.insertKey(12);\n    h.insertKey(8);\n    h.insertKey(2);\n    h.insertKey(14);\n\n// Printing the current size\n    // of the heap.\n    cout << \"The current size of the heap is \"\n         << h.curSize() << \"\\n\";\n\n// Printing the root element which is\n    // actually the maximum element.\n    cout << \"The current maximum element is \" << h.getMax()\n         << \"\\n\";\n\n// Deleting key at index 2.\n    h.deleteKey(2);\n\n// Printing the size of the heap\n    // after deletion.\n    cout << \"The current size of the heap is \"\n         << h.curSize() << \"\\n\";\n\n// Inserting 2 new keys into the heap.\n    h.insertKey(15);\n    h.insertKey(5);\n    cout << \"The current size of the heap is \"\n         << h.curSize() << \"\\n\";\n    cout << \"The current maximum element is \" << h.getMax()\n         << \"\\n\";\n\nreturn 0;\n}\n\n````\n\nJava\n\n````\n// Java code to depict\n// the implementation of a max heap.\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class MaxHeap {\n    // A pointer pointing to the elements\n    // in the array in the heap.\n    int[] arr;\n\n// Maximum possible size of\n    // the Max Heap.\n    int maxSize;\n\n// Number of elements in the\n    // Max heap currently.\n    int heapSize;\n\n// Constructor function.\n    MaxHeap(int maxSize) {\n        this.maxSize = maxSize;\n        arr = new int[maxSize];\n        heapSize = 0;\n}\n\n    // Heapifies a sub-tree taking the\n    // given index as the root.\n    void MaxHeapify(int i) {\n        int l = lChild(i);\nint r = rChild(i);\nint largest = i;\n        if (l < heapSize && arr[l] > arr[i])\n            largest = l;\n        if (r < heapSize && arr[r] > arr[largest])\n            largest = r;\n        if (largest != i) {\n            int temp = arr[i];\n            arr[i] = arr[largest];\n            arr[largest] = temp;\n            MaxHeapify(largest);\n}\n    }\n\n    // Returns the index of the parent\n    // of the element at ith index.\n    int parent(int i) {\n        return (i - 1) / 2;\n}\n\n    // Returns the index of the left child.\n    int lChild(int i) {\n        return (2 * i + 1);\n}\n\n    // Returns the index of the\n    // right child.\n    int rChild(int i) {\n        return (2 * i + 2);\n}\n\n    // Removes the root which in this\n    // case contains the maximum element.\n    int removeMax() {\n        // Checking whether the heap array\n        // is empty or not.\n        if (heapSize <= 0)\n            return Integer.MIN_VALUE;\n        if (heapSize == 1) {\n            heapSize--;\n            return arr[0];\n}\n\n        // Storing the maximum element\n        // to remove it.\n        int root = arr[0];\n        arr[0] = arr[heapSize - 1];\n        heapSize--;\n\n// To restore the property\n        // of the Max heap.\n        MaxHeapify(0);\n\nreturn root;\n}\n\n    // Increases value of key at\n    // index 'i' to new_val.\n    void increaseKey(int i, int newVal) {\n        arr[i] = newVal;\n        while (i != 0 && arr[parent(i)] < arr[i]) {\n            int temp = arr[i];\n            arr[i] = arr[parent(i)];\n            arr[parent(i)] = temp;\n            i = parent(i);\n}\n    }\n\n    // Returns the maximum key\n    // (key at root) from max heap.\n    int getMax() {\n        return arr[0];\n}\n\n    int curSize() {\n        return heapSize;\n}\n\n    // Deletes a key at given index i.\n    void deleteKey(int i) {\n        // It increases the value of the key\n        // to infinity and then removes\n        // the maximum value.\n        increaseKey(i, Integer.MAX_VALUE);\n        removeMax();\n}\n\n    // Inserts a new key 'x' in the Max Heap.\n    void insertKey(int x) {\n        // To check whether the key\n        // can be inserted or not.\n        if (heapSize == maxSize) {\n            System.out.println(\"\\nOverflow: Could not insertKey\\n\");\n            return;\n}\n\n        // The new key is initially\n        // inserted at the end.\n        heapSize++;\nint i = heapSize - 1;\n        arr[i] = x;\n\n// The max heap property is checked\n        // and if violation occurs,\n        // it is restored.\n        while (i != 0 && arr[parent(i)] < arr[i]) {\n            int temp = arr[i];\n            arr[i] = arr[parent(i)];\n            arr[parent(i)] = temp;\n            i = parent(i);\n}\n    }\n\n    // Driver program to test above functions.\n    public static void main(String[] args) {\n        // Assuming the maximum size of the heap to be 15.\n        MaxHeap h = new MaxHeap(15);\n\n// Asking the user to input the keys:\n        int k, i, n = 6;\n        System.out.println(\"Entered 6 keys:- 3, 10, 12, 8, 2, 14 \\n\");\n        h.insertKey(3);\n        h.insertKey(10);\n        h.insertKey(12);\n        h.insertKey(8);\n        h.insertKey(2);\n        h.insertKey(14);\n\n// Printing the current size\n        // of the heap.\n        System.out.println(\"The current size of the heap is \"\n                + h.curSize() + \"\\n\");\n\n// Printing the root element which is\n        // actually the maximum element.\n        System.out.println(\"The current maximum element is \" + h.getMax()\n                + \"\\n\");\n\n// Deleting key at index 2.\n        h.deleteKey(2);\n\n// Printing the size of the heap\n        // after deletion.\n        System.out.println(\"The current size of the heap is \"\n                + h.curSize() + \"\\n\");\n\n// Inserting 2 new keys into the heap.\n        h.insertKey(15);\n        h.insertKey(5);\n        System.out.println(\"The current size of the heap is \"\n                + h.curSize() + \"\\n\");\n        System.out.println(\"The current maximum element is \" + h.getMax()\n                + \"\\n\");\n}\n}\n\n````\n\nPython\n\n````\n# Python code to depict\n# the implementation of a max heap.\n\nclass MaxHeap:\n    # A pointer pointing to the elements\n    # in the array in the heap.\n    arr = []\n\n    # Maximum possible size of\n    # the Max Heap.\n    maxSize = 0\n\n    # Number of elements in the\n    # Max heap currently.\n    heapSize = 0\n\n    # Constructor function.\n    def __init__(self, maxSize):\n        self.maxSize = maxSize\n        self.arr = [None]*maxSize\n        self.heapSize = 0\n\n    # Heapifies a sub-tree taking the\n    # given index as the root.\n    def MaxHeapify(self, i):\n        l = self.lChild(i)\n        r = self.rChild(i)\n        largest = i\n        if l < self.heapSize and self.arr[l] > self.arr[i]:\n            largest = l\n        if r < self.heapSize and self.arr[r] > self.arr[largest]:\n            largest = r\n        if largest != i:\n            temp = self.arr[i]\n            self.arr[i] = self.arr[largest]\n            self.arr[largest] = temp\n            self.MaxHeapify(largest)\n\n    # Returns the index of the parent\n    # of the element at ith index.\n    def parent(self, i):\n        return (i - 1) // 2\n\n    # Returns the index of the left child.\n    def lChild(self, i):\n        return (2 * i + 1)\n\n    # Returns the index of the\n    # right child.\n    def rChild(self, i):\n        return (2 * i + 2)\n\n    # Removes the root which in this\n    # case contains the maximum element.\n    def removeMax(self):\n        # Checking whether the heap array\n        # is empty or not.\n        if self.heapSize <= 0:\n            return None\n        if self.heapSize == 1:\n            self.heapSize -= 1\n            return self.arr[0]\n\n        # Storing the maximum element\n        # to remove it.\n        root = self.arr[0]\n        self.arr[0] = self.arr[self.heapSize - 1]\n        self.heapSize -= 1\n\n        # To restore the property\n        # of the Max heap.\n        self.MaxHeapify(0)\n\n        return root\n\n    # Increases value of key at\n    # index 'i' to new_val.\n    def increaseKey(self, i, newVal):\n        self.arr[i] = newVal\n        while i != 0 and self.arr[self.parent(i)] < self.arr[i]:\n            temp = self.arr[i]\n            self.arr[i] = self.arr[self.parent(i)]\n            self.arr[self.parent(i)] = temp\n            i = self.parent(i)\n\n    # Returns the maximum key\n    # (key at root) from max heap.\n    def getMax(self):\n        return self.arr[0]\n\n    def curSize(self):\n        return self.heapSize\n\n    # Deletes a key at given index i.\n    def deleteKey(self, i):\n        # It increases the value of the key\n        # to infinity and then removes\n        # the maximum value.\n        self.increaseKey(i, float(\"inf\"))\n        self.removeMax()\n\n    # Inserts a new key 'x' in the Max Heap.\n    def insertKey(self, x):\n        # To check whether the key\n        # can be inserted or not.\n        if self.heapSize == self.maxSize:\n            print(\"\\nOverflow: Could not insertKey\\n\")\n            return\n\n        # The new key is initially\n        # inserted at the end.\n        self.heapSize += 1\n        i = self.heapSize - 1\n        self.arr[i] = x\n\n        # The max heap property is checked\n        # and if violation occurs,\n        # it is restored.\n        while i != 0 and self.arr[self.parent(i)] < self.arr[i]:\n            temp = self.arr[i]\n            self.arr[i] = self.arr[self.parent(i)]\n            self.arr[self.parent(i)] = temp\n            i = self.parent(i)\n\n\n# Driver program to test above functions.\nif __name__ == '__main__':\n    # Assuming the maximum size of the heap to be 15.\n    h = MaxHeap(15)\n\n    # Asking the user to input the keys:\n    k, i, n = 6, 0, 6\n    print(\"Entered 6 keys:- 3, 10, 12, 8, 2, 14 \\n\")\n    h.insertKey(3)\n    h.insertKey(10)\n    h.insertKey(12)\n    h.insertKey(8)\n    h.insertKey(2)\n    h.insertKey(14)\n\n    # Printing the current size\n    # of the heap.\n    print(\"The current size of the heap is \"\n          + str(h.curSize()) + \"\\n\")\n\n    # Printing the root element which is\n    # actually the maximum element.\n    print(\"The current maximum element is \" + str(h.getMax())\n          + \"\\n\")\n\n    # Deleting key at index 2.\n    h.deleteKey(2)\n\n    # Printing the size of the heap\n    # after deletion.\n    print(\"The current size of the heap is \"\n          + str(h.curSize()) + \"\\n\")\n\n    # Inserting 2 new keys into the heap.\n    h.insertKey(15)\n    h.insertKey(5)\n    print(\"The current size of the heap is \"\n          + str(h.curSize()) + \"\\n\")\n    print(\"The current maximum element is \" + str(h.getMax())\n          + \"\\n\")\n\n````\n\nJavaScript\n\n````\n// JavaScript code to depict\n// the implementation of a max heap.\n\nclass MaxHeap {\n    constructor(maxSize) {\n        // the array in the heap.\n        this.arr = new Array(maxSize).fill(null);\n\n// Maximum possible size of\n        // the Max Heap.\n        this.maxSize = maxSize;\n\n// Number of elements in the\n        // Max heap currently.\n        this.heapSize = 0;\n}\n\n    // Heapifies a sub-tree taking the\n    // given index as the root.\n    MaxHeapify(i) {\n        const l = this.lChild(i);\n        const r = this.rChild(i);\n        let largest = i;\n        if (l < this.heapSize && this.arr[l] > this.arr[i]) {\n            largest = l;\n}\n        if (r < this.heapSize && this.arr[r] > this.arr[largest]) {\n            largest = r;\n}\n        if (largest !== i) {\n            const temp = this.arr[i];\n            this.arr[i] = this.arr[largest];\n            this.arr[largest] = temp;\n            this.MaxHeapify(largest);\n}\n    }\n\n    // Returns the index of the parent\n    // of the element at ith index.\n    parent(i) {\n        return Math.floor((i - 1) / 2);\n}\n\n    // Returns the index of the left child.\n    lChild(i) {\n        return 2 * i + 1;\n}\n\n    // Returns the index of the\n    // right child.\n    rChild(i) {\n        return 2 * i + 2;\n}\n\n    // Removes the root which in this\n    // case contains the maximum element.\n    removeMax() {\n        // Checking whether the heap array\n        // is empty or not.\n        if (this.heapSize <= 0) {\n            return null;\n}\n        if (this.heapSize === 1) {\n            this.heapSize -= 1;\nreturn this.arr[0];\n}\n\n        // Storing the maximum element\n        // to remove it.\n        const root = this.arr[0];\n        this.arr[0] = this.arr[this.heapSize - 1];\n        this.heapSize -= 1;\n\n// To restore the property\n        // of the Max heap.\n        this.MaxHeapify(0);\n\nreturn root;\n}\n\n    // Increases value of key at\n    // index 'i' to new_val.\n    increaseKey(i, newVal) {\n        this.arr[i] = newVal;\n        while (i !== 0 && this.arr[this.parent(i)] < this.arr[i]) {\n            const temp = this.arr[i];\n            this.arr[i] = this.arr[this.parent(i)];\n            this.arr[this.parent(i)] = temp;\n            i = this.parent(i);\n}\n    }\n\n    // Returns the maximum key\n    // (key at root) from max heap.\n    getMax() {\n        return this.arr[0];\n}\n\n    curSize() {\n        return this.heapSize;\n}\n\n    // Deletes a key at given index i.\n    deleteKey(i) {\n        // It increases the value of the key\n        // to infinity and then removes\n        // the maximum value.\n        this.increaseKey(i, Infinity);\n        this.removeMax();\n}\n\n    // Inserts a new key 'x' in the Max Heap.\n    insertKey(x) {\n        // To check whether the key\n        // can be inserted or not.\n        if (this.heapSize === this.maxSize) {\n            console.log(\"\\nOverflow: Could not insertKey\\n\");\n            return;\n}\n\n        let i = this.heapSize;\n        this.arr[i] = x;\n\n// The new key is initially\n        // inserted at the end.\n        this.heapSize += 1;\n\n\n\n// The max heap property is checked\n        // and if violation occurs,\n        // it is restored.\n        while (i !== 0 && this.arr[this.parent(i)] < this.arr[i]) {\n            const temp = this.arr[i];\n            this.arr[i] = this.arr[this.parent(i)];\n            this.arr[this.parent(i)] = temp;\n            i = this.parent(i);\n}\n    }\n}\n\n\n// Driver program to test above functions.\n\n// Assuming the maximum size of the heap to be 15.\nconst h = new MaxHeap(15);\n\n// Asking the user to input the keys:\nconsole.log(\"Entered 6 keys:- 3, 10, 12, 8, 2, 14 \\n\");\n\nh.insertKey(3);\nh.insertKey(10);\nh.insertKey(12);\nh.insertKey(8);\nh.insertKey(2);\nh.insertKey(14);\n\n\n// Printing the current size\n// of the heap.\nconsole.log(\n    \"The current size of the heap is \" + h.curSize() + \"\\n\"\n);\n\n\n// Printing the root element which is\n// actually the maximum element.\nconsole.log(\n    \"The current maximum element is \" + h.getMax() + \"\\n\"\n);\n\n\n// Deleting key at index 2.\nh.deleteKey(2);\n\n\n// Printing the size of the heap\n// after deletion.\nconsole.log(\n    \"The current size of the heap is \" + h.curSize() + \"\\n\"\n);\n\n\n// Inserting 2 new keys into the heap.\nh.insertKey(15);\nh.insertKey(5);\n\nconsole.log(\n    \"The current size of the heap is \" + h.curSize() + \"\\n\"\n);\n\nconsole.log(\n    \"The current maximum element is \" + h.getMax() + \"\\n\"\n);\n\n// Contributed by sdeadityasharma\n\n````\n\n\n\n\n**Output**\n```\nEntered 6 keys:- 3, 10, 12, 8, 2, 14\nThe current size of the heap is 6\nThe current maximum element is 14\nThe current size of the heap is 5\nThe current size of the heap is 7\nThe current maximum element is 15\n```\n",
        "metadata": {
            "lesson_id": "0f843284-a32b-478b-af5b-85f375980a0b",
            "course_id": "8ff4ea92-41f2-4d49-b230-0281874efb2d",
            "course_name": "Introduction to DSA II",
            "lesson_description": "",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Given a number\n\n****n****\n, we need to print its table.\n\n\n****Examples :****\n\n\n> ****Input****\n> : 5\n>\n>\n>\n> ****Output****\n> :\n>\n>\n>\n> 5 \\* 1 = 5\n>\n>\n>\n> 5 \\* 2 = 10\n>\n>\n>\n> 5 \\* 3 = 15\n>\n>\n>\n> 5 \\* 4 = 20\n>\n>\n>\n> 5 \\* 5 = 25\n>\n>\n>\n> 5 \\* 6 = 30\n>\n>\n>\n> 5 \\* 7 = 35\n>\n>\n>\n> 5 \\* 8 = 40\n>\n>\n>\n> 5 \\* 9 = 45\n>\n>\n>\n> 5 \\* 10 = 50\n\nTable of Content\n\n* [Iterative Approach \u2013 O(1) Time and O(1) Space](#using-a-loop-o1-time-and-o1-space)\n* [Recursive Approach \u2013 O(1) Time and O(1) Space](#using-recursion-o1-space-and-o1-time)\n### Iterative Approach \u2013 O(1) Time and O(1) Space\n\nC++\n\n````\n// CPP program to print table of a number\n#include <iostream>\nusing namespace std;\n\nvoid printTable(int n) {\n  for (int i = 1; i <= 10; ++i)\n        cout << n << \" * \" << i << \" = \"\n             << n * i << endl;\n}\n\nint main() {\n    int n = 5;  // Change here to change output\n    printTable(n);\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to print table of a number\nimport java.io.*;\n\nclass GfG {\n\n    public static void printTable(int n)  {\n\n        for (int i = 1; i <= 10; ++i)\n            System.out.println(n + \" * \" + i +\n                               \" = \" + n * i);\n    }\n\n    public static void main(String arg[]){\n        int n = 5;\n        printTable(n);\n    }\n}\n\n````\n\nPython\n\n````\n# Python Program to print table of a number\n\ndef printTable(n):\n\n    for i in range (1, 11):\n\n        # multiples from 1 to 10\n        print \"%d * %d = %d\" % (n, i, n * i)\n\n\nif __name__ == \"__main__\":\n  n = 5\n  printTable(n)\n\n````\n\nC#\n\n````\n// C# program to print table of a number\nusing System;\n\nclass GfG {\n    public static void printTable(int n) {\n\n        for (int i = 1; i <= 10; ++i)\n            Console.Write(n + \" * \" + i +\n                              \" = \" + n *\n                               i + \"\\n\");\n    }\n\n    public static void Main()   {\n      int n = 5;\n      printTable(n);\n\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Javascript program to print\n// table of a number\n\nfunction printTable(n) {\nfor (let i = 1; i <= 10; ++i)\n    console.log( n + \" * \" +i +\n            \" = \" + n *\n                i);\n}\n\n// Driver Code\nlet n = 5;\nprintTable(n);\n\n````\n\n****Output :****\n\n\n```\n5 * 1 = 5\n5 * 2 = 10\n5 * 3 = 15\n5 * 4 = 20\n5 * 5 = 25\n5 * 6 = 30\n5 * 7 = 35\n5 * 8 = 40\n5 * 9 = 45\n5 * 10 = 50\n```\n### ****Recursive Approach \u2013 O(1) Time and O(1) Space****\n\nC++\n\n````\n#include <iostream>\nusing namespace std;\n\n// printTable() prints table of number and takes\n//1 required value that is number of whose teble to be printed\n//and an optional input i whose default value is 1\n\nvoid printTable(int n, int i = 1) {\n    if (i == 11)// base case\n        return;\n    cout << n << \" * \" << i << \" = \" << n * i << endl;\n    i++;//increment i\n    printTable(n,i);\n}\n\nint main() {\n    int n = 5;\n    printTable(n);\n}\n\n````\n\nJava\n\n````\nimport java.util.*;\n\nclass GfG {\n\n    // printTable() prints table of number and takes\n    // 1 required value that is number of whose teble to be\n    // printed and an optional input i whose default value is 1\n    static void printTable(int n, Integer... val)  {\n          int i = 1;\n        if (val.length != 0)\n            i = val[0];\n        if (i == 11) // base case\n            return;\n        System.out.println(n + \" * \" + i + \" = \" + n * i);\n        i++; // increment i\n        printTable(n, i);\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        printTable(n);\n    }\n}\n\n\n````\n\nPython\n\n````\n# printTable() prints table of number and takes\n# 1 required value that is number of whose teble to be printed\n# and an optional input i whose default value is 1\ndef printTable(n, i=1):\n\n    if (i == 11):  # base case\n        return\n    print(n, \"*\", i, \"=\", n * i)\n    i += 1  # increment i\n    printTable(n, i)\n\nif __name__ == \"__main__\":\n  n = 5\n  printTable(n)\n\n````\n\nC#\n\n````\nusing System;\nusing System.Collections.Generic;\n\nclass GfG {\n\n  // print_table() prints table of number and takes\n  // 1 required value that is number of whose teble to be\n  // printed and an optional input i whose default value is 1\n  static void printTable(int n, int i = 1) {\n    if (i == 11) // base case\n      return;\n    Console.WriteLine(n + \" * \" + i + \" = \" + n * i);\n    i++; // increment i\n    printTable(n, i);\n  }\n\n  public static void Main(string[] args) {\n    int n = 5;\n    printTable(n);\n  }\n}\n\n````\n\nJavaScript\n\n````\n// printTable() prints table of number and takes\n//1 required value that is number of whose teble to be printed\n//and an optional input i whose default value is 1\n\nfunction printTable(n, i = 1) {\n    if (i == 11)// base case\n        return;\n    console.log(n + \" * \" + i + \" = \" + n * i);\n    i++;//increment i\n    printTable(n,i);\n}\n\n// Driver Code\nlet n = 5;\nprintTable(n);\n\n````\n\n\n\n\n**Output**\n```\n5 * 1 = 5\n5 * 2 = 10\n5 * 3 = 15\n5 * 4 = 20\n5 * 5 = 25\n5 * 6 = 30\n5 * 7 = 35\n5 * 8 = 40\n5 * 9 = 45\n5 * 10 = 50\n```\n\n****Time Complexity:****\nO(1)\n\n\n\n****Auxiliary Space:****\nO(1), since the recursion stack will only go up to 10.\n\n",
        "metadata": {
            "lesson_id": "ae34492a-cfab-417f-952f-ddb4957195e8",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "Given a number\n\n****n****\n, check whether it is even or odd. Return\n\n****true****\nfor even and\n\n****false****\nfor odd.\n\n\n****Examples:****\n\n\n> ****Input****\n> : 2\n>\n>\n>\n> ****Output****\n> : true\n>\n>\n> ****Input****\n> : 5\n>\n>\n>\n> ****Output****\n> : false\n\nTable of Content\n\n* [By Finding the Remainder \u2013 O(1) Time and O(1) Space](#by-finding-the-reminder-o1-time-and-o1-space)\n* [Using Bitwise AND Operator \u2013 O(1) Time and O(1) Space](#using-bitwaise-operators-o1-time-and-o1-space)\n* [Using Bitwise Shift Operators \u2013 O(1) Time and O(1) Space](#using-bitwaise-shift-operators-o1-time-and-o1-space)\n### By Finding the Remainder \u2013 O(1) Time and O(1) Space\n\n\nWe can check the remainder when divided by 2. If the remainder is 0, the number is even; otherwise, it is odd\n\n\nC++\n\n````\n// A simple C++ program to check for even or odd\n#include <iostream>\nusing namespace std;\n\nbool isEven(int n) {\n  return (n % 2 == 0);\n}\n\nint main() {\n    int n = 101;\n    if(isEven(n))\n         cout << \"true\";\n      else\n        cout << \"false\";\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program  to check for even or odd\nclass GfG {\n\n    public static boolean isEven(int n)  {\n        return (n % 2 == 0);\n    }\n\n    public static void main(String[] args) {\n        int n = 101;\n        if (isEven(n) == true)\n            System.out.print(\"true\");\n        else\n            System.out.print(\"false\");\n    }\n}\n\n````\n\nPython\n\n````\n# A simple Python3 code check for even or odd\n\ndef isEven(n):\n    return (n % 2 == 0)\n\n\nif __name__ == \"__main__\":\n  n = 101\n  if is_even(n):\n      print(\"true\")\n  else:\n      print(\"false\")\n\n````\n\nC#\n\n````\n// C# program toif __name__ == \"__main__\":\nusing System;\nclass GfG {\n    public static bool isEven(int n) {\n        return (n % 2 == 0);\n    }\n\n    public static void Main() {\n        int n = 101;\n        if (isEven(n) == true)\n            Console.WriteLine(\"true\");\n        else\n            Console.WriteLine(\"false\");\n    }\n}\n\n````\n\nJavaScript\n\n````\n// A simple Javascript program to\n// check for even or odd\n\nfunction isEven(n) {\n    return (n % 2 == 0);\n}\n\n// Driver code\n\n    let n = 101;\n    if (isEven(n)) {\n        console.log(\"true\");\n    } else {\n        console.log(\"false\");\n    }\n\n````\n\n\n\n\n**Output**\n```\nfalse\n```\n### Using Bitwise AND Operator \u2013 O(1) Time and O(1) Space\n\n> The last bit of all odd numbers is always 1, while for even numbers it\u2019s 0. So, when performing bitwise AND operation with 1, odd numbers give 1, and even numbers give 0.\n>\n>\n> Ex: 5 (101) -> 101\n>\n>\n>\n> & 001\n>\n>\n>\n> \u2014-\n>\n>\n>\n> 001 , so this we can say it is an odd number.\n\nC++\n\n````\n// A simple C++ program to check for even or odd\n#include <iostream>\nusing namespace std;\n\nbool isEven(int n) {\n        if ((n & 1) == 0)\n            return true;\n        else\n            return false;\n}\n\nint main() {\n    int n = 101;\n     if (isEven(n) == true)\n        cout<<\"true\";\n       else\n        cout<<\"false\";\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <math.h>\n#include <stdio.h>\n\nbool isEven(int n) {\n         if ((n & 1) == 0)\n            return true;\n        else\n            return false;\n}\n\nint main() {\n    int n = 101;\n    if (isEven) {\n        printf(\"true\");\n    }\n    else {\n        printf(\"false\");\n    }\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to\n// check for even or odd\nclass GfG {\n    public static boolean isEven(int n){\n        if ((n & 1) == 0)\n            return true;\n        else\n            return false;\n    }\n\n    public static void main(String[] args) {\n        int n = 101;\n        if (isEven(n) == true)\n            System.out.print(\"true\");\n        else\n            System.out.print(\"false\");\n    }\n}\n\n````\n\nPython\n\n````\n# A Python3 code program\n# to check for even or odd\ndef isEven(n):\n\n    # n&1 is 1, then odd, else even\n    if (n & 1) == 0:\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n  n = 101\n  if isEven(n):\n      print(\"true\")\n  else:\n      print(\"false\")\n\n````\n\nC#\n\n````\n// C# program  to check for even or odd\nusing System;\n\nclass GfG {\n    public static bool isEven(int n)   {\n        if ((n & 1) == 0)\n            return true;\n        else\n            return false;\n    }\n\n    public static void Main() {\n        int n = 101;\n        if (isEven(n) == true)\n            Console.WriteLine(\"true\");\n        else\n            Console.WriteLine(\"false\");\n    }\n}\n\n````\n\nJavaScript\n\n````\n// A simple JavaScript program to\n// check for even or odd\n\nfunction isEven(n) {\n\n // n & 1 is 1, then odd, else even\n if ((n & 1) === 0) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Driver code\nlet n = 101;\nif (isEven(n)) {\n    console.log(\"true\");\n} else {\n    console.log(\"false\");\n}\n\n````\n\n\n\n\n**Output**\n```\nfalse\n```\n\n****Time Complexity: O(1)****\n\n\n****Auxiliary Space: O(1)****\n\n### Using Bitwise Shift Operators \u2013 O(1) Time and O(1) Space\n\n![](https://media.geeksforgeeks.org/wp-content/uploads/20221201114030/Group1.png)\nC++\n\n````\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isEven(int n) {\n  if (n == (n >> 1) << 1) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nint main() {\n\n  int n = 4;\n  if (isEven(n) == true)\n        cout<<\"true\";\n   else\n        cout<<\"false\";\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to\n// check for even or odd\nclass GfG {\n    public static boolean isEven(int n){\n       if (n == (n >> 1) << 1)\n            return true;\n        else\n            return false;\n    }\n\n    public static void main(String[] args) {\n        int n = 4;\n        if (isEven(n) == true)\n            System.out.print(\"true\");\n        else\n            System.out.print(\"false\");\n    }\n}\n\n````\n\nPython\n\n````\n# A Python3 code program\n# to check for even or odd\ndef isEven(n):\n\n    if n == (n >> 1) << 1:\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n  n = 4\n  if isEven(n):\n      print(\"true\")\n  else:\n      print(\"false\")\n\n````\n\nC#\n\n````\n// C# program  to check for even or odd\nusing System;\n\nclass GfG {\n    public static bool isEven(int n)   {\n        if (n == (n >> 1) << 1)\n            return true;\n        else\n            return false;\n    }\n\n    public static void Main() {\n        int n = 4;\n        if (isEven(n) == true)\n            Console.WriteLine(\"true\");\n        else\n            Console.WriteLine(\"false\");\n    }\n}\n\n````\n\nJavaScript\n\n````\n// A simple JavaScript program to\n// check for even or odd\n\nfunction isEven(n) {\n\n    if (n == (n >> 1) << 1)\n       return true;\n    else\n       return false;\n}\n\n// Driver code\nlet n = 4;\nif (isEven(n)) {\n    console.log(\"true\");\n} else {\n    console.log(\"false\");\n}\n\n````\n\n\n\n\n**Output**\n```\ntrue\n```\n",
        "metadata": {
            "lesson_id": "2bbe24be-6a3c-49ad-bb76-363d65e58895",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "****Properties of Priority Queue****\n------------------------------------\n\n*****So, a priority Queue is an extension of the*****\n[*****queue*****](https://www.geeksforgeeks.org/queue-set-1introduction-and-array-implementation/)\n*****with the following properties.*****\n\n* Every item has a priority associated with it.\n* An element with high priority is dequeued before an element with low priority.\n* If two elements have the same priority, they are served according to their order in the queue.\n\n\nIn the below priority queue, an element with a maximum ASCII value will have the highest priority. The elements with higher priority are served first.\n\n\n![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/Priority-Queue-min-1024x512.png)\n\n****How is Priority assigned to the elements in a Priority Queue?****\n---------------------------------------------------------------------\n\n\nIn a priority queue, generally, the value of an element is considered for assigning the priority.\n\n\nFor example, the element with the highest value is assigned the highest priority and the element with the lowest value is assigned the lowest priority. The reverse case can also be used i.e., the element with the lowest value can be assigned the highest priority. Also, the priority can be assigned according to our needs.\n\n\n****Operations of a Priority Queue:****\n---------------------------------------\n\n\nA typical priority queue supports the following operations:\n\n\n### ****1) Insertion in a Priority Queue****\n\n\nWhen a new element is inserted in a priority queue, it moves to the empty slot from top to bottom and left to right. However, if the element is not in the correct place then it will be compared with the parent node. If the element is not in the correct order, the elements are swapped. The swapping process continues until all the elements are placed in the correct position.\n\n\n### ****2) Deletion in a Priority Queue****\n\n\nAs you know that in a max heap, the maximum element is the root node. And it will remove the element which has maximum priority first. Thus, you remove the root node from the queue. This removal creates an empty slot, which will be further filled with new insertion. Then, it compares the newly inserted element with all the elements inside the queue to maintain the heap invariant.\n\n\n### ****3) Peek in a Priority Queue****\n\n\nThis operation helps to return the maximum element from Max Heap or the minimum element from Min Heap without deleting the node from the priority queue.\n\n\nTypes of Priority Queue:\n------------------------\n\n### ****1) Ascending Order Priority Queue****\n\n\nAs the name suggests, in ascending order priority queue, the element with a lower priority value is given a higher priority in the priority list. For example, if we have the following elements in a priority queue arranged in ascending order like 4,6,8,9,10. Here, 4 is the smallest number, therefore, it will get the highest priority in a priority queue and so when we dequeue from this type of priority queue, 4 will remove from the queue and dequeue returns 4.\n\n\n### ****2) Descending order Priority Queue****\n\n\nThe root node is the maximum element in a max heap, as you may know. It will also remove the element with the highest priority first. As a result, the root node is removed from the queue. This deletion leaves an empty space, which will be filled with fresh insertions in the future. The heap invariant is then maintained by comparing the newly inserted element to all other entries in the queue.\n\n\n![Types of Priority Queues](https://media.geeksforgeeks.org/wp-content/uploads/20220623153252/priorityqueue.jpg)\n\nTypes of Priority Queues\n\n****Difference between Priority Queue and Normal Queue?****\n-----------------------------------------------------------\n\n\nThere is no priority attached to elements in a queue, the rule of first-in-first-out(FIFO) is implemented whereas, in a priority queue, the elements have a priority. The elements with higher priority are served first.\n\n\n****How to Implement Priority Queue?****\n----------------------------------------\n\n\nPriority queue can be implemented using the following data structures:\n\n\n* Arrays\n* Linked list\n* Heap data structure\n* Binary search tree\n\n****Let\u2019s discuss all these in detail.****\n\n### ****1) Implement Priority Queue Using Array:****\n\n\nA simple implementation is to use an array of the following structure.\n\n\n> struct item {\n>\n>\n>\n> int item;\n>\n>\n>\n> int priority;\n>\n>\n>\n> }\n\n* ****enqueue():****\n  This function is used to insert new data into the queue.\n* ****dequeue():****\n  This function removes the element with the highest priority from the queue.\n* ****peek()/top():****\n  This function is used to get the highest priority element in the queue without removing it from the queue.\n\nC++\n\n````\n// C++ program to implement Priority Queue\n// using Arrays\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Structure for the elements in the\n// priority queue\nstruct item {\n    int value;\n    int priority;\n};\n\n// Store the element of a priority queue\nitem pr[100000];\n\n// Pointer to the last index\nint size = -1;\n\n// Function to insert a new element\n// into priority queue\nvoid enqueue(int value, int priority)\n{\n    // Increase the size\n    size++;\n\n    // Insert the element\n    pr[size].value = value;\n    pr[size].priority = priority;\n}\n\n// Function to check the top element\nint peek()\n{\n    int highestPriority = INT_MIN;\n    int ind = -1;\n\n    // Check for the element with\n    // highest priority\n    for (int i = 0; i <= size; i++) {\n\n        // If priority is same choose\n        // the element with the\n        // highest value\n        if (highestPriority == pr[i].priority && ind > -1\n            && pr[ind].value < pr[i].value) {\n            highestPriority = pr[i].priority;\n            ind = i;\n        }\n        else if (highestPriority < pr[i].priority) {\n            highestPriority = pr[i].priority;\n            ind = i;\n        }\n    }\n\n    // Return position of the element\n    return ind;\n}\n\n// Function to remove the element with\n// the highest priority\nvoid dequeue()\n{\n    // Find the position of the element\n    // with highest priority\n    int ind = peek();\n\n    // Shift the element one index before\n    // from the position of the element\n    // with highest priority is found\n    for (int i = ind; i < size; i++) {\n        pr[i] = pr[i + 1];\n    }\n\n    // Decrease the size of the\n    // priority queue by one\n    size--;\n}\n\n// Driver Code\nint main()\n{\n    // Function Call to insert elements\n    // as per the priority\n    enqueue(10, 2);\n    enqueue(14, 4);\n    enqueue(16, 4);\n    enqueue(12, 3);\n\n    // Stores the top element\n    // at the moment\n    int ind = peek();\n\n    cout << pr[ind].value << endl;\n\n    // Dequeue the top element\n    dequeue();\n\n    // Check the top element\n    ind = peek();\n    cout << pr[ind].value << endl;\n\n    // Dequeue the top element\n    dequeue();\n\n    // Check the top element\n    ind = peek();\n    cout << pr[ind].value << endl;\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to implement Priority Queue\n// using Arrays\nimport java.util.*;\n\n// Structure for the elements in the\n// priority queue\nclass item {\n  public int value;\n  public int priority;\n};\n\nclass GFG {\n\n  // Store the element of a priority queue\n  static item[] pr = new item[100000];\n\n  // Pointer to the last index\n  static int size = -1;\n  // Function to insert a new element\n  // into priority queue\n  static void enqueue(int value, int priority)\n  {\n    // Increase the size\n    size++;\n\n    // Insert the element\n    pr[size] = new item();\n    pr[size].value = value;\n    pr[size].priority = priority;\n  }\n\n  // Function to check the top element\n  static int peek()\n  {\n    int highestPriority = Integer.MIN_VALUE;\n    int ind = -1;\n\n    // Check for the element with\n    // highest priority\n    for (int i = 0; i <= size; i++) {\n\n      // If priority is same choose\n      // the element with the\n      // highest value\n      if (highestPriority == pr[i].priority\n          && ind > -1\n          && pr[ind].value < pr[i].value) {\n        highestPriority = pr[i].priority;\n        ind = i;\n      }\n      else if (highestPriority < pr[i].priority) {\n        highestPriority = pr[i].priority;\n        ind = i;\n      }\n    }\n\n    // Return position of the element\n    return ind;\n  }\n\n  // Function to remove the element with\n  // the highest priority\n  static void dequeue()\n  {\n    // Find the position of the element\n    // with highest priority\n    int ind = peek();\n\n    // Shift the element one index before\n    // from the position of the element\n    // with highest priority is found\n    for (int i = ind; i < size; i++) {\n      pr[i] = pr[i + 1];\n    }\n\n    // Decrease the size of the\n    // priority queue by one\n    size--;\n  }\n\n  public static void main(String[] args)\n  {\n    // Function Call to insert elements\n    // as per the priority\n    enqueue(10, 2);\n    enqueue(14, 4);\n    enqueue(16, 4);\n    enqueue(12, 3);\n\n    // Stores the top element\n    // at the moment\n    int ind = peek();\n\n    System.out.println(pr[ind].value);\n\n    // Dequeue the top element\n    dequeue();\n\n    // Check the top element\n    ind = peek();\n    System.out.println(pr[ind].value);\n\n    // Dequeue the top element\n    dequeue();\n\n    // Check the top element\n    ind = peek();\n    System.out.println(pr[ind].value);\n  }\n}\n\n// this code is contributed by phasing17\n\n````\n\nPython\n\n````\nimport sys\n\n# Structure for the elements in the\n# priority queue\nclass item :\n    value = 0\n    priority = 0\nclass GFG :\n\n    # Store the element of a priority queue\n    pr = [None] * (100000)\n\n    # Pointer to the last index\n    size = -1\n\n    # Function to insert a new element\n    # into priority queue\n    @staticmethod\n    def enqueue( value,  priority) :\n\n        # Increase the size\n        GFG.size += 1\n\n        # Insert the element\n        GFG.pr[GFG.size] = item()\n        GFG.pr[GFG.size].value = value\n        GFG.pr[GFG.size].priority = priority\n\n    # Function to check the top element\n    @staticmethod\n    def  peek() :\n        highestPriority = -sys.maxsize\n        ind = -1\n\n        # Check for the element with\n        # highest priority\n        i = 0\n        while (i <= GFG.size) :\n\n            # If priority is same choose\n            # the element with the\n            # highest value\n            if (highestPriority == GFG.pr[i].priority and ind > -1 and GFG.pr[ind].value < GFG.pr[i].value) :\n                highestPriority = GFG.pr[i].priority\n                ind = i\n            elif(highestPriority < GFG.pr[i].priority) :\n                highestPriority = GFG.pr[i].priority\n                ind = i\n            i += 1\n\n        # Return position of the element\n        return ind\n\n    # Function to remove the element with\n    # the highest priority\n    @staticmethod\n    def dequeue() :\n\n        # Find the position of the element\n        # with highest priority\n        ind = GFG.peek()\n\n        # Shift the element one index before\n        # from the position of the element\n        # with highest priority is found\n        i = ind\n        while (i < GFG.size) :\n            GFG.pr[i] = GFG.pr[i + 1]\n            i += 1\n\n        # Decrease the size of the\n        # priority queue by one\n        GFG.size -= 1\n    @staticmethod\n    def main( args) :\n\n        # Function Call to insert elements\n        # as per the priority\n        GFG.enqueue(10, 2)\n        GFG.enqueue(14, 4)\n        GFG.enqueue(16, 4)\n        GFG.enqueue(12, 3)\n\n        # Stores the top element\n        # at the moment\n        ind = GFG.peek()\n        print(GFG.pr[ind].value)\n\n        # Dequeue the top element\n        GFG.dequeue()\n\n        # Check the top element\n        ind = GFG.peek()\n        print(GFG.pr[ind].value)\n\n        # Dequeue the top element\n        GFG.dequeue()\n\n        # Check the top element\n        ind = GFG.peek()\n        print(GFG.pr[ind].value)\n\nif __name__==\"__main__\":\n    GFG.main([])\n\n    # This code is contributed by aadityaburujwale.\n\n````\n\nC#\n\n````\n// C# program to implement Priority Queue\n// using Arrays\n\nusing System;\n\n// Structure for the elements in the\n// priority queue\npublic class item {\n    public int value;\n    public int priority;\n};\n\n\npublic class GFG\n{\n\n    // Store the element of a priority queue\n    static item[] pr = new item[100000];\n\n    // Pointer to the last index\n    static int size = -1;\n    // Function to insert a new element\n    // into priority queue\n    static void enqueue(int value, int priority)\n    {\n        // Increase the size\n        size++;\n\n        // Insert the element\n        pr[size] = new item();\n        pr[size].value = value;\n        pr[size].priority = priority;\n    }\n\n    // Function to check the top element\n    static int peek()\n    {\n        int highestPriority =  int.MinValue;\n        int ind = -1;\n\n        // Check for the element with\n        // highest priority\n        for (int i = 0; i <= size; i++) {\n\n            // If priority is same choose\n            // the element with the\n            // highest value\n            if (highestPriority == pr[i].priority && ind > -1\n                && pr[ind].value < pr[i].value) {\n                highestPriority = pr[i].priority;\n                ind = i;\n            }\n            else if (highestPriority < pr[i].priority) {\n                highestPriority = pr[i].priority;\n                ind = i;\n            }\n        }\n\n        // Return position of the element\n        return ind;\n    }\n\n    // Function to remove the element with\n    // the highest priority\n    static void dequeue()\n    {\n        // Find the position of the element\n        // with highest priority\n        int ind = peek();\n\n        // Shift the element one index before\n        // from the position of the element\n        // with highest priority is found\n        for (int i = ind; i < size; i++) {\n            pr[i] = pr[i + 1];\n        }\n\n        // Decrease the size of the\n        // priority queue by one\n        size--;\n    }\n\n    public static void Main(string[] args)\n    {\n         // Function Call to insert elements\n        // as per the priority\n        enqueue(10, 2);\n        enqueue(14, 4);\n        enqueue(16, 4);\n        enqueue(12, 3);\n\n        // Stores the top element\n        // at the moment\n        int ind = peek();\n\n        Console.WriteLine(pr[ind].value);\n\n        // Dequeue the top element\n        dequeue();\n\n        // Check the top element\n        ind = peek();\n        Console.WriteLine(pr[ind].value);\n\n        // Dequeue the top element\n        dequeue();\n\n        // Check the top element\n        ind = peek();\n        Console.WriteLine(pr[ind].value);\n    }\n}\n\n//this code is contributed by phasing17\n\n````\n\nJavaScript\n\n````\n// JavaScript program to implement Priority Queue\n// using Arrays\n\n// Structure for the elements in the\n// priority queue\nclass item {\n    constructor()\n    {\n        this.value;\n        this.priority;\n    }\n};\n\n// Store the element of a priority queue\nlet pr = [];\nfor (var i = 0; i < 100000; i++)\n    pr.push(new item());\n\n// Pointer to the last index\nlet size = -1;\n\n// Function to insert a new element\n// into priority queue\nfunction enqueue(value, priority)\n{\n    // Increase the size\n    size++;\n\n    // Insert the element\n    pr[size] = new item();\n    pr[size].value = value;\n    pr[size].priority = priority;\n}\n\n// Function to check the top element\nfunction peek()\n{\n    let highestPriority = Number.MIN_SAFE_INTEGER;\n    let ind = -1;\n\n    // Check for the element with\n    // highest priority\n    for (var i = 0; i <= size; i++) {\n\n        // If priority is same choose\n        // the element with the\n        // highest value\n        if (highestPriority == pr[i].priority && ind > -1\n            && pr[ind].value < pr[i].value) {\n            highestPriority = pr[i].priority;\n            ind = i;\n        }\n        else if (highestPriority < pr[i].priority) {\n            highestPriority = pr[i].priority;\n            ind = i;\n        }\n    }\n\n    // Return position of the element\n    return ind;\n}\n\n// Function to remove the element with\n// the highest priority\nfunction dequeue()\n{\n    // Find the position of the element\n    // with highest priority\n    let ind = peek();\n\n    // Shift the element one index before\n    // from the position of the element\n    // with highest priority is found\n    for (var i = ind; i < size; i++) {\n        pr[i] = pr[i + 1];\n    }\n\n    // Decrease the size of the\n    // priority queue by one\n    size--;\n}\n\n// Function Call to insert elements\n// as per the priority\nenqueue(10, 2);\nenqueue(14, 4);\nenqueue(16, 4);\nenqueue(12, 3);\n\n// Stores the top element\n// at the moment\nlet ind = peek();\n\nconsole.log(pr[ind].value);\n\n// Dequeue the top element\ndequeue();\n\n// Check the top element\nind = peek();\nconsole.log(pr[ind].value);\n\n// Dequeue the top element\ndequeue();\n\n// Check the top element\nind = peek();\nconsole.log(pr[ind].value);\n\n// this code is contributed by phasing17\n\n````\n\n\n\n\n**Output**\n```\n16\n14\n12\n```\n> ****Note:****\n> Read\n>\n> [****this article****](https://www.geeksforgeeks.org/priority-queue-using-array-in-c/)\n>\n> for more details.\n\n### ****2) Implement Priority Queue Using Linked List:****\n\n\nIn a LinkedList implementation, the entries are sorted in descending order based on their priority. The highest priority element is always added to the front of the priority queue, which is formed using linked lists. The functions like\n\n****push()****\n,\n\n****pop()****\n, and\n\n****peek()****\nare used to implement a priority queue using a linked list and are explained as follows:\n\n\n* ****push():****\n  This function is used to insert new data into the queue.\n* ****pop():****\n  This function removes the element with the highest priority from the queue.\n* ****peek() / top():****\n  This function is used to get the highest priority element in the queue without removing it from the queue.\n\nC++\n\n````\n// C++ code to implement Priority Queue\n// using Linked List\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Node\ntypedef struct node {\n    int data;\n\n    // Lower values indicate\n    // higher priority\n    int priority;\n\n    struct node* next;\n\n} Node;\n\n// Function to create a new node\nNode* newNode(int d, int p)\n{\n    Node* temp = (Node*)malloc(sizeof(Node));\n    temp->data = d;\n    temp->priority = p;\n    temp->next = NULL;\n\n    return temp;\n}\n\n// Return the value at head\nint peek(Node** head) { return (*head)->data; }\n\n// Removes the element with the\n// highest priority form the list\nvoid pop(Node** head)\n{\n    Node* temp = *head;\n    (*head) = (*head)->next;\n    free(temp);\n}\n\n// Function to push according to priority\nvoid push(Node** head, int d, int p)\n{\n    Node* start = (*head);\n\n    // Create new Node\n    Node* temp = newNode(d, p);\n\n    // Special Case: The head of list has\n    // lesser priority than new node\n    if ((*head)->priority < p) {\n\n        // Insert New Node before head\n        temp->next = *head;\n        (*head) = temp;\n    }\n    else {\n\n        // Traverse the list and find a\n        // position to insert new node\n        while (start->next != NULL\n               && start->next->priority > p) {\n            start = start->next;\n        }\n\n        // Either at the ends of the list\n        // or at required position\n        temp->next = start->next;\n        start->next = temp;\n    }\n}\n\n// Function to check is list is empty\nint isEmpty(Node** head) { return (*head) == NULL; }\n\n// Driver code\nint main()\n{\n\n    // Create a Priority Queue\n    // 7->4->5->6\n    Node* pq = newNode(4, 1);\n    push(&pq, 5, 2);\n    push(&pq, 6, 3);\n    push(&pq, 7, 0);\n\n    while (!isEmpty(&pq)) {\n        cout << \" \" << peek(&pq);\n        pop(&pq);\n    }\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java code to implement Priority Queue\n// using Linked List\nimport java.util.* ;\n\nclass Solution\n{\n\n// Node\nstatic class Node {\n    int data;\n\n    // Lower values indicate higher priority\n    int priority;\n    Node next;\n\n}\n\nstatic Node node = new Node();\n\n// Function to Create A New Node\nstatic Node newNode(int d, int p)\n{\n    Node temp = new Node();\n    temp.data = d;\n    temp.priority = p;\n    temp.next = null;\n\n    return temp;\n}\n\n// Return the value at head\nstatic int peek(Node head)\n{\n    return (head).data;\n}\n\n// Removes the element with the\n// highest priority from the list\nstatic Node pop(Node head)\n{\n    Node temp = head;\n    (head) = (head).next;\n    return head;\n}\n\n// Function to push according to priority\nstatic Node push(Node head, int d, int p)\n{\n    Node start = (head);\n\n    // Create new Node\n    Node temp = newNode(d, p);\n\n    // Special Case: The head of list has lesser\n    // priority than new node. So insert new\n    // node before head node and change head node.\n    if ((head).priority < p) {\n\n        // Insert New Node before head\n        temp.next = head;\n        (head) = temp;\n    }\n    else {\n\n        // Traverse the list and find a\n        // position to insert new node\n        while (start.next != null &&\n            start.next.priority > p) {\n            start = start.next;\n        }\n\n        // Either at the ends of the list\n        // or at required position\n        temp.next = start.next;\n        start.next = temp;\n    }\n    return head;\n}\n\n// Function to check is list is empty\nstatic int isEmpty(Node head)\n{\n    return ((head) == null)?1:0;\n}\n\n// Driver code\npublic static void main(String args[])\n{\n    // Create a Priority Queue\n    // 7.4.5.6\n    Node pq = newNode(4, 1);\n    pq =push(pq, 5, 2);\n    pq =push(pq, 6, 3);\n    pq =push(pq, 7, 0);\n\n    while (isEmpty(pq)==0) {\n        System.out.printf(\"%d \", peek(pq));\n        pq=pop(pq);\n    }\n\n}\n}\n\n// This code is contributed by ishankhandelwals.\n\n````\n\nPython\n\n````\n# Python3 code to implement Priority Queue\n# using Singly Linked List\n\n# Class to create new node which includes\n# Node Data, and Node Priority\nclass PriorityQueueNode:\n\n    def _init_(self, value, pr):\n\n        self.data = value\n        self.priority = pr\n        self.next = None\n\n# Implementation of Priority Queue\n\n\nclass PriorityQueue:\n\n    def _init_(self):\n\n        self.front = None\n\n    # Method to check Priority Queue is Empty\n    # or not if Empty then it will return True\n    # Otherwise False\n    def isEmpty(self):\n\n        return True if self.front == None else False\n\n    # Method to add items in Priority Queue\n    # According to their priority value\n    def push(self, value, priority):\n\n        # Condition check for checking Priority\n        # Queue is empty or not\n        if self.isEmpty() == True:\n\n            # Creating a new node and assigning\n            # it to class variable\n            self.front = PriorityQueueNode(value,\n                                           priority)\n\n            # Returning 1 for successful execution\n            return 1\n\n        else:\n\n            # Special condition check to see that\n            # first node priority value\n            if self.front.priority < priority:\n\n                # Creating a new node\n                newNode = PriorityQueueNode(value,\n                                            priority)\n\n                # Updating the new node next value\n                newNode.next = self.front\n\n                # Assigning it to self.front\n                self.front = newNode\n\n                # Returning 1 for successful execution\n                return 1\n\n            else:\n\n                # Traversing through Queue until it\n                # finds the next smaller priority node\n                temp = self.front\n\n                while temp.next:\n\n                    # If same priority node found then current\n                    # node will come after previous node\n                    if priority >= temp.next.priority:\n                        break\n\n                    temp = temp.next\n\n                newNode = PriorityQueueNode(value,\n                                            priority)\n                newNode.next = temp.next\n                temp.next = newNode\n\n                # Returning 1 for successful execution\n                return 1\n\n    # Method to remove high priority item\n    # from the Priority Queue\n    def pop(self):\n\n        # Condition check for checking\n        # Priority Queue is empty or not\n        if self.isEmpty() == True:\n            return\n\n        else:\n\n            # Removing high priority node from\n            # Priority Queue, and updating front\n            # with next node\n            self.front = self.front.next\n            return 1\n\n    # Method to return high priority node\n    # value Not removing it\n    def peek(self):\n\n        # Condition check for checking Priority\n        # Queue is empty or not\n        if self.isEmpty() == True:\n            return\n        else:\n            return self.front.data\n\n    # Method to Traverse through Priority\n    # Queue\n    def traverse(self):\n\n        # Condition check for checking Priority\n        # Queue is empty or not\n        if self.isEmpty() == True:\n            return \"Queue is Empty!\"\n        else:\n            temp = self.front\n            while temp:\n                print(temp.data, end=\" \")\n                temp = temp.next\n\n\n# Driver code\nif _name_ == \"_main_\":\n\n    # Creating an instance of Priority\n    # Queue, and adding values\n    # 7 -> 4 -> 5 -> 6\n    pq = PriorityQueue()\n    pq.push(4, 1)\n    pq.push(5, 2)\n    pq.push(6, 3)\n    pq.push(7, 0)\n\n    # Traversing through Priority Queue\n    pq.traverse()\n\n    # Removing highest Priority item\n    # for priority queue\n    pq.pop()\n\n````\n\nC#\n\n````\n// C# code to implement Priority Queue\n// using Linked List\nusing System;\n\nclass GFG\n{\n  // Node\n  public class Node\n  {\n    public int data;\n\n    // Lower values indicate\n    // higher priority\n    public int priority;\n\n    public Node next;\n  }\n\n  public static Node node = new Node();\n\n  // Function to Create A New Node\n  public static Node newNode(int d, int p)\n  {\n    Node temp = new Node();\n    temp.data = d;\n    temp.priority = p;\n    temp.next = null;\n\n    return temp;\n  }\n\n  // Return the value at head\n  public static int peek(Node head)\n  {\n    return (head).data;\n  }\n\n  // Removes the element with the\n  // highest priority from the list\n  public static Node pop(Node head)\n  {\n    Node temp = head;\n    (head) = (head).next;\n    return head;\n  }\n\n  // Function to push according to priority\n  public static Node push(Node head,\n                          int d, int p)\n  {\n    Node start = (head);\n\n    // Create new Node\n    Node temp = newNode(d, p);\n\n    // Special Case: The head of list\n    // has lesser priority than new node.\n    // So insert new node before head node\n    // and change head node.\n    if ((head).priority < p)\n    {\n\n      // Insert New Node before head\n      temp.next = head;\n      (head) = temp;\n    }\n    else\n    {\n\n      // Traverse the list and find a\n      // position to insert new node\n      while (start.next != null &&\n             start.next.priority > p)\n      {\n        start = start.next;\n      }\n\n      // Either at the ends of the list\n      // or at required position\n      temp.next = start.next;\n      start.next = temp;\n    }\n    return head;\n  }\n\n  // Function to check is list is empty\n  public static int isEmpty(Node head)\n  {\n    return ((head) == null) ? 1 : 0;\n  }\n\n  // Driver code\n  public static void Main(string[] args)\n  {\n    // Create a Priority Queue\n    // 7.4.5.6\n    Node pq = newNode(4, 1);\n    pq = push(pq, 5, 2);\n    pq = push(pq, 6, 3);\n    pq = push(pq, 7, 0);\n\n    while (isEmpty(pq) == 0)\n    {\n      Console.Write(\"{0:D} \", peek(pq));\n      pq = pop(pq);\n    }\n  }\n}\n\n// This code is contributed by ishankhandelwals.\n\n````\n\nJavaScript\n\n````\n// JavaScript code to implement Priority Queue\n// using Linked List\n// Node\nclass Node {\n\n    // Lower values indicate\n    // higher priority\n    constructor() {\n        this.data = 0;\n        this.priority = 0;\n        this.next = null;\n    }\n}\n\nvar node = new Node();\n\n// Function to Create A New Node\nfunction newNode(d, p) {\n    var temp = new Node();\n    temp.data = d;\n    temp.priority = p;\n    temp.next = null;\n\n    return temp;\n}\n\n// Return the value at head\nfunction peek(head) {\n    return head.data;\n}\n\n// Removes the element with the\n// highest priority from the list\nfunction pop(head) {\n    var temp = head;\n    head = head.next;\n    return head;\n}\n\n// Function to push according to priority\nfunction push(head, d, p) {\n    var start = head;\n\n    // Create new Node\n    var temp = newNode(d, p);\n\n    // Special Case: The head of list\n    // has lesser priority than new node.\n    // So insert new node before head node\n    // and change head node.\n    if (head.priority < p) {\n\n        // Insert New Node before head\n        temp.next = head;\n        head = temp;\n    }\n    else {\n\n        // Traverse the list and find a\n        // position to insert new node\n        while (start.next != null && start.next.priority > p) {\n            start = start.next;\n        }\n\n        // Either at the ends of the list\n        // or at required position\n        temp.next = start.next;\n        start.next = temp;\n    }\n    return head;\n}\n\n// Function to check is list is empty\nfunction isEmpty(head) {\n    return head == null ? 1 : 0;\n}\n\n// Driver code\n// Create a Priority Queue\n// 7.4.5.6\nvar pq = newNode(4, 1);\npq = push(pq, 5, 2);\npq = push(pq, 6, 3);\npq = push(pq, 7, 0);\n\nwhile (isEmpty(pq) == 0) {\n    console.log(peek(pq),\" \");\n    pq = pop(pq);\n}\n\n// This code is contributed by ishankhandelwals.\n\n````\n\n\n\n\n**Output**\n```\n 6 5 4 7\n```\n\n\nRefer to\n\n[this article](https://www.geeksforgeeks.org/priority-queue-using-linked-list/)\nfor more details.\n\n\n> ****Note:****\n> We can also use Linked List, time complexity of all operations with linked list remains same as array. The advantage with linked list is\n>\n>\n> deleteHighestPriority()\n>\n>\n> can be more efficient as we don\u2019t have to move items.\n\n### ****3) Implement Priority Queue Using Heaps:****\n\n\nBinary Heap is generally preferred for priority queue implementation because heaps provide better performance compared to arrays or LinkedList. Considering the properties of a heap, The entry with the largest key is on the top and can be removed immediately. It will, however, take time O(log n) to restore the heap property for the remaining keys. However if another entry is to be inserted immediately, then some of this time may be combined with the O(log n) time needed to insert the new entry. Thus the representation of a priority queue as a heap proves advantageous for large n, since it is represented efficiently in contiguous storage and is guaranteed to require only logarithmic time for both insertions and deletions. Operations on Binary Heap are as follows:\n\n\n* ****insert(p):****\n  Inserts a new element with priority p.\n* ****extractMax():****\n  Extracts an element with maximum priority.\n* ****remove(i):****\n  Removes an element pointed by an iterator i.\n* ****getMax():****\n  Returns an element with maximum priority.\n* ****changePriority(i, p):****\n  Changes the priority of an element pointed by\n\n  ****i to p****\n  .\n\n> Refer to\n>\n> [this article](https://www.geeksforgeeks.org/priority-queue-using-binary-heap/)\n> for code implementation.\n\n### ****4) Implement Priority Queue Using Binary Search Tree:****\n\n\nA Self-Balancing Binary Search Tree like AVL Tree, Red-Black Tree, etc. can also be used to implement a priority queue. Operations like peek(), insert() and delete() can be performed using BST.\n\n\n****Applications of Priority Queue:****\n---------------------------------------\n\n* CPU Scheduling\n* Graph algorithms like\n\n  [Dijkstra\u2019s shortest path algorithm](https://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/)\n  ,\n\n  [Prim\u2019s Minimum Spanning Tree](https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/)\n  , etc.\n* All\n\n  [queue applications](https://www.geeksforgeeks.org/applications-of-queue-data-structure/)\n  where priority is involved.\n* Data compression in Huffman code\n* Event-driven simulation such as customers waiting in a queue.\n* Finding Kth largest/smallest element.\n\n****Advantages of Priority Queue:****\n-------------------------------------\n\n* It helps to access the elements in a faster way. This is because elements in a priority queue are ordered by priority, one can easily retrieve the highest priority element without having to search through the entire queue.\n* The ordering of elements in a Priority Queue is done dynamically. Elements in a priority queue can have their priority values updated, which allows the queue to dynamically reorder itself as priorities change.\n* Efficient algorithms can be implemented. Priority queues are used in many algorithms to improve their efficiency, such as Dijkstra\u2019s algorithm for finding the shortest path in a graph and the A\\* search algorithm for pathfinding.\n* Included in real-time systems. This is because priority queues allow you to quickly retrieve the highest priority element, they are often used in real-time systems where time is of the essence.\n\n****Disadvantages of Priority Queue:****\n----------------------------------------\n\n* High complexity. Priority queues are more complex than simple data structures like arrays and linked lists, and may be more difficult to implement and maintain.\n* High consumption of memory. Storing the priority value for each element in a priority queue can take up additional memory, which may be a concern in systems with limited resources.\n* It is not always the most efficient data structure. In some cases, other data structures like heaps or binary search trees may be more efficient for certain operations, such as finding the minimum or maximum element in the queue.\n* At times it is less predictable:. This is because the order of elements in a priority queue is determined by their priority values, the order in which elements are retrieved may be less predictable than with other data structures like stacks or queues, which follow a first-in, first-out (FIFO) or last-in, first-out (LIFO) order.\n",
        "metadata": {
            "lesson_id": "192cb6e4-14cd-4265-9d7d-7cbf5bc0817f",
            "course_id": "8ff4ea92-41f2-4d49-b230-0281874efb2d",
            "course_name": "Introduction to DSA II",
            "lesson_description": "A priority queue is a type of queue that arranges elements based on their priority values. Elements with higher priority values are typically retrieved or removed before elements with lower priority values. Each element has a priority value associated with it. When we add an item, it is inserted in a position based on its priority value.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Need of Recursive Function:\n---------------------------\n\n\nA recursive function is a function that solves a problem by solving smaller instances of the same problem. This technique is often used in programming to solve problems that can be broken down into simpler, similar subproblems.\n\n\n### 1. ****Solving complex tasks:****\n\n\nRecursive functions break complex problems into smaller instances of the same problem, resulting in compact and readable code.\n\n\n### 2. Divide and Conquer:\n\n\nRecursive functions are suitable for divide-and-conquer algorithms such as merge sort and quicksort, breaking problems into smaller subproblems, solving them recursively, and merging the solutions with the original problem.\n\n\n### 3. ****Backtracking**** :\n\n\nRecursive backtracking is ideal for exploring and solving problems like N-Queens and Sudoku.\n\n\n\n### 4. Dynamic ****programming:****\n\n\nRecursive functions efficiently solve dynamic programming problems by solving subproblems and combining their solutions into a complete solution.\n\n\n### 5. Tree and ****graph structures:****\n\n\nRecursive functions are great for working with tree and graph structures, simplifying traversal and pattern recognition tasks\n\n****.****\n\nHow to write a Recursive Function:\n----------------------------------\n\n### Components of a recursive function:\n\n****Base case:****\nEvery recursive function must have a base case. The base case is the simplest scenario that does not require further recursion. This is a termination condition that prevents the function from calling itself indefinitely. Without a proper base case, a recursive function can lead to infinite recursion.\n\n\n****Recursive case:****\nIn the recursive case, the function calls itself with the modified arguments. This is the essence of recursion \u2013 solving a larger problem by breaking it down into smaller instances of the same problem. The recursive case should move closer to the base case with each iteration.\n\n\nLet\u2019s consider the example of\n\n[factorial of number](https://www.geeksforgeeks.org/program-for-factorial-of-a-number/)\n:\n\n\nIn this example, the base case is when\n\n****n****\nis\n\n****0****\n, and the function returns\n\n****1****\n. The recursive case multiplies\n\n****n****\nwith the result of the function called with parameter\n\n****n \u2013 1****\n. The process continues until the base case is reached.\n\n\nIt\u2019s essential to ensure that the recursive function has a correct base case and that the recursive calls lead to the base case, otherwise, the procedure might run indefinitely, leading to a stack overflow (exceeding the available memory allocated for function calls).\n\n\nBelow is the implementation of factorial of a number:\n\n\nC++\n\n````\n#include <iostream>\nusing namespace std;\n\n// Recursive Function to calculate Factorial of a number\nint factorial(int n)\n{\n    // Base case\n    if (n == 0) {\n        return 1;\n    }\n\n    // Recursive case\n    return n * factorial(n - 1);\n}\n\n// Driver Code\n\nint main()\n{\n    int n = 4;\n\n    cout << \"Factorial of \" << n\n         << \" is:\" << factorial(n);\n    return 0;\n}\n\n````\n\nJava\n\n````\nimport java.util.Scanner;\n\npublic class Factorial {\n    // Recursive Function to calculate the factorial of a number\n    static int factorial(int n) {\n        // Base case: If n is 0, the factorial is 1.\n        if (n == 0) {\n            return 1;\n        }\n\n        // Recursive case: Calculate the factorial by multiplying n with the factorial of (n - 1).\n        return n * factorial(n - 1);\n    }\n\n    public static void main(String[] args) {\n        int n = 4;\n\n        // Calculate and print the factorial of n.\n        int result = factorial(n);\n        System.out.println(\"Factorial of \" + n + \" is: \" + result);\n    }\n}\n\n````\n\nPython\n\n````\n# Recursive Function to calculate Factorial of a number\ndef factorial(n):\n    # Base case\n    if n == 0:\n        return 1\n\n    # Recursive case\n    return n * factorial(n - 1)\n\n# Driver Code\nif __name__ == \"__main__\":\n    n = 4\n\n    print(\"Factorial of\", n, \"is:\", factorial(n))\n\n````\n\nC#\n\n````\nusing System;\n\nclass Program\n{\n    // Recursive Function to calculate Factorial of a number\n    static int Factorial(int n)\n    {\n        // Base case\n        if (n == 0)\n        {\n            return 1;\n        }\n\n        // Recursive case\n        return n * Factorial(n - 1);\n    }\n\n    // Driver Code\n    static void Main()\n    {\n        int n = 4;\n\n        Console.WriteLine(\"Factorial of \" + n + \" is: \" + Factorial(n));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Function to calculate the factorial of a number using recursion\nfunction factorial(n) {\n    // Base case: If n is 0, the factorial is 1.\n    if (n === 0) {\n        return 1;\n    }\n\n    // Recursive case: Calculate the factorial by multiplying n with the factorial of (n - 1).\n    return n * factorial(n - 1);\n}\n\n// Main function\nfunction main() {\n    // Given number\n    let n = 4;\n\n    // Calculate the factorial of n.\n    let result = factorial(n);\n\n    // Print the result\n    console.log(\"Factorial of \" + n + \" is: \" + result);\n}\n\n// Call the main function\nmain();\n\n````\n\n\n\n\n**Output**\n```\nFactorial of 4 is:24\n```\n\n****Time Complexity:****\nO(n)\n\n\n\n****Auxiliary Space:****\nO(n)\n\n",
        "metadata": {
            "lesson_id": "7106768d-cb8a-49a3-b944-1aa4e1266f10",
            "course_id": "8ff4ea92-41f2-4d49-b230-0281874efb2d",
            "course_name": "Introduction to DSA II",
            "lesson_description": "In other words, a recursive function is a function that solves a problem by solving smaller instances of the same problem. This technique is commonly used in programming to solve problems that can be broken down into simpler, similar subproblems.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "\n[Factorial](https://www.geeksforgeeks.org/factorial/)\nof a number\n\n****n****\nis defined as the product of all the\n\n****positive****\nnumbers less than n. In other words, Factorial of a number\n\n****n****\ncan be calculated as:\n\n****n \u00d7 (n \u2013 1) \u00d7 (n \u2013 2) \u00d7 \u2026 \u00d7 1.****\nFactorial of a number n is denoted as\n\n****n!****\n. It is widely used in Combinatorics and Algebra to find the number of ways to arrange or select items.\n\n\n****Examples:****\n\n> ****0!****\n> = 1\n>\n>\n> ****1!****\n> = 1\n>\n>\n> ****3!****\n> = 3 x 2 x 1 = 6\n\n\nHere is a list of problems based on Factorial.\n\n\n* [Factorial of a Number](https://www.geeksforgeeks.org/program-for-factorial-of-a-number/)\n* [Check Factorial](https://www.geeksforgeeks.org/check-if-a-given-number-is-factorial-of-any-number/)\n* [Factorial of Large number](https://www.geeksforgeeks.org/factorial-large-number/)\n* [Count trailing zeroes](https://www.geeksforgeeks.org/count-trailing-zeroes-factorial-number/)\n* [Sum of Digits](https://www.geeksforgeeks.org/find-sum-digits-factorial-number/)\n* [Double Factorial](https://www.geeksforgeeks.org/double-factorial/)\n* [Last Non-Zero digit](https://www.geeksforgeeks.org/last-non-zero-digit-factorial/)\n* [Check Strong Number](https://www.geeksforgeeks.org/program-to-check-strong-number/)\n* [Factorial without Multiplication](https://www.geeksforgeeks.org/factorial-of-a-number-without-using-multiplication/)\n* [Length of factorial](https://www.geeksforgeeks.org/find-the-length-of-factorial-of-a-number-in-any-given-base/)\n* [Sum of Factorials till N (1! + 2! + 3! + \u2026 + N!)](https://www.geeksforgeeks.org/find-sum-of-factorials-till-n-factorial-1-2-3-n/)\n* [Smallest number at least n trailing zeroes](https://www.geeksforgeeks.org/smallest-number-least-n-trailing-zeroes-factorial/)\n* [Factorial of an Array](https://www.geeksforgeeks.org/factorial-of-an-array-of-integers/)\n* [K-th Prime Factor](https://www.geeksforgeeks.org/k-th-prime-factor-given-number/)\n* [nCr](https://www.geeksforgeeks.org/program-calculate-value-ncr/)\n* [Ways to go from one point to another](https://www.geeksforgeeks.org/number-of-ways-to-go-from-one-point-to-another-in-a-grid/)\n* [Check Krishnamurthy Number](https://www.geeksforgeeks.org/check-if-a-number-is-a-krishnamurthy-number-or-not-2/)\n* [nCr using Fermat Little Theorem](https://www.geeksforgeeks.org/compute-ncrp-using-fermat-little-theorem/)\n* [Ways to arrange K different objects](https://www.geeksforgeeks.org/number-of-ways-to-arrange-k-different-objects-taking-n-objects-at-a-time/)\n\n> Recommended Links\n>\n>\n> * [Factorial Formula](https://www.geeksforgeeks.org/factorial-formula/)\n> * [Interesting Facts about Factorial](https://www.geeksforgeeks.org/interesting-facts-about-factorial/)\n",
        "metadata": {
            "lesson_id": "6477db8f-1fdf-4441-80b4-09122d290265",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "\n[Prime Numbers](https://www.geeksforgeeks.org/prime-numbers/)\nare natural numbers greater than 1 and can be divided by itself and 1 only. For instance, numbers 2, 3, 5, 7, and 11 are the prime numbers since they can only be divided by 1 and themselves, there is no other number that can fully divide them Since it is manually very difficult to check if a number is prime (no direct formula) and find prime factors, problems related to prime become really interesting coding problems.\n\n\nHere is a list of example problems based on prime.\n\n\n* [Check for Prime Number](https://www.geeksforgeeks.org/check-for-prime-number/)\n* [All Prime Factors](https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/)\n* [Largest Prime Factor](https://www.geeksforgeeks.org/find-largest-prime-factor-number/)\n* [Check for Co-Prime](https://www.geeksforgeeks.org/count-number-of-primes-in-an-array/)\n* [Primes in an Array](https://www.geeksforgeeks.org/find-two-prime-numbers-with-given-sum/)\n* [Primes with Given Sum](https://www.geeksforgeeks.org/pair-of-prime-numbers-with-a-given-sum-and-minimum-absolute-difference/)\n* [Pair of Primes with Given Sum and Min Diff](https://www.geeksforgeeks.org/pair-of-prime-numbers-with-a-given-sum-and-minimum-absolute-difference/)\n* [Prime Number Gap](https://www.geeksforgeeks.org/minimum-difference-between-any-two-primes-from-the-given-range/)\n* [Find the next prime](https://www.geeksforgeeks.org/program-to-find-the-next-prime-number/)\n* [Check for Strong Prime](https://www.geeksforgeeks.org/check-if-n-is-strong-prime/)\n* [Closest Prime](https://www.geeksforgeeks.org/count-of-n-digit-numbers-which-contains-all-single-digit-primes/)\n* [N Digit Numbers with Prime Digits](https://www.geeksforgeeks.org/count-of-n-digit-numbers-which-contains-all-single-digit-primes/)\n* [Sieve of Eratosthenes](https://www.geeksforgeeks.org/sieve-of-eratosthenes/)\n* [Nth Prime Number](https://www.geeksforgeeks.org/program-to-find-the-nth-prime-number/)\n* [Program to print prime numbers from 1 to N.](https://www.geeksforgeeks.org/program-to-print-first-n-prime-numbers/)\n* [Segmented Sieve](https://www.geeksforgeeks.org/segmented-sieve/)",
        "metadata": {
            "lesson_id": "e87fc291-5b1a-497b-ad5b-54a15743ed1f",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "\n### ****Mathematical Concepts:****\n\n* [Numbers](https://www.geeksforgeeks.org/numbers-aptitude-questions-and-answers/)\n* [Prime Numbers](https://www.geeksforgeeks.org/prime-numbers/)\n* [Arithmetic Progression](https://www.geeksforgeeks.org/what-is-arithmetic-progression/)\n* [Geometric Progression](https://www.geeksforgeeks.org/what-is-geometric-progression/)\n* [GCD](https://www.geeksforgeeks.org/greatest-common-divisor-gcd/)\n  and\n\n  [LCM](https://www.geeksforgeeks.org/lcm-least-common-multiple/)\n* [Factorial](https://www.geeksforgeeks.org/factorial/)\n* [Permutation](https://www.geeksforgeeks.org/permutation/)\n  and\n\n  [Combination](https://www.geeksforgeeks.org/combinations/)\n* [Catalan Number](https://www.geeksforgeeks.org/catalan-numbers/)\n* [Modular Arithmetic](https://www.geeksforgeeks.org/modular-arithmetic/)\n\n### ****Basic Problems****\n\n* [Sum of Naturals](https://www.geeksforgeeks.org/program-find-sum-first-n-natural-numbers/)\n* [Sum of Squares of Naturals](https://www.geeksforgeeks.org/sum-of-squares-of-first-n-natural-numbers/)\n* [Nth Term of AP](https://www.geeksforgeeks.org/program-n-th-term-arithmetic-progression-series/)\n* [Nth Term of GP](https://www.geeksforgeeks.org/find-nth-term-geometric-progression-series/)\n* [Nth Triangular Number](https://www.geeksforgeeks.org/triangular-numbers/)\n* [Sum of Sums of Natural Numbers](https://www.geeksforgeeks.org/sum-of-first-n-natural-numbers/)\n* [Count Digits](https://www.geeksforgeeks.org/program-count-digits-integer-3-different-methods/)\n* [Sum of Digits](https://www.geeksforgeeks.org/program-for-sum-of-the-digits-of-a-given-number/)\n* [Reverse Digits](https://www.geeksforgeeks.org/write-a-program-to-reverse-digits-of-a-number/)\n* [K-th Digit in a^b](https://www.geeksforgeeks.org/k-th-digit-raised-power-b/)\n* [Palindrome Number](https://www.geeksforgeeks.org/check-if-a-number-is-palindrome/)\n* [GCD of Two Numbers](https://www.geeksforgeeks.org/program-to-find-lcm-of-two-numbers/)\n* [LCM of Two Numbers](https://www.geeksforgeeks.org/program-to-find-lcm-of-two-numbers/)\n* [Add two fractions](https://www.geeksforgeeks.org/program-to-add-two-fractions/)\n* [Check for Co-Prime](https://www.geeksforgeeks.org/check-two-numbers-co-prime-not/)\n* [Factorial of a Number](https://www.geeksforgeeks.org/program-for-factorial-of-a-number/)\n* [GCD of more than 2](https://www.geeksforgeeks.org/gcd-two-array-numbers/)\n* [LCM of more than 2](https://www.geeksforgeeks.org/lcm-of-given-array-elements/)\n* [Padovan Sequence](https://www.geeksforgeeks.org/padovan-sequence/)\n\n### ****Easy Problems****\n\n* [Pair Cube Count](https://www.geeksforgeeks.org/count-pairs-a-b-whose-sum-of-cubes-is-n-a3-b3-n/)\n* [Sum of 2, 22, 222, \u2026\u2026\u2026](https://www.geeksforgeeks.org/sum-sequence-2-22-222/)\n* [Sum of 1^2 + 3^2 + 5^2 + . . . + (2\\*n \u2013 1)^2](https://www.geeksforgeeks.org/sum-series-12-32-52-2n-12/)\n* [Sum of 0.6, 0.06, 0.006, 0.0006, \u2026to n terms](https://www.geeksforgeeks.org/sum-series-0-6-0-06-0-006-0-0006-n-terms/)\n* [n-th term of 2, 12, 36, 80, 150\u2026.](https://www.geeksforgeeks.org/n-th-term-series-2-12-36-80-150/)\n* [Digit Root](https://www.geeksforgeeks.org/digital-rootrepeated-digital-sum-given-integer/)\n* [Fibonacci Numbers](https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/)\n* [Lucas Number](https://www.geeksforgeeks.org/lucas-numbers/)\n* [Check for Power](https://www.geeksforgeeks.org/check-if-a-number-is-power-of-another-number/)\n* [Three Divisors](https://www.geeksforgeeks.org/numbers-exactly-3-divisors/)\n* [Square Root](https://www.geeksforgeeks.org/square-root-of-an-integer/)\n* [Binomial Coefficient](https://www.geeksforgeeks.org/binomial-coefficient-dp-9/)\n* [Pascal Triangle](https://www.geeksforgeeks.org/pascal-triangle/)\n* [nth Row of the Pascal Triangle](https://www.geeksforgeeks.org/find-the-nth-row-in-pascals-triangle/)\n* [Armstrong Numbers](https://www.geeksforgeeks.org/program-for-armstrong-numbers/)\n* [Determinant of a Matrix](https://www.geeksforgeeks.org/determinant-of-a-matrix/)\n* [Modular Exponentiation](https://www.geeksforgeeks.org/modular-exponentiation-power-in-modular-arithmetic/)\n* [Check for Perfect Squares](https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/)\n* [Divisibility by 3](https://www.geeksforgeeks.org/check-large-number-divisible-3-not/)\n* [Divisibility by 4](https://www.geeksforgeeks.org/check-large-number-divisible-4-not/)\n* [Divisibility by 7](https://www.geeksforgeeks.org/divisibility-by-7/)\n* [Divisibility by 11](https://origin.geeksforgeeks.org/check-large-number-divisible-11-not/)\n* [Divisibility by 13](https://www.geeksforgeeks.org/check-large-number-divisible-13-not/)\n* [Divisibility by 29](https://www.geeksforgeeks.org/number-is-divisible-by-29-or-not/)\n\n### ****Medium Problems****\n\n* [Linear Diophantine Equations](https://www.geeksforgeeks.org/eulers-totient-function/)\n* [Euler's Totient Function](https://www.geeksforgeeks.org/eulers-totient-function/)\n* [Sieve of Eratosthenes](https://www.geeksforgeeks.org/find-all-factors-of-a-natural-number/)\n* [All Divisors](https://www.geeksforgeeks.org/prime-factor/)\n* [Prime Factorization](https://www.geeksforgeeks.org/find-largest-prime-factor-number/)\n* [Largest Prime Factor](https://www.geeksforgeeks.org/factorial-large-number/)\n* [Factorial of a Large Number](https://www.geeksforgeeks.org/factorial-large-number/)\n* [Largest Power Divisible in Factorial](https://www.geeksforgeeks.org/largest-power-k-n-factorial-k-may-not-prime/)\n* [Last Non-zero Digit of Factorial](https://www.geeksforgeeks.org/last-non-zero-digit-factorial/)\n* [Power Set](https://www.geeksforgeeks.org/power-set/)\n* [Add Two Polynomials](https://www.geeksforgeeks.org/program-add-two-polynomials/)\n* [All Permutations of a String](https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/)\n* [Next Permutation](https://www.geeksforgeeks.org/next-permutation/)\n* [Check for Carmichael Numbers](https://www.geeksforgeeks.org/carmichael-numbers/)\n* [Collatz sequence](https://www.geeksforgeeks.org/program-to-print-collatz-sequence/)\n* [Grid Unique Paths](https://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/)\n* [Nth Even Fibonacci Number](https://www.geeksforgeeks.org/nth-even-fibonacci-number/)\n* [Last 2 Digits of Nth Fibonacci](https://www.geeksforgeeks.org/program-find-last-two-digits-nth-fibonacci-number/)\n\n### ****Hard Problems****\n\n* [Josephus Problem](https://www.geeksforgeeks.org/josephus-problem/)\n* [Water Jug Tutorial](https://www.geeksforgeeks.org/water-jug-problem-complete-tutorial/)\n* [Segmented Sieve](https://www.geeksforgeeks.org/segmented-sieve/)\n* [k-th prime factor](https://www.geeksforgeeks.org/k-th-prime-factor-given-number/)\n* [N-th Root](https://www.geeksforgeeks.org/n-th-root-number/)\n* [Sum of Digits in Factorial](https://www.geeksforgeeks.org/find-sum-digits-factorial-number/)\n* [Egg Dropping](https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/)\n* [Next String](https://www.geeksforgeeks.org/lexicographically-next-string/)",
        "metadata": {
            "lesson_id": "28f5205e-a507-4ef7-aaf7-73b013044326",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "The following is the list of mathematical concepts and related coding problems. The coding problems are ordered according to difficulty level. Please refer\nMathematical Algorithms (Topic Wise) for the topic wise list of problems.",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "\nGiven a fraction, find a recurring sequence of digits if it exists, otherwise, print \u201cNo recurring sequence\u201d.\n\n                                                                                                                                    **Examples:**\n\n                                                                                                                                    ```\n                                                                                                                                    Input  : Numerator = 8, Denominator = 3\n                                                                                                                                    Output : Recurring sequence is 6\n                                                                                                                                    Explanation : 8/3 = 2.66666666.......\n\n                                                                                                                                    Input : Numerator = 50, Denominator = 22\n                                                                                                                                    Output : Recurring sequence is 27\n                                                                                                                                    Explanation : 50/22 = 2.272727272.....\n\n                                                                                                                                    Input : Numerator = 11, Denominator = 2\n                                                                                                                                    Output : No recurring sequence\n                                                                                                                                    Explanation : 11/2 = 5.5\n                                                                                                                                    ```\n\n                                                                                                                                       [We strongly recommend that you click here and practice it, before moving on to the solution.](https://www.geeksforgeeks.org/problems/a-simple-fraction0921/1)\n--------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n**When does the fractional part repeat?**\n\n\nLet us simulate the process of converting fractions to decimals. Let us look at the part where we have already figured out the integer part, which is floor(numerator/denominator). Now we are left with ( remainder = numerator%denominator ) / denominator.\n\nIf you remember the process of converting to decimal, at each step we do the following :\n\n                                                                                                                                    1. Multiply the remainder by 10.\n                                                                                                                                    2. Append the remainder/denominator to the result.\n                                                                                                                                    3. Remainder = remainder % denominator.\n\n                                                                                                                                    At any moment, if the remainder becomes 0, we are done.\n\n\nHowever, when there is a recurring sequence, the remainder never becomes 0. For example, if you look at 1/3, the remainder never becomes 0.\n\nBelow is one important observation :\n\n\nIf we start with the remainder \u2018rem\u2019 and if the remainder repeats at any point in time, the digits between the two occurrences of \u2018rem\u2019 keep repeating.\n\n\nSo the idea is to store seen remainders in a map. Whenever a remainder repeats, we return the sequence before the next occurrence.\n\nBelow is the implementation of the above idea.\n\nC++\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// C++ program to find repeating\n// sequence in a fraction\n#include <bits/stdc++.h>\nusing namespace std;\n\n// This function returns repeating sequence of\n// a fraction.  If repeating sequence doesn't\n// exist, then returns empty string\nstring fractionToDecimal( int numr, int denr)\n{\nstring res; // Initialize result\n\n// Create a map to store already\n// seen remainders, remainder is used\n// as key and its position in\n// result is stored as value.\n// Note that we need\n// position for cases like 1/6.\n// In this case,the recurring sequence\n// doesn't start from first\n// remainder.\nmap< int , int > mp;\nmp.clear();\n\n// Find first remainder\nint rem = numr % denr;\n\n// Keep finding remainder until either remainder\n// becomes 0 or repeats\nwhile ((rem != 0)\n&& (mp.find(rem) == mp.end()))\n{\n// Store this remainder\nmp[rem] = res.length();\n\n// Multiply remainder with 10\nrem = rem * 10;\n\n// Append rem / denr to result\nint res_part = rem / denr;\nres += to_string(res_part);\n\n// Update remainder\nrem = rem % denr;\n}\n\nreturn (rem == 0) ? \"\" : res.substr(mp[rem]);\n}\n\n// Driver code\nint main()\n{\nint numr = 50, denr = 22;\nstring res = fractionToDecimal(numr, denr);\nif (res == \"\" )\ncout << \"No recurring sequence\" ;\nelse\ncout << \"Recurring sequence is \" << res;\nreturn 0;\n}\n```\n\n\n\n\n\nJava\n----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// Java program to find\n// repeating sequence\n// in a fraction\nimport java.util.*;\nclass GFG {\n\n// This function returns repeating\n// sequence of a fraction. If\n// repeating sequence doesn't\n// exist, then returns empty String\nstatic String fractionToDecimal( int numr, int denr)\n{\n// Initialize result\nString res = \"\" ;\n\n// Create a map to store already\n// seen remainders. Remainder is\n// used as key and its position in\n// result is stored as value.\n// Note that we need position for\n// cases like 1/6.  In this case,\n// the recurring sequence doesn't\n// start from first remainder.\nHashMap<Integer, Integer> mp = new HashMap<>();\nmp.clear();\n\n// Find first remainder\nint rem = numr % denr;\n\n// Keep finding remainder until\n//  either remainder becomes 0 or repeats\nwhile ((rem != 0 ) && (!mp.containsKey(rem)))\n{\n// Store this remainder\nmp.put(rem, res.length());\n\n// Multiply remainder with 10\nrem = rem * 10 ;\n\n// Append rem / denr to result\nint res_part = rem / denr;\nres += String.valueOf(res_part);\n\n// Update remainder\nrem = rem % denr;\n}\n\nif (rem == 0 )\nreturn \"\" ;\nelse if (mp.containsKey(rem))\nreturn res.substring(mp.get(rem));\n\nreturn \"\" ;\n}\n\n// Driver code\npublic static void main(String[] args)\n{\nint numr = 50 , denr = 22 ;\nString res = fractionToDecimal(numr, denr);\nif (res == \"\" )\nSystem.out.print( \"No recurring sequence\" );\nelse\nSystem.out.print( \"Recurring sequence is \"\n+ res);\n}\n}\n\n// This code is contributed by gauravrajput1\n```\n\n\n\n\n\nPython3\n-------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n# Python3 program to find repeating\n# sequence in a fraction\n\n# This function returns repeating sequence\n# of a fraction.If repeating sequence doesn't\n# exist, then returns empty string\n\n\ndef fractionToDecimal(numr, denr):\n\n# Initialize result\nres = \"\"\n\n# Create a map to store already seen\n# remainders. Remainder is used as key\n# and its position in result is stored\n# as value. Note that we need position\n# for cases like 1/6.  In this case,\n# the recurring sequence doesn't start\n# from first remainder.\nmp = {}\n\n# Find first remainder\nrem = numr % denr\n\n# Keep finding remainder until either\n# remainder becomes 0 or repeats\nwhile ((rem ! = 0 ) and (rem not in mp)):\n\n# Store this remainder\nmp[rem] = len (res)\n\n# Multiply remainder with 10\nrem = rem * 10\n\n# Append rem / denr to result\nres_part = rem / / denr\nres + = str (res_part)\n\n# Update remainder\nrem = rem % denr\n\nif (rem = = 0 ):\nreturn \"\"\nelse :\nreturn res[mp[rem]:]\n\n\n# Driver code\nnumr, denr = 50 , 22\nres = fractionToDecimal(numr, denr)\n\nif (res = = \"\"):\nprint ( \"No recurring sequence\" )\nelse :\nprint ( \"Recurring sequence is\" , res)\n\n# This code is contributed by divyeshrabadiya07\n```\n\n\n\n\n\nC#\n--\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// C# program to find repeating sequence\n// in a fraction\nusing System;\nusing System.Collections.Generic;\n\nclass GFG {\n\n// This function returns repeating\n// sequence of a fraction. If\n// repeating sequence doesn't\n// exist, then returns empty String\nstatic string fractionToDecimal( int numr, int denr)\n{\n// Initialize result\nstring res = \"\" ;\n\n// Create a map to store already\n// seen remainders. Remainder is\n// used as key and its position in\n// result is stored as value.\n// Note that we need position for\n// cases like 1/6.  In this case,\n// the recurring sequence doesn't\n// start from first remainder.\nDictionary< int , int > mp\n= new Dictionary< int , int >();\n\n// Find first remainder\nint rem = numr % denr;\n\n// Keep finding remainder until\n// either remainder becomes 0\n// or repeats\nwhile ((rem != 0) && (!mp.ContainsKey(rem)))\n{\n\n// Store this remainder\nmp[rem] = res.Length;\n\n// Multiply remainder with 10\nrem = rem * 10;\n\n// Append rem / denr to result\nint res_part = rem / denr;\nres += res_part.ToString();\n\n// Update remainder\nrem = rem % denr;\n}\n\nif (rem == 0)\nreturn \"\" ;\nelse if (mp.ContainsKey(rem))\nreturn res.Substring(mp[rem]);\n\nreturn \"\" ;\n}\n\n// Driver code\npublic static void Main( string [] args)\n{\nint numr = 50, denr = 22;\nstring res = fractionToDecimal(numr, denr);\n\nif (res == \"\" )\nConsole.Write( \"No recurring sequence\" );\nelse\nConsole.Write( \"Recurring sequence is \" + res);\n}\n}\n\n// This code is contributed by rutvik_56\n```\n\n\n\n\n\nJavascript\n----------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n<script>\n\n// Javascript program to find\n// repeating sequence\n// in a fraction\n\n// This function returns repeating\n// sequence of a fraction. If\n// repeating sequence doesn't\n// exist, then returns empty String\nfunction fractionToDecimal(numr, denr)\n{\n// Initialize result\nlet res = \"\" ;\n\n// Create a map to store already\n// seen remainders. Remainder is\n// used as key and its position in\n// result is stored as value.\n// Note that we need position for\n// cases like 1/6.  In this case,\n// the recurring sequence doesn't\n// start from first remainder.\nlet mp = new Map();\nmp.clear();\n\n// Find first remainder\nlet rem = numr % denr;\n\n// Keep finding remainder until\n//  either remainder becomes 0 or repeats\nwhile ((rem != 0) && (!mp.has(rem)))\n{\n// Store this remainder\nmp.set(rem, res.length);\n\n// Multiply remainder with 10\nrem = rem * 10;\n\n// Append rem / denr to result\nlet res_part = Math.floor(rem / denr);\nres += res_part.toString();\n\n// Update remainder\nrem = rem % denr;\n}\n\nif (rem == 0)\nreturn \"\" ;\nelse if (mp.has(rem))\nreturn res.substr(mp.get(rem));\n\nreturn \"\" ;\n}\n\n// Driver program\n\nlet numr = 50, denr = 22;\nlet res = fractionToDecimal(numr, denr);\nif (res == \"\" )\ndocument.write( \"No recurring sequence\" );\nelse\ndocument.write( \"Recurring sequence is \"\n+ res);\n\n</script>\n```\n\n\n\n\n\n\n\n**Output**\n```\nRecurring sequence is 27\n```\n\n**Time Complexity : O(N)**\n\n**Auxiliary Space : O(N) ,**\n                                                                                                                                        as we use map as extra space.\n                                                                                                                                        ",
        "metadata": {
            "lesson_id": "c08fa70f-b522-438e-a134-46e4a754c0c8",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "Table of Content\n\n                                                                                                                                        * [Divide and Conquer Algorithm Definition](#divide-and-conquer-algorithm-definition)\n                                                                                                                                        * [Working of Divide and Conquer Algorithm](#working-of-divide-and-conquer-algorithm)\n                                                                                                                                        * [Characteristics of Divide and Conquer Algorithm](#characteristics-of-divide-and-conquer-algorithm)\n                                                                                                                                        * [Examples of Divide and Conquer Algorithm](#examples-of-divide-and-conquer-algorithm)\n                                                                                                                                        * [Complexity Analysis of Divide and Conquer Algorithm](#complexity-analysis-of-divide-and-conquer-algorithm)\n                                                                                                                                        * [Applications of Divide and Conquer Algorithm](#applications-of-divide-and-conquer-algorithm)\n                                                                                                                                        * [Advantages of Divide and Conquer Algorithm](#advantages-of-divide-and-conquer-algorithm)\n                                                                                                                                        * [Disadvantages of Divide and Conquer Algorithm](#disadvantages-of-divide-and-conquer-algorithm)\n\n                                                                                                                                        ****Divide and Conquer****\n\n                                                                                                                                        Algorithm Definition:\n-------------------------------------------------\n\n                                                                                                                                        > ****Divide and Conquer Algorithm****\n                                                                                                                                        > involves breaking a larger problem into smaller subproblems, solving them independently, and then combining their solutions to solve the original problem. The basic idea is to recursively divide the problem into smaller subproblems until they become simple enough to be solved directly. Once the solutions to the subproblems are obtained, they are then combined to produce the overall solution.\n\nWorking of Divide and Conquer Algorithm:\n----------------------------------------\n\n\nDivide and Conquer Algorithm can be divided into three steps:\n\n****Divide****\n                                                                                                                                       ,\n\n                                                                                                                                    ****Conquer****\n                                                                                                                                        and\n\n                                                                                                                                    ****Merge****\n                                                                                                                                        .\n\n\n![Working-of-Divide-and-Conquer-Algorithm](https://media.geeksforgeeks.org/wp-content/uploads/20240501171531/Working-of-Divide-and-Conquer-Algorithm.webp)\n\n### ****1. Divide:****\n\n* Break down the original problem into smaller subproblems.\n* Each subproblem should represent a part of the overall problem.\n* The goal is to divide the problem until no further division is possible.\n\n### ****2. Conquer:****\n\n* Solve each of the smaller subproblems individually.\n* If a subproblem is small enough (often referred to as the \u201cbase case\u201d), we solve it directly without further recursion.\n* The goal is to find solutions for these subproblems independently.\n\n### 3. Merge:\n\n* Combine the sub-problems to get the final solution of the whole problem.\n* Once the smaller subproblems are solved, we recursively combine their solutions to get the solution of larger problem.\n* The goal is to formulate a solution for the original problem by merging the results from the subproblems.\n\nCharacteristics of Divide and Conquer Algorithm:\n------------------------------------------------\n\n\nDivide and Conquer Algorithm involves breaking down a problem into smaller, more manageable parts, solving each part individually, and then combining the solutions to solve the original problem. The characteristics of Divide and Conquer Algorithm are:\n\n\n\n                                                                                                                                    * ****Dividing the Problem****\n                                                                                                                                    : The first step is to break the problem into smaller, more manageable subproblems. This division can be done recursively until the subproblems become simple enough to solve directly.\n* ****Independence of Subproblems****\n  : Each subproblem should be independent of the others, meaning that solving one subproblem does not depend on the solution of another. This allows for parallel processing or concurrent execution of subproblems, which can lead to efficiency gains.\n* ****Conquering Each Subproblem****\n  : Once divided, the subproblems are solved individually. This may involve applying the same divide and conquer approach recursively until the subproblems become simple enough to solve directly, or it may involve applying a different algorithm or technique.\n                                                                                                                                    * ****Combining Solutions****\n                                                                                                                                    : After solving the subproblems, their solutions are combined to obtain the solution to the original problem. This combination step should be relatively efficient and straightforward, as the solutions to the subproblems should be designed to fit together seamlessly.\n\n                                                                                                                                    ****Examples of Divide and Conquer Algorithm:****\n-------------------------------------------------\n\n                                                                                                                                    ### ****1. Finding the maximum element in the array:****\n\n\n                                                                                                                                    We can use Divide and Conquer Algorithm to find the maximum element in the array by dividing the array into two equal sized subarrays, finding the maximum of those two individual halves by again dividing them into two smaller halves. This is done till we reach subarrays of size 1. After reaching the elements, we return the maximum element and combine the subarrays by returning the maximum in each subarray.\n\n\n\nC++\n\n````\n// function to find the maximum no.\n// in a given array.\nint findMax(int a[], int lo, int hi)\n{\n    // If lo becomes greater than hi, then return minimum\n                                                                                                                                    // integer possible\n                                                                                                                                    if (lo > hi)\n                                                                                                                                    return INT_MIN;\n// If the subarray has only one element, return the\n    // element\n    if (lo == hi)\n        return a[lo];\nint mid = (lo + hi) / 2;\n// Get the maximum element from the left half\n    int leftMax = findMax(a, lo, mid);\n// Get the maximum element from the right half\n    int rightMax = findMax(a, mid + 1, hi);\n// Return the maximum element from the left and right\n    // half\n    return max(leftMax, rightMax);\n}\n\n````\n\nJava\n\n````\n// Function to find the maximum number\n// in a given array.\nstatic int findMax(int[] a, int lo, int hi)\n{\n    // If lo becomes greater than hi, then return\n    // minimum integer possible\n    if (lo > hi)\n        return Integer.MIN_VALUE;\n// If the subarray has only one element, return the\n    // element\n    if (lo == hi)\n        return a[lo];\nint mid = (lo + hi) / 2;\n// Get the maximum element from the left half\n    int leftMax = findMax(a, lo, mid);\n// Get the maximum element from the right half\n    int rightMax = findMax(a, mid + 1, hi);\n// Return the maximum element from the left and\n    // right half\n    return Math.max(leftMax, rightMax);\n}\n\n````\n\nPython3\n\n````\n# Function to find the maximum number\n# in a given array.\ndef find_max(a, lo, hi):\n    # If lo becomes greater than hi, then return minimum\n    # integer possible\n    if lo > hi:\n        return float('-inf')\n    # If the subarray has only one element, return the\n    # element\n    if lo == hi:\n        return a[lo]\n    mid = (lo + hi) // 2\n    # Get the maximum element from the left half\n    left_max = find_max(a, lo, mid)\n    # Get the maximum element from the right half\n    right_max = find_max(a, mid + 1, hi)\n    # Return the maximum element from the left and right\n    # half\n    return max(left_max, right_max)\n\n````\n\nC#\n\n````\n// Function to find the maximum number\n// in a given array.\nstatic int FindMax(int[] a, int lo, int hi)\n{\n    // If lo becomes greater than hi, then return\n    // minimum integer possible\n    if (lo > hi)\n        return int.MinValue;\n// If the subarray has only one element, return the\n    // element\n    if (lo == hi)\n        return a[lo];\nint mid = (lo + hi) / 2;\n// Get the maximum element from the left half\n    int leftMax = FindMax(a, lo, mid);\n// Get the maximum element from the right half\n    int rightMax = FindMax(a, mid + 1, hi);\n// Return the maximum element from the left and\n    // right half\n    return Math.Max(leftMax, rightMax);\n}\n\n````\n\nJavaScript\n\n````\n// Function to find the maximum number\n// in a given array.\nfunction findMax(a, lo, hi) {\n    // If lo becomes greater than hi, then return minimum\n    // integer possible\n    if (lo > hi)\n        return Number.MIN_VALUE;\n// If the subarray has only one element, return the\n    // element\n    if (lo === hi)\n        return a[lo];\n    const mid = Math.floor((lo + hi) / 2);\n// Get the maximum element from the left half\n    const leftMax = findMax(a, lo, mid);\n// Get the maximum element from the right half\n    const rightMax = findMax(a, mid + 1, hi);\n// Return the maximum element from the left and right\n    // half\n    return Math.max(leftMax, rightMax);\n}\n\n````\n\n### ****2. Finding the minimum element in the array:****\n\n\nSimilarly, we can use Divide and Conquer Algorithm to find the minimum element in the array by dividing the array into two equal sized subarrays, finding the minimum of those two individual halves by again dividing them into two smaller halves. This is done till we reach subarrays of size 1. After reaching the elements, we return the minimum element and combine the subarrays by returning the minimum in each subarray.\n\n\n### 3. [Merge Sort:](https://www.geeksforgeeks.org/merge-sort/)\n\n\nWe can use Divide and Conquer Algorithm to sort the array in ascending or descending order by dividing the array into smaller subarrays, sorting the smaller subarrays and then merging the sorted arrays to sort the original array.\n\n\nComplexity Analysis of Divide and Conquer Algorithm:\n----------------------------------------------------\n\n> T(n) = aT(n/b) + f(n), where\n> n = size of input\n> a = number of subproblems in the recursion\n> n/b = size of each subproblem. All subproblems are assumed to have the same size.\n> f(n) = cost of the work done outside the recursive call, which includes the cost of dividing the problem and cost of merging the solutions\n\nApplications of Divide and Conquer Algorithm:\n---------------------------------------------\n\n\nThe following are some standard algorithms that follow Divide and Conquer algorithm:\n\n\n* [****Quicksort****](https://www.geeksforgeeks.org/quick-sort/)\n  is a sorting algorithm that picks a pivot element and rearranges the array elements so that all elements smaller than the picked pivot element move to the left side of the pivot, and all greater elements move to the right side. Finally, the algorithm recursively sorts the subarrays on the left and right of the pivot element.\n* [****Merge Sort****](https://www.geeksforgeeks.org/merge-sort/)\n  is also a sorting algorithm. The algorithm divides the array into two halves, recursively sorts them, and finally merges the two sorted halves.\n* [****Closest Pair of Points****](https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/)\n  The problem is to find the closest pair of points in a set of points in the x-y plane. The problem can be solved in O(n^2) time by calculating the distances of every pair of points and comparing the distances to find the minimum. The Divide and Conquer algorithm solves the problem in O(N log N) time.\n* [****Strassen\u2019s Algorithm****](https://www.geeksforgeeks.org/strassens-matrix-multiplication/)\n  is an efficient algorithm to multiply two matrices. A simple method to multiply two matrices needs 3 nested loops and is O(n^3). Strassen\u2019s algorithm multiplies two matrices in O(n^2.8974) time.\n* [****Cooley\u2013Tukey Fast Fourier Transform (FFT) algorithm****](http://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm)\n  is the most common algorithm for FFT. It is a divide and conquer algorithm which works in O(N log N) time.\n* [****Karatsuba algorithm for fast multiplication****](https://www.geeksforgeeks.org/karatsuba-algorithm-for-fast-multiplication-using-divide-and-conquer-algorithm/)\n  does the multiplication of two binary strings in O(n\n\n  1.59\n  ) where n is the length of binary string.\n\n****Advantages of Divide and Conquer Algorithm:****\n---------------------------------------------------\n\n* ****Solving difficult problems:****\n  Divide and conquer technique is a tool for solving difficult problems conceptually. e.g. Tower of Hanoi puzzle. It requires a way of breaking the problem into sub-problems, and solving all of them as an individual cases and then combining sub- problems to the original problem.\n* ****Algorithm efficiency:****\n  The divide-and-conquer algorithm often helps in the discovery of efficient algorithms. It is the key to algorithms like Quick Sort and Merge Sort, and fast Fourier transforms.\n* ****Parallelism:****\n  Normally Divide and Conquer algorithms are used in multi-processor machines having shared-memory systems where the communication of data between processors does not need to be planned in advance, because distinct sub-problems can be executed on different processors.\n* ****Memory access:****\n  These algorithms naturally make an efficient use of memory caches. Since the subproblems are small enough to be solved in cache without using the main memory that is slower one. Any algorithm that uses cache efficiently is called cache oblivious.\n\n****Disadvantages of Divide and Conquer Algorithm:****\n------------------------------------------------------\n\n* ****Overhead:****\n  The process of dividing the problem into subproblems and then combining the solutions can require additional time and resources. This overhead can be significant for problems that are already relatively small or that have a simple solution.\n* ****Complexity:****\n  Dividing a problem into smaller subproblems can increase the complexity of the overall solution. This is particularly true when the subproblems are interdependent and must be solved in a specific order.\n* ****Difficulty of implementation:****\n  Some problems are difficult to divide into smaller subproblems or require a complex algorithm to do so. In these cases, it can be challenging to implement a divide and conquer solution.\n* ****Memory limitations:****\n  When working with large data sets, the memory requirements for storing the intermediate results of the subproblems can become a limiting factor.\n\nFrequently Asked Questions (FAQs) on Divide and Conquer Algorithm:\n------------------------------------------------------------------\n\n### ****1. What is the Divide and Conquer algorithm?****\n\n> Divide and Conquer is a problem-solving technique where a problem is divided into smaller, more manageable subproblems. These subproblems are solved recursively, and then their solutions are combined to solve the original problem.\n\n### ****2. What are the key steps involved in the Divide and Conquer algorithm?****\n\n> The main steps are:\n>\n>\n> ****Divide****\n> : Break the problem into smaller subproblems.\n>\n>\n> ****Conquer****\n> : Solve the subproblems recursively.\n>\n>\n> ****Combine****\n> : Merge or combine the solutions of the subproblems to obtain the solution to the original problem.\n\n### ****3. What are some examples of problems solved using Divide and Conquer?****\n\n> Divide and Conquer Algorithm is used in sorting algorithms like Merge Sort and Quick Sort, finding closest pair of points, Strassen\u2019s Algorithm, etc.\n\n### ****4. How does Merge Sort use the Divide and Conquer approach?****\n\n> Merge Sort divides the array into two halves, recursively sorts each half, and then merges the sorted halves to produce the final sorted array.\n\n### ****5. What is the time complexity of Divide and Conquer algorithms?****\n\n> The time complexity varies depending on the specific problem and how it\u2019s implemented. Generally, many Divide and Conquer algorithms have a time complexity of O(n log n) or better.\n\n### ****6. Can Divide and Conquer algorithms be parallelized?****\n\n> Yes, Divide and Conquer algorithms are often naturally parallelizable because independent subproblems can be solved concurrently. This makes them suitable for parallel computing environments.\n\n### ****7. What are some strategies for choosing the base case in Divide and Conquer algorithms?****\n\n> The base case should be simple enough to solve directly, without further division. It\u2019s often chosen based on the smallest input size where the problem can be solved trivially.\n\n### ****8. Are there any drawbacks or limitations to using Divide and Conquer?****\n\n> While Divide and Conquer can lead to efficient solutions for many problems, it may not be suitable for all problem types. Overhead from recursion and combining solutions can also be a concern for very large problem sizes.\n\n### ****9. How do you analyze the space complexity of Divide and Conquer algorithms?****\n\n> Space complexity depends on factors like the recursion depth and auxiliary space required for combining solutions. Analyzing space complexity typically involves considering the space used by each recursive call.\n\n### ****10. What are some common advantages of Divide and Conquer Algorithm?****\n\n> Divide and Conquer Algorithm has numerous advantages. Some of them include:\n>\n>\n> * Solving difficult problems\n> * Algorithm efficiency\n> * Parallelism\n> * Memory access\n\n\nDivide and Conquer is a popular algorithmic technique in computer science that involves breaking down a problem into smaller sub-problems, solving each sub-problem independently, and then combining the solutions to the sub-problems to solve the original problem. The basic idea behind this technique is to divide a problem into smaller, more manageable sub-problems that can be solved more easily.\n\n",
        "metadata": {
            "lesson_id": "7d5f99f3-4391-444d-92b9-28764219d6c9",
            "course_id": "8ff4ea92-41f2-4d49-b230-0281874efb2d",
            "course_name": "Introduction to DSA II",
            "lesson_description": "Algorithm is a problem-solving technique used to solve problems by dividing the main problem into subproblems, solving them individually and then merging them to find solution to the original problem. In this article, we are going to discuss how Divide and Conquer Algorithm is helpful and how we can use it to solve problems.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Basic Terminologies of Linked List\n----------------------------------\n\n* ****Head:****\n  The Head of a linked list is a pointer to the first node or reference of the first node of linked list. This pointer marks the beginning of the linked list.\n* ****Node:****\n  Linked List consists of a series of nodes where each node has two parts:\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ****data****\n                                              and\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ****next pointer****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           .\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Data:****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Data is the part of node which stores the information in the linked list.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Next pointer:****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Next pointer is the part of the node which points to the next node of the linked list.\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Importance of Linked List\n-------------------------\n\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Here are a few advantages of a linked list that is listed below, it will help you understand why it is necessary to know.\n\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Dynamic Data structure:****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The size of memory can be allocated or de-allocated at run time based on the operation insertion or deletion.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Ease of Insertion/Deletion:****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The insertion and deletion of elements are simpler than arrays since no elements need to be shifted after insertion and deletion, Just the address needed to be updated.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Efficient Memory Utilization:****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           As we know Linked List is a dynamic data structure the size increases or decreases as per the requirement so this avoids the wastage of memory.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Implementation:****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Various advanced data structures can be implemented using a linked list like a stack, queue, graph, hash maps, etc.\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Implementations of Basic Operations on Different Types of List\n--------------------------------------------------------------\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * [Singly Linked List](https://www.geeksforgeeks.org/singly-linked-list-tutorial/)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * [Doubly Linked List](https://www.geeksforgeeks.org/doubly-linked-list/)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * [Circular Linked List](https://www.geeksforgeeks.org/circular-linked-list/)\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ### Basic Operations on Singly Linked List\n\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The following are some basic operations performed on a Single Linked List:\n\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Insertion:****\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The insertion operation can be performed in three ways. They are as follows:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           + [Inserting At the Beginning of the list](https://www.geeksforgeeks.org/linked-list-set-2-inserting-a-node/#:~:text=Add%20a%20node%20at%20the%20front%3A)\n        + [Inserting At End of the list](https://www.geeksforgeeks.org/linked-list-set-2-inserting-a-node/#:~:text=Add%20a%20node%20at%20the%20end)\n  + [Inserting At Specific location in the list](https://www.geeksforgeeks.org/linked-list-set-2-inserting-a-node/#:~:text=Add%20a%20node%20after%20a%20given%20node)\n* ****Deletion:****\n  The deletion operation can be performed in three ways. They are as follows:\n  + [Deleting from the Beginning of the list](https://www.geeksforgeeks.org/linked-list-set-3-deleting-node/?ref=lbp#:~:text=Delete%20from%20Beginning,head%20%3D%20head%2D%3Enext)\n  + [Deleting from the End of the list](https://www.geeksforgeeks.org/delete-nth-node-from-the-end-of-the-given-linked-list/)\n  + [Deleting a Specific Node](https://www.geeksforgeeks.org/delete-a-linked-list-node-at-a-given-position/)\n* [****Traverse****](https://www.geeksforgeeks.org/traversal-of-singly-linked-list/)\n  ****:****\n  This process displays the elements of a Single-linked list.\n* [****Search:****](https://www.geeksforgeeks.org/search-an-element-in-a-linked-list-iterative-and-recursive/)\n\n  It is a process of determining and retrieving a specific node either from the front, the end or anywhere in the list.\n\n### ****Operations on Doubly Linked List:****\n\n\nIn a doubly linked list, we perform the following operations\u2026\n\n\n* ****Insertion:****\n  The insertion operation can be performed in three ways as follows:\n  + [Inserting At the Beginning of the list](https://www.geeksforgeeks.org/doubly-linked-list/#:~:text=Add%20a%20node%20at%20the%20front)\n  + [Inserting after a given node.](https://www.geeksforgeeks.org/doubly-linked-list/#:~:text=Add%20a%20node%20after%20a%20given%20node.)\n  + [Inserting at the end](https://www.geeksforgeeks.org/doubly-linked-list/#:~:text=Add%20a%20node%20at%20the%20end)\n    .\n  + [Inserting before a given node](https://www.geeksforgeeks.org/doubly-linked-list/#:~:text=Add%20a%20node%20before%20a%20given%20node)\n* ****Deletion:****\n  The deletion operation can be performed in three ways as follows\u2026\n  + [Deleting from the Beginning of the list](https://www.geeksforgeeks.org/delete-doubly-linked-list-node-given-position/)\n  + [Deleting from the End of the list](https://www.geeksforgeeks.org/delete-a-node-in-a-doubly-linked-list/)\n  + Deleting a Specific Node\n* ****Display:****\n  This process displays the elements of a double-linked list.\n\n### ****Commonly used operations on Circular Linked List:****\n\n\nThe following operations are performed on a Circular Linked List\n\n\n\n* ****Insertion:****\n  The insertion operation can be performed in three ways:\n  + [Insertion in an empty list](https://www.geeksforgeeks.org/circular-singly-linked-list-insertion/#:~:text=Insertion%20in%20an%20empty%20List%C2%A0)\n  + [Insertion at the beginning of the list](https://www.geeksforgeeks.org/circular-singly-linked-list-insertion/#:~:text=Insertion%20at%20the%20beginning%20of%20the%20list%C2%A0)\n  + [Insertion at the end of the list](https://www.geeksforgeeks.org/circular-singly-linked-list-insertion/#:~:text=Insertion%20at%20the%20end%20of%20the%20list%C2%A0)\n  + [Insertion in between the nodes](https://www.geeksforgeeks.org/circular-singly-linked-list-insertion/#:~:text=Insertion%20in%20between%20the%20nodes%C2%A0)\n* ****Deletion:****\n  The deletion operation can be performed in three ways:\n  + [Deleting from the Beginning of the list](https://www.geeksforgeeks.org/deletion-at-different-positions-in-a-circular-linked-list/)\n  + [Deleting from the End of the list](https://www.geeksforgeeks.org/deletion-at-different-positions-in-a-circular-linked-list/)\n  + [Deleting a Specific Node](https://www.geeksforgeeks.org/deletion-at-different-positions-in-a-circular-linked-list/)\n* ****Display:****\n  This process displays the elements of a Circular linked list.\n\n[Linked List vs. Array:](https://www.geeksforgeeks.org/linked-list-vs-array/)\n-----------------------------------------------------------------------------\n\nTime Complexity Analysis of Linked List and Array:\n--------------------------------------------------\n\n\nPlease refer\n\n[Applications, Advantages and Disadvantages of Linked List](https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-linked-list/)\nfor more details\n\n\nFrequently Asked Questions (FAQs) about Linked List:\n----------------------------------------------------\n\n### 1. What is linked list data structure?\n\n> Linked list are most commonly used to handle dynamic data elements. Linked list consists of nodes and a node consists of two fields one for storing data and other for keeping the reference of next node.\n\n### 2. What is linked list example?\n\n> A linked list can be assumed as a garland that is made up of flowers. Similarly, a linked list is made up of nodes. Every flower in this particular garland is referred to as a node. In addition, each node points to the next node in this list, and it contains data (in this case, the type of flower).\n\n### 3. Why do we need linked list data structure??\n\n> There are some important advantages to using linked lists over other linear data structures. This is unlike arrays, as they are resizable at runtime. Additionally, they can be easily inserted and deleted.\n\n### 4. What are linked lists used for?\n\n> The linked list is a linear data structure that stores data in nodes. these nodes hold both the data and a reference to the next node in the list. Linked are very efficient at adding and removing nodes because of their simple structure.\n\n### 5. What is the difference between array and linked list?\n\n> There are some following differences between them:\n>\n>\n> * Arrays are data structures containing similar data elements, whereas linked lists are non-primitive data structures containing unordered linked elements.\n> * In an array, elements are indexed, but in a linked list nodes are not indexed.\n> * Accessing an element array is fast if we know the position of an element in the array, while in the Linked list it takes linear time so, the Linked list is quite bit slower.\n> * Operations like insertion and deletion in arrays take a lot of time. Whereas, the performance of these operations is faster in Linked lists.\n> * Arrays are of fixed size and their size is static but Linked lists are dynamic and flexible and can expand and shrink their size.\n\n### 6. Why is a linked list preferred over an array?\n\n> Following are the reason that linked lists are preferred over array\n>\n>\n> * Nodes in a linked array, insertions, and deletions can be done at any point in the list at a constant time.\n> * Arrays are of fixed size and their size is static but Linked lists are dynamic and flexible and can expand and shrink their size.\n> * Linked lists provide an efficient way of storing related data and performing basic operations such as insertion, deletion, and updating of information at the cost of extra space required for storing the address.\n> * Insertion and deletion operations in the linked list are faster as compared to the array.\n\n### 7. Which is the best array or linked list?\n\n> There are some advantages and disadvantages to both arrays and linked lists when it comes to storing linear data of similar types.\n>\n>\n> #### Advantages of linked list over arrays:\n>\n> * ****Dynamic size:****\n>   Linked lists are dynamic and flexible and can expand and shrink their size\n> * ****Ease of Insertion/Deletion:****\n>   Insertion and deletion operations in linked list are faster as compared to the array\n>\n> #### ****Disadvantages of linked list over arrays:****\n>\n> * If the array is sorted we can apply binary search to search any element which takes\n>\n>   ****O(log(n))****\n>   time. But even if the linked list is sorted we cannot apply binary search and the complexity of searching elements in the linked list is\n>\n>   ****O(n)****\n>   .\n> * A linked list takes more memory as compared to the array because extra memory space is required for the pointer with each element in the linked list.\n\n### 8. What are the limitations of linked list?\n\n> Following are some limitations of the linked list:\n>\n>\n> * The use of pointers is more in linked lists hence, complex and requires more memory.\n> * Random access is not possible due to dynamic memory allocation.\n> * Traversing is more time-consuming and reverse traversing is not possible in singly linked lists.\n> * Searching for an element is costly and requires\n>\n>   ****O(n)****\n>   time complexity.\n\n### 9. Why insertion/deletion are faster in a linked list?\n\n> If any element is inserted/ deleted from the array, all the other elements after it will be shifted in memory this takes a lot of time whereas manipulation in Linked List is faster because we just need to manipulate the addresses of nodes, so no bit shifting is required in memory, and it will not take that much of time.\n\n### 10. What is the difference between a singly and doubly linked list?\n\n\nFollowing are some\n\n[difference between single and double linked list.](https://www.geeksforgeeks.org/difference-between-singly-linked-list-and-doubly-linked-list/)\n\nConclusion:\n-----------\n\n\nThere are many advantages of the linked list compared to array, despite the fact that they solve the similar problem to arrays, we have also discussed the advantage, disadvantages, and its application, and we concluded the fact that we can use a linked list if we need the dynamic size of storage and list are good for adding and removing items quickly or for tasks that require sequence but are not suitable for querying or search elements in a large collection of data.\n\n\nSo, it becomes important that we should always keep in mind the\n\n****positive****\nand\n\n****negative****\naspects of a\n\n****data structure****\nand how they relate to the problem you are trying to solve.",
        "metadata": {
            "lesson_id": "0a6a3db2-efff-45ec-8886-b5862fbb75e1",
            "course_id": "8ff4ea92-41f2-4d49-b230-0281874efb2d",
            "course_name": "Introduction to DSA II",
            "lesson_description": "In this article, we will provide a complete introduction of Linked List, which will help you tackle any problem based on Linked List.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Features of Pattern Searching Algorithm:\n----------------------------------------\n\n* Pattern searching algorithms should recognize familiar patterns quickly and accurately.\n* Recognize and classify unfamiliar patterns.\n* Identify patterns even when partly hidden.\n* Recognize patterns quickly with ease, and with automaticity.\n\n[Naive Pattern Searching algorithm](https://www.geeksforgeeks.org/naive-algorithm-for-pattern-searching/)\n---------------------------------------------------------------------------------------------------------\n\n\nNaive pattern searching is the simplest method among other pattern-searching algorithms. It checks for all characters of the main string to the pattern. This algorithm is helpful for smaller texts. It does not need any pre-processing phases. We can find the substring by checking once for the string. It also does not occupy extra space to perform the operation.\n\n\n![Compare text characters with pattern characters](https://media.geeksforgeeks.org/wp-content/uploads/20220809155713/image.png)\n\nCompare text characters with pattern characters\n\n\nThe time complexity of Naive Pattern Search method is O(m\\*n). The m is the size of pattern and n is the size of the main string.\n\n\nC++\n\n````\n// C++ program for Naive Pattern\n// Searching algorithm\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid search(char* pat, char* txt)\n{\n    int M = strlen(pat);\nint N = strlen(txt);\n\n    /* A loop to slide pat[] one by one */\nfor (int i = 0; i <= N - M; i++) {\n        int j;\n\n        /* For current index i, check for pattern match */\nfor (j = 0; j < M; j++)\n            if (txt[i + j] != pat[j])\n                break;\n\n        if (j\n            == M) // if pat[0...M-1] = txt[i, i+1, ...i+M-1]\n            cout << \"Pattern found at index \" << i << endl;\n}\n}\n\n// Driver's Code\nint main()\n{\n    char txt[] = \"AABAACAADAABAAABAA\";\n    char pat[] = \"AABA\";\n\n    // Function call\n    search(pat, txt);\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program for Naive Pattern\n// Searching algorithm\nclass GFG {\n\n  static void search(char[] pat, char[] txt)\n  {\n    int M = pat.length;\n    int N = txt.length;\n\n    /* A loop to slide pat[] one by one */\n    for (int i = 0; i <= N - M; i++) {\n      int j;\n\n      /* For current index i, check for pattern match\n             */\n      for (j = 0; j < M; j++)\n        if (txt[i + j] != pat[j])\n          break;\n\n      // if pat[0...M-1] = txt[i, i+1, ...i+M-1]\n      if (j == M)\n        System.out.println(\"Pattern found at index \"\n                           + i);\n    }\n  }\n\n  // Driver's Code\n\n  public static void main(String[] args)\n  {\n    char txt[] = \"AABAACAADAABAAABAA\".toCharArray();\n\nchar pat[] = \"AABA\".toCharArray();\n\n// Function call\n    search(pat, txt);\n}\n}\n\n// This code is contributed by karandeep1234\n\n````\n\nPython\n\n````\ndef search(pat, txt):\n    M = len(pat)\n    N = len(txt)\n\n    # A loop to slide pat[] one by one\n    for i in range(N - M + 1):\n        j = 0\n\n        # For current index i, check for pattern match\n        while j < M:\n            if txt[i + j] != pat[j]:\n                break\n            j += 1\n\n        if j == M:  # if pat[0...M-1] = txt[i, i+1, ...i+M-1]\n            print(f\"Pattern found at index {i}\")\n\n\n# Driver's Code\ntxt = \"AABAACAADAABAAABAA\"\npat = \"AABA\"\n\n# Function call\nsearch(pat, txt)\n\n````\n\nC#\n\n````\nusing System;\n\npublic class GFG {\n\n  public static void search(char[] pat, char[] txt)\n  {\n    int M = pat.Length;\n    int N = txt.Length;\n\n    /* A loop to slide pat[] one by one */\n    for (int i = 0; i <= N - M; i++) {\n      int j;\n\n      /* For current index i, check for pattern match\n             */\n      for (j = 0; j < M; j++)\n        if (txt[i + j] != pat[j])\n          break;\n\n      if (j == M) // if pat[0...M-1] = txt[i, i+1,\n        // ...i+M-1]\n        Console.WriteLine(\"Pattern found at index \"\n                          + i);\n    }\n  }\n\n  static public void Main()\n  {\n\n    char[] txt = \"AABAACAADAABAAABAA\".ToCharArray();\n    char[] pat = \"AABA\".ToCharArray();\n\n    // Function call\n    search(pat, txt);\n  }\n}\n// This code is contributed by akashish__\n\n````\n\nJavaScript\n\n````\n// JS program for Naive Pattern\n// Searching algorithm\nfunction search(pat, txt)\n{\n    let M = pat.length;\n    let N = txt.length;\n\n    /* A loop to slide pat[] one by one */\n    for (let i = 0; i <= N - M; i++) {\n        let j = 0;\n\n        /* For current index i, check for pattern match */\n        for (j = 0; j < M; j++)\n            if (txt[i + j] != pat[j])\n                break;\n        if (j == M) // if pat[0...M-1] = txt[i, i+1, ...i+M-1]\n            console.log(\"Pattern found at index\",i);\n    }\n}\n\n// Driver's Code\n    let txt = \"AABAACAADAABAAABAA\";\n    let pat = \"AABA\";\n\n// Function call\n    search(pat, txt);\n\n// This code is contributed by ishankhandelwals.\n\n````\n\n\n\n\n**Output**\n```\nPattern found at index 0\nPattern found at index 9\nPattern found at index 13\n```\n\n****Time Complexity:****\nO(N\\*M)\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n[KMP algorithm](https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/)\n-----------------------------------------------------------------------------------\n\n\nKMP algorithm is used to find a \u201cPattern\u201d in a \u201cText\u201d. This algorithm compares character by character from left to right. But whenever a mismatch occurs, it uses a preprocessed table called \u201cPrefix Table\u201d to skip characters comparison while matching. Sometimes prefix table is also known as LPS Table. Here LPS stands for \u201cLongest proper Prefix which is also Suffix\u201d.\n\n\n### How to use LPS Table\n\n\nWe use the LPS table to decide how many characters are to be skipped for comparison when a mismatch has occurred.\n\n\n\nWhen a mismatch occurs, check the LPS value of the previous character of the mismatched character in the pattern. If it is \u20180\u2019 then start comparing the first character of the pattern with the next character to the mismatched character in the text. If it is not \u20180\u2019 then start comparing the character which is at an index value equal to the LPS value of the previous character to the mismatched character in pattern with the mismatched character in the Text.\n\n\n\n\n\n\n\n![Example of KMP algorithm](https://media.geeksforgeeks.org/wp-content/uploads/20221108112045/KMP2.png)\n\nExample of KMP algorithm\n\n\n![Compare first character of pattern with first character of text from left to right](https://media.geeksforgeeks.org/wp-content/uploads/20221108112046/step1.png)\n\nCompare first character of pattern with first character of text from left to right\n\n\n![Compare first character of pattern with next character of text](https://media.geeksforgeeks.org/wp-content/uploads/20221108112307/step2.png)\n\nCompare first character of pattern with next character of text\n\n\n![Compare pattern[0] and pattern[1] values](https://media.geeksforgeeks.org/wp-content/uploads/20221108112047/step3.png)\n\nCompare pattern[0] and pattern[1] values\n\n\n![Compare pattern[0] with next characters in text.](https://media.geeksforgeeks.org/wp-content/uploads/20221108112048/step4.png)\n\nCompare pattern[0] with next characters in text.\n\n\n![Compare pattern[2] with mismatched characters in text.](https://media.geeksforgeeks.org/wp-content/uploads/20221108112049/step5.png)\n\nCompare pattern[2] with mismatched characters in text.\n\n### How the KMP Algorithm Works\n\n\nLet\u2019s take a look on working example of KMP Algorithm to find a Pattern in a Text.\n\n\n\n![LPS table](https://media.geeksforgeeks.org/wp-content/uploads/20221108112550/kmp.png)\n\nLPS table\n\n\n![Define variables](https://media.geeksforgeeks.org/wp-content/uploads/20221108112551/step1.png)\n\nDefine variables\n\n\n![Compare A with B](https://media.geeksforgeeks.org/wp-content/uploads/20221108112552/step2.png)\n\nCompare A with B\n\n\n![Compare A with C](https://media.geeksforgeeks.org/wp-content/uploads/20221108112552/step3.png)\n\nCompare A with C\n\n\n![Compare A with D](https://media.geeksforgeeks.org/wp-content/uploads/20221108112553/step4.png)\n\nCompare A with D\n\n\n![Compare A with A](https://media.geeksforgeeks.org/wp-content/uploads/20221108112554/step5.png)\n\nCompare A with A\n\n\n![Compare B with B](https://media.geeksforgeeks.org/wp-content/uploads/20221108112555/step6.png)\n\nCompare B with B\n\n\n![Compare C with D](https://media.geeksforgeeks.org/wp-content/uploads/20221108112555/step7.png)\n\nCompare C with D\n\n\n![Compare A with D](https://media.geeksforgeeks.org/wp-content/uploads/20221108112556/step8.png)\n\nCompare A with D\n\n\nImplementation of the KMP algorithm:\n\n\nC++\n\n````\n// C++ program for implementation of KMP pattern searching\n// algorithm\n#include <bits/stdc++.h>\n\nvoid computeLPSArray(char* pat, int M, int* lps);\n\n// Prints occurrences of txt[] in pat[]\nvoid KMPSearch(char* pat, char* txt)\n{\n    int M = strlen(pat);\nint N = strlen(txt);\n\n// create lps[] that will hold the longest prefix suffix\n    // values for pattern\n    int lps[M];\n\n// Preprocess the pattern (calculate lps[] array)\n    computeLPSArray(pat, M, lps);\n\nint i = 0; // index for txt[]\n    int j = 0; // index for pat[]\n    while ((N - i) >= (M - j)) {\n        if (pat[j] == txt[i]) {\n            j++;\n            i++;\n}\n\n        if (j == M) {\n            printf(\"Found pattern at index %d \", i - j);\n            j = lps[j - 1];\n}\n\n        // mismatch after j matches\n        else if (i < N && pat[j] != txt[i]) {\n            // Do not match lps[0..lps[j-1]] characters,\n            // they will match anyway\n            if (j != 0)\n                j = lps[j - 1];\nelse\n                i = i + 1;\n}\n    }\n}\n\n// Fills lps[] for given pattern pat[0..M-1]\nvoid computeLPSArray(char* pat, int M, int* lps)\n{\n    // length of the previous longest prefix suffix\n    int len = 0;\n\n    lps[0] = 0; // lps[0] is always 0\n\n    // the loop calculates lps[i] for i = 1 to M-1\n    int i = 1;\n    while (i < M) {\n        if (pat[i] == pat[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n}\n        else // (pat[i] != pat[len])\n        {\n            // This is tricky. Consider the example.\n            // AAACAAAA and i = 7. The idea is similar\n            // to search step.\n            if (len != 0) {\n                len = lps[len - 1];\n\n// Also, note that we do not increment\n                // i here\n            }\n            else // if (len == 0)\n            {\n                lps[i] = 0;\n                i++;\n}\n        }\n    }\n}\n\n// Driver program to test above function\nint main()\n{\n    char txt[] = \"ABABDABACDABABCABAB\";\nchar pat[] = \"ABABCABAB\";\n    KMPSearch(pat, txt);\nreturn 0;\n}\n\n````\n\nJava\n\n````\n// Java program for implementation of KMP pattern searching\n// algorithm\npublic class KMP_String_Matching {\n    void KMPSearch(String pat, String txt)\n    {\n        int M = pat.length();\nint N = txt.length();\n\n// create lps[] that will hold the longest prefix suffix\n        // values for pattern\n        int lps[] = new int[M];\nint j = 0; // index for pat[]\n\n        // Preprocess the pattern (calculate lps[] array)\n        computeLPSArray(pat, M, lps);\n\nint i = 0; // index for txt[]\n        while (i < N) {\n            if (pat.charAt(j) == txt.charAt(i)) {\n                j++;\n                i++;\n}\n            if (j == M) {\n                System.out.println(\"Found pattern \" + \"at index \" + (i - j));\n                j = lps[j - 1];\n}\n\n            // mismatch after j matches\n            else if (i < N && pat.charAt(j) != txt.charAt(i)) {\n                // Do not match lps[0..lps[j-1]] characters,\n                // they will match anyway\n                if (j != 0)\n                    j = lps[j - 1];\nelse\n                    i = i + 1;\n}\n        }\n    }\n\n    void computeLPSArray(String pat, int M, int lps[])\n    {\n        // length of the previous longest prefix suffix\n        int len = 0;\nint i = 1;\n        lps[0] = 0; // lps[0] is always 0\n\n        // the loop calculates lps[i] for i = 1 to M-1\n        while (i < M) {\n            if (pat.charAt(i) == pat.charAt(len)) {\n                len++;\n                lps[i] = len;\n                i++;\n}\n            else // (pat[i] != pat[len])\n            {\n                // This is tricky. Consider the example.\n                // AAACAAAA and i = 7. The idea is similar\n                // to search step.\n                if (len != 0) {\n                    len = lps[len - 1];\n\n// Also, note that we do not increment\n                    // i here\n                }\n                else // if (len == 0)\n                {\n                    lps[i] = len;\n                    i++;\n}\n            }\n        }\n    }\n\n    // Driver program to test above function\n    public static void main(String[] args)\n    {\n        String txt = \"ABABDABACDABABCABAB\";\n        String pat = \"ABABCABAB\";\n        new KMP_String_Matching().KMPSearch(pat, txt);\n}\n}\n\n````\n\nPython\n\n````\n# Python program for implementation of KMP pattern searching\n# algorithm\ndef computeLPSArray(pat, M, lps):\n    len = 0  # length of the previous longest prefix suffix\n\n    lps[0]  # lps[0] is always 0\n    i = 1\n\n    # the loop calculates lps[i] for i = 1 to M-1\n    while i < M:\n        if pat[i] == pat[len]:\n            len += 1\n            lps[i] = len\n            i += 1\n        else:\n            # This is tricky. Consider the example.\n            # AAACAAAA and i = 7. The idea is similar\n            # to search step.\n            if len != 0:\n                len = lps[len-1]\n\n            # Also, note that we do not increment i here\n            else:\n                lps[i] = 0\n                i += 1\n\ndef KMPSearch(pat, txt):\n    M = len(pat)\n    N = len(txt)\n\n    # create lps[] that will hold the longest prefix suffix\n    # values for pattern\n    lps = [0]*M\n    j = 0  # index for pat[]\n\n    # Preprocess the pattern (calculate lps[] array)\n    computeLPSArray(pat, M, lps)\n\n    i = 0  # index for txt[]\n    while (N - i) >= (M - j):\n        if pat[j] == txt[i]:\n            j += 1\n            i += 1\n\n        if j == M:\n            print(\"Found pattern at index:\", i-j)\n            j = lps[j-1]\n\n        # mismatch after j matches\n        elif i < N and pat[j] != txt[i]:\n            # Do not match lps[0..lps[j-1]] characters,\n            # they will match anyway\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n\ntxt = \"ABABDABACDABABCABAB\"\npat = \"ABABCABAB\"\nKMPSearch(pat, txt)\n\n# This code is contributed by ishankhandelwals.\n\n````\n\nC#\n\n````\nusing System;\nusing System.Collections.Generic;\n\npublic class GFG {\n\n  // Prints occurrences of txt[] in pat[]\n  public static void KMPSearch(char[] pat, char[] txt)\n  {\n    int M = pat.Length;\nint N = txt.Length;\n\n// create lps[] that will hold the longest prefix\n    // suffix values for pattern\n    int[] lps = new int[M];\n\n// Preprocess the pattern (calculate lps[] array)\n    computeLPSArray(pat, M, lps);\n\nint i = 0; // index for txt[]\n    int j = 0; // index for pat[]\n    while ((N - i) >= (M - j)) {\n      if (pat[j] == txt[i]) {\n        j++;\n        i++;\n}\n\n      if (j == M) {\n        int temp = i - j;\n        Console.WriteLine(\"Found pattern at index \"\n                          + temp);\n        j = lps[j - 1];\n}\n\n      // mismatch after j matches\n      else if (i < N && pat[j] != txt[i]) {\n        // Do not match lps[0..lps[j-1]] characters,\n        // they will match anyway\n        if (j != 0)\n          j = lps[j - 1];\nelse\n          i = i + 1;\n}\n    }\n  }\n\n  // Fills lps[] for given pattern pat[0..M-1]\n  public static void computeLPSArray(char[] pat, int M,\n                                     int[] lps)\n  {\n    // length of the previous longest prefix suffix\n    int len = 0;\n\n    lps[0] = 0; // lps[0] is always 0\n\n    // the loop calculates lps[i] for i = 1 to M-1\n    int i = 1;\n    while (i < M) {\n      if (pat[i] == pat[len]) {\n        len++;\n        lps[i] = len;\n        i++;\n}\n      else // (pat[i] != pat[len])\n      {\n        // This is tricky. Consider the example.\n        // AAACAAAA and i = 7. The idea is similar\n        // to search step.\n        if (len != 0) {\n          len = lps[len - 1];\n\n// Also, note that we do not increment\n          // i here\n        }\n        else // if (len == 0)\n        {\n          lps[i] = 0;\n          i++;\n}\n      }\n    }\n  }\n\n  static public void Main()\n  {\n\n    char[] txt = \"ABABDABACDABABCABAB\".ToCharArray();\nchar[] pat = \"ABABCABAB\".ToCharArray();\n    KMPSearch(pat, txt);\n}\n}\n\n// This code is contributed by akashish__\n\n````\n\nJavaScript\n\n````\n// JS program for implementation of KMP pattern searching\n// algorithm\n// Prlets occurrences of txt[] in pat[]\nfunction computeLPSArray(pat, M, lps)\n{\n\n    // length of the previous longest prefix suffix\n    let len = 0;\n    lps[0] = 0; // lps[0] is always 0\n    // the loop calculates lps[i] for i = 1 to M-1\n    let i = 1;\n    while (i < M) {\n        if (pat[i] == pat[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n}\n        else // (pat[i] != pat[len])\n        {\n\n            // This is tricky. Consider the example.\n            // AAACAAAA and i = 7. The idea is similar\n            // to search step.\n            if (len != 0) {\n                len = lps[len - 1];\n\n// Also, note that we do not increment\n                // i here\n            }\n            else // if (len == 0)\n            {\n                lps[i] = 0;\n                i++;\n}\n        }\n    }\n}\nfunction KMPSearch(pat, txt) {\n    let M = pat.length;\n    let N = txt.length\n\n    // create lps[] that will hold the longest prefix suffix\n    // values for pattern\n    let lps = [];\n\n// Preprocess the pattern (calculate lps[] array)\n    computeLPSArray(pat, M, lps);\n    let i = 0; // index for txt[]\n    let j = 0; // index for pat[]\n    while ((N - i) >= (M - j)) {\n        if (pat[j] == txt[i]) {\n            j++;\n            i++;\n}\n        if (j == M) {\n            console.log(\"Found pattern at index:\", i - j);\n            j = lps[j - 1];\n}\n\n        // mismatch after j matches\n        else if (i < N && pat[j] != txt[i])\n        {\n\n            // Do not match lps[0..lps[j-1]] characters,\n            // they will match anyway\n            if (j != 0)\n                j = lps[j - 1];\nelse\n                i = i + 1;\n}\n    }\n}\n\n// Fills lps[] for given pattern pat[0..M-1]\n// Driver program to test above function\nlet txt = \"ABABDABACDABABCABAB\";\nlet pat = \"ABABCABAB\";\nKMPSearch(pat, txt);\n\n// This code is contributed by ishankhandelwals.\n\n````\n\n\n\n\n**Output**\n```\nFound pattern at index 10\n```\n\n****Time complexity:****\nO(n + m)\n\n\n\n****Auxiliary Space:****\nO(M)\n\n\n[Rabin Karp algorithm](https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/)\n:\n---------------------------------------------------------------------------------------------------\n\n\nRabin-Karp algorithm is an algorithm used for searching/matching patterns in the text using a hash function. Unlike Naive string-matching algorithm, it does not travel through every character in the initial phase rather it filters the characters that do not match and then perform the comparison.\n\n\nRabin-Karp compares a string\u2019s hash values, rather than the strings themselves. For efficiency, the hash value of the next position in the text is easily computed from the hash value of the current position.\n\n\n### Working of Rabin-Karp algorithm\n\n* Initially calculate the hash value of the pattern P.\n* Start iterating from the start of the string:\n  + Calculate the hash value of the current substring having length m.\n  + If the hash value of the current substring and the pattern are same check if the substring is same as the pattern.\n  + If they are same, store the starting index as a valid answer. Otherwise, continue for the next substrings.\n* Return the starting indices as the required answer.\n\n![Example of Rabin Karp](https://media.geeksforgeeks.org/wp-content/uploads/20221108112930/rabinkarp.png)\n\nExample of Rabin Karp\n\n\nBelow is the implementation of the Rabin-Karp algorithm.\n\n\n\nC++\n\n````\n/* Following program is a C++ implementation of Rabin Karp\nAlgorithm given in the CLRS book */\n#include <bits/stdc++.h>\nusing namespace std;\n\n// d is the number of characters in the input alphabet\n#define d 256\n\n/* pat -> pattern\n    txt -> text\n    q -> A prime number\n*/\nvoid search(char pat[], char txt[], int q)\n{\n    int M = strlen(pat);\nint N = strlen(txt);\nint i, j;\nint p = 0; // hash value for pattern\n    int t = 0; // hash value for txt\n    int h = 1;\n\n// The value of h would be \"pow(d, M-1)%q\"\n    for (i = 0; i < M - 1; i++)\n        h = (h * d) % q;\n\n// Calculate the hash value of pattern and first\n    // window of text\n    for (i = 0; i < M; i++) {\n        p = (d * p + pat[i]) % q;\n        t = (d * t + txt[i]) % q;\n}\n\n    // Slide the pattern over text one by one\n    for (i = 0; i <= N - M; i++) {\n\n        // Check the hash values of current window of text\n        // and pattern. If the hash values match then only\n        // check for characters one by one\n        if (p == t) {\n            /* Check for characters one by one */\n            for (j = 0; j < M; j++) {\n                if (txt[i + j] != pat[j]) {\n                    break;\n}\n            }\n\n            // if p == t and pat[0...M-1] = txt[i, i+1,\n            // ...i+M-1]\n\n            if (j == M)\n                cout << \"Pattern found at index \" << i\n                     << endl;\n}\n\n        // Calculate hash value for next window of text:\n        // Remove leading digit, add trailing digit\n        if (i < N - M) {\n            t = (d * (t - txt[i] * h) + txt[i + M]) % q;\n\n// We might get negative value of t, converting\n            // it to positive\n            if (t < 0)\n                t = (t + q);\n}\n    }\n}\n\n/* Driver code */\nint main()\n{\n    char txt[] = \"GEEKS FOR GEEKS\";\nchar pat[] = \"GEEK\";\n\n// we mod to avoid overflowing of value but we should\n    // take as big q as possible to avoid the collison\n    int q = INT_MAX;\n\n// Function Call\n    search(pat, txt, q);\nreturn 0;\n}\n\n// This is code is contributed by rathbhupendra\n\n````\n\nJava\n\n````\nimport java.io.*;\nimport java.lang.*;\nimport java.util.*;\n\n/* pat -> pattern\n    txt -> text\n    q -> A prime number\n*/\npublic class GFG {\n  // d is the number of characters in the input alphabet\n  public final static int d = 256;\npublic static void search(String pat, String txt, int q)\n  {\n    int M = pat.length();\nint N = txt.length();\nint i, j;\nint p = 0; // hash value for pattern\n    int t = 0; // hash value for txt\n    int h = 1;\n\n// The value of h would be \"pow(d, M-1)%q\"\n    for (i = 0; i < M - 1; i++)\n      h = (h * d) % q;\n// Calculate the hash value of pattern and first\n    // window of text\n    for (i = 0; i < M; i++) {\n      p = (d * p + pat.charAt(i)) % q;\n      t = (d * t + txt.charAt(i)) % q;\n}\n\n    // Slide the pattern over text one by one\n    for (i = 0; i <= N - M; i++) {\n\n      // Check the hash values of current window of\n      // text and pattern. If the hash values match\n      // then only check for characters one by one\n      if (p == t) {\n        /* Check for characters one by one */\n        for (j = 0; j < M; j++) {\n          if (txt.charAt(i + j)\n              != pat.charAt(j)) {\n            break;\n}\n        }\n\n        // if p == t and pat[0...M-1] = txt[i, i+1,\n        // ...i+M-1]\n\n        if (j == M) {\n          System.out.println(\n            \"Pattern found at index \" + i);\n}\n      }\n      // Calculate hash value for next window of text:\n      // Remove leading digit, add trailing digit\n      if (i < N - M) {\n        t = (d * (t - txt.charAt(i) * h)\n             + txt.charAt(i + M))\n          % q;\n\n// We might get negative value of t,\n        // converting it to positive\n        if (t < 0)\n          t = (t + q);\n}\n    }\n  }\n\n  /* Driver code */\n  public static void main(String[] args)\n  {\n    String txt = \"GEEKS FOR GEEKS\";\n    String pat = \"GEEK\";\n\n// A prime number\n    int q = 101;\n\n// Function Call\n    search(pat, txt, q);\n}\n}\n\n// This code is contributed by ishankhandelwals.\n\n````\n\nPython\n\n````\n# d is the number of characters in the input alphabet\nd = 256\n\n''' pat -> pattern\ntxt -> text\nq -> A prime number '''\ndef search(pat, txt, q):\n\n    M = len(pat)\n    N = len(txt)\n    p = 0 # hash value for pattern\n    t = 0 # hash value for txt\n    h = 1\n\n    # The value of h would be \"pow(d, M-1)%q\"\n    for i in range(M - 1):\n        h = (h * d) % q\n\n    # Calculate the hash value of pattern and first\n    # window of text\n    for i in range(M):\n        p = (d * p + ord(pat[i])) % q\n        t = (d * t + ord(txt[i])) % q\n\n    # Slide the pattern over text one by one\n    for i in range(N - M + 1):\n        # Check the hash values of current window of text\n        # and pattern. If the hash values match then only\n        # check for characters one by one\n        if p == t:\n            # Check for characters one by one\n            for j in range(M):\n                if txt[i + j] != pat[j]:\n                    break\n            # if p == t and pat[0...M-1] = txt[i, i+1,\n            # ...i+M-1]\n            if j == M - 1:\n                print(\"Pattern found at index \" + str(i))\n\n        # Calculate hash value for next window of text:\n        # Remove leading digit, add trailing digit\n        if i < N - M:\n            t = (d * (t - ord(txt[i]) * h) + ord(txt[i + M])) % q\n            # We might get negative value of t, converting\n            # it to positive\n            if t < 0:\n                t = (t + q)\n\n# Driver code\ntxt = \"GEEKS FOR GEEKS\"\npat = \"GEEK\"\n\n# we mod to avoid overflowing of value but we should\n# take as big q as possible to avoid the collison\nq = float('inf')\n\n# Function Call\nsearch(pat, txt, q)\n\n# This code is contributed by akashish__\n\n````\n\nC#\n\n````\n// C# code\nusing System;\n\n/* pat -> pattern\n    txt -> text\n    q -> A prime number\n*/\n\nclass GFG {\n  // d is the number of characters in the input alphabet\n  public static int d = 256;\npublic static void search(string pat, string txt, int q)\n  {\n    int M = pat.Length;\nint N = txt.Length;\nint i, j;\nint p = 0; // hash value for pattern\n    int t = 0; // hash value for txt\n    int h = 1;\n// The value of h would be \"pow(d, M-1)%q\"\n    for (i = 0; i < M - 1; i++)\n      h = (h * d) % q;\n// Calculate the hash value of pattern and first\n    // window of text\n    for (i = 0; i < M; i++) {\n      p = (d * p + pat[i]) % q;\n      t = (d * t + txt[i]) % q;\n}\n\n    // Slide the pattern over text one by one\n    for (i = 0; i <= N - M; i++) {\n\n      // Check the hash values of current window of\n      // text and pattern. If the hash values match\n      // then only check for characters one by one\n      if (p == t) {\n        /* Check for characters one by one */\n        for (j = 0; j < M; j++) {\n          if (txt[i + j] != pat[j]) {\n            break;\n}\n        }\n\n        // if p == t and pat[0...M-1] = txt[i, i+1,\n        // ...i+M-1]\n\n        if (j == M) {\n          Console.WriteLine(\n            \"Pattern found at index \" + i);\n}\n      }\n      // Calculate hash value for next window of text:\n      // Remove leading digit, add trailing digit\n      if (i < N - M) {\n        t = (d * (t - txt[i] * h) + txt[i + M]) % q;\n\n// We might get negative value of t,\n        // converting it to positive\n        if (t < 0)\n          t = (t + q);\n}\n    }\n  }\n\n  /* Driver code */\n  public static void Main(string[] args)\n  {\n    string txt = \"GEEKS FOR GEEKS\";\n    string pat = \"GEEK\";\n\n// A prime number\n    int q = 101;\n\n// Function Call\n    search(pat, txt, q);\n}\n}\n\n// This code is contributed by akashish__\n\n````\n\nJavaScript\n\n````\n// d is the number of characters in the input alphabet\nconst d = 256;\n\n/* pat -> pattern\n    txt -> text\n    q -> A prime number\n*/\nfunction search(pat, txt, q) {\n  const M = pat.length;\n  const N = txt.length;\n  let p = 0; // hash value for pattern\n  let t = 0; // hash value for txt\n  let h = 1;\n\n// The value of h would be \"pow(d, M-1)%q\"\n  for (let i = 0; i < M - 1; i++) {\n    h = (h * d) % q;\n}\n\n  // Calculate the hash value of pattern and first\n  // window of text\n  for (let i = 0; i < M; i++) {\n    p = (d * p + pat.charCodeAt(i)) % q;\n    t = (d * t + txt.charCodeAt(i)) % q;\n}\n\n  // Slide the pattern over text one by one\n  for (let i = 0; i <= N - M; i++) {\n    // Check the hash values of current window of text\n    // and pattern. If the hash values match then only\n    // check for characters one by one\n    if (p === t) {\n    /* Check for characters one by one */\n    for (j = 0; j < M; j++) {\n        if (txt.charAt(i + j) !== pat.charAt(j)) {\n        break;\n}\n    }\n\n    // if p == t and pat[0...M-1] = txt[i, i+1,\n    // ...i+M-1]\n\n    if (j === M)\n        console.log(\"Pattern found at index \" + i);\n}\n\n    // Calculate hash value for next window of text:\n    // Remove leading digit, add trailing digit\n    if (i < N - M) {\n    t = (d * (t - txt.charCodeAt(i) * h) + txt.charCodeAt(i + M)) % q;\n\n// We might get negative value of t, converting\n    // it to positive\n    if (t < 0)\n        t = (t + q);\n}\n  }\n}\n\n/* Driver code */\nconst txt = \"GEEKS FOR GEEKS\";\nconst pat = \"GEEK\";\n\n// we mod to avoid overflowing of value but we should\n// take as big q as possible to avoid the collison\nconst q = Number.MAX_SAFE_INTEGER;\n\n// Function Call\nsearch(pat, txt, q);\n\n// This code is contributed by ishankhandelwals.\n\n````\n\n\n\n\n**Output**\n```\nPattern found at index 0\nPattern found at index 10\n```\n\n****Time Complexity:****\n\n* The average and best-case running time of the Rabin-Karp algorithm is O(n+m), but its worst-case time is O(nm).\n* The worst case of the Rabin-Karp algorithm occurs when all characters of pattern and text are the same as the hash values of all the substrings of txt[] match with the hash value of pat[].\n\n****Space Complexity :****\n\n\nThe space complexity of the Rabin-Karp algorithm is O(1), which means that it is a constant amount of memory that is required, regardless of the size of the input text and pattern. This is because the algorithm only needs to store a few variables that are updated as the algorithm progresses through the text and pattern. Specifically, the algorithm needs to store the hash value of the pattern, the hash value of the current window in the text, and a few loop counters and temporary variables. Since the size of these variables is fixed, the space complexity is constant.\n\n\n[Z algorithm](https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/)\n:\n---------------------------------------------------------------------------------------------------\n\n\nThis algorithm finds all occurrences of a pattern in a text in linear time. Let length of text be n and of pattern be m, then total time taken is O(m + n) with linear space complexity. Z algorithm works by maintaining an auxiliary array called the Z array. This Z array stores the length of the longest substring, starting from the current index, that also it\u2019s prefix.\n\n\n### What is Z Array?\n\n\nFor a string str[0..n-1], Z array is of same length as string. An element Z[i] of Z array stores length of the longest substring starting from str[i] which is also a prefix of str[0..n-1]. The first entry of Z array is meaning less as complete string is always prefix of itself.\n\n\n****Example:****\n\n> Index            0   1   2   3   4   5   6   7   8   9  10  11\n>\n>\n>\n> Text             a   a   b   c   a   a   b   x   a   a   a   z\n>\n>\n>\n> Z values         X   1   0   0   3   1   0   0   2   2   1   0\n\n### How to construct Z array?\n\n\nA Simple Solution is to run two nested loops, the outer loop goes to every index and the inner loop finds length of the longest prefix that matches the substring starting at current index. The time complexity of this solution is O(n2).\n\n\nWe can construct Z array in linear time. The idea is to maintain an interval [L, R] which is the interval with max R\n\n\n\nsuch that [L, R] is prefix substring (substring which is also a prefix.\n\n\n****Steps for maintaining this interval are as follows \u2013****\n\n> 1. If\n>\n>    ****i > R****\n>    then there is no prefix substring that starts before i and ends after i, so we reset L and R and compute new [L, R] by comparing\n>\n>    ****str[0..]****\n>    to\n>\n>    ****str[i..]****\n>    and get\n>\n>    ****Z[i] (= R-L+1)****\n>    .\n> 2. If\n>\n>    ****i <= R****\n>    then let\n>\n>    ****K = i-L****\n>    ,  now\n>\n>    ****Z[i] >= min(Z[K], R-i+1)****\n>    because str[i..] matches with\n>\n>    ****str[K..]****\n>    for atleast\n>\n>    ****R-i+1****\n>    characters (they are in[L, R] interval which we know is a prefix substring).\n>\n>\n>\n>    Now two sub cases arise:\n>    * If\n>\n>      ****Z[K] < R-i+1****\n>      then there is no prefix substring starting at str[i] (otherwise\n>\n>      ****Z[K]****\n>      would be larger)  so  Z[i] = Z[K]and interval [L, R] remains same.\n>    * If\n>\n>      ****Z[K] >= R-i+1****\n>      then it is possible to extend the [L, R] interval thus we will set L as i and start matching from\n>\n>      ****str[R]****\n>      onwards  and get new R then we will update interval [L, R] and calculate\n>\n>      ****Z[i] (=R-L+1)****\n>      .\n\n![Construction of Z array](https://media.geeksforgeeks.org/wp-content/uploads/20200224124754/Untitled-Diagram371.jpg)\n\nConstruction of Z array\n\n\nBelow is the implementation of the Z algorithm:\n\n\nC++\n\n````\n// A C++ program that implements Z algorithm for pattern\n// searching\n#include <iostream>\nusing namespace std;\n\nvoid getZarr(string str, int Z[]);\n\n// prints all occurrences of pattern in text using Z algo\nvoid search(string text, string pattern)\n{\n    // Create concatenated string \"P$T\"\n    string concat = pattern + \"$\" + text;\n    int l = concat.length();\n\n    // Construct Z array\n    int Z[l];\n    getZarr(concat, Z);\n\n    // now looping through Z array for matching condition\n    for (int i = 0; i < l; ++i) {\n        // if Z[i] (matched region) is equal to pattern\n        // length we got the pattern\n        if (Z[i] == pattern.length())\n            cout << \"Pattern found at index \"\n                 << i - pattern.length() - 1 << endl;\n    }\n}\n\n// Fills Z array for given string str[]\nvoid getZarr(string str, int Z[])\n{\n    int n = str.length();\n    int L, R, k;\n\n    // [L, R] make a window which matches with prefix of s\n    L = R = 0;\n    for (int i = 1; i < n; ++i) {\n        // if i>R nothing matches so we will calculate.\n        // Z[i] using naive way.\n        if (i > R) {\n            L = R = i;\n\n            // R-L = 0 in starting, so it will start\n            // checking from 0'th index. For example,\n            // for \"ababab\" and i = 1, the value of R\n            // remains 0 and Z[i] becomes 0. For string\n            // \"aaaaaa\" and i = 1, Z[i] and R become 5\n            while (R < n && str[R - L] == str[R])\n                R++;\n            Z[i] = R - L;\n            R--;\n        }\n        else {\n            // k = i-L so k corresponds to number which\n            // matches in [L, R] interval.\n            k = i - L;\n\n            // if Z[k] is less than remaining interval\n            // then Z[i] will be equal to Z[k].\n            // For example, str = \"ababab\", i = 3, R = 5\n            // and L = 2\n            if (Z[k] < R - i + 1)\n                Z[i] = Z[k];\n\n            // For example str = \"aaaaaa\" and i = 2, R is 5,\n            // L is 0\n            else {\n                // else start from R and check manually\n                L = i;\n                while (R < n && str[R - L] == str[R])\n                    R++;\n                Z[i] = R - L;\n                R--;\n            }\n        }\n    }\n}\n\n// Driver program\nint main()\n{\n    string text = \"GEEKS FOR GEEKS\";\n    string pattern = \"GEEK\";\n    search(text, pattern);\n    return 0;\n}\n\n````\n\nJava\n\n````\n// A Java program that implements Z algorithm for pattern\n// searching\nimport java.io.*;\n\nclass GFG\n{\n\n  // prints all occurrences of pattern in text using Z\n  // algo\n  static void search(String text, String pattern)\n  {\n\n    // Create concatenated string \"P$T\"\n    String concat = pattern + \"$\" + text;\n    int l = concat.length();\n\n    // Construct Z array\n    int[] Z = new int[l];\n    getZarr(concat, Z);\n\n    // now looping through Z array for matching\n    // condition\n    for (int i = 0; i < l; i++) {\n      // if Z[i] (matched region) is equal to pattern\n      // length we got the pattern\n      if (Z[i] == pattern.length()) {\n        System.out.println(\n          \"Pattern found at index \"\n          + (i - pattern.length() - 1));\n      }\n    }\n  }\n\n  // Fills Z array for given string str[]\n  static void getZarr(String str, int[] Z)\n  {\n    int n = str.length();\n    // [L, R] make a window which matches with prefix of\n    // s\n    int L = 0, R = 0, k;\n\n    for (int i = 1; i < n; ++i) {\n      // if i>R nothing matches so we will calculate.\n      // Z[i] using naive way.\n      if (i > R) {\n        L = R = i;\n        // R-L = 0 in starting, so it will start\n        // checking from 0'th index. For example,\n        // for \"ababab\" and i = 1, the value of R\n        // remains 0 and Z[i] becomes 0. For string\n        // \"aaaaaa\" and i = 1, Z[i] and R become 5\n        while (R < n\n               && str.charAt(R - L)\n               == str.charAt(R)) {\n          R++;\n        }\n        Z[i] = R - L;\n        R--;\n      }\n      else {\n        // k = i-L so k corresponds to number which\n        // matches in [L, R] interval.\n        k = i - L;\n\n        // if Z[k] is less than remaining interval\n        // then Z[i] will be equal to Z[k].\n        // For example, str = \"ababab\", i = 3, R = 5\n        // and L = 2\n        if (Z[k] < R - i + 1)\n          Z[i] = Z[k];\n\n        // For example str = \"aaaaaa\" and i = 2, R\n        // is 5, L is 0\n        else {\n          // else start from R and check manually\n          L = i;\n          while (R < n\n                 && str.charAt(R - L)\n                 == str.charAt(R)) {\n            R++;\n          }\n          Z[i] = R - L;\n          R--;\n        }\n      }\n    }\n  }\n\n  public static void main(String[] args)\n  {\n    String text = \"GEEKS FOR GEEKS\";\n    String pattern = \"GEEK\";\n    search(text, pattern);\n  }\n}\n\n// This code is contributed by lokeshmvs21.\n\n````\n\nPython\n\n````\n# A Python program that implements Z algorithm for pattern\n# searching\n# Fills Z array for given string str[]\ndef getZarr(string, Z):\n    n = len(string)\n\n    # [L, R] make a window which matches with prefix of s\n    L, R, k = 0, 0, 0\n    Z[0] = n\n\n    for i in range(1, n):\n\n      # if i>R nothing matches so we will calculate.\n        # Z[i] using naive way.\n        if i > R:\n            L, R = i, i\n\n            # R-L = 0 in starting, so it will start\n            # checking from 0'th index. For example,\n            # for \"ababab\" and i = 1, the value of R\n            # remains 0 and Z[i] becomes 0. For string\n            # \"aaaaaa\" and i = 1, Z[i] and R become 5\n            while R < n and string[R - L] == string[R]:\n                R += 1\n            Z[i] = R - L\n            R -= 1\n        else:\n\n          # k = i-L so k corresponds to number which\n            # matches in [L, R] interval.\n            k = i - L\n\n            # if Z[k] is less than remaining interval\n            # then Z[i] will be equal to Z[k].\n            # For example, str = \"ababab\", i = 3, R = 5\n            # and L = 2\n            if Z[k] < R - i + 1:\n                Z[i] = Z[k]\n\n            # For example str = \"aaaaaa\" and i = 2, R is 5,\n            # L is 0\n            else:\n\n              # else start from R and check manually\n                L = i\n                while R < n and string[R - L] == string[R]:\n                    R += 1\n                Z[i] = R - L\n                R -= 1\n\n# prints all occurrences of pattern in text using Z algo\ndef search(text, pattern):\n\n  # Create concatenated string \"P$T\"\n    concat = pattern + \"$\" + text\n    l = len(concat)\n\n    # Construct Z array\n    Z = [0] * l\n    getZarr(concat, Z)\n\n    # now looping through Z array for matching condition\n    for i in range(l):\n\n      # if Z[i] (matched region) is equal to pattern\n        # length we got the pattern\n        if Z[i] == len(pattern):\n            print(\"Pattern found at index\", i - len(pattern) - 1)\n\n# Driver program\nif __name__ == \"__main__\":\n    text = \"GEEKS FOR GEEKS\"\n    pattern = \"GEEK\"\n    search(text, pattern)\n\n# This code is contributed by akashish__\n\n````\n\nC#\n\n````\nusing System;\nusing System.Linq;\n\npublic class GFG {\n\n  // prints all occurrences of pattern in text using Z\n  // algo\n  static void search(string text, string pattern)\n  {\n    // Create concatenated string \"P$T\"\n    string concat = pattern + \"$\" + text;\n    int l = concat.Length;\n\n    // Construct Z array\n    int[] Z = new int[l];\n    GetZarr(concat, Z);\n\n    // now looping through Z array for matching\n    // condition\n    for (int i = 0; i < l; i++) {\n      // if Z[i] (matched region) is equal to\n      // pattern length we got the pattern\n      if (Z[i] == pattern.Length) {\n        Console.WriteLine(\n          \"Pattern found at index \"\n          + (i - pattern.Length - 1));\n      }\n    }\n  }\n\n  // Fills Z array for given string str[]\n  static void GetZarr(string str, int[] Z)\n  {\n    int n = str.Length;\n    // [L, R] make a window which matches with\n    // prefix of\n    // s\n    int L = 0, R = 0, k;\n\n    for (int i = 1; i < n; ++i) {\n      // if i>R nothing matches so we will\n      // calculate. Z[i] using naive way.\n      if (i > R) {\n        L = R = i;\n        // R-L = 0 in starting, so it will start\n        // checking from 0'th index. For\n        // example, for \"ababab\" and i = 1, the\n        // value of R remains 0 and Z[i] becomes\n        // 0. For string \"aaaaaa\" and i = 1,\n        // Z[i] and R become 5\n        while (R < n && str[R - L] == str[R]) {\n          R++;\n        }\n        Z[i] = R - L;\n        R--;\n      }\n      else {\n        // k = i-L so k corresponds to number\n        // which matches in [L, R] interval.\n        k = i - L;\n\n        // if Z[k] is less than remaining\n        // interval then Z[i] will be equal to\n        // Z[k]. For example, str = \"ababab\", i\n        // = 3, R = 5 and L = 2\n        if (Z[k] < R - i + 1)\n          Z[i] = Z[k];\n\n        // For example str = \"aaaaaa\" and i = 2,\n        // R is 5, L is 0\n        else {\n          // else start from R and check\n          // manually\n          L = i;\n          while (R < n && str[R - L] == str[R]) {\n            R++;\n          }\n          Z[i] = R - L;\n          R--;\n        }\n      }\n    }\n  }\n\n  static public void Main()\n  {\n    string text = \"GEEKS FOR GEEKS\";\n    string pattern = \"GEEK\";\n    search(text, pattern);\n  }\n}\n// This code is contributed by akashish__\n\n````\n\nJavaScript\n\n````\nfunction search(text, pattern) {\n  // Create concatenated string \"P$T\"\n  let concat = pattern + \"$\" + text;\n  let l = concat.length;\n\n  // Construct Z array\n  let Z = [];\n  getZarr(concat, Z);\n\n  // now looping through Z array for matching condition\n  for (let i = 0; i < l; i++) {\n    // if Z[i] (matched region) is equal to pattern\n    // length we got the pattern\n    if (Z[i] == pattern.length) {\n      console.log(`Pattern found at index ${i - pattern.length - 1}`);\n    }\n  }\n}\n\n// Fills Z array for given string str[]\nfunction getZarr(str, Z) {\n  let n = str.length;\n  let L, R, k;\n\n  // [L, R] make a window which matches with prefix of s\n  L = R = 0;\n  for (let i = 1; i < n; i++) {\n    // if i>R nothing matches so we will calculate.\n    // Z[i] using naive way.\n    if (i > R) {\n      L = R = i;\n\n      // R-L = 0 in starting, so it will start\n      // checking from 0'th index. For example,\n      // for \"ababab\" and i = 1, the value of R\n      // remains 0 and Z[i] becomes 0. For string\n      // \"aaaaaa\" and i = 1, Z[i] and R become 5\n      while (R < n && str[R - L] == str[R]) {\n        R++;\n      }\n      Z[i] = R - L;\n      R--;\n    } else {\n      // k = i-L so k corresponds to number which\n      // matches in [L, R] interval.\n      k = i - L;\n\n      // if Z[k] is less than remaining interval\n      // then Z[i] will be equal to Z[k].\n      // For example, str = \"ababab\", i = 3, R = 5\n      // and L = 2\n      if (Z[k] < R - i + 1) {\n        Z[i] = Z[k];\n      }\n\n      // For example str = \"aaaaaa\" and i = 2, R is 5,\n      // L is 0\n      else {\n        // else start from R and check manually\n        L = i;\n        while (R < n && str[R - L] == str[R]) {\n          R++;\n        }\n        Z[i] = R - L;\n        R--;\n      }\n    }\n  }\n}\n\n// Driver program\nlet text = \"GEEKS FOR GEEKS\";\nlet pattern = \"GEEK\";\nsearch(text, pattern);\n\n// This code is contributed by akashish__\n\n````\n\n\n\n\n**Output**\n```\nPattern found at index 0\nPattern found at index 10\n```\n\n****Time Complexity:****\nO(m+n), where m is length of pattern and n is length of text.\n\n\n\n****Auxiliary Space:****\nO(m+n)\n\n\n[Aho-Corasick algorithm](https://www.geeksforgeeks.org/aho-corasick-algorithm-pattern-searching/)\n:\n---------------------------------------------------------------------------------------------------\n\n****Aho-Corasick Algorithm****\nfinds all words in O(n + m + z) time where z is the total number of occurrences of words in text. The Aho\u2013Corasick string matching algorithm formed the basis of the original Unix command\n\n****\u201cfgrep\u201d****\n.\n\n\n****Preprocessing:****\nBuild an automaton of all words in arr[] The automaton has mainly three functions:\n\n\n> ****Go To:****\n> This function simply follows edges of Trie of all words in arr[].\n>\n>\n>\n> It is represented as 2D array g[][] where we store next state for current state and character.\n>\n>\n> ****Failure:****\n> This function stores all edges that are followed when current character doesn\u2019t have edge in Trie.\n>\n>\n>\n> It is represented as1D array f[] where we store next state for current state.\n>\n>\n> ****Output:****\n> Stores indexes of all words that end at current state.\n>\n>\n>\n> It is represented as 1D  array o[] where we store indices of all matching words as a bitmap for current state.\n\n****Matching:****\nTraverse the given text over built automaton to find all matching words.\n\n\n\nPreprocessing:\n\n\n### ****Illustration of Aho-Corasick algorithm****\n\n****Preprocessing:****\nWe first Build a Trie (or Keyword Tree) of all words.\n\n\n![ Build a Trie (or Keyword Tree) of all words.](https://media.geeksforgeeks.org/wp-content/uploads/20221108113210/aho.png)\n\nBuild a Trie (or Keyword Tree) of all words.\n\n* This part fills entries in goto g[][] and output o[].\n* Next, we extend Trie into an automaton to support linear time matching.\n\n![ills entries in goto g[][] and output o[]](https://media.geeksforgeeks.org/wp-content/uploads/20221108113225/aho2.png)\n\nFills entries in goto g[][] and output o[]\n\n* This part fills entries in failure f[] and output o[].\n\n****Go to:****\nWe build Trie. And for all characters which don\u2019t have an edge at the root, we add an edge back to root.\n\n\n\n****Failure:****\nFor a state s, we find the longest proper suffix which is a proper prefix of some pattern. This is done using Breadth First Traversal of Trie.\n\n\n\n****Output:****\nFor a state s, indexes of all words ending at s are stored. These indexes are stored as bitwise map (by doing bitwise OR of values). This is also computing using Breadth First Traversal with Failure.\n\n\nBelow is the implementation of the Aho-Corasick Algorithm:\n\n\nC++\n\n````\n// C++ program for implementation of\n// Aho Corasick algorithm for String\n// matching\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Max number of states in the matching\n// machine. Should be equal to the sum\n// of the length of all keywords.\n\n#define MAXS 500\n\n// Maximum number of characters\n// in input alphabet\n\n#define MAXC 26\n\n// OUTPUT FUNCTION IS IMPLEMENTED USING out[]\n// Bit i in this mask is one if the word with\n// index i appears when the machine enters\n// this state.\nint out[MAXS];\n\n// FAILURE FUNCTION IS IMPLEMENTED USING f[]\nint f[MAXS];\n\n// GOTO FUNCTION (OR TRIE) IS\n// IMPLEMENTED USING g[][]\nint g[MAXS][MAXC];\n\n// Builds the String matching machine.\n// arr - array of words. The index of each keyword is\n// important:\n//\"out[state] & (1 << i)\" is > 0 if we just found\n// word[i] in the text.\n// Returns the number of states that the built machine\n// has. States are numbered 0 up to the return value -\n// 1, inclusive.\n\nint buildMatchingMachine(string arr[], int k)\n{\n    // Initialize all values in output function as 0.\n    memset(out, 0, sizeof out);\n\n    // Initialize all values in goto function as -1.\n    memset(g, -1, sizeof g);\n\n    // Initially, we just have the 0 state\n    int states = 1;\n\n    // Convalues for goto function, i.e., fill g[][]\n    // This is same as building a Trie for arr[]\n    for (int i = 0; i < k; i++) {\n        string word = arr[i];\n        int currentState = 0;\n\n        // Insert all characters of current\n        // word in arr[]\n        for (int j = 0; j < word.length(); j++) {\n            int ch = word[j] - 'a';\n\n            // Allocate a new node (create a new state)\n            // if a node for ch doesn't exist.\n            if (g[currentState][ch] == -1)\n                g[currentState][ch] = states++;\n\n            currentState = g[currentState][ch];\n        }\n\n        // Add current word in output function\n        out[currentState] |= (1 << i);\n    }\n\n    // For all characters which don't have\n    // an edge from root (or state 0) in Trie,\n    // add a goto edge to state 0 itself\n    for (int ch = 0; ch < MAXC; ch++)\n        if (g[0][ch] == -1)\n            g[0][ch] = 0;\n\n    // Now, let's build the failure function\n    // Initialize values in fail function\n    memset(f, -1, sizeof f);\n\n    // Failure function is computed in\n    // breadth first order\n    // using a queue\n    queue<int> q;\n\n    // Iterate over every possible input\n    for (int ch = 0; ch < MAXC; ch++) {\n\n        // All nodes of depth 1 have failure\n        // function value as 0. For example,\n        // in above diagram we move to 0\n        // from states 1 and 3.\n        if (g[0][ch] != 0) {\n            f[g[0][ch]] = 0;\n            q.push(g[0][ch]);\n        }\n    }\n\n    // Now queue has states 1 and 3\n    while (!q.empty()) {\n\n        // Remove the front state from queue\n        int state = q.front();\n        q.pop();\n\n        // For the removed state, find failure\n        // function for all those characters\n        // for which goto function is\n        // not defined.\n        for (int ch = 0; ch < MAXC; ch++) {\n\n            // If goto function is defined for\n            // character 'ch' and 'state'\n            if (g[state][ch] != -1) {\n\n                // Find failure state of removed state\n                int failure = f[state];\n\n                // Find the deepest node labeled by\n                // proper suffix of String from root to\n                // current state.\n                while (g[failure][ch] == -1)\n                    failure = f[failure];\n                failure = g[failure][ch];\n                f[g[state][ch]] = failure;\n\n                // Merge output values\n                out[g[state][ch]] |= out[failure];\n\n                // Insert the next level node\n                // (of Trie) in Queue\n                q.push(g[state][ch]);\n            }\n        }\n    }\n    return states;\n}\n\n// Returns the next state the machine will transition to\n// using goto and failure functions. currentState - The\n// current state of the machine. Must be between\n// 0 and the number of states - 1,\n// inclusive.\n// nextInput - The next character that enters into the\n// machine.\n\n// This function finds all occurrences of\n// all array words in text.\nvoid searchWords(string arr[], int k, string text)\n{\n\n    // Preprocess patterns.\n    // Build machine with goto, failure\n    // and output functions\n    buildMatchingMachine(arr, k);\n\n    // Initialize current state\n    int currentState = 0;\n\n    // Traverse the text through the\n    // built machine to find all\n    // occurrences of words in arr[]\n    for (int i = 0; i < text.length(); i++) {\n        int ch = text[i] - 'a';\n\n        // If goto is not defined, use\n        // failure function\n        while (g[currentState][ch] == -1)\n            currentState = f[currentState];\n        currentState = g[currentState][ch];\n\n        // If match not found, move to next state\n        if (out[currentState] == 0)\n            continue;\n\n        // Match found, print all matching\n        // words of arr[]\n        // using output function.\n        for (int j = 0; j < k; j++) {\n            if (out[currentState] & (1 << j))\n                cout << \"Word \" << arr[j]\n                     << \" appears from \"\n                     << i - arr[j].length() + 1 << \" to \"\n                     << i << endl;\n        }\n    }\n}\n// Driver code\n\nint main()\n{\n    string arr[] = { \"he\", \"she\", \"hers\", \"his\" };\n    int k = sizeof(arr) / sizeof(arr[0]);\n    string text = \"ahishers\";\n    searchWords(arr, k, text);\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program for implementation of\n// Aho Corasick algorithm for String\n// matching\nimport java.util.*;\n\nclass GFG {\n\n    // Max number of states in the matching\n    // machine. Should be equal to the sum\n    // of the length of all keywords.\n    static int MAXS = 500;\n\n    // Maximum number of characters\n    // in input alphabet\n    static int MAXC = 26;\n\n    // OUTPUT FUNCTION IS IMPLEMENTED USING out[]\n    // Bit i in this mask is one if the word with\n    // index i appears when the machine enters\n    // this state.\n    static int[] out = new int[MAXS];\n\n    // FAILURE FUNCTION IS IMPLEMENTED USING f[]\n    static int[] f = new int[MAXS];\n\n    // GOTO FUNCTION (OR TRIE) IS\n    // IMPLEMENTED USING g[][]\n    static int[][] g = new int[MAXS][MAXC];\n\n    // Builds the String matching machine.\n    // arr - array of words. The index of each keyword is\n    // important:\n    //         \"out[state] & (1 << i)\" is > 0 if we just\n    //         found\n    // word[i]          in the text.\n    // Returns the number of states that the built machine\n    // has. States are numbered 0 up to the return value -\n    // 1, inclusive.\n    static int buildMatchingMachine(String arr[], int k)\n    {\n\n        // Initialize all values in output function as 0.\n        Arrays.fill(out, 0);\n\n        // Initialize all values in goto function as -1.\n        for (int i = 0; i < MAXS; i++)\n            Arrays.fill(g[i], -1);\n\n        // Initially, we just have the 0 state\n        int states = 1;\n\n        // Convalues for goto function, i.e., fill g[][]\n        // This is same as building a Trie for arr[]\n        for (int i = 0; i < k; ++i) {\n            String word = arr[i];\n            int currentState = 0;\n\n            // Insert all characters of current\n            // word in arr[]\n            for (int j = 0; j < word.length(); ++j) {\n                int ch = word.charAt(j) - 'a';\n\n                // Allocate a new node (create a new state)\n                // if a node for ch doesn't exist.\n                if (g[currentState][ch] == -1)\n                    g[currentState][ch] = states++;\n\n                currentState = g[currentState][ch];\n            }\n\n            // Add current word in output function\n            out[currentState] |= (1 << i);\n        }\n\n        // For all characters which don't have\n        // an edge from root (or state 0) in Trie,\n        // add a goto edge to state 0 itself\n        for (int ch = 0; ch < MAXC; ++ch)\n            if (g[0][ch] == -1)\n                g[0][ch] = 0;\n\n        // Now, let's build the failure function\n        // Initialize values in fail function\n        Arrays.fill(f, -1);\n\n        // Failure function is computed in\n        // breadth first order\n        // using a queue\n        Queue<Integer> q = new LinkedList<>();\n\n        // Iterate over every possible input\n        for (int ch = 0; ch < MAXC; ++ch) {\n\n            // All nodes of depth 1 have failure\n            // function value as 0. For example,\n            // in above diagram we move to 0\n            // from states 1 and 3.\n            if (g[0][ch] != 0) {\n                f[g[0][ch]] = 0;\n                q.add(g[0][ch]);\n            }\n        }\n\n        // Now queue has states 1 and 3\n        while (!q.isEmpty()) {\n\n            // Remove the front state from queue\n            int state = q.peek();\n            q.remove();\n\n            // For the removed state, find failure\n            // function for all those characters\n            // for which goto function is\n            // not defined.\n            for (int ch = 0; ch < MAXC; ++ch) {\n\n                // If goto function is defined for\n                // character 'ch' and 'state'\n                if (g[state][ch] != -1) {\n\n                    // Find failure state of removed state\n                    int failure = f[state];\n\n                    // Find the deepest node labeled by\n                    // proper suffix of String from root to\n                    // current state.\n                    while (g[failure][ch] == -1)\n                        failure = f[failure];\n\n                    failure = g[failure][ch];\n                    f[g[state][ch]] = failure;\n\n                    // Merge output values\n                    out[g[state][ch]] |= out[failure];\n\n                    // Insert the next level node\n                    // (of Trie) in Queue\n                    q.add(g[state][ch]);\n                }\n            }\n        }\n        return states;\n    }\n\n    // Returns the next state the machine will transition to\n    // using goto and failure functions. currentState - The\n    // current state of the machine. Must be between\n    // 0 and the number of states - 1,\n    // inclusive.\n    // nextInput - The next character that enters into the\n    // machine.\n    static int findNextState(int currentState,\n                             char nextInput)\n    {\n        int answer = currentState;\n        int ch = nextInput - 'a';\n\n        // If goto is not defined, use\n        // failure function\n        while (g[answer][ch] == -1)\n            answer = f[answer];\n\n        return g[answer][ch];\n    }\n\n    // This function finds all occurrences of\n    // all array words in text.\n    static void searchWords(String arr[], int k,\n                            String text)\n    {\n\n        // Preprocess patterns.\n        // Build machine with goto, failure\n        // and output functions\n        buildMatchingMachine(arr, k);\n\n        // Initialize current state\n        int currentState = 0;\n\n        // Traverse the text through the\n        // built machine to find all\n        // occurrences of words in arr[]\n        for (int i = 0; i < text.length(); ++i) {\n            currentState = findNextState(currentState,\n                                         text.charAt(i));\n\n            // If match not found, move to next state\n            if (out[currentState] == 0)\n                continue;\n\n            // Match found, print all matching\n            // words of arr[]\n            // using output function.\n            for (int j = 0; j < k; ++j) {\n                if ((out[currentState] & (1 << j)) > 0) {\n                    System.out.print(\n                        \"Word \" + arr[j] + \" appears from \"\n                        + (i - arr[j].length() + 1) + \" to \"\n                        + i + \"\\n\");\n                }\n            }\n        }\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        String arr[] = { \"he\", \"she\", \"hers\", \"his\" };\n        String text = \"ahishers\";\n        int k = arr.length;\n\n        searchWords(arr, k, text);\n    }\n}\n// This code is wriiten by Sundaram.\n\n````\n\nPython\n\n````\n# Python program for implementation of\n# Aho-Corasick algorithm for string matching\n\n# defaultdict is used only for storing the final output\n# We will return a dictionary where key is the matched word\n# and value is the list of indexes of matched word\nfrom collections import defaultdict\n\n# For simplicity, Arrays and Queues have been implemented using lists.\n# If you want to improve performance try using them instead\n\n\nclass AhoCorasick:\n    def __init__(self, words):\n\n        # Max number of states in the matching machine.\n        # Should be equal to the sum of the length of all keywords.\n        self.max_states = sum([len(word) for word in words])\n\n        # Maximum number of characters.\n        # Currently supports only alphabets [a, z]\n        self.max_characters = 26\n\n        # OUTPUT FUNCTION IS IMPLEMENTED USING out []\n        # Bit i in this mask is 1 if the word with\n        # index i appears when the machine enters this state.\n        # Lets say, a state outputs two words \"he\" and \"she\" and\n        # in our provided words list, he has index 0 and she has index 3\n        # so value of out[state] for this state will be 1001\n        # It has been initialized to all 0.\n        # We have taken one extra state for the root.\n        self.out = [0]*(self.max_states + 1)\n\n        # FAILURE FUNCTION IS IMPLEMENTED USING fail []\n        # There is one value for each state + 1 for the root\n        # It has been initialized to all -1\n        # This will contain the fail state value for each state\n        self.fail = [-1]*(self.max_states + 1)\n\n        # GOTO FUNCTION (OR TRIE) IS IMPLEMENTED USING goto [[]]\n        # Number of rows = max_states + 1\n        # Number of columns = max_characters i.e 26 in our case\n        # It has been initialized to all -1.\n        self.goto = [\n            [-1]*self.max_characters for _ in range(self.max_states + 1)]\n\n        # Convert all words to lowercase\n        # so that our search is case insensitive\n        for i in range(len(words)):\n            words[i] = words[i].lower()\n\n        # All the words in dictionary which will be used to create Trie\n        # The index of each keyword is important:\n        # \"out[state] & (1 << i)\" is > 0 if we just found word[i]\n        # in the text.\n        self.words = words\n\n        # Once the Trie has been built, it will contain the number\n        # of nodes in Trie which is total number of states required <= max_states\n        self.states_count = self.__build_matching_machine()\n\n    # Builds the String matching machine.\n    # Returns the number of states that the built machine has.\n    # States are numbered 0 up to the return value - 1, inclusive.\n\n    def __build_matching_machine(self):\n        k = len(self.words)\n\n        # Initially, we just have the 0 state\n        states = 1\n\n        # Convalues for goto function, i.e., fill goto\n        # This is same as building a Trie for words[]\n        for i in range(k):\n            word = self.words[i]\n            current_state = 0\n\n            # Process all the characters of the current word\n            for character in word:\n                ch = ord(character) - 97  # Ascii value of 'a' = 97\n\n                # Allocate a new node (create a new state)\n                # if a node for ch doesn't exist.\n                if self.goto[current_state][ch] == -1:\n                    self.goto[current_state][ch] = states\n                    states += 1\n\n                current_state = self.goto[current_state][ch]\n\n            # Add current word in output function\n            self.out[current_state] |= (1 << i)\n\n        # For all characters which don't have\n        # an edge from root (or state 0) in Trie,\n        # add a goto edge to state 0 itself\n        for ch in range(self.max_characters):\n            if self.goto[0][ch] == -1:\n                self.goto[0][ch] = 0\n\n        # Failure function is computed in\n        # breadth first order using a queue\n        queue = []\n\n        # Iterate over every possible input\n        for ch in range(self.max_characters):\n\n            # All nodes of depth 1 have failure\n            # function value as 0. For example,\n            # in above diagram we move to 0\n            # from states 1 and 3.\n            if self.goto[0][ch] != 0:\n                self.fail[self.goto[0][ch]] = 0\n                queue.append(self.goto[0][ch])\n\n        # Now queue has states 1 and 3\n        while queue:\n\n            # Remove the front state from queue\n            state = queue.pop(0)\n\n            # For the removed state, find failure\n            # function for all those characters\n            # for which goto function is not defined.\n            for ch in range(self.max_characters):\n\n                # If goto function is defined for\n                # character 'ch' and 'state'\n                if self.goto[state][ch] != -1:\n\n                    # Find failure state of removed state\n                    failure = self.fail[state]\n\n                    # Find the deepest node labeled by proper\n                    # suffix of String from root to current state.\n                    while self.goto[failure][ch] == -1:\n                        failure = self.fail[failure]\n\n                    failure = self.goto[failure][ch]\n                    self.fail[self.goto[state][ch]] = failure\n\n                    # Merge output values\n                    self.out[self.goto[state][ch]] |= self.out[failure]\n\n                    # Insert the next level node (of Trie) in Queue\n                    queue.append(self.goto[state][ch])\n\n        return states\n\n    # Returns the next state the machine will transition to using goto\n    # and failure functions.\n    # current_state - The current state of the machine. Must be between\n    # 0 and the number of states - 1, inclusive.\n    # next_input - The next character that enters into the machine.\n\n    def __find_next_state(self, current_state, next_input):\n        answer = current_state\n        ch = ord(next_input) - 97  # Ascii value of 'a' is 97\n\n        # If goto is not defined, use\n        # failure function\n        while self.goto[answer][ch] == -1:\n            answer = self.fail[answer]\n\n        return self.goto[answer][ch]\n\n    # This function finds all occurrences of all words in text.\n\n    def search_words(self, text):\n        # Convert the text to lowercase to make search case insensitive\n        text = text.lower()\n\n        # Initialize current_state to 0\n        current_state = 0\n\n        # A dictionary to store the result.\n        # Key here is the found word\n        # Value is a list of all occurrences start index\n        result = defaultdict(list)\n\n        # Traverse the text through the built machine\n        # to find all occurrences of words\n        for i in range(len(text)):\n            current_state = self.__find_next_state(current_state, text[i])\n\n            # If match not found, move to next state\n            if self.out[current_state] == 0:\n                continue\n\n            # Match found, store the word in result dictionary\n            for j in range(len(self.words)):\n                if (self.out[current_state] & (1 << j)) > 0:\n                    word = self.words[j]\n\n                    # Start index of word is (i-len(word)+1)\n                    result[word].append(i-len(word)+1)\n\n        # Return the final result dictionary\n        return result\n\n\n# Driver code\nif __name__ == \"__main__\":\n    words = [\"he\", \"she\", \"hers\", \"his\"]\n    text = \"ahishers\"\n\n    # Create an Object to initialize the Trie\n    aho_chorasick = AhoCorasick(words)\n\n    # Get the result\n    result = aho_chorasick.search_words(text)\n\n    # Print the result\n    for word in result:\n        for i in result[word]:\n            print(\"Word\", word, \"appears from\", i, \"to\", i + len(word)-1)\n\n````\n\nJavaScript\n\n````\nconst MAXS = 500;\nconst MAXC = 26;\n\nlet out = new Array(MAXS).fill(0);\nlet f = new Array(MAXS).fill(-1);\nlet g = Array.from(Array(MAXS), () => new Array(MAXC).fill(-1));\n\nfunction buildMatchingMachine(arr, k) {\n  out.fill(0);\n  g.forEach(row => row.fill(-1));\n  let states = 1;\n  for (let i = 0; i < k; i++) {\n    const word = arr[i];\n    let currentState = 0;\n    for (let j = 0; j < word.length; j++) {\n      const ch = word.charCodeAt(j) - 'a'.charCodeAt(0);\n      if (g[currentState][ch] === -1) g[currentState][ch] = states++;\n      currentState = g[currentState][ch];\n    }\n    out[currentState] |= 1 << i;\n  }\n  for (let ch = 0; ch < MAXC; ch++) {\n    if (g[0][ch] === -1) g[0][ch] = 0;\n  }\n  f.fill(-1);\n  const q = [];\n  for (let ch = 0; ch < MAXC; ch++) {\n    if (g[0][ch] !== 0) {\n      f[g[0][ch]] = 0;\n      q.push(g[0][ch]);\n    }\n  }\n  while (q.length) {\n    const state = q.shift();\n    for (let ch = 0; ch < MAXC; ch++) {\n      if (g[state][ch] !== -1) {\n        let failure = f[state];\n        while (g[failure][ch] === -1) failure = f[failure];\n        failure = g[failure][ch];\n        f[g[state][ch]] = failure;\n        out[g[state][ch]] |= out[failure];\n        q.push(g[state][ch]);\n      }\n    }\n  }\n  return states;\n}\n\nfunction searchWords(arr, k, text) {\n  buildMatchingMachine(arr, k);\n  let currentState = 0;\n  for (let i = 0; i < text.length; i++) {\n    const ch = text.charCodeAt(i) - 'a'.charCodeAt(0);\n    while (g[currentState][ch] === -1) currentState = f[currentState];\n    currentState = g[currentState][ch];\n    if (out[currentState] === 0) continue;\n    for (let j = 0; j < k; j++) {\n      if (out[currentState] & (1 << j)) {\n        console.log(`Word ${arr[j]} appears from ${i - arr[j].length + 1} to ${i}`);\n      }\n    }\n  }\n}\n\n// Driver code\nconst arr = [\"he\", \"she\", \"hers\", \"his\"];\nconst k = arr.length;\nconst text = \"ahishers\";\nsearchWords(arr, k, text);\n\n````\n\n\n\n\n**Output**\n```\nWord his appears from 1 to 3\nWord he appears from 4 to 5\nWord she appears from 3 to 5\nWord hers appears from 4 to 7\n```\n\n****Time Complexity:****\nO(n + l + z), where \u2018n\u2019 is the length of the text, \u2018l\u2019 is the length of keywords, and \u2018z\u2019 is the number of matches.\n\n\n\n****Auxiliary Space:****\nO(l \\* q), where \u2018q\u2019 is the length of the alphabet since that is the maximum number of children a node can have.",
        "metadata": {
            "lesson_id": "f6b69eae-bbcf-44ad-9b2d-18253be9e546",
            "course_id": "8ff4ea92-41f2-4d49-b230-0281874efb2d",
            "course_name": "Introduction to DSA II",
            "lesson_description": "We use certain algorithms to do the search process. The complexity of pattern searching varies from algorithm to algorithm. They are very useful when performing a search in a database. The Pattern Searching algorithm is useful for finding patterns in substrings of larger strings. This process can be accomplished using a variety of algorithms that we are going to discuss in this blog.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Table of Content\n\n* [What is Backtracking?](#what-is-backtracking)\n* [Types of Backtracking Problems](#types-of-backtracking-problems)\n* [How does Backtracking works?](#how-does-backtracking-works)\n* [Determining Backtracking Problems](#determining-backtracking-problems)\n* [Pseudocode for Backtracking](#pseudocode-for-backtracking)\n* [Complexity Analysis of Backtracking](#complexity-analysis-of-backtracking)\n* [How Backtracking is different from Recursion?](#how-backtracking-is-different-from-recursion)\n* [Applications of Backtracking](#applications-of-backtracking)\n* [Must Do Backtracking Problems](#must-do-backtracking-problems)\n\nWhat is Backtracking?\n---------------------\n\n\nBacktracking is a problem-solving algorithmic technique that involves finding a solution incrementally by trying\n\n****different options****\nand\n\n****undoing****\nthem if they lead to a\n\n****dead end****\n. It is commonly used in situations where you need to explore multiple possibilities to solve a problem, like searching for a path in a maze or solving puzzles like Sudoku. When a dead end is reached, the algorithm backtracks to the previous decision point and explores a different path until a solution is found or all possibilities have been exhausted.\n\n\n> Backtracking can be defined as a general algorithmic technique that considers searching every possible combination in order to solve a computational problem.\n\n![backtracking-banner-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20231016112106/backtracking-banner-(1).png)\n\nIntroduction to Backtracking\n\n### Basic Terminologies\n\n* ****Candidate:****\n  A candidate is a potential choice or element that can be added to the current solution.\n* ****Solution:****\n  The solution is a valid and complete configuration that satisfies all problem constraints.\n* ****Partial Solution:****\n  A partial solution is an intermediate or incomplete configuration being constructed during the backtracking process.\n* ****Decision Space:****\n  The decision space is the set of all possible candidates or choices at each decision point.\n* ****Decision Point:****\n  A decision point is a specific step in the algorithm where a candidate is chosen and added to the partial solution.\n* ****Feasible Solution:****\n  A feasible solution is a partial or complete solution that adheres to all constraints.\n* ****Dead End:****\n  A dead end occurs when a partial solution cannot be extended without violating constraints.\n* ****Backtrack:****\n  Backtracking involves undoing previous decisions and returning to a prior decision point.\n* ****Search Space:****\n  The search space includes all possible combinations of candidates and choices.\n* ****Optimal Solution:****\n  In optimization problems, the optimal solution is the best possible solution.\n\nTypes of Backtracking Problems\n------------------------------\n\n\nProblems associated with backtracking can be categorized into 3 categories:\n\n\n* ****Decision Problems:****\n  Here, we search for a feasible solution.\n* ****Optimization Problems:****\n  For this type, we search for the best solution.\n* ****Enumeration Problems:****\n  We find set of all possible feasible solutions to the problems of this type.\n\nHow does Backtracking works?\n----------------------------\n\n> As we know backtracking algorithm explores each and every possible path in order to find a valid solution, this exploration of path can be easily understood via given images:\n>\n>\n> ![backtracking](https://media.geeksforgeeks.org/wp-content/uploads/20231010124142/backtracking.png)\n>\n>\n> As shown in the image, \u201c\n>\n> ****IS\u201d****\n> represents the\n>\n> ****Initial State****\n> where the recursion call starts to find a valid solution.\n>\n>\n>\n> ****C :****\n> it represents different\n>\n> ****Checkpoints****\n> for recursive calls\n>\n>\n> ****TN****\n> : it represents the\n>\n> ****Terminal Nodes****\n> where no further recursive calls can be made, these nodes act as base case of recursion and we determine whether the current solution is valid or not at this state.\n>\n>\n> At each Checkpoint, our program makes some decisions and move to other checkpoints untill it reaches a terminal Node, after determining whether a solution is valid or not, the program starts to revert back to the checkpoints and try to explore other paths. For example in the above image\n>\n> ****TN1\u2026TN5****\n> are the terminal node where the solution is not acceptable, while\n>\n> ****TN6****\n> is the state where we found a valid solution.\n>\n>\n> The back arrows in the images shows backtracking in actions, where we revert the changes made by some checkpoint.\n\nDetermining Backtracking Problems:\n----------------------------------\n\n\nGenerally every constraint satisfaction problem can be solved using backtracking but, Is it optimal to use backtracking every time? Turns out\n\n****NO****\n, there are a vast number of problem that can be solved using\n\n[Greedy](https://www.geeksforgeeks.org/introduction-to-greedy-algorithm-data-structures-and-algorithm-tutorials/)\nor\n\n[Dynamic programming](https://www.geeksforgeeks.org/dynamic-programming/)\nin logarithmic or polynomial time complexity which is far better than exponential complexity of Backtracking. However many problems still exists that can only be solved using Backtracking.\n\n\n> To understand whether a problem is Backtracking based or not, let us take a simple problem:\n>\n>\n>\n> ****Problem:****\n>\n> Imagine you have 3 closed boxes, among which 2 are empty and 1 has a gold coin. Your task is to get the gold coin.\n>\n>\n> ****Why dynamic programming fails to solve this question:****\n>\n> ****D****\n> oes opening or closing one box has any effect on the other box? Turns out NO, each and every box is independent of each other and opening/closing state of one box can not determine the transition for other boxes. Hence DP fails.\n>\n>\n> ****Why greedy fails to solve this question:****\n>\n>\n> Greedy algorithm chooses a local maxima in order to get global maxima, but in this problem each and every box has equal probability of having a gold coin i.e 1/3 hence there is no criteria to make a greedy choice.\n>\n>\n> ****Why Backtracking works:****\n>\n> As discussed already, backtracking algorithm is simply brute forcing each and every choice, hence we can one by one choose every box to find the gold coin, If a box is found empty we can close it back which acts as a Backtracking step.\n>\n>\n> Technically, for backtracking problems:\n>\n>\n> * The algorithm builds a solution by exploring all possible paths created by the choices in the problem, this solution begins with an empty set\n>\n>   ****S={}****\n> * Each choice creates a new sub-tree \u2018\n>\n>   ****s\u2019****\n>   which we add into are set.\n> * Now there exist two cases:\n>   + ****S+s is valid set****\n>   + ****S+s is not valid set****\n> * In case the set is valid then we further make choices and repeat the process until a solution is found, otherwise we backtrack our decision of including \u2018\n>\n>   ****s\u2019****\n>   and explore other paths until a solution is found or all the possible paths are exhausted.\n\nPseudocode for Backtracking\n---------------------------\n\n\nThe best way to implement backtracking is through recursion, and all backtracking code can be summarised as per the given Pseudocode:\n\n\n> void\n>\n> ****FIND\\_SOLUTIONS****\n> ( parameters):\n>\n>\n> if (valid\n>\n> ****solution****\n> ):\n>\n>\n> store the\n>\n> ****solution****\n>\n>\n> Return\n>\n>\n> for (all\n>\n> ****choice****\n> ):\n>\n>\n> if (valid\n>\n> ****choice****\n> ):\n>\n>\n> ****APPLY****\n> (\n>\n> ****choice****\n> )\n>\n>\n> ****FIND\\_SOLUTIONS****\n> (parameters)\n>\n>\n> ****BACKTRACK****\n> (remove\n>\n> ****choice****\n> )\n>\n>\n> Return\n\nComplexity Analysis of Backtracking\n-----------------------------------\n\n\nSince backtracking algorithm is purely brute force therefore in terms of time complexity, it performs very poorly. Generally backtracking can be seen having below mentioned time complexities:\n\n\n* Exponential (O(K^N))\n* Factorial (O(N!))\n\n\nThese complexities are due to the fact that at each state we have multiple choices due to which the number of paths increases and sub-trees expand rapidly.\n\n\nHow Backtracking is different from Recursion?\n---------------------------------------------\n\n\nRecursion and Backtracking are related concepts in computer science and programming, but they are not the same thing. Let\u2019s explore the key differences between them:\n\n\nApplications of Backtracking\n----------------------------\n\n* Creating smart bots to play Board Games such as Chess.\n* Solving mazes and puzzles such as N-Queen problem.\n* Network Routing and Congestion Control.\n* Decryption\n* Text Justification",
        "metadata": {
            "lesson_id": "b8165176-c256-44f6-bc1a-a32a3626fad5",
            "course_id": "8ff4ea92-41f2-4d49-b230-0281874efb2d",
            "course_name": "Introduction to DSA II",
            "lesson_description": "Backtracking is like trying different paths, and when you hit a dead end, you backtrack to the last choice and try a different route. In this article, we\u2019ll explore the basics of backtracking, how it works, and how it can help solve all sorts of challenging problems. It\u2019s like a method for finding the right way through a complex choices.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "What is a Doubly Linked List?\n-----------------------------\n\nA ****doubly linked list****\nis a data structure that consists of a set of nodes, each of which\ncontains a ****value**** and ****two pointers****, one pointing to the ****previous node**** in the list and one pointing to the ****next node****\nin the list. This allows for efficient traversal of the list in ****both directions****, making it suitable for applications where frequent ****insertions**** and ****deletions**** are required.\n\n![Insertion-at-the-End-in-Doubly-Linked-List-copy](https://media.geeksforgeeks.org/wp-content/uploads/20240809123741/Insertion-at-the-End-in-Doubly-Linked-List-copy.webp)\n\nDoubly Linked List\n\n\nRepresentation of Doubly Linked List in Data Structure\n------------------------------------------------------\n\nIn a data structure, a doubly linked list is represented using nodes\nthat have three fields:\n\n1. Data\n2. A pointer to the next node (****next****)\n3. A pointer to the previous node (****prev****)\n\n![Node-Structure-of-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124907/Node-Structure-of-Doubly-Linked-List.webp)\n\nNode Structure of Doubly Linked List\n\n\nNode Definition\n---------------\n\nHere is how a node in a Doubly Linked List is typically\nrepresented:\n\n[Try it on GfG Practice\n![redirect icon](https://media.geeksforgeeks.org/auth-dashboard-uploads/Group-arrow.svg)](https://www.geeksforgeeks.org/problems/display-doubly-linked-list--154650/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=practice_card)\nC++\n````\nstruct Node {\n\n    // To store the Value or data.\n    int data;\n\n    // Pointer to point the Previous Element\n    Node* prev;\n\n    // Pointer to point the Next Element\n    Node* next;\n\n    // Constructor\n    Node(int d) {\n       data = d;\n       prev = next = nullptr;\n    }\n};\n\n````\n\nC\n````\nstruct Node {\n\n    // To store the Value or data.\n    int data;\n\n    // Pointer to point the Previous Element\n    Node* prev;\n\n    // Pointer to point the Next Element\n    Node* next;\n};\n\n// Function to create a new node\nstruct Node *createNode(int new_data) {\n    struct Node *new_node = (struct Node *)\n    malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    new_node->prev = NULL;\n    return new_node;\n}\n\n````\n\nJava\n````\nclass Node {\n\n    // To store the Value or data.\n    int data;\n\n    // Reference to the Previous Node\n    Node prev;\n\n    // Reference to the next Node\n    Node next;\n\n    // Constructor\n    Node(int d) {\n       data = d;\n       prev = next = null;\n    }\n};\n\n````\n\nPython\n````\nclass Node:\n\n    def __init__(self, data):\n        # To store the value or data.\n        self.data = data\n\n        # Reference to the previous node\n        self.prev = None\n\n        # Reference to the next node\n        self.next = None\n\n````\n\nC#\n````\nclass Node\n{\n  \t// To store the value or data\n    public int Data;\n\n  \t// Pointer to the next node\n    public Node Next;\n\n  \t// Pointer to the previous node\n    public Node Prev;\n\n    // Constructor\n    public Node(int d)\n    {\n        Data = d;\n        Prev = Next = null;\n    }\n}\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(data)\n    {\n        // To store the value or data.\n        this.data = data;\n\n        // Reference to the previous node\n        this.prev = null;\n\n        // Reference to the next node\n        this.next = null;\n    }\n}\n\n````\n\nEach node in a ****Doubly Linked List**** contains the ****data**** it holds, a pointer to the ****next**** node in the list, and a pointer to the ****previous****\nnode in the list. By linking these nodes together through the ****next**** and ****prev****\npointers, we can traverse the list in both directions (forward and\nbackward), which is a key feature of a Doubly Linked List.\n\n[Operations on Doubly Linked List](https://www.geeksforgeeks.org/doubly-linked-list-tutorial)\n---------------------------------------------------------------------------------------------\n\n* ****Traversal in Doubly Linked List****\n* ****Searching in Doubly Linked List****\n* ****Finding Length of Doubly Linked List****\n* [****Insertion in Doubly Linked List****:](https://www.geeksforgeeks.org/introduction-and-insertion-in-a-doubly-linked-list)\n  + Insertion at the beginning of Doubly Linked List\n  + Insertion at the end of the Doubly Linked List\n  + Insertion at a specific position in Doubly Linked List\n* [****Deletion in Doubly Linked List****:](https://www.geeksforgeeks.org/delete-a-node-in-a-doubly-linked-list)\n  + Deletion of a node at the beginning of Doubly Linked List\n  + Deletion of a node at the end of Doubly Linked List\n  + Deletion of a node at a specific position in Doubly Linked\n    List\n\nLet's go through each of the operations mentioned above, one by\none.\n\n[Traversal in Doubly Linked List](https://www.geeksforgeeks.org/traversal-in-doubly-linked-list/)\n-------------------------------------------------------------------------------------------------\n\nTo Traverse the doubly list, we can use the following steps:\n\n****a. Forward Traversal:****\n\n* Initialize a pointer to the head of the linked list.\n* While the pointer is not null:\n  + Visit the data at the current node.\n  + Move the pointer to the next node.\n\n****b. Backward Traversal:****\n\n* Initialize a pointer to the tail of the linked list.\n* While the pointer is not null:\n  + Visit the data at the current node.\n  + Move the pointer to the previous node.\n\nBelow are the implementation of the above approach:\n\nC++\n````\n#include <iostream>\nusing namespace std;\n\n// Define the Node structure\nstruct Node {\n    int data;\n    Node* next;\n    Node* prev;\n\n// Constructor to initialize Node with data\n    Node(int data) : data(data), next(nullptr),\n  \tprev(nullptr) {}\n};\n\n// Function to traverse the doubly linked list\n// in forward direction\nvoid forwardTraversal(Node* head) {\n\n    // Start traversal from the head of the list\n    Node* curr = head;\n\n// Continue until current node is not null\n    // (end of list)\n    while (curr != nullptr) {\n\n        // Output data of the current node\n        cout << curr->data << \" \";\n\n// Move to the next node\n        curr = curr->next;\n}\n\n    // Print newline after traversal\n    cout << endl;\n}\n\n// Function to traverse the doubly linked list\n// in backward direction\nvoid backwardTraversal(Node* tail) {\n\n    // Start traversal from the tail of the list\n    Node* curr = tail;\n\n// Continue until current node is not null\n    // (end of list)\n    while (curr != nullptr) {\n\n        // Output data of the current node\n        cout << curr->data << \" \";\n\n// Move to the previous node\n        curr = curr->prev;\n}\n\n    // Print newline after traversal\n    cout << endl;\n}\n\nint main() {\n\n    // Sample usage of the doubly linked list and\n    // traversal functions\n    Node* head = new Node(1);\n    Node* second = new Node(2);\n    Node* third = new Node(3);\n\n    head->next = second;\nsecond->prev = head;\nsecond->next = third;\n    third->prev = second;\n\n    cout << \"Forward Traversal:\" << endl;\n    forwardTraversal(head);\n\n    cout << \"Backward Traversal:\" << endl;\n    backwardTraversal(third);\n\nreturn 0;\n}\n\n````\n\nC\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the Node structure\nstruct Node {\n    int data; // Data stored in the node\n    struct Node* next; // Pointer to the next node\n    struct Node* prev; // Pointer to the previous node\n};\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode =\n      (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    newNode->prev = NULL;\nreturn newNode;\n}\n\n// Function to traverse the doubly linked list\n// in forward direction\nvoid forwardTraversal(struct Node* head) {\n\n    // Start traversal from the head of the list\n    struct Node* curr = head;\n\n// Continue until the current node is not\n    // null (end of list)\n    while (curr != NULL) {\n\n        // Output data of the current node\n        printf(\"%d \", curr->data);\n\n// Move to the next node\n        curr = curr->next;\n}\n\n    // Print newline after traversal\n    printf(\"\\n\");\n}\n\n// Function to traverse the doubly linked list\n// in backward direction\nvoid backwardTraversal(struct Node* tail) {\n\n    // Start traversal from the tail of the list\n    struct Node* curr = tail;\n\n// Continue until the current node is not\n    // null (end of list)\n    while (curr != NULL) {\n\n        // Output data of the current node\n        printf(\"%d \", curr->data);\n\n// Move to the previous node\n        curr = curr->prev;\n}\n\n    // Print newline after traversal\n    printf(\"\\n\");\n}\n\nint main() {\n\n    // Sample usage of the doubly linked list and\n    // traversal functions\n    struct Node* head = createNode(1);\n    struct Node* second = createNode(2);\n    struct Node* third = createNode(3);\n\n    head->next = second;\nsecond->prev = head;\nsecond->next = third;\n    third->prev = second;\n\n    printf(\"Forward Traversal:\\n\");\n    forwardTraversal(head);\n\n    printf(\"Backward Traversal:\\n\");\n    backwardTraversal(third);\n\n// Free memory allocated for nodes\n    free(head);\n    free(second);\n    free(third);\n\nreturn 0;\n}\n\n````\n\nJava\n````\n// Define the Node class\nclass Node {\n    int data; // Data stored in the node\n    Node next; // Pointer to the next node\n    Node prev; // Pointer to the previous node\n\n    // Constructor to initialize the node with data\n    public Node(int data) {\n        this.data = data;\n        this.next = null;\n        this.prev = null;\n}\n}\n\n// Class to manage the doubly linked list\nclass GfG {\n\n    // Function to traverse the doubly linked list\n    // in forward direction\n    static void forwardTraversal(Node head) {\n\n        // Start traversal from the head of the list\n        Node curr = head;\n\n// Continue until the current node is\n        // null (end of the list)\n        while (curr != null) {\n\n            // Output data of the current node\n            System.out.print(curr.data + \" \");\n\n// Move to the next node\n            curr = curr.next;\n}\n\n        // Print newline after traversal\n        System.out.println();\n}\n\n    // Function to traverse the doubly linked list\n  \t//in backward direction\n    static void backwardTraversal(Node tail) {\n\n        // Start traversal from the tail of the list\n        Node curr = tail;\n\n// Continue until the current node is\n        // null (end of the list)\n        while (curr != null) {\n\n            // Output data of the current node\n            System.out.print(curr.data + \" \");\n\n// Move to the previous node\n            curr = curr.prev;\n}\n\n        // Print newline after traversal\n        System.out.println();\n}\n\n    public static void main(String[] args) {\n\n        // Sample usage of the doubly linked\n        // list and traversal functions\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.next = second;\nsecond.prev = head;\nsecond.next = third;\n        third.prev = second;\n\n        System.out.println(\"Forward Traversal:\");\n        forwardTraversal(head);\n\n        System.out.println(\"Backward Traversal:\");\n        backwardTraversal(third);\n}\n}\n\n````\n\nPython\n````\n# Define the Node class\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n# Function to traverse the doubly linked list\n# in forward direction\ndef forward_traversal(head):\n\n    # Start traversal from the head of the list\n    curr = head\n\n    # Continue until the current node is\n    # null (end of the list)\n    while curr is not None:\n\n        # Output data of the current node\n        print(curr.data, end=\" \")\n\n        # Move to the next node\n        curr = curr.next\n\n    # Print newline after traversal\n    print()\n\n# Function to traverse the doubly linked\n# list in backward direction\ndef backward_traversal(tail):\n\n    # Start traversal from the tail of the list\n    curr = tail\n\n    # Continue until the current node\n    # is null (end of the list)\n    while curr is not None:\n\n        # Output data of the current node\n        print(curr.data, end=\" \")\n\n        # Move to the previous node\n        curr = curr.prev\n\n    # Print newline after traversal\n    print()\n\n# Sample usage of the doubly linked list\n# and traversal functions\nif __name__ == \"__main__\":\n\n    # Create a doubly linked list with 3 nodes\n    head = Node(1)\n    second = Node(2)\n    third = Node(3)\n\n    head.next = second\n    second.prev = head\n    second.next = third\n    third.prev = second\n\n    print(\"Forward Traversal:\")\n    forward_traversal(head)\n\n    print(\"Backward Traversal:\")\n    backward_traversal(third)\n\n````\n\nC#\n````\nusing System;\n\n// Define the Node class\nclass Node\n{\n    public int Data; // Data stored in the node\n    public Node Next; // Pointer to the next node\n    public Node Prev; // Pointer to the previous node\n\n    // Constructor to initialize the node with data\n    public Node(int data)\n    {\n        Data = data;\nNext = null;\n        Prev = null;\n}\n}\n\n// Class to manage the doubly linked list\nclass GfG\n{\n    // Function to traverse the doubly linked list\n  \t//in forward direction\n    static void ForwardTraversal(Node head)\n    {\n        // Start traversal from the head of the list\n        Node curr = head;\n\n// Continue until the current node is null\n      \t//(end of the list)\n        while (curr != null)\n        {\n            // Output data of the current node\n            Console.Write(curr.Data + \" \");\n\n// Move to the next node\n            curr = curr.Next;\n}\n\n        // Print newline after traversal\n        Console.WriteLine();\n}\n\n    // Function to traverse the doubly linked list\n  \t//in backward direction\n    static void BackwardTraversal(Node tail)\n    {\n        // Start traversal from the tail of the list\n        Node curr = tail;\n\n// Continue until the current node is null\n      \t//(end of the list)\n        while (curr != null)\n        {\n            // Output data of the current node\n            Console.Write(curr.Data + \" \");\n\n// Move to the previous node\n            curr = curr.Prev;\n}\n\n        // Print newline after traversal\n        Console.WriteLine();\n}\n\n    public static void Main()\n    {\n        // Sample usage of the doubly linked list\n      \t//and traversal functions\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.Next = second;\nsecond.Prev = head;\nsecond.Next = third;\n        third.Prev = second;\n\n        Console.WriteLine(\"Forward Traversal:\");\n        ForwardTraversal(head);\n\n        Console.WriteLine(\"Backward Traversal:\");\n        BackwardTraversal(third);\n}\n}\n\n````\n\nJavaScript\n````\n// Define the Node class\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n}\n}\n\n// Function to traverse the doubly linked list\n// in forward direction\nfunction forwardTraversal(head) {\n\n    // Start traversal from the head of the list\n    let curr = head;\n\n// Continue until the current node is null\n    // (end of the list)\n    while (curr !== null) {\n\n        // Output data of the current node\n        console.log(curr.data + \" \");\n\n// Move to the next node\n        curr = curr.next;\n}\n\n    // Print newline after traversal\n    console.log();\n}\n\n// Function to traverse the doubly linked list\n// in backward direction\nfunction backwardTraversal(tail) {\n\n    // Start traversal from the tail of the list\n    let curr = tail;\n\n// Continue until the current node is null\n    // (end of the list)\n    while (curr !== null) {\n\n        // Output data of the current node\n        console.log(curr.data + \" \");\n\n// Move to the previous node\n        curr = curr.prev;\n}\n\n    // Print newline after traversal\n    console.log();\n}\n\n// Sample usage of the doubly linked list\n//and traversal functions\n// Create a doubly linked list with 3 nodes\nconst head = new Node(1);\nconst second = new Node(2);\nconst third = new Node(3);\n\nhead.next = second;\nsecond.prev = head;\nsecond.next = third;\nthird.prev = second;\n\nconsole.log(\"Forward Traversal:\");\nforwardTraversal(head);\n\nconsole.log(\"Backward Traversal:\");\nbackwardTraversal(third);\n\n````\n\n\n\n**Output**\n```\n\nForward Traversal:\n1 2 3\nBackward Traversal:\n3 2 1\n\n```\n\n[Finding Length of Doubly Linked List](https://www.geeksforgeeks.org/program-find-size-doubly-linked-list/)\n-----------------------------------------------------------------------------------------------------------\n\nTo find the length of doubly list, we can use the following\nsteps:\n\n* Start at the head of the list.\n* Traverse through the list, counting each node visited.\n* Return the total count of nodes as the length of the list.\n\nBelow are the implementation of the above approach:\n\nC++\n````\n#include <iostream>\n\nusing namespace std;\n\n// Node structure for doubly linked list\nstruct Node {\n    int data;\n    Node * prev;\n    Node * next;\n\n    Node(int val) {\n        data = val;\n        prev = next = nullptr;\n}\n};\n\n// Function to find the length of a doubly\n//linked list\nint findLength(Node * head) {\n    int count = 0;\nfor (Node * cur = head; cur != nullptr; cur = cur -> next)\n        count++;\nreturn count;\n}\n\nint main() {\n\n    // Create a DLL with 3 nodes\n    Node * head = new Node(1);\n    Node * second = new Node(2);\n    Node * third = new Node(3);\n    head -> next = second;\nsecond -> prev = head;\nsecond -> next = third;\n    third -> prev = second;\n\n    cout << \"Length of the doubly linked list: \" <<\n        findLength(head) << endl;\n\nreturn 0;\n}\n\n````\n\nC\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Node structure for doubly linked list\nstruct Node {\n    int data; // Data stored in the node\n    struct Node* prev; // Pointer to the previous node\n    struct Node* next; // Pointer to the next node\n};\n\n// Constructor function to create a new node\nstruct Node* createNode(int val) {\n    struct Node* newNode =\n         (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = val;\n    newNode->prev = NULL;\n    newNode->next = NULL;\nreturn newNode;\n}\n\n// Function to find the length of a doubly linked list\nint findLength(struct Node* head) {\n    int count = 0;\nfor (struct Node* cur = head; cur != NULL; cur = cur->next)\n        count++;\nreturn count;\n}\n\nint main() {\n    // Create a DLL with 3 nodes\n    struct Node* head = createNode(1);\n    struct Node* second = createNode(2);\n    struct Node* third = createNode(3);\n\n    head->next = second;\nsecond->prev = head;\nsecond->next = third;\n    third->prev = second;\n\n    printf(\"Length of the doubly linked list: %d\\n\",\n           findLength(head));\n\nreturn 0;\n}\n\n````\n\nJava\n````\nclass Node {\n    int data;\n    Node prev;\n    Node next;\n\n// Constructor\n    public Node(int val) {\n        data = val;\n        prev = null;\nnext = null;\n}\n}\n\nclass GfG {\n\n    // Function to find the length of\n    // a doubly linked list\n    static int FindLength(Node head) {\n        int count = 0;\nfor (Node cur = head; cur != null; cur = cur.next)\n            count++;\nreturn count;\n}\n\n    // Driver code\n    public static void main(String[] args) {\n\n        // Create a doubly linked list\n        // with 3 nodes\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.next = second;\nsecond.prev = head;\nsecond.next = third;\n        third.prev = second;\n\n        System.out.println(\"Length of doubly linked list: \"\n                           + FindLength(head));\n}\n}\n\n````\n\nPython\n````\nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.prev = None\n        self.next = None\n\n# Function to find the length of\n# a doubly linked list\ndef find_length(head):\n    count = 0\n    cur = head\n    while cur is not None:\n        count += 1\n        cur = cur.next\n    return count\n\n# Driver code\nif __name__ == \"__main__\":\n\n    # Create a doubly linked list\n    # with 3 nodes\n    head = Node(1)\n    second = Node(2)\n    third = Node(3)\n\n    head.next = second\n    second.prev = head\n    second.next = third\n    third.prev = second\n\n    print(\"Length of the doubly linked list: \" +\n          str(find_length(head)))\n\n````\n\nC#\n````\nusing System;\n\nclass Node {\n    public int data;\npublic Node prev;\npublic Node next;\n\n// Constructor\n    public Node(int val) {\n        data = val;\n        prev = null;\nnext = null;\n}\n}\n\npublic class GfG {\n\n    // Function to find the length of\n    // a doubly linked list\n    static int FindLength(Node head) {\n        int count = 0;\nfor (Node cur = head; cur != null; cur = cur.next)\n            count++;\nreturn count;\n}\n\n    // Driver code\n    public static void Main(string[] args) {\n\n        // Create a doubly linked list\n        // with 3 nodes\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.next = second;\nsecond.prev = head;\nsecond.next = third;\n        third.prev = second;\n\n        Console.WriteLine(\"Length of doubly linked list: \"\n                                 + FindLength(head));\n}\n}\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(val) {\n        this.data = val;\n        this.prev = null;\n        this.next = null;\n}\n}\n\n// Function to find the length of\n// a doubly linked list\nfunction findLength(head) {\n    let count = 0;\n    let cur = head;\n    while (cur !== null) {\n        count++;\n        cur = cur.next;\n}\n    return count;\n}\n\n// Create a doubly linked list with 3 nodes\nconst head = new Node(1);\nconst second = new Node(2);\nconst third = new Node(3);\n\nhead.next = second;\nsecond.prev = head;\nsecond.next = third;\nthird.prev = second;\n\nconsole.log(\"Length of the doubly linked list: \" +\n            findLength(head));\n\n````\n\n\n\n\n\n**Output**\n```\n\nLength of the doubly linked list: 3\n\n```\n\n[Insertion at the Beginning in Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-frontbeginning-of-doubly-linked-list/)\n----------------------------------------------------------------------------------------------------------------------------------------\n\n![Insertion-at-the-Beginning-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809123903/Insertion-at-the-Beginning-in-Doubly-Linked-List.webp)\n\nInsertion at the Beginning in Doubly Linked List\n\n\nTo insert a new node at the beginning of the doubly list, we can use\nthe following steps:\n\n* Create a new node, say ****new\\_node****with the given data and set its previous pointer to null, ****new\\_node->prev =**** ****NULL****.\n* Set the next pointer of new\\_node to current head, ****new\\_node->next = head.****\n* If the linked list is not empty, update the previous pointer of the\n                                                                                                                                                                                                                current head to new\\_node, ****head->prev = new\\_node****.\n                                                                                                                                                                                                                * Return new\\_node as the head of the updated linked list.\n\n                                                                                                                                                                                                                Below are the implementation of the above approach:\n\n                                                                                                                                                                                                                C++\n                                                                                                                                                                                                                ````\n                                                                                                                                                                                                                // C++ Program to insert a new node at the\n                                   // beginning of doubly linked list\n\n                                   #include <iostream>\n                                   using namespace std;\n\n// Node structure for the doubly linked list\nstruct Node {\n    int data;\n    Node* prev;\n    Node* next;\n\n    Node(int d) {\n      data = d;\n      prev = next = NULL;\n}\n};\n\n// Insert a node at the beginning\nNode* insertBegin(Node* head, int data) {\n\n    // Create a new node\n    Node* new_node = new Node(data);\n\n// Make next of it as head\n    new_node->next = head;\n\n// Set previous of head as new node\n    if (head != NULL) {\n        head->prev = new_node;\n}\n\n    // Return new node as new head\n    return new_node;\n}\n\nvoid printList(Node* head) {\n    Node* curr = head;\n    while (curr != NULL) {\n        cout << curr->data << \" \";\n        curr = curr->next;\n}\n  \tcout << \"\\n\";\n}\n\nint main() {\n\n    // Create a hardcoded linked list:\n  \t// 2 <-> 3 <-> 4\n    Node* head = new Node(2);\n    Node* temp1 = new Node(3);\n    Node* temp2 = new Node(4);\n    head->next = temp1;\n    temp1->prev = head;\n    temp1->next = temp2;\n    temp2->prev = temp1;\n\n// Print the original list\n    cout << \"Original Linked List: \";\n    printList(head);\n\n// Insert a new node at the front of the list\n    head = insertBegin(head, 1);\n\n// Print the updated list\n  \tcout << \"After inserting Node 1 at the front: \";\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nC\n````\n// C Program to insert a node at the beginning\n//of doubly linked list\n\n\n#include <stdio.h>\n\n// Node structure for the doubly linked list\nstruct Node {\n    int data;\n    struct Node* prev;\n    struct Node* next;\n};\n\n// Create a new node\nstruct Node* createNode(int data) {\n    struct Node* new_node =\n      (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = data;\n    new_node->prev = NULL;\n    new_node->next = NULL;\nreturn new_node;\n}\n\n// Insert a node at the beginning\nstruct Node* insertBegin(struct Node* head, int data) {\n\n    // Create a new node\n    struct Node* new_node = createNode(data);\n\n// Make next of it as head\n    new_node->next = head;\n\n// Set previous of head as new node\n    if (head != NULL) {\n        head->prev = new_node;\n}\n\n    // Return new node as new head\n    return new_node;\n}\n\n// Print the doubly linked list\nvoid printList(struct Node* head) {\n    struct Node* curr = head;\n    while (curr != NULL) {\n        printf(\"%d \", curr->data);\n        curr = curr->next;\n}\n  \tprintf(\"\\n\");\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 2 <-> 3 <-> 4\n    struct Node *head = createNode(2);\n    head->next = createNode(3);\n    head->next->prev = head;\n    head->next->next = createNode(4);\n    head->next->next->prev = head->next;\n\n// Print the original list\n    printf(\"Original Linked List: \");\n    printList(head);\n\n// Insert a new node at the front of the list\n    head = insertBegin(head, 1);\n\n// Print the updated list\n  \tprintf(\"After inserting Node 1 at the front: \");\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nJava\n````\n// Java Program to insert a node at the beginning of a\n// doubly linked list\n\nclass Node {\n    int data;\n    Node prev, next;\n\n// Node structure for the doubly linked list\n    Node(int d) {\n        data = d;\n        prev = null;\nnext = null;\n}\n}\n\nclass GfG {\n\n    // Insert a node at the beginning\n    static Node insertBegin(Node head, int data) {\n\n        // Create a new node\n        Node new_node = new Node(data);\n\n// Make next of it as head\n        new_node.next = head;\n\n// Set previous of head as new node\n        if (head != null) {\n            head.prev = new_node;\n}\n\n        // Return new node as new head\n        return new_node;\n}\n\n    // Print the doubly linked list\n    static void printList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            System.out.print(curr.data + \" \");\n            curr = curr.next;\n}\n      \tSystem.out.println();\n}\n\n    public static void main(String[] args) {\n\n        // Create a hardcoded doubly linked list:\n        // 2 <-> 3 <-> 4\n        Node head = new Node(2);\n        head.next = new Node(3);\n        head.next.prev = head;\n        head.next.next = new Node(4);\n        head.next.next.prev = head.next;\n\n// Print the original list\n        System.out.print(\"Original Linked List: \");\n        printList(head);\n\n// Insert a new node at the front of the list\n        head = insertBegin(head, 1);\n\n// Print the updated list\n      \tSystem.out.print(\n            \"After inserting Node 1 at the front: \");\n        printList(head);\n}\n}\n\n````\n\nPython\n````\n# Python Program to insert a node at the beginning\n#of doubly linked list\n\n# Node structure for the doubly linked list\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n# Insert a node at the beginning\ndef insertBegin(head, data):\n\n    # Create a new node\n    new_node = Node(data)\n\n    # Make next of it as head\n    new_node.next = head\n\n    # Set previous of head as new node\n    if head is not None:\n        head.prev = new_node\n\n    # Return new node as new head\n    return new_node\n\n# Print the doubly linked list\ndef printList(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\" \")\n        curr = curr.next\n    print()\n\nif __name__ == \"__main__\":\n\n    # Create a hardcoded doubly linked list:\n    # 2 <-> 3 <-> 4\n    head = Node(2)\n    head.next = Node(3)\n    head.next.prev = head\n    head.next.next = Node(4)\n    head.next.next.prev = head.next\n\n    # Print the original list\n    print(\"Original Linked List:\", end=' ')\n    printList(head)\n\n    # Insert a new node at the front of the list\n    head = insertBegin(head, 1)\n\n    # Print the updated list\n    print(\"After inserting Node 1 at the front:\", end=' ')\n    printList(head)\n\n````\n\nC#\n````\n// C# Program to insert a node at the beginning of a\n// doubly linked list\n\nusing System;\n\n// Node structure for the doubly linked list\nclass Node {\n    public int data;\npublic Node prev, next;\n\n// Constructor for creating a new node\n    public Node(int d) {\n        data = d;\n        prev = null;\nnext = null;\n}\n}\n\nclass GfG {\n\n    // Insert a node at the beginning\n    public static\n    Node insertBegin(Node head, int data) {\n\n        // Create a new node\n        Node new_node = new Node(data);\n\n// Make next of it as head\n        new_node.next = head;\n\n// Set previous of head as new node\n        if (head != null) {\n            head.prev = new_node;\n}\n\n        // Return new node as new head\n        return new_node;\n}\n\n    // Print the doubly linked list\n    public static void printList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            Console.Write(curr.data + \" \");\n            curr = curr.next;\n}\n      \tConsole.WriteLine();\n}\n\n    public static void Main(string[] args) {\n\n        // Create a hardcoded doubly linked list:\n        // 2 <-> 3 <-> 4\n        Node head = new Node(2);\n        head.next = new Node(3);\n        head.next.prev = head;\n        head.next.next = new Node(4);\n        head.next.next.prev = head.next;\n\n// Print the original list\n        Console.Write(\"Original Linked List: \");\n        printList(head);\n\n// Insert a new node at the front of the list\n        head = insertBegin(head, 1);\n\n// Print the updated list\n      \tConsole.Write\n        (\"After inserting Node 1 at the front: \");\n        printList(head);\n}\n}\n\n````\n\nJavaScript\n````\n// JavaScript Program to insert a node at the\n//beginning of doubly linked list\n\n// Node structure for the doubly linked list\nfunction Node(data) {\n    this.data = data;\n    this.prev = null;\n    this.next = null;\n}\n\n// Insert a node at the beginning\nfunction insertBegin(head, data) {\n\n    // Create a new node\n    const new_node = new Node(data);\n\n// Make next of it as head\n    new_node.next = head;\n\n// Set previous of head as new node\n    if (head !== null) {\n        head.prev = new_node;\n}\n\n    // Return new node as new head\n    return new_node;\n}\n\n// Print the doubly linked list\nfunction printList(head) {\n    let curr = head;\n    while (curr !== null) {\n        console.log(curr.data);\n        curr = curr.next;\n}\n}\n\n// Create a hardcoded doubly linked list:\n// 2 <-> 3 <-> 4\nlet head = new Node(2);\nhead.next = new Node(3);\nhead.next.prev = head;\nhead.next.next = new Node(4);\nhead.next.next.prev = head.next;\n\n// Print the original list\nconsole.log(\"Original Linked List:\");\nprintList(head);\n\n// Insert a new node at the front of the list\nconsole.log\n(\"After inserting Node 1 at the front:\");\nlet data = 1;\nhead = insertBegin(head, data);\n\n// Print the updated list\nprintList(head);\n\n````\n\n\n\n\n\n\n\n\n**Output**\n```\n\nOriginal Linked List: 2 3 4\nAfter inserting Node 1 at the front: 1 2 3 4\n\n```\n\n[Insertion at the End of Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-the-end-of-doubly-linked-list/)\n---------------------------------------------------------------------------------------------------------------------------\n\n![Insertion-at-the-End-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809123955/Insertion-at-the-End-in-Doubly-Linked-List.webp)\n\nInsertion at the End in the Doubly Linked List\n\n\nTo insert a new node at the end of the doubly linked list, we can use\nthe following steps:\n\n* Allocate memory for a new node and assign the provided value to its\n  data field.\n* Initialize the next pointer of the new node to nullptr.\n* If the list is empty:\n  + Set the previous pointer of the new node to nullptr.\n  + Update the head pointer to point to the new node.\n                                                                                          * If the list is not empty:\n                                                                                          + Traverse the list starting from the head to reach the last\n                                                                                          node.\n                                                                                          + Set the next pointer of the last node to point to the new\n                                                                                          node.\n                                                                                          + Set the previous pointer of the new node to point to the last\n                                                                                          node.\n\n                                                                                          Below are the implementation of the above approach:\n\n                                                                                          C++\n                                                                                          ````\n                                                                                          // C++ Program to insert a node at the end of\n//doubly linked list\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node *next, *prev;\n\n    Node(int new_data) {\n        data = new_data;\nnext = prev = nullptr;\n}\n};\n\n// Function to insert a new node at the end of\n//doubly linked list\nNode *insertEnd(Node *head, int new_data) {\n\n    // Create a new node\n    Node *new_node = new Node(new_data);\n\n// If the linked list is empty, set the new\n  \t//node as the head of linked list\n    if (head == NULL) {\n        head = new_node;\n}\n    else {\n          Node *curr = head;\n        while (curr->next != NULL) {\n            curr = curr->next;\n}\n\n        // Set the next of last node to new node\n        curr->next = new_node;\n\n// Set prev of new node to last node\n        new_node->prev = curr;\n}\n\n    // Return the head of the doubly linked list\n    return head;\n}\n\nvoid printList(Node *head) {\n    Node *curr = head;\n    while (curr != NULL) {\n        cout << curr->data << \" \";\n        curr = curr->next;\n}\n    cout << endl;\n}\n\nint main() {\n\n    // Create a harcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->prev = head;\n    head->next->next = new Node(3);\n    head->next->next->prev = head->next;\n\n// Print the original list\n    cout << \"Original Linked List: \";\n    printList(head);\n\n// Insert a new node with data 4 at the end\n    cout << \"Inserting Node with data 4 at the end: \";\nint data = 4;\n    head = insertEnd(head, data);\n\n// Print the updated list\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nC\n````\n// C Program to insert a node at the end of\n//doubly linked list\n\n#include <stdio.h>\n\nstruct Node {\n    int data;\n    struct Node *next;\n    struct Node *prev;\n};\n\n// Function to create a new node with the given data\nstruct Node *createNode(int new_data) {\n    struct Node *new_node =\n    (struct Node *)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\nreturn new_node;\n}\n\n// Function to insert a new node at the end of the\n//doubly linked list\nstruct Node* insertEnd(struct Node *head, int new_data) {\n    struct Node *new_node = createNode(new_data);\n\n// If the linked list is empty, set the\n \t//new node as the head\n    if (head == NULL) {\n        head = new_node;\n} else {\n        struct Node *curr = head;\n        while (curr->next != NULL) {\n            curr = curr->next;\n}\n\n        // Set the next of last node to new node\n        curr->next = new_node;\n// Set prev of new node to last node\n        new_node->prev = curr;\n}\n\n    return head;\n}\n\nvoid printList(struct Node *head) {\n    struct Node *curr = head;\n    while (curr != NULL) {\n        printf(\"%d \", curr->data);\n        curr = curr->next;\n}\n    printf(\"\\n\");\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->prev = head;\n    head->next->next = createNode(3);\n    head->next->next->prev = head->next;\n\n// Print the original list\n    printf(\"Original Linked List: \");\n    printList(head);\n\n// Insert a new node with data 4 at the end\n    printf(\"Inserting Node with data 4 at the end: \");\n    head = insertEnd(head, 4);\n\n// Print the updated list\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nJava\n````\n// Java Program to insert a node at the end of\n// doubly linked list\n\nclass Node {\n    int data;\n    Node next, prev;\n\n    Node(int newData) {\n        data = newData;\nnext = prev = null;\n}\n}\n\nclass GFG {\n\n    // Function to insert a new node at the end of the\n    // doubly linked list\n    public static Node insertEnd(Node head, int newData) {\n\n        // Create a new node\n        Node newNode = new Node(newData);\n\n// If the linked list is empty, set the new node as\n        // the head\n        if (head == null) {\n            head = newNode;\n}\n        else {\n            Node curr = head;\n            while (curr.next != null) {\n                curr = curr.next;\n}\n\n            // Set the next of last node to the new node\n            curr.next = newNode;\n\n// Set the prev of new node to the last node\n            newNode.prev = curr;\n}\n\n        return head;\n}\n\n    // Function to print the doubly linked list\n    public static void printList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            System.out.print(curr.data + \" \");\n            curr = curr.next;\n}\n        System.out.println();\n}\n\n    public static void main(String[] args) {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.prev = head;\n        head.next.next = new Node(3);\n        head.next.next.prev = head.next;\n\n// Print the original list\n        System.out.println(\"Original Linked List: \");\n        printList(head);\n\n// Insert a new node with data 4 at the end\n        System.out.println(\n            \"Inserting Node with data 4 at the end: \");\nint data = 4;\n        head = insertEnd(head, data);\n\n// Print the updated list\n        printList(head);\n}\n}\n\n````\n\nPython\n````\n# Python Program to insert a node at the end of\n#doubly linked list\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\n# Function to insert a new node at the end of the\n#doubly linked list\ndef insert_end(head, new_data):\n\n    # Create a new node\n    new_node = Node(new_data)\n\n    # If the linked list is empty, set the new node\n    #as the head\n    if head is None:\n        head = new_node\n    else:\n        curr = head\n        while curr.next is not None:\n            curr = curr.next\n\n        # Set the next of the last node to the new node\n        curr.next = new_node\n\n        # Set the prev of the new node to the last node\n        new_node.prev = curr\n\n    return head\n\ndef print_list(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\" \")\n        curr = curr.next\n    print()\n\nif __name__ == \"__main__\":\n\n    # Create a hardcoded doubly linked list:\n    # 1 <-> 2 <-> 3\n    head = Node(1)\n    head.next = Node(2)\n    head.next.prev = head\n    head.next.next = Node(3)\n    head.next.next.prev = head.next\n\n    # Print the original list\n    print(\"Original Linked List: \", end=\"\")\n    print_list(head)\n\n    # Insert a new node with data 4 at the end\n    print(\"Inserting Node with data 4 at the end: \", end=\"\")\n    data = 4\n    head = insert_end(head, data)\n\n    # Print the updated list\n    print_list(head)\n\n````\n\nC#\n````\n// C# Program to insert a node at the end of\n//doubly linked list\n\nusing System;\n\nclass Node {\n    public int Data;\npublic Node Next;\npublic Node Prev;\n\npublic Node(int data) {\n        Data = data;\nNext = null;\n        Prev = null;\n}\n}\n\nclass GFG {\n\n    // Function to insert a new node at the end\n  \t//of the doubly linked list\n    public static Node InsertEnd(Node head, int newData) {\n\n          // Create a new node\n        Node newNode = new Node(newData);\n\n// If the linked list is empty, set the\n      \t//new node as the head\n        if (head == null) {\n            head = newNode;\n}\n        else {\n            Node curr = head;\n            while (curr.Next != null) {\n                curr = curr.Next;\n}\n\n            // Set the next of the last node to\n          \t//the new node\n            curr.Next = newNode;\n\n// Set the prev of the new node to\n          \t//the last node\n            newNode.Prev = curr;\n}\n\n        return head;\n}\n\n    // Function to print the doubly linked list\n    public static void PrintList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            Console.Write(curr.Data + \" \");\n            curr = curr.Next;\n}\n        Console.WriteLine();\n}\n\n    static void Main() {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.Next = new Node(2);\n        head.Next.Prev = head;\n        head.Next.Next = new Node(3);\n        head.Next.Next.Prev = head.Next;\n\n// Print the original list\n        Console.Write(\"Original Linked List: \");\n        PrintList(head);\n\n// Insert a new node with data 4 at the end\n        Console.Write(\"Inserting Node with data 4 at the end: \");\nint data = 4;\n        head = InsertEnd(head, data);\n\n// Print the updated list\n        PrintList(head);\n}\n}\n\n````\n\nJavaScript\n````\n// Javascript Program to insert a node at the end of\n//doublylinked list\n\nclass Node {\n    constructor(data)\n    {\n        this.data = data;\n        this.next = null;\n        this.prev = null;\n}\n}\n\nfunction insertEnd(head, newData) {\n\n    // Create a new node\n    const newNode = new Node(newData);\n\n// If the linked list is empty, set the\n    //new node as the head\n    if (head === null) {\n        head = newNode;\n}\n    else {\n        let curr = head;\n        while (curr.next !== null) {\n            curr = curr.next;\n}\n\n        // Set the next of the last node to the\n        //new node\n        curr.next = newNode;\n\n// Set the prev of the new node to the\n        //last node\n        newNode.prev = curr;\n}\n\n    return head;\n}\n\nfunction printList(head)\n{\n    let curr = head;\n    let result = \"\";\n    while (curr !== null) {\n        result += curr.data + \" \";\n        curr = curr.next;\n}\n    console.log(result.trim());\n}\n\n// Create a hardcoded doubly linked list:\n// 1 <-> 2 <-> 3\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.prev = head;\nhead.next.next = new Node(3);\nhead.next.next.prev = head.next;\n\n// Print the original list\nconsole.log(\"Original Linked List: \");\nprintList(head);\n\n// Insert a new node with data 4 at the end\nconsole.log(\"Inserting Node with data 4 at the end: \");\nconst data = 4;\nhead = insertEnd(head, data);\n\n// Print the updated list\nprintList(head);\n\n````\n\n\n\n\n**Output**\n```\n\nOriginal Linked List: 1 2 3\nInserting Node with data 4 at the end: 1 2 3 4\n\n```\n\n[Insertion at a Specific Position in Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-a-specific-position-in-doubly-linked-list/)\n---------------------------------------------------------------------------------------------------------------------------------------------------\n\nTo insert a node at a specific Position in doubly linked list, we can\nuse the following steps:\n\n![Insertion-at-a-Specific-Position-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124039/Insertion-at-a-Specific-Position-in-Doubly-Linked-List.webp)\n\n\nInsertion at a Specific Position in Doubly Linked List\n\n\n\nTo insert a new node at a specific position,\n\n* If position = 1, create a new node and make it the head of the linked\n  list and return it.\n* Otherwise, traverse the list to reach the node at position \u2013 1,\n  say ****curr****.\n* If the position is valid, create a new node with given data,\n  say ****new\\_node****.\n* Update the next pointer of new node to the next\n                                                                                                                                             of current node and prev pointer of new node to current\n                                                                                                                                             node, ****new\\_node->next = curr->next****and ****new\\_node->prev = curr.****\n                                                                                                                                             * Similarly, update next pointer of current node to\n                                                                                                                                                              thenew node, ****curr->next = new\\_node****.\n                                                                                                                                                              * If the new node is not the last node, update prev pointer of new\n                                                                                                                                                                                                          node\u2019s next to the new node, ****new\\_node->next->prev = new\\_node.****\n\n                                                                                                                                                                                                          Below is the implementation of the above approach:\n\n                                                                                                                                                                                                          C++\n                                                                                                                                                                                                          ````\n                                                                                                                                                                                                          // C++ Program to insert a node at a given position\n\n                                                                                                                                                                                                      #include <bits/stdc++.h>\n                                                                                                                                                                                                      using namespace std;\n\nstruct Node {\n    int data;\n    Node *next, *prev;\n\n    Node(int new_data) {\n        data = new_data;\nnext = prev = nullptr;\n}\n};\n\n// Function to insert a new node at a given position\nNode *insertAtPosition(Node *head, int pos, int new_data) {\n\n    // Create a new node\n    Node *new_node = new Node(new_data);\n\n// Insertion at the beginning\n    if (pos == 1) {\n        new_node->next = head;\n\n// If the linked list is not empty, set the prev\n      \t//of head to new node\n        if (head != NULL)\n            head->prev = new_node;\n\n// Set the new node as the head of linked list\n        head = new_node;\nreturn head;\n}\n\n    Node *curr = head;\n// Traverse the list to find the node before the\n    // insertion point\n    for (int i = 1; i < pos - 1 && curr != NULL; ++i) {\n        curr = curr->next;\n}\n\n    // If the position is out of bounds\n    if (curr == NULL) {\n        cout << \"Position is out of bounds.\" << endl;\n        delete new_node;\nreturn head;\n}\n\n    // Set the prev of new node to curr\n    new_node->prev = curr;\n\n// Set the new of new node to next of curr\n    new_node->next = curr->next;\n\n// Update the next of current node to new node\n       curr->next = new_node;\n\n// If the new node is not the last node, update prev\n                                             //of next node to new node\n                                             if (new_node->next != NULL)\n                                             new_node->next->prev = new_node;\n\n// Return the head of the doubly linked list\n    return head;\n}\n\nvoid printList(Node *head) {\n    Node *curr = head;\n    while (curr != NULL) {\n        cout << curr->data << \" \";\n        curr = curr->next;\n}\n    cout << endl;\n}\n\nint main() {\n\n    // Create a harcoded doubly linked list:\n    // 1 <-> 2 <-> 4\n    Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->prev = head;\n    head->next->next = new Node(4);\n    head->next->next->prev = head->next;\n\n// Print the original list\n    cout << \"Original Linked List: \";\n    printList(head);\n\n// Insert new node with data 3 at position 3\n    cout << \"Inserting Node with data 3 at position 3: \";\nint data = 3;\nint pos = 3;\n    head = insertAtPosition(head, pos, data);\n\n// Print the updated list\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nC\n````\n// C Program to insert a node at a given position\n\n#include <stdio.h>\n\nstruct Node {\n    int data;\n    struct Node * next;\n    struct Node * prev;\n};\n\n// Function to create a new node with the given data\nstruct Node * createNode(int new_data) {\n    struct Node * new_node =\n        (struct Node * ) malloc(sizeof(struct Node));\n    new_node -> data = new_data;\n    new_node -> next = NULL;\nreturn new_node;\n}\n\n// Function to insert a new node at a given position\nstruct Node * insertAtPosition(struct Node * head, int pos, int new_data) {\n    // Create a new node\n    struct Node * new_node = createNode(new_data);\n\n// Insertion at the beginning\n    if (pos == 1) {\n        new_node -> next = head;\n\n// If the linked list is not empty, set the\n      //prev of head to new node\n        if (head != NULL) {\n            head -> prev = new_node;\n}\n\n        // Set the new node as the head of linked list\n        head = new_node;\nreturn head;\n}\n\n    struct Node * curr = head;\n\n// Traverse the list to find the node before the insertion point\n    for (int i = 1; i < pos - 1 && curr != NULL; ++i) {\n        curr = curr -> next;\n}\n\n    // If the position is out of bounds\n    if (curr == NULL) {\n        printf(\"Position is out of bounds.\\n\");\n        free(new_node);\nreturn head;\n}\n\n    // Set the prev of new node to curr\n    new_node -> prev = curr;\n\n// Set the next of new node to next of curr\n    new_node -> next = curr -> next;\n\n// Update the next of current node to new node\n       curr -> next = new_node;\n\n// If the new node is not the last node, update\n                                             //the prev of next node to new node\n                                             if (new_node -> next != NULL) {\n                                             new_node -> next -> prev = new_node;\n}\n\n    // Return the head of the doubly linked list\n    return head;\n}\n\n// Function to print the linked list\nvoid printList(struct Node * head) {\n    struct Node * curr = head;\n    while (curr != NULL) {\n        printf(\"%d \", curr -> data);\n        curr = curr -> next;\n}\n    printf(\"\\n\");\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 4\n    struct Node * head = createNode(1);\n    head -> next = createNode(2);\n    head -> next -> prev = head;\n    head -> next -> next = createNode(4);\n    head -> next -> next -> prev = head -> next;\n\n// Print the original list\n    printf(\"Original Linked List: \");\n    printList(head);\n\n// Insert new node with data 3 at position 3\n    printf(\"Inserting Node with data 3 at position 3: \");\nint data = 3;\nint pos = 3;\n    head = insertAtPosition(head, pos, data);\n\n// Print the updated list\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nJava\n````\n// Java Program to insert a node at a given position\n\nclass Node {\n    int data;\n    Node next;\n    Node prev;\n\n    Node(int new_data) {\n        data = new_data;\nnext = prev = null;\n}\n}\n\nclass GFG {\n\n    // Function to insert a new node at a given position\n    public static Node insertAtPosition(Node head, int pos, int new_data) {\n        // Create a new node\n        Node new_node = new Node(new_data);\n\n// Insertion at the beginning\n        if (pos == 1) {\n            new_node.next = head;\n\n// If the linked list is not empty, set\n          \t//the prev of head to new node\n            if (head != null) {\n                head.prev = new_node;\n}\n\n            // Set the new node as the head of linked list\n            head = new_node;\nreturn head;\n}\n\n        Node curr = head;\n\n// Traverse the list to find the node before\n      \t//the insertion point\n        for (int i = 1; i < pos - 1 && curr != null; ++i) {\n            curr = curr.next;\n}\n\n        // If the position is out of bounds\n        if (curr == null) {\n            System.out.println(\"Position is out of bounds.\");\nreturn head;\n}\n\n        // Set the prev of new node to curr\n        new_node.prev = curr;\n\n// Set the next of new node to next of curr\n        new_node.next = curr.next;\n\n// Update the next of current node to new node\n       curr.next = new_node;\n\n// If the new node is not the last node, update\n                                             //prev of next node to new node\n                                             if (new_node.next != null) {\n                                             new_node.next.prev = new_node;\n}\n\n        // Return the head of the doubly linked list\n        return head;\n}\n\n    // Function to print the linked list\n    public static void printList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            System.out.print(curr.data + \" \");\n            curr = curr.next;\n}\n        System.out.println();\n}\n\n    public static void main(String[] args) {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 4\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.prev = head;\n        head.next.next = new Node(4);\n        head.next.next.prev = head.next;\n\n// Print the original list\n        System.out.print(\"Original Linked List: \");\n        printList(head);\n\n// Insert new node with data 3 at position 3\n        System.out.print(\"Inserting Node with data 3 at position 3: \");\nint data = 3;\nint pos = 3;\n        head = insertAtPosition(head, pos, data);\n\n// Print the updated list\n        printList(head);\n}\n}\n\n````\n\nPython\n````\n# Python Program to insert a node at a given position\n\nclass Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n        self.prev = None\n\ndef insert_at_position(head, pos, new_data):\n\n    # Create a new node\n    new_node = Node(new_data)\n\n    # Insertion at the beginning\n    if pos == 1:\n        new_node.next = head\n\n        # If the linked list is not empty, set the\n        #prev of head to new node\n        if head is not None:\n            head.prev = new_node\n\n        # Set the new node as the head of the linked list\n        head = new_node\n        return head\n\n    curr = head\n\n    # Traverse the list to find the node before the\n    #insertion point\n    for _ in range(1, pos - 1):\n        if curr is None:\n            print(\"Position is out of bounds.\")\n            return head\n        curr = curr.next\n\n    # If the position is out of bounds\n    if curr is None:\n        print(\"Position is out of bounds.\")\n        return head\n\n    # Set the prev of new node to curr\n    new_node.prev = curr\n\n    # Set the next of new node to next of curr\n    new_node.next = curr.next\n\n    # Update the next of current node to new node\n                       curr.next = new_node\n\n                       # If the new node is not the last node, update\n                                                                   #prev of next node to new node\n                                                                   if new_node.next is not None:\n                                                                   new_node.next.prev = new_node\n\n                                                                   return head\n\n                                                                   def print_list(head):\n                                                                   curr = head\n                                                                   while curr is not None:\n                                                                   print(curr.data, end=\" \")\n                                                                   curr = curr.next\n                                                                   print()\n\n                                                                   if __name__ == \"__main__\":\n\n                                                                   # Create a hardcoded doubly linked list:\n    # 1 <-> 2 <-> 4\n    head = Node(1)\n    head.next = Node(2)\n    head.next.prev = head\n    head.next.next = Node(4)\n    head.next.next.prev = head.next\n\n    # Print the original list\n    print(\"Original Linked List: \", end=\"\")\n    print_list(head)\n\n    # Insert new node with data 3 at position 3\n    print(\"Inserting Node with data 3 at position 3: \", end=\"\")\n    data = 3\n    pos = 3\n    head = insert_at_position(head, pos, data)\n\n    # Print the updated list\n    print_list(head)\n\n````\n\nC#\n````\n// C# Program to insert a node at a given position\n\nusing System;\n\nclass Node {\n    public int Data;\npublic Node Next;\npublic Node Prev;\n\npublic Node(int data) {\n        Data = data;\nNext = null;\n        Prev = null;\n}\n}\n\nclass GFG {\n\n    // Function to insert a new node at a given position\n    static Node InsertAtPosition(Node head, int pos, int newData) {\n\n        // Create a new node\n        Node newNode = new Node(newData);\n\n// Insertion at the beginning\n        if (pos == 1) {\n            newNode.Next = head;\n            if (head != null)\n                head.Prev = newNode;\n            head = newNode;\nreturn head;\n}\n\n        Node curr = head;\n\n// Traverse the list to find the node\n      \t //before the insertion point\n        for (int i = 1; i < pos - 1 && curr != null; ++i) {\n            curr = curr.Next;\n}\n\n        // If the position is out of bounds\n        if (curr == null) {\n            Console.WriteLine(\"Position is out of bounds.\");\nreturn head;\n}\n\n        // Set the prev of new node to curr\n        newNode.Prev = curr;\n\n// Set the next of new node to the next of curr\n        newNode.Next = curr.Next;\n\n// Update the next of current node to new node\n       curr.Next = newNode;\n\n// If the new node is not the last node, update\n                                             //prev of next node to new node\n                                             if (newNode.Next != null)\n                                             newNode.Next.Prev = newNode;\n\nreturn head;\n}\n\n    // Function to print the list\n    static void PrintList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            Console.Write(curr.Data + \" \");\n            curr = curr.Next;\n}\n        Console.WriteLine();\n}\n\n    static void Main() {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 4\n        Node head = new Node(1);\n        head.Next = new Node(2);\n        head.Next.Prev = head;\n        head.Next.Next = new Node(4);\n        head.Next.Next.Prev = head.Next;\n\n// Print the original list\n        Console.WriteLine(\"Original Linked List: \");\n        PrintList(head);\n\n// Insert new node with data 3 at position 3\n        Console.WriteLine(\"Inserting Node with data 3 at position 3: \");\n        head = InsertAtPosition(head, 3, 3);\n\n// Print the updated list\n        PrintList(head);\n}\n}\n\n````\n\nJavaScript\n````\n// Javascript Program to insert a node at a given position\n\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n        this.prev = null;\n}\n}\n\n// Function to insert a new node at a given position\nfunction insertAtPosition(head, pos, newData) {\n\n    // Create a new node\n    let newNode = new Node(newData);\n\n// Insertion at the beginning\n    if (pos === 1) {\n        newNode.next = head;\n        if (head !== null) {\n            head.prev = newNode;\n}\n        head = newNode;\nreturn head;\n}\n\n    let curr = head;\n\n// Traverse the list to find the node\n    //before the insertion point\n    for (let i = 1; i < pos - 1 && curr !== null; ++i) {\n        curr = curr.next;\n}\n\n    // If the position is out of bounds\n    if (curr === null) {\n        console.log(\"Position is out of bounds.\");\nreturn head;\n}\n\n    // Set the prev of new node to curr\n    newNode.prev = curr;\n\n// Set the next of new node to the next of curr\n    newNode.next = curr.next;\n\n// Update the next of current node to new node\n       curr.next = newNode;\n\n// If the new node is not the last node,\n    // update prev of next node to new node\n           if (newNode.next !== null) {\n           newNode.next.prev = newNode;\n}\n\n    return head;\n}\n\n// Function to print the list\nfunction printList(head) {\n    let curr = head;\n    while (curr !== null) {\n        console.log(curr.data + \" \");\n        curr = curr.next;\n}\n    console.log();\n}\n\n// Create a hardcoded doubly linked list:\n// 1 <-> 2 <-> 4\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.prev = head;\nhead.next.next = new Node(4);\nhead.next.next.prev = head.next;\n\n// Print the original list\nconsole.log(\"Original Linked List:\");\nprintList(head);\n\n// Insert new node with data 3 at position 3\nconsole.log(\"Inserting Node with data 3 at position 3:\");\nhead = insertAtPosition(head, 3, 3);\n\n// Print the updated list\nprintList(head);\n\n````\n\n\n\n\n\n**Output**\n```\n\nOriginal Linked List: 1 2 4\nInserting Node with data 3 at position 3: 1 2 3 4\n\n```\n\n[Deletion at the Beginning of Doubly Linked List](https://www.geeksforgeeks.org/deletion-at-beginning-removal-of-first-node-in-a-doubly-linked-list/)\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n![Deletion-at-the-Beginning-of-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124112/Deletion-at-the-Beginning-of-Doubly-Linked-List.webp)\n\nDeletion at the Beginning of Doubly Linked List\n\n\nTo delete a node at the beginning in doubly linked list, we can use the\nfollowing steps:\n\n* Check if the list is empty, there is nothing to delete. Return.\n* Store the head pointer in a variable, say ****temp****.\n* Update the head of linked list to the node next to the current head, ****head = head->next****.\n                                                                        * If the new head is not NULL, update the previous pointer of new head\n                                                                                                           to NULL, ****head->prev = NULL****.\n\n                                                                                                           Below is the implementation of the above approach:\n\n                                                                                                           C++\n                                                                                                           ````\n                                                                                                           // C++ Program to delete a node from the\n// beginning of Doubly Linked List\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node{\n    int data;\n    Node *prev;\n    Node *next;\n    Node(int d) {\n      \tdata = d;\n      \tprev = next = nullptr;\n}\n};\n\n// Deletes the first node (head) of the list\n// and returns the second node as new head\nNode *delHead(Node *head) {\n\n    // If empty, return\n    if (head == nullptr)\n        return nullptr;\n\n// Store in temp for deletion later\n    Node *temp = head;\n\n// Move head to the next node\n    head = head->next;\n\n// Set prev of the new head\n    if (head != nullptr)\n        head->prev = nullptr;\n\n// Free memory and return new head\n    delete temp;\nreturn head;\n}\n\nvoid printList(Node *head) {\n    for (Node *curr = head; curr != nullptr; curr = curr->next)\n        cout << curr->data << \" \";\n    cout << endl;\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    struct Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->prev = head;\n    head->next->next = new Node(3);\n    head->next->next->prev = head->next;\n\n    printf(\"Original Linked List: \");\n    printList(head);\n\n    printf(\"After Deletion at the beginning: \");\n    head = delHead(head);\n\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nC\n````\n// C Program to delete a node from the\n// beginning of Doubly Linked List\n\n#include <stdio.h>\n\nstruct Node {\n    int data;\n    struct Node *prev;\n    struct Node *next;\n};\n\n// Function to create a new node\nstruct Node *createNode(int data) {\n    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->prev = NULL;\n    newNode->next = NULL;\nreturn newNode;\n}\n\n// Function to delete the first node (head) of the list\n// and return the second node as the new head\nstruct Node *delHead(struct Node *head) {\n    // If empty, return NULL\n    if (head == NULL)\n        return NULL;\n\n// Store in temp for deletion later\n    struct Node *temp = head;\n\n// Move head to the next node\n    head = head->next;\n\n// Set prev of the new head\n    if (head != NULL)\n        head->prev = NULL;\n\n// Free memory and return new head\n    free(temp);\nreturn head;\n}\n\nvoid printList(struct Node *head) {\n    struct Node *curr = head;\n    while (curr != NULL) {\n        printf(\"%d \", curr->data);\n        curr = curr->next;\n}\n    printf(\"\\n\");\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->prev = head;\n    head->next->next = createNode(3);\n    head->next->next->prev = head->next;\n\n    printf(\"Original Linked List: \");\n    printList(head);\n\n    printf(\"After Deletion at the beginning: \");\n    head = delHead(head);\n\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nJava\n````\n// Java Program to delete a node from the\n// beginning of Doubly Linked List\n\nclass Node {\n    int data;\n    Node prev;\n    Node next;\n\n    Node(int data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n}\n}\n\nclass GFG {\n\n    // Function to delete the first node (head) of the list\n    // and return the second node as the new head\n    public static Node delHead(Node head) {\n        // If empty, return null\n        if (head == null) {\n            return null;\n}\n\n        // Store in temp for deletion later\n        Node temp = head;\n\n// Move head to the next node\n        head = head.next;\n\n// Set prev of the new head\n        if (head != null) {\n            head.prev = null;\n}\n\n        // Return new head\n        return head;\n}\n\n    public static void printList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            System.out.print(curr.data + \" \");\n            curr = curr.next;\n}\n        System.out.println();\n}\n\n    public static void main(String[] args) {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.prev = head;\n        head.next.next = new Node(3);\n        head.next.next.prev = head.next;\n\n        System.out.print(\"Original Linked List: \");\n        printList(head);\n\n        System.out.print(\"After Deletion at the beginning: \");\n        head = delHead(head);\n\n        printList(head);\n}\n}\n\n````\n\nPython\n````\n# Python Program to delete a node from the\n# beginning of Doubly Linked List\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n# Function to delete the first node (head) of the list\n# and return the second node as the new head\ndef del_head(head):\n\n    # If empty, return None\n    if head is None:\n        return None\n\n    # Store in temp for deletion later\n    temp = head\n\n    # Move head to the next node\n    head = head.next\n\n    # Set prev of the new head\n    if head is not None:\n        head.prev = None\n\n    # Return new head\n    return head\n\ndef print_list(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\" \")\n        curr = curr.next\n    print()\n\n\nif __name__ == \"__main__\":\n\n\t# Create a hardcoded doubly linked list:\n    # 1 <-> 2 <-> 3\n    head = Node(1)\n    head.next = Node(2)\n    head.next.prev = head\n    head.next.next = Node(3)\n    head.next.next.prev = head.next\n\n    print(\"Original Linked List: \", end=\"\")\n    print_list(head)\n\n    print(\"After Deletion at the beginning: \", end=\"\")\n    head = del_head(head)\n\n    print_list(head)\n\n````\n\nC#\n````\n// C# Program to delete a node from the\n// beginning of Doubly Linked List\n\nusing System;\n\nclass Node {\n    public int Data;\npublic Node Prev;\npublic Node Next;\n\npublic Node(int data) {\n        Data = data;\n        Prev = null;\nNext = null;\n}\n}\n\nclass GFG {\n\n    // Deletes the first node (head) of the list\n    // and returns the second node as the new head\n    public static Node DelHead(Node head) {\n\n        // If empty, return null\n        if (head == null)\n            return null;\n\n// Move head to the next node\n        head = head.Next;\n\n// Set prev of the new head\n        if (head != null)\n            head.Prev = null;\n\n// Return new head\n        return head;\n}\n\n    public static void PrintList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            Console.Write(curr.Data + \" \");\n            curr = curr.Next;\n}\n        Console.WriteLine();\n}\n\n    static void Main() {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.Next = new Node(2);\n        head.Next.Prev = head;\n        head.Next.Next = new Node(3);\n        head.Next.Next.Prev = head.Next;\n\n        Console.Write(\"Original Linked List: \");\n        PrintList(head);\n\n        Console.Write(\"After Deletion at the beginning: \");\n        head = DelHead(head);\n\n        PrintList(head);\n}\n}\n\n````\n\nJavaScript\n````\n// JavaScript Program to delete a node from the\n// beginning of Doubly Linked List\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n}\n}\n\n// Deletes the first node (head) of the list and returns the second node as the new head\nfunction delHead(head) {\n    // If empty, return null\n    if (head === null) {\n        return null;\n}\n\n    // Store in temp for deletion later\n    let temp = head;\n\n// Move head to the next node\n    head = head.next;\n\n// Set prev of the new head\n    if (head !== null) {\n        head.prev = null;\n}\n\n    // Return new head\n    return head;\n}\n\n// Function to print the list\nfunction printList(head) {\n    let curr = head;\n    let output = '';\n    while (curr !== null) {\n        output += curr.data + ' ';\n        curr = curr.next;\n}\n    console.log(output.trim());\n}\n\n// Create a hardcoded doubly linked list:\n// 1 <-> 2 <-> 3\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.prev = head;\nhead.next.next = new Node(3);\nhead.next.next.prev = head.next;\n\nconsole.log(\"Original Linked List: \");\nprintList(head);\n\nconsole.log(\"After Deletion at the beginning: \");\nhead = delHead(head);\n\nprintList(head);\n\n````\n\n\n\n**Output**\n```\n\nOriginal Linked List: 1 2 3\nAfter Deletion at the beginning: 2 3\n\n```\n\n[Deletion at the End of Doubly Linked List](https://www.geeksforgeeks.org/deletion-at-end-removal-of-last-node-in-a-doubly-linked-list/)\n----------------------------------------------------------------------------------------------------------------------------------------\n\n![Deletion-at-the-End-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124140/Deletion-at-the-End-in-Doubly-Linked-List.webp)\n\nDeletion at the End in Doubly Linked List\n\n\nTo delete a node at the end in doubly linked list, we can use the\nfollowing steps:\n\n* Check if the doubly linked list is empty. If it is empty, then there\n  is nothing to delete.\n* If the list is not empty, then move to the last node of the doubly\n  linked list, say ****curr****.\n* Update the second-to-last node's next pointer to NULL, ****curr->prev->next = NULL****.\n* Free the memory allocated for the node that was deleted.\n\nBelow is the implementation of the above approach:\n\nC++\n````\n// C++ Program to delete a node from the end of\n//Doubly Linked List\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node *prev;\n    Node *next;\n    Node(int d) {\n        data = d;\n        prev = NULL;\n        next = NULL;\n    }\n};\n\n// Function to delete the last node of the doubly\n// linked list\nNode *delLast(Node *head) {\n\n    // Corner cases\n    if (head == NULL)\n        return NULL;\n    if (head->next == NULL) {\n        delete head;\n        return NULL;\n    }\n\n    // Traverse to the last node\n    Node *curr = head;\n    while (curr->next != NULL)\n        curr = curr->next;\n\n    // Update the previous node's next pointer\n                                                                                         curr->prev->next = NULL;\n\n// Delete the last node\n    delete curr;\n\n// Return the updated head\n    return head;\n}\n\nvoid printList(Node *head) {\n    Node *curr = head;\n    while (curr != NULL) {\n        cout << curr->data << \" \";\n        curr = curr->next;\n}\n    cout << endl;\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    struct Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->prev = head;\n    head->next->next = new Node(3);\n    head->next->next->prev = head->next;\n\n    printf(\"Original Linked List: \");\n    printList(head);\n\n    printf(\"After Deletion at the end: \");\n    head = delLast(head);\n\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nC\n````\n// C Program to delete a node from the end of\n//Doubly Linked List\n\n#include <stdio.h>\n\nstruct Node {\n    int data;\n    struct Node* prev;\n    struct Node* next;\n};\n\n// Function to delete the last node of the\n//doubly linked list\nstruct Node* delLast(struct Node *head) {\n\n    // Corner cases\n    if (head == NULL)\n        return NULL;\n    if (head->next == NULL) {\n        free(head);\nreturn NULL;\n}\n\n    // Traverse to the last node\n    struct Node *curr = head;\n    while (curr->next != NULL)\n        curr = curr->next;\n\n// Update the previous node's next pointer\n    curr->prev->next = NULL;\n\n    // Delete the last node\n    free(curr);\n\n    // Return the updated head\n    return head;\n}\n\n// Function to print the list\nvoid printList(struct Node *head) {\n    struct Node *curr = head;\n    while (curr != NULL) {\n        printf(\"%d \", curr->data);\n        curr = curr->next;\n    }\n    printf(\"\\n\");\n}\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node *newNode =\n      (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->prev = NULL;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->prev = head;\n    head->next->next = createNode(3);\n    head->next->next->prev = head->next;\n\n    printf(\"Original Linked List: \");\n    printList(head);\n\n    printf(\"After Deletion at the end: \");\n    head = delLast(head);\n\n    printList(head);\n\n    return 0;\n}\n\n````\n\nJava\n````\n// Java Program to delete a node from the end of\n//Doubly Linked List\n\nclass Node {\n    int data;\n    Node prev;\n    Node next;\n\n    Node(int data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n    }\n}\n\nclass GFG {\n\n    // Function to delete the last node of the\n  \t//doubly linked list\n    public static Node delLast(Node head) {\n\n        // Corner cases\n        if (head == null) {\n            return null;\n        }\n        if (head.next == null) {\n            return null;\n        }\n\n        // Traverse to the last node\n        Node curr = head;\n        while (curr.next != null) {\n            curr = curr.next;\n        }\n\n        // Update the previous node's next pointer\n       if (curr.prev != null) {\n       curr.prev.next = null;\n}\n\n        // Return the updated head\n        return head;\n}\n\n    // Function to print the list\n    public static void printList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            System.out.print(curr.data + \" \");\n            curr = curr.next;\n}\n        System.out.println();\n}\n\n    public static void main(String[] args) {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.prev = head;\n        head.next.next = new Node(3);\n        head.next.next.prev = head.next;\n\n        System.out.print(\"Original Linked List: \");\n        printList(head);\n\n        System.out.print(\"After Deletion at the end: \");\n        head = delLast(head);\n\n        printList(head);\n}\n}\n\n````\n\nPython\n````\n# Python Program to delete a node from the end of\n#Doubly Linked List\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\ndef del_last(head):\n\n    # Corner cases\n    if head is None:\n        return None\n    if head.next is None:\n        return None\n\n    # Traverse to the last node\n    curr = head\n    while curr.next is not None:\n        curr = curr.next\n\n    # Update the previous node's next pointer\n    if curr.prev is not None:\n        curr.prev.next = None\n\n    # Return the updated head\n    return head\n\ndef print_list(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\" \")\n        curr = curr.next\n    print()\n\nif __name__ == \"__main__\":\n\n    # Create a hardcoded doubly linked list:\n    # 1 <-> 2 <-> 3\n    head = Node(1)\n    head.next = Node(2)\n    head.next.prev = head\n    head.next.next = Node(3)\n    head.next.next.prev = head.next\n\n    print(\"Original Linked List: \", end=\"\")\n    print_list(head)\n\n    print(\"After Deletion at the end: \", end=\"\")\n    head = del_last(head)\n\n    print_list(head)\n\n````\n\nC#\n````\n// C# Program to delete a node from the end of\n//Doubly Linked List\n\nusing System;\n\nclass Node {\n    public int Data;\n    public Node Prev;\n    public Node Next;\n\n    public Node(int data) {\n        Data = data;\n        Prev = null;\n        Next = null;\n    }\n}\n\nclass GFG {\n\n    // Function to delete the last node of the\n  \t//doubly linked list\n    static Node DelLast(Node head) {\n\n      \t// Corner cases\n        if (head == null)\n            return null;\n        if (head.Next == null) {\n            return null;\n        }\n\n        // Traverse to the last node\n        Node curr = head;\n        while (curr.Next != null)\n            curr = curr.Next;\n\n        // Update the previous node's next pointer\n                                     if (curr.Prev != null)\n                                     curr.Prev.Next = null;\n\n// Delete the last node\n        curr = null;\n\n// Return the updated head\n        return head;\n}\n\n    // Function to print the list\n    static void PrintList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            Console.Write(curr.Data + \" \");\n            curr = curr.Next;\n}\n        Console.WriteLine();\n}\n\n    static void Main() {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.Next = new Node(2);\n        head.Next.Prev = head;\n        head.Next.Next = new Node(3);\n        head.Next.Next.Prev = head.Next;\n\n        Console.Write(\"Original Linked List: \");\n        PrintList(head);\n\n        Console.Write(\"After Deletion at the end: \");\n        head = DelLast(head);\n\n        PrintList(head);\n}\n}\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n}\n}\n\n// Function to delete the last node of the\n//doubly linked list\nfunction delLast(head) {\n    // Corner cases\n    if (head === null) return null;\n    if (head.next === null) {\n        // Only one node in the list\n        return null;\n}\n\n    // Traverse to the last node\n    let curr = head;\n    while (curr.next !== null) {\n        curr = curr.next;\n}\n\n    // Update the previous node's next pointer\n    if (curr.prev !== null) {\n        curr.prev.next = null;\n    }\n\n    // Node curr is now deleted (garbage collected in JS)\n    return head;\n}\n\n// Function to print the list\nfunction printList(head) {\n    let curr = head;\n    while (curr !== null) {\n        console.log(curr.data + \" \");\n        curr = curr.next;\n    }\n}\n\n// Create a hardcoded doubly linked list:\n// 1 <-> 2 <-> 3\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.prev = head;\nhead.next.next = new Node(3);\nhead.next.next.prev = head.next;\n\nconsole.log(\"Original Linked List:\");\nprintList(head);\n\nconsole.log(\"After Deletion at the end:\");\nhead = delLast(head);\n\nprintList(head);\n\n````\n\n\n\n\n**Output**\n```\n\nOriginal Linked List: 1 2 3\nAfter Deletion at the end: 1 2\n\n```\n\n[Deletion at a Specific Position in Doubly Linked List](https://www.geeksforgeeks.org/delete-doubly-linked-list-node-given-position)\n------------------------------------------------------------------------------------------------------------------------------------\n\n![Deletion-at-a-Specific-Position-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124205/Deletion-at-a-Specific-Position-in-Doubly-Linked-List.webp)\n\n\nDeletion at a Specific Position in Doubly Linked List\n\n\n\nTo delete a node at a specific position in doubly linked list, we can\nuse the following steps:\n\n* Traverse to the node at the specified position, say ****curr****.\n* If the position is valid, adjust the pointers to skip the node to be\n  deleted.\n  + If curr is not the head of the linked list, update the next\n    pointer of the node before curr to point to the node after curr, ****curr->prev->next = curr-next****.\n  + If curr is not the last node of the linked list, update the\n    previous pointer of the node after curr to the node before curr, ****curr->next->prev = curr->prev****.\n* Free the memory allocated for the deleted node.\n\nBelow is the implementation of the above approach:\n\nC++\n````\n// C++ Program to delete node at a specific position\n// in Doubly Linked List\n\n#include <iostream>\n\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node * prev;\n    Node * next;\n    Node(int d) {\n        data = d;\n        prev = next = NULL;\n    }\n};\n\n// Function to delete a node at a specific position\n// in the doubly linked list\nNode * delPos(Node * head, int pos) {\n\n    // If the list is empty\n    if (!head)\n        return head;\n\n    Node * curr = head;\n\n    // Traverse to the node at the given position\n    for (int i = 1; curr && i < pos; ++i) {\n        curr = curr -> next;\n    }\n\n    // If the position is out of range\n    if (!curr)\n        return head;\n\n    // Update the previous node's next pointer\n           if (curr -> prev)\n           curr -> prev -> next = curr -> next;\n\n// Update the next node's prev pointer\n    if (curr -> next)\n        curr -> next -> prev = curr -> prev;\n\n    // If the node to be deleted is the head node\n    if (head == curr)\n        head = curr -> next;\n\n    // Deallocate memory for the deleted node\n    delete curr;\n    return head;\n}\n\n// Function to print the doubly linked list\nvoid printList(Node * head) {\n    Node * curr = head;\n    while (curr != nullptr) {\n        cout << curr -> data << \" \";\n        curr = curr -> next;\n    }\n    cout << endl;\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    struct Node * head = new Node(1);\n    head -> next = new Node(2);\n    head -> next -> prev = head;\n    head -> next -> next = new Node(3);\n    head -> next -> next -> prev = head -> next;\n\n    cout << \"Original Linked List: \";\n    printList(head);\n\n    cout << \"After Deletion at the position 2: \";\n    head = delPos(head, 2);\n\n    printList(head);\n\n    return 0;\n}\n\n````\n\nC\n````\n// C Program to delete node at a specific position\n//in Doubly Linked List\n\n#include <stdio.h>\n\nstruct Node {\n    int data;\n    struct Node * prev;\n    struct Node * next;\n};\n\nstruct Node * createNode(int data) {\n    struct Node * newNode = (struct Node * )\n    malloc(sizeof(struct Node));\n    newNode -> data = data;\n    newNode -> prev = NULL;\n    newNode -> next = NULL;\n    return newNode;\n}\n\n// Function to delete a node at a specific\n//position in the doubly linked list\nstruct Node * delPos(struct Node * head, int pos) {\n\n    // If the list is empty\n    if (head == NULL)\n        return head;\n\n    struct Node * curr = head;\n\n    // Traverse to the node at the given position\n    for (int i = 1; curr && i < pos; ++i) {\n        curr = curr -> next;\n    }\n\n    // If the position is out of range\n    if (curr == NULL)\n        return head;\n\n    // Update the previous node's next pointer\n       if (curr -> prev)\n       curr -> prev -> next = curr -> next;\n\n// Update the next node's prev pointer\n    if (curr -> next)\n        curr -> next -> prev = curr -> prev;\n\n    // If the node to be deleted is the head node\n    if (head == curr)\n        head = curr -> next;\n\n    // Deallocate memory for the deleted node\n    free(curr);\n    return head;\n}\n\n// Function to print the doubly linked list\nvoid printList(struct Node * head) {\n    struct Node * curr = head;\n    while (curr != NULL) {\n        printf(\"%d \", curr -> data);\n        curr = curr -> next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    struct Node * head = createNode(1);\n    struct Node * temp1 = createNode(2);\n    struct Node * temp2 = createNode(3);\n\n    // Link the nodes together\n    head -> next = temp1;\n    temp1 -> prev = head;\n    temp1 -> next = temp2;\n    temp2 -> prev = temp1;\n\n    printf(\"Original Linked List: \");\n    printList(head);\n\n    // Delete node at position 2\n    head = delPos(head, 2);\n\n    printf(\"After Deletion at position 2: \");\n    printList(head);\n\n    return 0;\n}\n\n````\n\nJava\n````\n// Java Program to delete node at a specific position in Doubly Linked List\n\nclass Node {\n    int data;\n    Node prev;\n    Node next;\n\n    Node(int d) {\n        data = d;\n        prev = null;\n        next = null;\n    }\n}\n\nclass GFG {\n\n    // Function to delete a node at a\n  \t//specific position in the doubly linked list\n    public static Node delPos(Node head, int pos) {\n\n        // If the list is empty\n        if (head == null) {\n            return head;\n        }\n\n        Node curr = head;\n\n        // Traverse to the node at the given position\n        for (int i = 1; curr != null && i < pos; ++i) {\n            curr = curr.next;\n        }\n\n        // If the position is out of range\n        if (curr == null) {\n            return head;\n        }\n\n        // Update the previous node's next pointer\n       if (curr.prev != null) {\n       curr.prev.next = curr.next;\n}\n\n        // Update the next node's prev pointer\n        if (curr.next != null) {\n            curr.next.prev = curr.prev;\n        }\n\n        // If the node to be deleted is the head node\n        if (head == curr) {\n            head = curr.next;\n        }\n\n        // Return the updated head\n        return head;\n    }\n\n    // Function to print the doubly linked list\n    public static void printList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            System.out.print(curr.data + \" \");\n            curr = curr.next;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.prev = head;\n        head.next.next = new Node(3);\n        head.next.next.prev = head.next;\n\n        System.out.print(\"Original Linked List: \");\n        printList(head);\n\n        System.out.print(\"After Deletion at position 2: \");\n        head = delPos(head, 2);\n\n        printList(head);\n    }\n}\n\n````\n\nPython\n````\n# Python Program to delete node at a specific position\n#in Doubly Linked List\n\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n\n# Function to delete a node at a specific position\n#in the doubly linked list\ndef del_pos(head, pos):\n    # If the list is empty\n    if head is None:\n        return head\n\n    curr = head\n\n    # Traverse to the node at the given position\n    for i in range(1, pos):\n        if curr is None:\n            return head\n        curr = curr.next\n\n    # If the position is out of range\n    if curr is None:\n        return head\n\n    # Update the previous node's next pointer\n               if curr.prev is not None:\n               curr.prev.next = curr.next\n\n               # Update the next node's prev pointer\n    if curr.next is not None:\n        curr.next.prev = curr.prev\n\n    # If the node to be deleted is the head node\n    if head == curr:\n        head = curr.next\n\n    # Return the updated head\n    return head\n\n\ndef print_list(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\" \")\n        curr = curr.next\n    print()\n\n\nif __name__ == \"__main__\":\n\n    # Create a hardcoded doubly linked list:\n    # 1 <-> 2 <-> 3\n    head = Node(1)\n    head.next = Node(2)\n    head.next.prev = head\n    head.next.next = Node(3)\n    head.next.next.prev = head.next\n\n    print(\"Original Linked List: \", end=\"\")\n    print_list(head)\n\n    print(\"After Deletion at the position 2: \", end=\"\")\n    head = del_pos(head, 2)\n\n    print_list(head)\n\n````\n\nC#\n````\n// C# Program to delete node at a specific position\n//in Doubly Linked List\n\nusing System;\n\nclass Node {\n    public int Data;\n    public Node Prev;\n    public Node Next;\n\n    public Node(int data) {\n        Data = data;\n        Prev = null;\n        Next = null;\n    }\n}\n\nclass Program {\n    // Function to delete a node at a specific position\n    // in the doubly linked list\n    static Node DelPos(Node head, int pos) {\n        // If the list is empty\n        if (head == null)\n            return head;\n\n        Node curr = head;\n\n        // Traverse to the node at the given position\n        for (int i = 1; curr != null && i < pos; ++i) {\n            curr = curr.Next;\n        }\n\n        // If the position is out of range\n        if (curr == null)\n            return head;\n\n        // Update the previous node's next pointer\n                     if (curr.Prev != null)\n                     curr.Prev.Next = curr.Next;\n\n// Update the next node's prev pointer\n        if (curr.Next != null)\n            curr.Next.Prev = curr.Prev;\n\n        // If the node to be deleted is the head node\n        if (head == curr)\n            head = curr.Next;\n\n        // Deallocate memory for the deleted node\n        // In C#, garbage collection will handle this\n      \t//automatically\n\n        return head;\n    }\n\n    // Function to print the doubly linked list\n    static void PrintList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            Console.Write(curr.Data + \" \");\n            curr = curr.Next;\n        }\n        Console.WriteLine();\n    }\n\n    static void Main() {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.Next = new Node(2);\n        head.Next.Prev = head;\n        head.Next.Next = new Node(3);\n        head.Next.Next.Prev = head.Next;\n\n        Console.Write(\"Original Linked List: \");\n        PrintList(head);\n\n        Console.Write(\"After Deletion at position 2: \");\n        head = DelPos(head, 2);\n\n        PrintList(head);\n    }\n}\n\n````\n\nJavaScript\n````\nclass Node {\n\tconstructor(data) {\n\t\tthis.data = data;\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\t}\n}\n\n// Function to delete a node at a specific position\n// in the doubly linked list\nfunction delPos(head, pos) {\n\t// If the list is empty\n\tif (head === null) return head;\n\n\tlet curr = head;\n\n\t// Traverse to the node at the given position\n\tfor (let i = 1; curr && i < pos; ++i) {\n\t\tcurr = curr.next;\n\t}\n\n\t// If the position is out of range\n\tif (curr === null) return head;\n\n\t// Update the previous node's next pointer\n       if (curr.prev) {\n       curr.prev.next = curr.next;\n}\n\n\t// Update the next node's prev pointer\n\tif (curr.next) {\n\t\tcurr.next.prev = curr.prev;\n\t}\n\n\t// If the node to be deleted is the head node\n\tif (head === curr) {\n\t\thead = curr.next;\n\t}\n\n\t// Deallocate memory for the deleted node\n\t// In JavaScript, garbage collection handles\n    //this automatically\n\n\treturn head;\n}\n\n// Function to print the doubly linked list\nfunction printList(head) {\n\tlet curr = head;\n\tlet result = [];\n\twhile (curr !== null) {\n\t\tresult.push(curr.data);\n\t\tcurr = curr.next;\n\t}\n\tconsole.log(result.join(' '));\n}\n\n\n// Create a hardcoded doubly linked list:\n// 1 <-> 2 <-> 3\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.prev = head;\nhead.next.next = new Node(3);\nhead.next.next.prev = head.next;\n\nconsole.log(\"Original Linked List:\");\nprintList(head);\n\nconsole.log(\"After Deletion at the position 2:\");\nhead = delPos(head, 2);\n\nprintList(head);\n\n````\n\n\n**Output**\n```\n\nOriginal Linked List: 1 2 3\nAfter Deletion at the position 2: 1 3\n\n```\n\nAdvantages of Doubly Linked List\n--------------------------------\n\n* ****Efficient traversal in both directions:**** Doubly linked lists allow for efficient traversal of the list in both\n  directions, making it suitable for applications where frequent\n  insertions and deletions are required.\n* ****Easy insertion and deletion of nodes:**** The presence of pointers to both the previous and next nodes makes it\n  easy to insert or delete nodes from the list, without having to\n  traverse the entire list.\n* ****Can be used to implement a stack or queue:**** Doubly linked lists can be used to implement both stacks and queues,\n  which are common data structures used in programming.\n\nDisadvantages of Doubly Linked List\n-----------------------------------\n\n* ****More complex than singly linked lists:****\n  Doubly linked lists are more complex than singly linked lists, as they\n  require additional pointers for each node.\n* ****More memory overhead:**** Doubly linked lists require more memory overhead than singly linked\n  lists, as each node stores two pointers instead of one.",
        "metadata": {
            "lesson_id": "2250b823-d1c9-4781-9d3d-71a989d37c49",
            "course_id": "bd157822-862c-4b14-80e0-791fb1f7f1f6",
            "course_name": "Linked List Data Structure Guide",
            "lesson_description": "A doubly linked list is a more complex data structure than a singly linked list, but it offers several advantages. The main advantage of a doubly linked list is that it allows for efficient traversal of the list in both directions. This is because each node in the list contains a pointer to the previous node and a pointer to the next node. This allows for quick and easy insertion and deletion of nodes from the list, as well as efficient traversal of the list in both directions.",
            "course_description": "An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving."
        }
    },
    {
        "page_content": "\n[Time Complexity](https://www.geeksforgeeks.org/understanding-time-complexity-simple-examples/)\nis a concept in computer science that deals with the quantification of the amount of time taken by a set of code or\n\n[algorithm](https://www.geeksforgeeks.org/fundamentals-of-algorithms/)\nto process or run as a function of the amount of input. In other words, the time complexity is how long a program takes to process a given input. The efficiency of an algorithm depends on two parameters:\n\n\n* Time Complexity\n* Space Complexity\n\n****Time Complexity:****\nIt is defined as the number of times a particular instruction set is executed rather than the total time taken. It is because the total time taken also depends on some external factors like the compiler used, the processor\u2019s speed, etc.\n\n\n****Space Complexity:****\nIt is the total memory space required by the program for its execution.\n\n\n### Best case time complexity of different data structures for different operations\n\n### ****Worst Case time complexity of different data structures for different operations****\n\n### ****The average time complexity of different data structures for different operations****\n\n### Related Article on Time and Space Complexity:\n\n* [Time and Space Complexity of Binary Search](https://www.geeksforgeeks.org/complexity-analysis-of-binary-search/)\n* [Time and Space Complexity of Linear Search](https://www.geeksforgeeks.org/time-and-space-complexity-of-linear-search-algorithm/)\n* [Time and Space Complexity of Ternary Search](https://www.geeksforgeeks.org/time-and-space-complexity-of-ternary-search/)\n* [Time and Space Complexity of Breadth First Search (BFS)](https://www.geeksforgeeks.org/time-and-space-complexity-of-breadth-first-search-bfs/)\n* [Time and Space Complexity of Depth First Search (DFS)](https://www.geeksforgeeks.org/time-and-space-complexity-of-depth-first-search-dfs/)\n* [Time and Space Complexity of Insertion Sort](https://www.geeksforgeeks.org/time-and-space-complexity-of-insertion-sort-algorithm/)\n* [Time and Space Complexity of Selection Sort](https://www.geeksforgeeks.org/time-and-space-complexity-analysis-of-selection-sort/)\n* [Time and Space Complexity of Bubble Sort](https://www.geeksforgeeks.org/time-and-space-complexity-analysis-of-bubble-sort/)\n* [Time and Space Complexity of Quick Sort](https://www.geeksforgeeks.org/time-and-space-complexity-analysis-of-quick-sort/)\n* [Time and Space Complexity of Merge Sort](https://www.geeksforgeeks.org/time-and-space-complexity-analysis-of-merge-sort/)\n* [Time and Space complexity of Radix Sort Algorithm](https://www.geeksforgeeks.org/time-and-space-complexity-of-radix-sort-algorithm/)\n* [Time and Space Complexity of Linked List](https://www.geeksforgeeks.org/time-and-space-complexity-of-linked-list/)\n* [Time and Space Complexity of Floyd Warshall Algorithm](https://www.geeksforgeeks.org/time-and-space-complexity-of-floyd-warshall-algorithm/)\n* [Time and Space Complexity of Bellman\u2013Ford Algorithm](https://www.geeksforgeeks.org/time-and-space-complexity-of-bellman-ford-algorithm/)\n* [Time and Space Complexity of Dijkstra\u2019s Algorithm](https://www.geeksforgeeks.org/time-and-space-complexity-of-dijkstras-algorithm/)\n* [Time and Space Complexity Analysis of Prim\u2019s Algorithm](https://www.geeksforgeeks.org/time-and-space-complexity-analysis-of-prims-algorithm/)",
        "metadata": {
            "lesson_id": "c8c6920e-7046-48a4-8dbe-89905c592b0d",
            "course_id": "8ff4ea92-41f2-4d49-b230-0281874efb2d",
            "course_name": "Introduction to DSA II",
            "lesson_description": "Time Complexity: It is defined as the number of times a particular instruction set is executed rather than the total time taken. It is because the total time taken also depends on some external factors like the compiler used, the processor\u2019s speed, etc.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Representation of Stack Data Structure:\n---------------------------------------\n\n\nStack follows LIFO (Last In First Out) Principle so the element which is pushed last is popped first.\n\n\n![Stack-representation-in-Data-Structures-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180735/Stack-representation-in-Data-Structures-(1).webp)\n\n****Types of Stack:****\n-----------------------\n\n* ****Fixed Size Stack****\n  : As the name suggests, a fixed size stack has a fixed size and cannot grow or shrink dynamically. If the stack is full and an attempt is made to add an element to it, an overflow error occurs. If the stack is empty and an attempt is made to remove an element from it, an underflow error occurs.\n* ****Dynamic Size Stack****\n  : A dynamic size stack can grow or shrink dynamically. When the stack is full, it automatically increases its size to accommodate the new element, and when the stack is empty, it decreases its size. This type of stack is implemented using a linked list, as it allows for easy resizing of the stack.\n\nBasic Operations on Stack:\n--------------------------\n\n\nIn order to make manipulations in a stack, there are certain operations provided to us.\n\n\n* ****push()****\n  to insert an element into the stack\n* ****pop()****\n  to remove an element from the stack\n* ****top()****\n  Returns the top element of the stack.\n* ****isEmpty()****\n  returns true if stack is empty else false.\n* ****isFull()****\n  returns true if the stack is full else false.\n\n\nTo implement stack, we need to maintain reference to the top item.\n\n\n### ****Push Operation on Stack****\n\n\nAdds an item to the stack. If the stack is full, then it is said to be an\n\n****Overflow condition.****\n\n****Algorithm for Push Operation:****\n\n\n* Before pushing the element to the stack, we check if the stack is\n\n  ****full****\n  .\n* If the stack is full\n\n  ****(top == capacity-1)****\n  , then\n\n  ****Stack Overflows****\n  and we cannot insert the element to the stack.\n* Otherwise, we increment the value of top by 1\n\n  ****(top = top + 1)****\n  and the new value is inserted at\n\n  ****top position****\n  .\n* The elements can be pushed into the stack till we reach the\n\n  ****capacity****\n  of the stack.\n\n![Push-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180844/Push-Operation-in-Stack-(1).webp)\n### ****Pop Operation in Stack****\n\n\nRemoves an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an\n\n****Underflow condition.****\n\n****Algorithm for Pop Operation:****\n\n* Before popping the element from the stack, we check if the stack is\n\n  ****empty****\n  .\n* If the stack is empty (top == -1), then\n\n  ****Stack Underflows****\n  and we cannot remove any element from the stack.\n* Otherwise, we store the value at top, decrement the value of top by 1\n\n  ****(top = top \u2013 1)****\n  and return the stored top value.\n\n![Pop-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180943/Pop-Operation-in-Stack-(1).webp)\n### ****Top or Peek Operation on Stack****\n\n\nReturns the top element of the stack.\n\n\n****Algorithm for Top Operation:****\n\n* Before returning the top element from the stack, we check if the stack is empty.\n* If the stack is empty (top == -1), we simply print \u201cStack is empty\u201d.\n* Otherwise, we return the element stored at\n\n  ****index = top****\n  .\n\n![Top-or-Peek-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181023/Top-or-Peek-Operation-in-Stack-(1).webp)\n### ****isEmpty Operation in Stack Data Structure:****\n\n\nReturns true if the stack is empty, else false.\n\n\n****Algorithm for isEmpty Operation****\n:\n\n\n* Check for the value of\n\n  ****top****\n  in stack.\n* If\n\n  ****(top == -1)****\n  , then the stack is\n\n  ****empty****\n  so return\n\n  ****true****\n  .\n* Otherwise, the stack is not empty so return\n\n  ****false****\n  .\n\n![isEmpty-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181101/isEmpty-Operation-in-Stack-(1).webp)\n### isFull ****Operation in Stack**** ****Data Structure**** :\n\n\nReturns true if the stack is full, else false.\n\n\n****Algorithm for isFull Operation:****\n\n* Check for the value of\n\n  ****top****\n  in stack.\n* If\n\n  ****(top == capacity-1),****\n  then the stack is\n\n  ****full****\n  so return\n\n  ****true****\n  .\n* Otherwise, the stack is not full so return\n\n  ****false****\n  .\n\n![isFull-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181147/isFull-Operation-in-Stack-(1).webp)\n\nImplementation of Stack\n-----------------------\n\n\nThe basic operations that can be performed on a stack include push, pop, and peek. There are two ways to implement a stack \u2013\n\n\n* [****Implementation of Stack using Array****](https://www.geeksforgeeks.org/implement-stack-using-array/)\n* [****Implementation of Stack using Linked List****](https://www.geeksforgeeks.org/implement-a-stack-using-singly-linked-list/)\n\n",
        "metadata": {
            "lesson_id": "aa9a9fdb-517e-4bec-ad2a-32a18c54993c",
            "course_id": "8ff4ea92-41f2-4d49-b230-0281874efb2d",
            "course_name": "Introduction to DSA II",
            "lesson_description": "Stack is a linear data structure that follows LIFO (Last In First Out) Principle, the last element inserted is the first to be popped out. It means both insertion and deletion operations happen at one end only.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "What is a Hash Function?\n------------------------\n\n\nA\n\n****hash function****\nis a function that takes an input (or \u2018message\u2019) and returns a fixed-size string of bytes. The output, typically a number, is called the\n\n****hash code****\nor\n\n****hash value****\n. The main purpose of a hash function is to efficiently map data of arbitrary size to fixed-size values, which are often used as indexes in hash tables.\n\n\n### Key Properties of Hash Functions\n\n* ****Deterministic****\n  : A hash function must consistently produce the same output for the same input.\n* ****Fixed Output Size****\n  : The output of a hash function should have a fixed size, regardless of the size of the input.\n* ****Efficiency****\n  : The hash function should be able to process input quickly.\n* ****Uniformity****\n  : The hash function should distribute the hash values uniformly across the output space to avoid clustering.\n* ****Pre-image Resistance****\n  : It should be computationally infeasible to reverse the hash function, i.e., to find the original input given a hash value.\n* ****Collision Resistance****\n  : It should be difficult to find two different inputs that produce the same hash value.\n* ****Avalanche Effect****\n  : A small change in the input should produce a significantly different hash value.\n\nApplications of Hash Functions\n------------------------------\n\n* ****Hash Tables****\n  : The most common use of hash functions in DSA is in hash tables, which provide an efficient way to store and retrieve data.\n* ****Data Integrity****\n  : Hash functions are used to ensure the integrity of data by generating checksums.\n* ****Cryptography****\n  : In cryptographic applications, hash functions are used to create secure hash algorithms like SHA-256.\n* ****Data Structures****\n  : Hash functions are utilized in various data structures such as Bloom filters and hash sets.\n\nTypes of Hash Functions\n-----------------------\n\n\nThere are many hash functions that use numeric or alphanumeric keys. This article focuses on discussing different hash functions:\n\n\n1. Division Method.\n2. Multiplication Method\n3. Mid-Square Method\n4. Folding Method\n5. Cryptographic Hash Functions\n6. Universal Hashing\n7. Perfect Hashing\n\n\nLet\u2019s begin discussing these methods in detail.\n\n\n1. Division Method\n------------------\n\n\nThe division method involves dividing the key by a prime number and using the remainder as the hash value.\n\n\n> **h**\n> (\n>\n> **k**\n> )=\n>\n> **k**\n> mod\n>\n> **m**\n>\n>\n> Where\n>\n> **k**\n> is the key and \ud835\udc5a\n>\n> **m**\n> is a prime number.\n\n****Advantages****\n:\n\n\n* Simple to implement.\n* Works well when \ud835\udc5a\n\n  **m**\n  is a prime number.\n\n****Disadvantages****\n:\n\n\n* Poor distribution if \ud835\udc5a\n\n  **m**\n  is not chosen wisely.\n\n2. Multiplication Method\n------------------------\n\n\nIn the multiplication method, a constant \ud835\udc34\n\n**A**\n(0 < A < 1) is used to multiply the key. The fractional part of the product is then multiplied by \ud835\udc5a\n\n**m**\nto get the hash value.\n\n\n> **h**\n> (\n>\n> **k**\n> )=\u230a\n>\n> **m**\n> (\n>\n> **kA**\n> mod1)\u230b\n>\n>\n> Where \u230a \u230b denotes the floor function.\n\n****Advantages****\n:\n\n\n* Less sensitive to the choice of \ud835\udc5a\n\n  **m**\n  .\n\n****Disadvantages****\n:\n\n\n* More complex than the division method.\n\n3. Mid-Square Method\n--------------------\n\n\nIn the mid-square method, the key is squared, and the middle digits of the result are taken as the hash value.\n\n\n****Steps****\n:\n\n\n1. Square the key.\n2. Extract the middle digits of the squared value.\n\n****Advantages****\n:\n\n\n* Produces a good distribution of hash values.\n\n****Disadvantages****\n:\n\n\n* May require more computational effort.\n\n4. Folding Method\n-----------------\n\n\nThe folding method involves dividing the key into equal parts, summing the parts, and then taking the modulo with respect to \ud835\udc5a\n\n**m**\n.\n\n\n****Steps****\n:\n\n\n1. Divide the key into parts.\n2. Sum the parts.\n3. Take the modulo \ud835\udc5a\n\n   **m**\n   of the sum.\n\n****Advantages****\n:\n\n\n* Simple and easy to implement.\n\n****Disadvantages****\n:\n\n\n* Depends on the choice of partitioning scheme.\n\n5. Cryptographic Hash Functions\n-------------------------------\n\n\nCryptographic hash functions are designed to be secure and are used in cryptography. Examples include MD5, SHA-1, and SHA-256.\n\n\n****Characteristics****\n:\n\n\n* Pre-image resistance.\n* Second pre-image resistance.\n* Collision resistance.\n\n****Advantages****\n:\n\n\n* High security.\n\n****Disadvantages****\n:\n\n\n* Computationally intensive.\n\n6. Universal Hashing\n--------------------\n\n\nUniversal hashing uses a family of hash functions to minimize the chance of collision for any given set of inputs.\n\n\n> **h**\n> (\n>\n> **k**\n> )=((\n>\n> **a**\n> \u22c5\n>\n> **k**\n> +\n>\n> **b**\n> )mod\n>\n> **p**\n> )mod\n>\n> **m**\n>\n>\n> Where\n>\n> **a**\n> and\n>\n> **b**\n> are randomly chosen constants,\n>\n> **p**\n> is a prime number greater than\n>\n> **m**\n> , and\n>\n> **k**\n> is the key.\n\n****Advantages****\n:\n\n\n* Reduces the probability of collisions.\n\n****Disadvantages****\n:\n\n\n* Requires more computation and storage.\n\n7. Perfect Hashing\n------------------\n\n\nPerfect hashing aims to create a collision-free hash function for a static set of keys. It guarantees that no two keys will hash to the same value.\n\n\n****Types****\n:\n\n\n* Minimal Perfect Hashing: Ensures that the range of the hash function is equal to the number of keys.\n* Non-minimal Perfect Hashing: The range may be larger than the number of keys.\n\n****Advantages****\n:\n\n\n* No collisions.\n\n****Disadvantages****\n:\n\n\n* Complex to construct.\n\nConclusion\n----------\n\n\nIn conclusion, hash functions are very important tools that help store and find data quickly. Knowing the different types of hash functions and how to use them correctly is key to making software work better and more securely. By choosing the right hash function for the job, developers can greatly improve the efficiency and reliability of their systems.\n",
        "metadata": {
            "lesson_id": "22607c58-8b6f-45e8-ab9c-6da9a201ea46",
            "course_id": "8ff4ea92-41f2-4d49-b230-0281874efb2d",
            "course_name": "Introduction to DSA II",
            "lesson_description": "Hash functions are a fundamental concept in computer science and play a crucial role in various applications such as data storage, retrieval, and cryptography. In data structures and algorithms (DSA), hash functions are primarily used in hash tables, which are essential for efficient data management. This article delves into the intricacies of hash functions, their properties, and the different types of hash functions used in DSA.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "\n****What is Hash Table?****\n---------------------------\n\n\nA Hash table is defined as a data structure used to insert, look up, and remove key-value pairs quickly. It operates on the\n\n[hashing concept](https://www.geeksforgeeks.org/what-is-hashing/)\n, where each key is translated by a hash function into a distinct index in an array. The index functions as a storage location for the matching value. In simple words, it maps the keys with the value.\n\n\n![Components-of-Hashing](https://media.geeksforgeeks.org/wp-content/uploads/20240508162721/Components-of-Hashing.webp)\n\nHash Function and Table\n\nWhat is Load factor?\n--------------------\n\n\nA hash table\u2019s load factor is determined by how many elements are kept there in relation to how big the table is. The table may be cluttered and have longer search times and collisions if the load factor is high. An ideal load factor can be maintained with the use of a good hash function and proper table resizing.\n\n\nWhat is a Hash function?\n------------------------\n\n\nA Function that translates keys to array indices is known as a hash function. The keys should be evenly distributed across the array via a decent hash function to reduce collisions and ensure quick lookup speeds.\n\n\n* ****Integer universe assumption:****\n\n  The keys are assumed to be integers within a certain range according to the integer universe assumption. This enables the use of basic hashing operations like division or multiplication hashing.\n* ****Hashing by division:****\n\n  This straightforward hashing technique uses the key\u2019s remaining value after dividing it by the array\u2019s size as the index. When an array size is a prime number and the keys are evenly spaced out, it performs well.\n* ****Hashing by multiplication:****\n\n  This straightforward hashing operation multiplies the key by a constant between 0 and 1 before taking the fractional portion of the outcome. After that, the index is determined by multiplying the fractional component by the array\u2019s size. Also, it functions effectively when the keys are scattered equally.\n\n### [Choosing a hash function](https://www.geeksforgeeks.org/what-are-hash-functions-and-how-to-choose-a-good-hash-function/) :\n\n\nSelecting a decent hash function is based on the properties of the keys and the intended functionality of the hash table. Using a function that evenly distributes the keys and reduces collisions is crucial.\n\n\n****Criteria based on which a hash function is chosen:****\n\n\n* To ensure that the number of collisions is kept to a minimum, a good hash function should distribute the keys throughout the hash table in a uniform manner. This implies that for all pairings of keys, the likelihood of two keys hashing to the same position in the table should be rather constant.\n* To enable speedy hashing and key retrieval, the hash function should be computationally efficient.\n* It ought to be challenging to deduce the key from its hash value. As a result, attempts to guess the key using the hash value are less likely to succeed.\n* A hash function should be flexible enough to adjust as the data being hashed changes. For instance, the hash function needs to continue to perform properly if the keys being hashed change in size or format.\n\n### [Collision resolution techniques](https://www.geeksforgeeks.org/collision-resolution-techniques/) :\n\n\nCollisions happen when two or more keys point to the same array index. Chaining, open addressing, and double hashing are a few techniques for resolving collisions.\n\n\n![collision-in-hashing](https://media.geeksforgeeks.org/wp-content/uploads/20240514124239/collision-in-hashing.webp)\n\n\n\n\n* [****Open addressing****](https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/)\n  ****:****\n  collisions are handled by looking for the following empty space in the table. If the first slot is already taken, the hash function is applied to the subsequent slots until one is left empty. There are various ways to use this approach, including double hashing, linear probing, and quadratic probing.\n* [****Separate Chaining****](https://www.geeksforgeeks.org/separate-chaining-collision-handling-technique-in-hashing/)\n  ****:****\n  In separate chaining, a linked list of objects that hash to each slot in the hash table is present. Two keys are included in the linked list if they hash to the same slot. This method is rather simple to use and can manage several collisions.\n* ****Robin Hood hashing:****\n  To reduce the length of the chain, collisions in Robin Hood hashing are addressed by switching off keys. The algorithm compares the distance between the slot and the occupied slot of the two keys if a new key hashes to an already-occupied slot. The existing key gets swapped out with the new one if it is closer to its ideal slot. This brings the existing key closer to its ideal slot. This method has a tendency to cut down on collisions and average chain length.\n\n### Dynamic resizing:\n\n\nThis feature enables the hash table to expand or contract in response to changes in the number of elements contained in the table. This promotes a load factor that is ideal and quick lookup times.\n\n\nExample Implementation of Hash Table\n------------------------------------\n\n\nPython, Java, C++, and Ruby are just a few of the programming languages that support hash tables. They can be used as a customized data structure in addition to frequently being included in the standard library.\n\n\n****Example: hashIndex = key % noOfBuckets****\n\n\n****Insert****\n: Move to the bucket corresponding to the above-calculated hash index and insert the new node at the end of the list.\n\n\n\n****Delete****\n: To delete a node from hash table, calculate the hash index for the key, move to the bucket corresponding to the calculated hash index, and search the list in the current bucket to find and remove the node with the given key (if found).\n\n\n![](https://media.geeksforgeeks.org/wp-content/uploads/chain-hashing-1.png)\n\n\nPlease refer\n\n[****Hashing | Set 2 (Separate Chaining)****](https://www.geeksforgeeks.org/hashing-set-2-separate-chaining/)\n\nfor details.\n\n\nC++\n\n````\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Hash {\n    int BUCKET; // No. of buckets\n\n    // Vector of vectors to store the chains\n    vector<vector<int>> table;\n\n    // Inserts a key into hash table\n    void insertItem(int key) {\n        int index = hashFunction(key);\n        table[index].push_back(key);\n    }\n\n    // Deletes a key from hash table\n    void deleteItem(int key);\n\n    // Hash function to map values to key\n    int hashFunction(int x) {\n        return (x % BUCKET);\n    }\n\n    void displayHash();\n\n    // Constructor to initialize bucket count and table\n    Hash(int b) {\n        this->BUCKET = b;\n        table.resize(BUCKET);\n    }\n};\n\n// Function to delete a key from the hash table\nvoid Hash::deleteItem(int key) {\n    int index = hashFunction(key);\n\n    // Find and remove the key from the table[index] vector\n    auto it = find(table[index].begin(), table[index].end(), key);\n    if (it != table[index].end()) {\n        table[index].erase(it); // Erase the key if found\n    }\n}\n\n// Function to display the hash table\nvoid Hash::displayHash() {\n    for (int i = 0; i < BUCKET; i++) {\n        cout << i;\n        for (int x : table[i]) {\n            cout << \" --> \" << x;\n        }\n        cout << endl;\n    }\n}\n\n// Driver program\nint main() {\n    // Vector that contains keys to be mapped\n    vector<int> a = {15, 11, 27, 8, 12};\n\n    // Insert the keys into the hash table\n    Hash h(7); // 7 is the number of buckets\n    for (int key : a)\n        h.insertItem(key);\n\n    // Delete 12 from the hash table\n    h.deleteItem(12);\n\n    // Display the hash table\n    h.displayHash();\n\n    return 0;\n}\n\n````\n\nJava\n\n````\nimport java.util.ArrayList;\n\npublic class Hash {\n    // Number of buckets\n    private final int bucket;\n    // Hash table of size bucket\n    private final ArrayList<Integer>[] table;\n\n    public Hash(int bucket)\n    {\n        this.bucket = bucket;\n        this.table = new ArrayList[bucket];\n        for (int i = 0; i < bucket; i++) {\n            table[i] = new ArrayList<>();\n        }\n    }\n\n    // hash function to map values to key\n    public int hashFunction(int key)\n    {\n        return (key % bucket);\n    }\n\n    public void insertItem(int key)\n    {\n        // get the hash index of key\n        int index = hashFunction(key);\n        // insert key into hash table at that index\n        table[index].add(key);\n    }\n\n    public void deleteItem(int key)\n    {\n        // get the hash index of key\n        int index = hashFunction(key);\n\n        // Check if key is in hash table\n        if (!table[index].contains(key)) {\n            return;\n        }\n\n        // delete the key from hash table\n        table[index].remove(Integer.valueOf(key));\n    }\n\n    // function to display hash table\n    public void displayHash()\n    {\n        for (int i = 0; i < bucket; i++) {\n            System.out.print(i);\n            for (int x : table[i]) {\n                System.out.print(\" --> \" + x);\n            }\n            System.out.println();\n        }\n    }\n\n    // Drive Program\n    public static void main(String[] args)\n    {\n        // array that contains keys to be mapped\n        int[] a = { 15, 11, 27, 8, 12 };\n\n        // Create a empty has of BUCKET_SIZE\n        Hash h = new Hash(7);\n\n        // insert the keys into the hash table\n        for (int x : a) {\n            h.insertItem(x);\n        }\n\n        // delete 12 from the hash table\n        h.deleteItem(12);\n\n        // Display the hash table\n        h.displayHash();\n    }\n}\n\n````\n\nPython\n\n````\n# Python3 program to implement hashing with chaining\nBUCKET_SIZE = 7\n\n\nclass Hash(object):\n    def __init__(self, bucket):\n        # Number of buckets\n        self.__bucket = bucket\n        # Hash table of size bucket\n        self.__table = [[] for _ in range(bucket)]\n\n    # hash function to map values to key\n    def hashFunction(self, key):\n        return (key % self.__bucket)\n\n    def insertItem(self, key):\n        # get the hash index of key\n        index = self.hashFunction(key)\n        self.__table[index].append(key)\n\n    def deleteItem(self, key):\n        # get the hash index of key\n        index = self.hashFunction(key)\n\n        # Check the key in the hash table\n        if key not in self.__table[index]:\n            return\n\n        # delete the key from hash table\n        self.__table[index].remove(key)\n\n    # function to display hash table\n    def displayHash(self):\n        for i in range(self.__bucket):\n            print(\"[%d]\" % i, end='')\n            for x in self.__table[i]:\n                print(\" --> %d\" % x, end='')\n            print()\n\n\n# Drive Program\nif __name__ == \"__main__\":\n    # array that contains keys to be mapped\n    a = [15, 11, 27, 8, 12]\n\n    # Create a empty has of BUCKET_SIZE\n    h = Hash(BUCKET_SIZE)\n\n    # insert the keys into the hash table\n    for x in a:\n        h.insertItem(x)\n\n    # delete 12 from the hash table\n    h.deleteItem(x)\n    # Display the hash table\n    h.displayHash()\n\n````\n\nC#\n\n````\nusing System;\nusing System.Collections.Generic;\n\nclass Hash\n{\n    int BUCKET; // No. of buckets\n\n    // List of integers to store values\n    List<int>[] table;\n\n    public Hash(int V)\n    {\n        this.BUCKET = V;\n        table = new List<int>[BUCKET];\n        for (int i = 0; i < BUCKET; i++)\n            table[i] = new List<int>();\n    }\n\n    // Hash function to map values to key\n    int hashFunction(int x)\n    {\n        return (x % BUCKET);\n    }\n\n    // Inserts a key into the hash table\n    public void insertItem(int key)\n    {\n        int index = hashFunction(key);\n        table[index].Add(key);\n    }\n\n    // Deletes a key from the hash table\n    public void deleteItem(int key)\n    {\n        int index = hashFunction(key);\n        table[index].Remove(key);\n    }\n\n    // Displays the hash table\n    public void displayHash()\n    {\n        for (int i = 0; i < BUCKET; i++)\n        {\n            Console.Write(i + \" --> \");\n            foreach (int x in table[i])\n                Console.Write(x + \" \");\n            Console.WriteLine();\n        }\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // Array that contains keys to be mapped\n        int[] a = { 15, 11, 27, 8, 12 };\n        int n = a.Length;\n\n        // Insert the keys into the hash table\n        Hash h = new Hash(7); // 7 is the count of buckets in the hash table\n        for (int i = 0; i < n; i++)\n            h.insertItem(a[i]);\n\n        // Delete 12 from the hash table\n        h.deleteItem(12);\n\n        // Display the hash table\n        h.displayHash();\n    }\n}\n\n````\n\nJavaScript\n\n````\nclass Hash {\n    constructor(V) {\n        this.BUCKET = V; // No. of buckets\n        this.table = new Array(V); // Pointer to an array containing buckets\n        for (let i = 0; i < V; i++) {\n            this.table[i] = new Array();\n        }\n    }\n\n    // inserts a key into hash table\n    insertItem(x) {\n        const index = this.hashFunction(x);\n        this.table[index].push(x);\n    }\n\n    // deletes a key from hash table\n    deleteItem(key) {\n        // get the hash index of key\n        const index = this.hashFunction(key);\n\n        // find the key in (index)th list\n        const i = this.table[index].indexOf(key);\n\n        // if key is found in hash table, remove it\n        if (i !== -1) {\n            this.table[index].splice(i, 1);\n        }\n    }\n\n    // hash function to map values to key\n    hashFunction(x) {\n        return x % this.BUCKET;\n    }\n\n    // function to display hash table\n    displayHash() {\n        for (let i = 0; i < this.BUCKET; i++) {\n            let str = `${i}`;\n            for (let j = 0; j < this.table[i].length; j++) {\n                str += ` --> ${this.table[i][j]}`;\n            }\n            console.log(str);\n        }\n    }\n}\n\n// Driver program\nconst a = [15, 11, 27, 8, 12];\nconst n = a.length;\n\n// insert the keys into the hash table\nconst h = new Hash(7);   // 7 is count of buckets in hash table\nfor (let i = 0; i < n; i++) {\n    h.insertItem(a[i]);\n}\n\n// delete 12 from hash table\nh.deleteItem(12);\n\n// display the Hash table\nh.displayHash();\n\n````\n\n\n\n\n**Output**\n```\n0\n1 --> 15 --> 8\n2\n3\n4 --> 11\n5\n6 --> 27\n```\n\nComplexity Analysis of a Hash Table:\n------------------------------------\n\n\nFor lookup, insertion, and deletion operations, hash tables have an average-case time complexity of O(1). Yet, these operations may, in the worst case, require O(n) time, where n is the number of elements in the table.\n\n\nApplications of Hash Table:\n---------------------------\n\n* Hash tables are frequently used for indexing and searching massive volumes of data. A search engine might use a hash table to store the web pages that it has indexed.\n* Data is usually cached in memory via hash tables, enabling rapid access to frequently used information.\n* Hash functions are frequently used in cryptography to create digital signatures, validate data, and guarantee data integrity.\n* Hash tables can be used for implementing database indexes, enabling fast access to data based on key values.",
        "metadata": {
            "lesson_id": "1c6f4928-3c61-463e-8c84-f82e57915477",
            "course_id": "8ff4ea92-41f2-4d49-b230-0281874efb2d",
            "course_name": "Introduction to DSA II",
            "lesson_description": "",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "****Example:****\n\n\n> ****Input:****\n>\n>\n> {{1, 2, 3}\n>\n>\n>\n> {4, 5, 6}\n>\n>\n>\n> {7, 8, 9}}\n>\n>\n>\n> ****Output:****\n> 1 2 4 7 5 3 6 8 9\n>\n>\n> ****Input :****\n> [[1, 2, 3, 4],\n>\n>\n>\n> [5, 6, 7, 8],\n>\n>\n>\n> [9, 10, 11, 12],\n>\n>\n>\n> [13, 14, 15, 16]]\n>\n>\n>\n> ****Output::****\n> 1 2 5 9 6 3 4 7 10 13 14 11 8 12 15 16\n\n\nThis approach uses a diagonal traversal technique to print the matrix in a zig-zag pattern. It iterates through the matrix diagonally, switching between incrementing the row and column indices based on the current position. This creates a zig-zag path that covers all elements of the matrix.\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Utility function to print matrix in zig-zag form\nvoid zigZagMatrix(vector<vector<int>>& mat) {\n    int n = mat.size();\n    int m = mat[0].size();\n    int row = 0, col = 0;\n\n    // Boolean variable that is true if we need\n    // to increment 'row' value;\n    // otherwise, false if we increment 'col' value.\n    bool row_inc = 0;\n\n    // Print the first half of the zig-zag pattern\n    int mn = min(m, n);\n    for (int len = 1; len <= mn; ++len) {\n        for (int i = 0; i < len; ++i) {\n            cout << mat[row][col] << \" \";\n\n            if (i + 1 == len) break;\n\n            // If row_inc is true, increment row\n            // and decrement col;\n            // otherwise, decrement row and increment col.\n            if (row_inc) ++row, --col;\n            else --row, ++col;\n        }\n\n        if (len == mn) break;\n\n        // Update row or col value based on the\n        // last increment\n        if (row_inc) ++row, row_inc = false;\n        else ++col, row_inc = true;\n    }\n\n    // Adjust row and col for the second half of the matrix\n    if (row == 0) {\n        if (col == m - 1) ++row;\n        else ++col;\n        row_inc = 1;\n    } else {\n        if (row == n - 1) ++col;\n        else ++row;\n        row_inc = 0;\n    }\n\n    // Print the second half of the zig-zag pattern\n    int MAX = max(m, n) - 1;\n    for (int len, diag = MAX; diag > 0; --diag) {\n        len = (diag > mn) ? mn : diag;\n        for (int i = 0; i < len; ++i) {\n            cout << mat[row][col] << \" \";\n\n            if (i + 1 == len) break;\n\n            // Update row or col value based on the last increment\n            if (row_inc) ++row, --col;\n            else ++col, --row;\n        }\n\n        // Update row and col based on position in the matrix\n        if (row == 0 || col == m - 1) {\n            if (col == m - 1) ++row;\n            else ++col;\n            row_inc = true;\n        } else if (col == 0 || row == n - 1) {\n            if (row == n - 1) ++col;\n            else ++row;\n            row_inc = false;\n        }\n    }\n}\n\n// Driver code\nint main() {\n    vector<vector<int>> mat = { { 1, 2, 3 },\n                                { 4, 5, 6 },\n                                { 7, 8, 9 } };\n    zigZagMatrix(mat);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\npublic class ZigZagMatrix {\n\n    // Utility function to print matrix in zig-zag form\n    public static void zigZagMatrix(int[][] mat) {\n        int n = mat.length;\n        int m = mat[0].length;\n        int row = 0, col = 0;\n\n        // Boolean variable that is true if we need to\n        // increment 'row' value;\n        // otherwise, false if we increment 'col' value.\n        boolean rowInc = false;\n\n        // Print the first half of the zig-zag pattern\n        int minDim = Math.min(m, n);\n        for (int len = 1; len <= minDim; ++len) {\n            for (int i = 0; i < len; ++i) {\n                System.out.print(mat[row][col] + \" \");\n\n                if (i + 1 == len) break;\n\n                // If rowInc is true, increment row and decrement col;\n                // otherwise, decrement row and increment col.\n                if (rowInc) {\n                    row++;\n                    col--;\n                } else {\n                    row--;\n                    col++;\n                }\n            }\n\n            if (len == minDim) break;\n\n            // Update row or col value based on the last increment\n            if (rowInc) {\n                row++;\n                rowInc = false;\n            } else {\n                col++;\n                rowInc = true;\n            }\n        }\n\n        // Adjust row and col for the second half of the matrix\n        if (row == 0) {\n            if (col == m - 1) row++;\n            else col++;\n            rowInc = true;\n        } else {\n            if (row == n - 1) col++;\n            else row++;\n            rowInc = false;\n        }\n\n        // Print the second half of the zig-zag pattern\n        int maxDim = Math.max(m, n) - 1;\n        for (int len, diag = maxDim; diag > 0; --diag) {\n            len = (diag > minDim) ? minDim : diag;\n            for (int i = 0; i < len; ++i) {\n                System.out.print(mat[row][col] + \" \");\n\n                if (i + 1 == len) break;\n\n                // Update row or col value based on the last increment\n                if (rowInc) {\n                    row++;\n                    col--;\n                } else {\n                    col++;\n                    row--;\n                }\n            }\n\n            // Update row and col based on position in the matrix\n            if (row == 0 || col == m - 1) {\n                if (col == m - 1) row++;\n                else col++;\n                rowInc = true;\n            } else if (col == 0 || row == n - 1) {\n                if (row == n - 1) col++;\n                else row++;\n                rowInc = false;\n            }\n        }\n    }\n\n    // Driver code\n    public static void main(String[] args) {\n        int[][] mat = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n        zigZagMatrix(mat);\n    }\n}\n\n````\n\nPython\n\n````\n# Utility function to print matrix in zig-zag form\n\ndef zig_zag_matrix(mat):\n    n = len(mat)\n    m = len(mat[0])\n    row = 0\n    col = 0\n\n    # Boolean variable that is true if we need\n    # to increment 'row' value;\n    # otherwise, false if we increment 'col' value.\n    row_inc = False\n\n    # Print the first half of the zig-zag pattern\n    mn = min(m, n)\n    for length in range(1, mn + 1):\n        for i in range(length):\n            print(mat[row][col], end=' ')\n\n            if i + 1 == length:\n                break\n\n            # If row_inc is true, increment row\n            # and decrement col;\n            # otherwise, decrement row and increment col.\n            if row_inc:\n                row += 1\n                col -= 1\n            else:\n                row -= 1\n                col += 1\n\n        if length == mn:\n            break\n\n        # Update row or col value based on the\n        # last increment\n        if row_inc:\n            row += 1\n            row_inc = False\n        else:\n            col += 1\n            row_inc = True\n\n    # Adjust row and col for the second half of the matrix\n    if row == 0:\n        if col == m - 1:\n            row += 1\n        else:\n            col += 1\n        row_inc = True\n    else:\n        if row == n - 1:\n            col += 1\n        else:\n            row += 1\n        row_inc = False\n\n    # Print the second half of the zig-zag pattern\n    MAX = max(m, n) - 1\n    for diag in range(MAX, 0, -1):\n        length = mn if diag > mn else diag\n        for i in range(length):\n            print(mat[row][col], end=' ')\n\n            if i + 1 == length:\n                break\n\n            # Update row or col value based on the last increment\n            if row_inc:\n                row += 1\n                col -= 1\n            else:\n                col += 1\n                row -= 1\n\n        # Update row and col based on position in the matrix\n        if row == 0 or col == m - 1:\n            if col == m - 1:\n                row += 1\n            else:\n                col += 1\n            row_inc = True\n        elif col == 0 or row == n - 1:\n            if row == n - 1:\n                col += 1\n            else:\n                row += 1\n            row_inc = False\n\n# Driver code\nif __name__ == '__main__':\n    mat = [[1, 2, 3],\n           [4, 5, 6],\n           [7, 8, 9]]\n    zig_zag_matrix(mat)\n\n````\n\nC#\n\n````\nusing System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static void ZigZagMatrix(int[,] mat)\n    {\n        int n = mat.GetLength(0);\n        int m = mat.GetLength(1);\n        int row = 0;\n        int col = 0;\n\n        // Boolean variable that is true if we need\n        // to increment 'row' value;\n        // otherwise, false if we increment 'col' value.\n        bool rowInc = false;\n\n        // Print the first half of the zig-zag pattern\n        int mn = Math.Min(m, n);\n        for (int length = 1; length <= mn; length++)\n        {\n            for (int i = 0; i < length; i++)\n            {\n                Console.Write(mat[row, col] + \" \");\n\n                if (i + 1 == length)\n                    break;\n\n                // If rowInc is true, increment row\n                // and decrement col;\n                // otherwise, decrement row and increment col.\n                if (rowInc)\n                {\n                    row++;\n                    col--;\n                }\n                else\n                {\n                    row--;\n                    col++;\n                }\n            }\n\n            if (length == mn)\n                break;\n\n            // Update row or col value based on the\n            // last increment\n            if (rowInc)\n            {\n                row++;\n                rowInc = false;\n            }\n            else\n            {\n                col++;\n                rowInc = true;\n            }\n        }\n\n        // Adjust row and col for the second half of the matrix\n        if (row == 0)\n        {\n            if (col == m - 1)\n                row++;\n            else\n                col++;\n            rowInc = true;\n        }\n        else\n        {\n            if (row == n - 1)\n                col++;\n            else\n                row++;\n            rowInc = false;\n        }\n\n        // Print the second half of the zig-zag pattern\n        int MAX = Math.Max(m, n) - 1;\n        for (int diag = MAX; diag > 0; diag--)\n        {\n            int length = (diag > mn) ? mn : diag;\n            for (int i = 0; i < length; i++)\n            {\n                Console.Write(mat[row, col] + \" \");\n\n                if (i + 1 == length)\n                    break;\n\n                // Update row or col value based on the last increment\n                if (rowInc)\n                {\n                    row++;\n                    col--;\n                }\n                else\n                {\n                    col++;\n                    row--;\n                }\n            }\n\n            // Update row and col based on position in the matrix\n            if (row == 0 || col == m - 1)\n            {\n                if (col == m - 1)\n                    row++;\n                else\n                    col++;\n                rowInc = true;\n            }\n            else if (col == 0 || row == n - 1)\n            {\n                if (row == n - 1)\n                    col++;\n                else\n                    row++;\n                rowInc = false;\n            }\n        }\n    }\n\n    // Driver code\n    static void Main()\n    {\n        int[,] mat = new int[,] {\n            { 1, 2, 3 },\n            { 4, 5, 6 },\n            { 7, 8, 9 }\n        };\n        ZigZagMatrix(mat);\n    }\n}\n\n````\n\nJavaScript\n\n````\nfunction zigZagMatrix(mat) {\n    const n = mat.length;\n    const m = mat[0].length;\n    let row = 0;\n    let col = 0;\n\n    // Boolean variable that is true if we need\n    // to increment 'row' value;\n    // otherwise, false if we increment 'col' value.\n    let rowInc = false;\n\n    // Print the first half of the zig-zag pattern\n    const mn = Math.min(m, n);\n    for (let length = 1; length <= mn; length++) {\n        for (let i = 0; i < length; i++) {\n            process.stdout.write(mat[row][col] + ' ');\n\n            if (i + 1 === length) break;\n\n            // If rowInc is true, increment row\n            // and decrement col;\n            // otherwise, decrement row and increment col.\n            if (rowInc) {\n                row++;\n                col--;\n            } else {\n                row--;\n                col++;\n            }\n        }\n\n        if (length === mn) break;\n\n        // Update row or col value based on the\n        // last increment\n        if (rowInc) {\n            row++;\n            rowInc = false;\n        } else {\n            col++;\n            rowInc = true;\n        }\n    }\n\n    // Adjust row and col for the second half of the matrix\n    if (row === 0) {\n        if (col === m - 1) row++;\n        else col++;\n        rowInc = true;\n    } else {\n        if (row === n - 1) col++;\n        else row++;\n        rowInc = false;\n    }\n\n    // Print the second half of the zig-zag pattern\n    const MAX = Math.max(m, n) - 1;\n    for (let diag = MAX; diag > 0; diag--) {\n        const length = diag > mn ? mn : diag;\n        for (let i = 0; i < length; i++) {\n            process.stdout.write(mat[row][col] + ' ');\n\n            if (i + 1 === length) break;\n\n            // Update row or col value based on the last increment\n            if (rowInc) {\n                row++;\n                col--;\n            } else {\n                col++;\n                row--;\n            }\n        }\n\n        // Update row and col based on position in the matrix\n        if (row === 0 || col === m - 1) {\n            if (col === m - 1) row++;\n            else col++;\n            rowInc = true;\n        } else if (col === 0 || row === n - 1) {\n            if (row === n - 1) col++;\n            else row++;\n            rowInc = false;\n        }\n    }\n}\n\n// Driver code\nconst mat = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\nzigZagMatrix(mat);\n\n````\n\n\n\n\n**Output**\n```\n1 2 4 7 5 3 6 8 9\n```\n\n****Time complexity:****\nO(n\\*m)\n\n\n\n****Auxiliary space:****\nO(1), since no extra space has been taken.\n\n",
        "metadata": {
            "lesson_id": "98378e7c-1240-46fe-be25-0032ad7aa554",
            "course_id": "4e26b4bd-d406-4641-9d68-3ba8e1c39c97",
            "course_name": "Matrix Data Structure Guide",
            "lesson_description": "Given a matrix of 2D array of n rows and m columns. Print this matrix in ZIG-ZAG fashion as shown in figure.",
            "course_description": "The fundamentals and applications of the matrix as a data structure. You\u2019ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming."
        }
    },
    {
        "page_content": "Two common ways of traversing a matrix are row-major-order and column-major-order\n\n\n\n****Row Major Order:****\nWhen matrix is accessed row by row.\n\n\n\n****Column Major Order:****\nWhen matrix is accessed column by column.\n\n\n\n****Examples:****\n\n> ****Input :****\n> mat[][] = {{1, 2, 3},\n>\n>\n>\n> {4, 5, 6},\n>\n>\n>\n> {7, 8, 9}}\n>\n>\n> ****Output :****\n> Row-wise: 1 2 3 4 5 6 7 8 9\n>\n>\n>\n> Col-wise : 1 4 7 2 5 8 3 6 9\n\n\nIn many problems (like\n\n[Search in a Matrix](https://www.geeksforgeeks.org/search-in-a-matrix-or-2d-array/)\n), we can use any of the above two, so the question arises which one to use?\n\n\nIf we see according to time complexity, both lead to\n\n****O(n****\n****2****\n****)****\n, but when it comes to cache level one of the orders access will be faster as compare to other one. It depends on the language we are using. Most of the languages including C, C++, Java, Python, C# and JavaScrtipt\n\n\nstore matrix in row major form so while accessing the i+1\n\nth\nelement after i\n\nth\n, most probably it will lead to a hit, which will further reduce the time of program.\n\n\nThe following codes are showing the time difference in row major and column major access.\n\n\nC++\n\n````\n#include <iostream>\n#include <vector>\n#include <ctime>\n\nusing namespace std;\n\nvoid rowMajor(vector<vector<int>>& arr) {\n    int rows = arr.size();\n    int cols = arr[0].size();\n\n    // Accessing elements row-wise\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            arr[i][j]++;\n        }\n    }\n}\n\nvoid colMajor(vector<vector<int>>& arr) {\n    int rows = arr.size();\n    int cols = arr[0].size();\n\n    // Accessing elements column-wise\n    for (int j = 0; j < cols; j++) {\n        for (int i = 0; i < rows; i++) {\n            arr[i][j]++;\n        }\n    }\n}\n\nint main() {\n    int n = 1000; // Size of the matrix (n x n)\n    vector<vector<int>> arr(n, vector<int>(n, 0));\n\n    // Time taken by row-major order\n    clock_t t = clock();\n    rowMajor(arr);\n    t = clock() - t;\n    cout << \"Row major access time: \" << t / (double)CLOCKS_PER_SEC << \" s\\n\";\n\n    // Time taken by column-major order\n    t = clock();\n    colMajor(arr);\n    t = clock() - t;\n    cout << \"Column major access time: \" << t / (double)CLOCKS_PER_SEC << \" s\\n\";\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\n\n#define MAX 1000 // Size of the matrix (MAX x MAX)\n\nvoid rowMajor(int arr[MAX][MAX]) {\n    // Accessing elements row-wise\n    for (int i = 0; i < MAX; i++) {\n        for (int j = 0; j < MAX; j++) {\n            arr[i][j]++;\n        }\n    }\n}\n\nvoid colMajor(int arr[MAX][MAX]) {\n    // Accessing elements column-wise\n    for (int j = 0; j < MAX; j++) {\n        for (int i = 0; i < MAX; i++) {\n            arr[i][j]++;\n        }\n    }\n}\n\nint main() {\n    int arr[MAX][MAX] = {0}; // Initialize matrix with zeros\n\n    // Time taken by row-major order\n    clock_t t = clock();\n    rowMajor(arr);\n    t = clock() - t;\n    printf(\"Row major access time: %f s\\n\", (double)t / CLOCKS_PER_SEC);\n\n    // Time taken by column-major order\n    t = clock();\n    colMajor(arr);\n    t = clock() - t;\n    printf(\"Column major access time: %f s\\n\", (double)t / CLOCKS_PER_SEC);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.*;\n\nclass GFG {\n\n    static void rowMajor(int[][] arr) {\n        int rows = arr.length;\n        int cols = arr[0].length;\n\n        // Accessing elements row-wise\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                arr[i][j]++;\n            }\n        }\n    }\n\n    static void colMajor(int[][] arr) {\n        int rows = arr.length;\n        int cols = arr[0].length;\n\n        // Accessing elements column-wise\n        for (int j = 0; j < cols; j++) {\n            for (int i = 0; i < rows; i++) {\n                arr[i][j]++;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int n = 1000; // Size of the matrix (n x n)\n        int[][] arr = new int[n][n];\n\n        // Time taken by row-major order\n        Instant start = Instant.now();\n        rowMajor(arr);\n        Instant end = Instant.now();\n        System.out.println(\"Row major access time: \" + Duration.between(start, end));\n\n        // Time taken by column-major order\n        start = Instant.now();\n        colMajor(arr);\n        end = Instant.now();\n        System.out.println(\"Column major access time: \" + Duration.between(start, end));\n    }\n}\n\n````\n\nPython\n\n````\nfrom time import perf_counter\n\ndef row_major(arr):\n    rows = len(arr)\n    cols = len(arr[0])\n\n    # Accessing elements row-wise\n    for i in range(rows):\n        for j in range(cols):\n            arr[i][j] += 1\n\ndef col_major(arr):\n    rows = len(arr)\n    cols = len(arr[0])\n\n    # Accessing elements column-wise\n    for j in range(cols):\n        for i in range(rows):\n            arr[i][j] += 1\n\nif __name__ == '__main__':\n\n    n = 1000  # Size of the matrix (n x n)\n    arr = [[0] * n for _ in range(n)]\n\n    # Time taken by row-major order\n    t_start = perf_counter()\n    row_major(arr)\n    t_row = perf_counter() - t_start\n    print(\"Row major access time: {:.2f} s\".format(t_row))\n\n    # Time taken by column-major order\n    t_start = perf_counter()\n    col_major(arr)\n    t_col = perf_counter() - t_start\n    print(\"Column major access time: {:.2f} s\".format(t_col))\n\n````\n\nC#\n\n````\nusing System;\n\npublic class GFG {\n    public static void RowMajor(int[,] arr) {\n        int rows = arr.GetLength(0);\n        int cols = arr.GetLength(1);\n\n        // Accessing elements row-wise\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                arr[i, j]++;\n            }\n        }\n    }\n\n    public static void ColMajor(int[,] arr) {\n        int rows = arr.GetLength(0);\n        int cols = arr.GetLength(1);\n\n        // Accessing elements column-wise\n        for (int j = 0; j < cols; j++) {\n            for (int i = 0; i < rows; i++) {\n                arr[i, j]++;\n            }\n        }\n    }\n\n    public static void Main(string[] args) {\n        int n = 1000; // Size of the matrix (n x n)\n        int[,] arr = new int[n, n];\n\n        // Time taken by row-major order\n        var start = DateTime.UtcNow;\n        RowMajor(arr);\n        var end = DateTime.UtcNow;\n        TimeSpan spanR = end - start;\n        Console.WriteLine(\"Row major access time: \" + spanR.TotalSeconds + \" s\");\n\n        // Time taken by column-major order\n        start = DateTime.UtcNow;\n        ColMajor(arr);\n        end = DateTime.UtcNow;\n        TimeSpan spanC = end - start;\n        Console.WriteLine(\"Column major access time: \" + spanC.TotalSeconds + \" s\");\n    }\n}\n\n````\n\nJavaScript\n\n````\nfunction rowMajor(arr) {\n    let rows = arr.length;\n    let cols = arr[0].length;\n\n    // Accessing elements row-wise\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            arr[i][j]++;\n        }\n    }\n}\n\nfunction colMajor(arr) {\n    let rows = arr.length;\n    let cols = arr[0].length;\n\n    // Accessing elements column-wise\n    for (let j = 0; j < cols; j++) {\n        for (let i = 0; i < rows; i++) {\n            arr[i][j]++;\n        }\n    }\n}\n\n// Driver code\nlet n = 1000; // Size of the matrix (n x n)\nlet arr = Array.from({ length: n }, () => Array(n).fill(0));\n\n// Time taken by row-major order\nlet start = Date.now();\nrowMajor(arr);\nlet end = Date.now();\nconsole.log(`Row major access time: ${end - start} ms`);\n\n// Time taken by column-major order\nstart = Date.now();\ncolMajor(arr);\nend = Date.now();\nconsole.log(`Column major access time: ${end - start} ms`);\n\n````\n\n****Time Complexity:****\nO(MAX\\*MAX)\n\n\n\n****Auxiliary Space:****\nO(MAX\\*MAX)",
        "metadata": {
            "lesson_id": "630b6281-246f-490e-bb03-77b0b5ea16f1",
            "course_id": "4e26b4bd-d406-4641-9d68-3ba8e1c39c97",
            "course_name": "Matrix Data Structure Guide",
            "lesson_description": "",
            "course_description": "The fundamentals and applications of the matrix as a data structure. You\u2019ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming."
        }
    },
    {
        "page_content": "Given a matrix\n\n****mat[n][m]****\nand an element\n\n****target****\n. return true if the target is present in the matrix, else return false.\n\n\n****Examples:****\n\n> ****Input****\n> : mat[][] = { {10, 51, 9},\n>\n>\n>\n> {14, 20, 21},\n>\n>\n>\n> {30, 24, 43} }\n>\n>\n>\n> ****target****\n> = 14\n>\n>\n>\n> ****Output****\n> : Found\n>\n>\n>\n>\n>\n> ****Input****\n> : mat[][] = {{31, 5, 9, 11},\n>\n>\n>\n> {14, 7, 21, 26},\n>\n>\n>\n> {30, 4, 43, 50} }\n>\n>\n>\n> ****target****\n> = 42\n>\n>\n>\n> ****Output****\n> : Not Found\n\n\nWe traverse the mat[][] and compare target with every element of the matrix. If matches, then return true If we reach the end we will return false.\n\n\nC++\n\n````\n// C++ program to search target in a matrix\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool matrixSearch(vector<vector<int> >& mat, int x)\n{\n    int n = mat.size(), m = mat[0].size();\n\n    // Compare each element one by one\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            if (mat[i][j] == x)\n                return true;\n    return false;\n}\n\nint main() {\n    vector<vector<int> > mat = { { 1, 5, 9, 11 },\n                                 { 14, 20, 21, 26 },\n                                 { 30, 34, 43, 50 } };\n    if (matrixSearch(mat, 14))\n        cout << \"Found\\n\";\n    else\n        cout << \"Not Found\\n\";\n\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to check position of target Linearly\n#include <stdbool.h>\n#include <stdio.h>\n\n#define MAX 100\n\nbool matrixSearch(int mat[MAX][MAX], int n, int m,\n                        int x)\n{\n    // Compare each element one by one\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (mat[i][j] == x) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    int mat[MAX][MAX] = { { 1, 5, 9, 11 },\n                          { 14, 20, 21, 26 },\n                          { 30, 34, 43, 50 } };\n    // Number of rows\n  \tint n = 3;\n\n    // Number of columns\n    int m = 4;\n\n    // Element to search\n    int x = 14;\n\n    if (matrixSearch(mat, n, m, x)) {\n        printf(\"Found\\n\");\n    }\n    else {\n        printf(\"Not Found\\n\");\n    }\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to check position of target Linearly\nimport java.util.*;\n\nclass GfG {\n\n    public static boolean matrixSearch(int[][] mat,\n                                             int x)\n    {\n        int n = mat.length;\n        int m = mat[0].length;\n\n        // Compare each element one by one\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (mat[i][j] == x) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args)\n    {\n        int[][] mat = { { 1, 5, 9, 11 },\n                        { 14, 20, 21, 26 },\n                        { 30, 34, 43, 50 } };\n        if (matrixSearch(mat, 14)) {\n            System.out.println(\"Found\");\n        }\n        else {\n            System.out.println(\"Not Found\");\n        }\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to check position of target Linearly\ndef matrixSearch(mat, x):\n    n = len(mat)\n    m = len(mat[0])\n\n    # Compare each element one by one\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == x:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    mat = [\n        [1, 5, 9, 11],\n        [14, 20, 21, 26],\n        [30, 34, 43, 50]\n    ]\n    if matrixSearch(mat, 14):\n        print(\"Found\")\n    else:\n        print(\"Not Found\")\n\n````\n\nC#\n\n````\n// C# program to check position of target Linearly\nusing System;\n\nclass GfG {\n    public static bool matrixSearch(int[, ] mat, int x)\n    {\n        int n = mat.GetLength(0);\n        int m = mat.GetLength(1);\n\n        // Compare each element one by one\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                if (mat[i, j] == x)\n                    return true;\n\n        return false;\n    }\n\n    public static void Main()\n    {\n        int[, ] mat = { { 1, 5, 9, 11 },\n                        { 14, 20, 21, 26 },\n                        { 30, 34, 43, 50 } };\n\n        if (matrixSearch(mat, 14))\n            Console.WriteLine(\"Found\");\n        else\n            Console.WriteLine(\"Not Found\");\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Javascript program to check position of target Linearly\nfunction matrixSearch(mat, x)\n{\n    let n = mat.length;\n    let m = mat[0].length;\n\n    // Compare each element one by one\n    for (let i = 0; i < n; i++)\n        for (let j = 0; j < m; j++)\n            if (mat[i][j] === x)\n                return true;\n\n    return false;\n}\n\nlet mat = [\n    [ 1, 5, 9, 11 ], [ 14, 20, 21, 26 ], [ 30, 34, 43, 50 ]\n];\n\nif (matrixSearch(mat, 14))\n    console.log(\"Found\");\nelse\n    console.log(\"Not Found\");\n\n````\n\n\n\n\n**Output**\n```\nFound\n\n```\n\n\n\n****Time Complexity :****\nO(n \\* m), where n and m are the rows and column of matrix.\n\n\n\n****Auxiliary Space :****\nO(1)",
        "metadata": {
            "lesson_id": "c009b1a3-025d-4295-841e-6faecee91690",
            "course_id": "4e26b4bd-d406-4641-9d68-3ba8e1c39c97",
            "course_name": "Matrix Data Structure Guide",
            "lesson_description": "",
            "course_description": "The fundamentals and applications of the matrix as a data structure. You\u2019ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming."
        }
    },
    {
        "page_content": "\n\nGiven two\n\n****N****\nx\n\n****M matrices****\n. Find a\n\n****N****\nx\n\n****M****\nmatrix as the sum of given matrices each value at the sum of values of corresponding elements of the given two matrices.\n\n\n![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/program-for-addition-of-two-matrices-1024x512.png)\n\n****Approach:****\nBelow is the idea to solve the problem.\n\n\n> Iterate over every cell of matrix (i, j), add the corresponding values of the two matrices and store in a single matrix i.e. the resultant matrix.\n\n\nFollow the below steps to Implement the idea:\n\n\n* Initialize a resultant matrix res[N][M].\n* Run a for loop for counter\n\n  ****i****\n  as each row and in each iteration:\n  + Run a for loop for counter\n\n    ****j****\n    as each column and in each iteration:\n    - Add values of the two matrices for index i, j and store in res[i][j].\n* Return res.\n\n\nBelow is the Implementation of above approach.\n\n\nC++\n\n````\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid add(vector<vector<int>>& A, vector<vector<int>>& B,\n                                 vector<vector<int>>& C) {\n    int n = A.size();\n    int m = A[0].size();\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nint main() {\n    vector<vector<int>> A = { {1, 1, 1},\n                              {2, 2, 2},\n                              {3, 3, 3},\n                              {4, 4, 4} };\n\n    vector<vector<int>> B = { {1, 1, 1},\n                              {2, 2, 2},\n                              {3, 3, 3},\n                              {4, 4, 4} };\n\n    int n = A.size();\n    int m = A[0].size();\n    vector<vector<int>> C(n, vector<int>(m));\n\n    add(A, B, C);\n\n    cout << \"Result matrix is:\" << endl;\n    for (const auto& row : C) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 4  // Number of rows\n#define M 3  // Number of columns\n\nvoid add(int A[][M], int B[][M], int C[][M]) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nint main() {\n    int A[N][M] = { {1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4} };\n    int B[N][M] = { {1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4} };\n    int C[N][M];\n\n    add(A, B, C);\n\n    printf(\"Result matrix is:\\n\");\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            printf(\"%d \", C[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n````\n\nJava\n\n````\npublic class GfG {\n    public static void add(int[][] A, int[][] B, int[][] C) {\n        int n = A.length;\n        int m = A[0].length;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                C[i][j] = A[i][j] + B[i][j];\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[][] A = { {1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4} };\n        int[][] B = { {1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4} };\n        int[][] C = new int[4][3];\n        add(A, B, C);\n\n        System.out.println(\"Result matrix is:\");\n        for (int[] row : C) {\n            for (int val : row) {\n                System.out.print(val + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n\n````\n\nPython\n\n````\ndef add(A, B):\n    n = len(A)\n    m = len(A[0])\n    C = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            C[i][j] = A[i][j] + B[i][j]\n    return C\n\nA = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ]\nB = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ]\nC = add(A, B)\n\nprint(\"Result matrix is:\")\nfor row in C:\n    print(' '.join(map(str, row)))\n\n````\n\nJavaScript\n\n````\nfunction add(A, B) {\n    let n = A.length;\n    let m = A[0].length;\n    let C = Array.from({ length: n }, () => Array(m).fill(0));\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n    return C;\n}\n\nconst A = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ];\nconst B = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ];\nconst C = add(A, B);\n\nconsole.log(\"Result matrix is:\");\nC.forEach(row => {\n    console.log(row.join(' '));\n});\n\n````\n\nPHP\n\n````\n<?php\nfunction add($A, $B) {\n    $n = count($A);\n    $m = count($A[0]);\n    $C = array_fill(0, $n, array_fill(0, $m, 0));\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $m; $j++) {\n            $C[$i][$j] = $A[$i][$j] + $B[$i][$j];\n        }\n    }\n    return $C;\n}\n\n$A = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ];\n$B = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ];\n$C = add($A, $B);\n\necho \"Result matrix is:\\n\";\nforeach ($C as $row) {\n    echo implode(' ', $row) . \"\\n\";\n}\n?>\n\n````\n\n\n\n\n**Output**\n```\nResult matrix is\n2 2 2 2\n4 4 4 4\n6 6 6 6\n8 8 8 8\n```\n\n****Time complexity:****\nO(n x m).\n\n\n\n****Auxiliary space:****\nO(n x m).  since n\n\n2\nextra space has been taken for storing results\n\n\nThe program can be extended for rectangular matrices. The following post can be useful for extending this program.",
        "metadata": {
            "lesson_id": "c810809a-8425-4105-91f6-cc98e64ead3e",
            "course_id": "4e26b4bd-d406-4641-9d68-3ba8e1c39c97",
            "course_name": "Matrix Data Structure Guide",
            "lesson_description": "",
            "course_description": "The fundamentals and applications of the matrix as a data structure. You\u2019ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming."
        }
    },
    {
        "page_content": "\n\nGiven two\n\n[matrices](https://www.geeksforgeeks.org/matrices/)\n, the task is to multiply them. Matrices can either be square or rectangular:\n\n\n****Examples:****\n\n\n> ****(Square Matrix Multiplication)****\n>\n> ****Input:****\n> m1[m][n] = { {1, 1}, {2, 2} }\n>\n>\n>\n> m2[n][p] = { {1, 1}, {2, 2} }\n>\n>\n>\n> ****Output:****\n> res[m][p] = { {3, 3}, {6, 6} }\n>\n>\n> ****(Rectangular Matrix Multiplication)****\n>\n> ****Input:****\n> m1[3][2] = { {1, 1}, {2, 2}, {3, 3} }\n>\n>\n>\n> m2[2][3] = { {1, 1, 1}, {2, 2, 2} }\n>\n>\n>\n> ****Output:****\n> res[3][3] = { {3, 3, 3}, {6, 6, 6}, {9, 9, 9} }\n>\n>\n> ![](https://media.geeksforgeeks.org/wp-content/uploads/20210902010632/MatrixMultiply1001jpeg001.jpeg)\n\n****Multiplication of two Square or Rectangular Matrices****\n------------------------------------------------------------\n\n> * The number of columns in Matrix-1 must be equal to the number of rows in Matrix-2.\n> * Output of multiplication of Matrix-1 and Matrix-2, results with equal to the number of rows of Matrix-1 and  the number of columns of Matrix-2 i.e. rslt[R1][C2]\n\n\nBelow is the implementation of the multiplication of two\n\n[matrices](https://www.geeksforgeeks.org/matrices/)\n:\n\n\n\n\n\nC++\n\n````\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid mulMat(vector<vector<int>>& m1, vector<vector<int>>& m2,\n            vector<vector<int>>& res) {\n    int r1 = m1.size();\n    int c1 = m1[0].size();\n    int r2 = m2.size();\n    int c2 = m2[0].size();\n\n    if (c1 != r2) {\n        cout << \"Invalid Input\" << endl;\n        exit(EXIT_FAILURE);\n    }\n\n    // Resize result matrix to fit the result dimensions\n    res.resize(r1, vector<int>(c2, 0));\n\n    for (int i = 0; i < r1; i++) {\n        for (int j = 0; j < c2; j++) {\n            for (int k = 0; k < c1; k++) {\n                res[i][j] += m1[i][k] * m2[k][j];\n            }\n        }\n    }\n}\n\n// Driver code\nint main() {\n    vector<vector<int>> m1 = { {1, 1}, {2, 2} };\n    vector<vector<int>> m2 = { {1, 1}, {2, 2} };\n    vector<vector<int>> res;\n\n    mulMat(m1, m2, res);\n\n    cout << \"Multiplication of given two matrices is:\\n\";\n    for (const auto& row : res) {\n        for (int val : row) {\n            cout << val << \"\\t\";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n#define R1 2 // number of rows in Matrix-1\n#define C1 2 // number of columns in Matrix-1\n#define R2 2 // number of rows in Matrix-2\n#define C2 2 // number of columns in Matrix-2\n\nvoid mulMat(int m1[][C1], int m2[][C2], int rslt[][C2]) {\n    if (C1 != R2) {\n       printf(\"Invalid Input\");\n       return;\n    }\n\n    for (int i = 0; i < R1; i++) {\n        for (int j = 0; j < C2; j++) {\n            rslt[i][j] = 0;\n\n            // Changed R2 to C1 for correct multiplication\n            for (int k = 0; k < C1; k++) {\n                rslt[i][j] += m1[i][k] * m2[k][j];\n            }\n        }\n    }\n}\n\nint main() {\n    int m1[R1][C1] = { { 1, 1 },\n                       { 2, 2 } };\n\n    int m2[R2][C2] = { { 1, 1 },\n                       { 2, 2 } };\n\n    int rslt[R1][C2]; // Result matrix\n\n    // Function call to multiply matrices\n    mulMat(m1, m2, rslt);\n\n    // Print the result matrix\n    printf(\"Result matrix is:\\n\");\n    for (int i = 0; i < R1; i++) {\n        for (int j = 0; j < C2; j++) {\n            printf(\"%d\\t\", rslt[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n\n````\n\nJava\n\n````\npublic class MatrixMultiplication {\n\n    public static void mulMat(int[][] m1, int[][] m2, int[][] res) {\n        int r1 = m1.length;\n        int c1 = m1[0].length;\n        int r2 = m2.length;\n        int c2 = m2[0].length;\n\n        if (c1 != r2) {\n            System.out.println(\"Invalid Input\");\n            System.exit(1);\n        }\n\n        // Perform matrix multiplication\n        for (int i = 0; i < r1; i++) {\n            for (int j = 0; j < c2; j++) {\n                res[i][j] = 0; // Initialize result cell\n                for (int k = 0; k < c1; k++) {\n                    res[i][j] += m1[i][k] * m2[k][j];\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[][] m1 = {\n            {1, 1},\n            {2, 2}\n        };\n\n        int[][] m2 = {\n            {1, 1},\n            {2, 2}\n        };\n\n        int r1 = m1.length;\n        int c2 = m2[0].length;\n        int[][] res = new int[r1][c2]; // Resultant matrix\n\n        mulMat(m1, m2, res);\n\n        System.out.println(\"Multiplication of given two matrices is:\");\n        for (int i = 0; i < r1; i++) {\n            for (int j = 0; j < c2; j++) {\n                System.out.print(res[i][j] + \"\\t\");\n            }\n            System.out.println();\n        }\n    }\n}\n\n````\n\nPython\n\n````\ndef mulMat(m1, m2):\n    r1 = len(m1)\n    c1 = len(m1[0])\n    r2 = len(m2)\n    c2 = len(m2[0])\n\n    if c1 != r2:\n        print(\"Invalid Input\")\n        return None\n\n    # Initialize the result matrix with zeros\n    res = [[0] * c2 for _ in range(r1)]\n\n    # Perform matrix multiplication\n    for i in range(r1):\n        for j in range(c2):\n            for k in range(c1):\n                res[i][j] += m1[i][k] * m2[k][j]\n\n    return res\n\n# Driver code\nif __name__ == \"__main__\":\n    m1 = [\n        [1, 1],\n        [2, 2]\n    ]\n\n    m2 = [\n        [1, 1],\n        [2, 2]\n    ]\n\n    result = mulMat(m1, m2)\n\n    print(\"Multiplication of given two matrices is:\")\n    for row in result:\n        print(\" \".join(map(str, row)))\n\n````\n\nC#\n\n````\nusing System;\n\nclass Program\n{\n    static int[,] MulMat(int[,] m1, int[,] m2)\n    {\n        int r1 = m1.GetLength(0);\n        int c1 = m1.GetLength(1);\n        int r2 = m2.GetLength(0);\n        int c2 = m2.GetLength(1);\n\n        if (c1 != r2)\n        {\n            Console.WriteLine(\"Invalid Input\");\n            return null;\n        }\n\n        // Initialize the result matrix\n        int[,] res = new int[r1, c2];\n\n        // Perform matrix multiplication\n        for (int i = 0; i < r1; i++)\n        {\n            for (int j = 0; j < c2; j++)\n            {\n                for (int k = 0; k < c1; k++)\n                {\n                    res[i, j] += m1[i, k] * m2[k, j];\n                }\n            }\n        }\n\n        return res;\n    }\n\n    static void Main()\n    {\n        int[,] m1 = { { 1, 1 }, { 2, 2 } };\n        int[,] m2 = { { 1, 1 }, { 2, 2 } };\n\n        int[,] result = MulMat(m1, m2);\n\n        if (result != null)\n        {\n            Console.WriteLine(\"Multiplication of given two matrices is:\");\n            for (int i = 0; i < result.GetLength(0); i++)\n            {\n                for (int j = 0; j < result.GetLength(1); j++)\n                {\n                    Console.Write(result[i, j] + \"\\t\");\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n\n````\n\nJavaScript\n\n````\nfunction mulMat(m1, m2) {\n    const r1 = m1.length;\n    const c1 = m1[0].length;\n    const r2 = m2.length;\n    const c2 = m2[0].length;\n\n    if (c1 !== r2) {\n        console.log(\"Invalid Input\");\n        return null;\n    }\n\n    // Initialize the result matrix\n    const res = Array.from({ length: r1 }, () => Array(c2).fill(0));\n\n    // Perform matrix multiplication\n    for (let i = 0; i < r1; i++) {\n        for (let j = 0; j < c2; j++) {\n            for (let k = 0; k < c1; k++) {\n                res[i][j] += m1[i][k] * m2[k][j];\n            }\n        }\n    }\n\n    return res;\n}\n\n// Driver code\nconst m1 = [\n    [1, 1],\n    [2, 2]\n];\n\nconst m2 = [\n    [1, 1],\n    [2, 2]\n];\n\nconst result = mulMat(m1, m2);\n\nif (result) {\n    console.log(\"Multiplication of given two matrices is:\");\n    for (const row of result) {\n        console.log(row.join(\" \"));\n    }\n}\n\n````\n\n\n\n\n**Output**\n```\nMultiplication of given two matrices is:\n3    3\n6    6\n```\n\n****Time complexity:****\nO(R1 \\* C2 \\* R2) for given matrices mat1[R1][C1] and mat2[R2][C2]\n\n\n\n****Auxiliary space:****\nO(R1 \\* C2)\n\n\n****Multiplication of Rectangular Matrices using Pointers in C/C++:****\n-----------------------------------------------------------------------\n\n\nTo solve the problem follow the below idea:\n\n\n> We use pointers in C/C++ to multiply matrices\n\n****Prerequisite:****\n\n[How to pass a 2D array as a parameter in C?](https://www.geeksforgeeks.org/pass-2d-array-parameter-c/)\n\n\nBelow is the implementation of the above approach:\n\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n#define R1 2 // number of rows in Matrix-1\n#define C1 2 // number of columns in Matrix-1\n#define R2 2 // number of rows in Matrix-2\n#define C2 2 // number of columns in Matrix-2\n\nvoid mulMat(int (*m1)[C1], int (*m2)[C2], int (*rslt)[C2]) {\n    if (C1 != R2) {\n        printf(\"Invalid Input\");\n        return;\n    }\n\n    for (int i = 0; i < R1; i++) {\n        for (int j = 0; j < C2; j++) {\n            rslt[i][j] = 0; // Initialize result matrix element\n\n            for (int k = 0; k < C1; k++) { // Use C1 for multiplication\n                rslt[i][j] += m1[i][k] * m2[k][j];\n            }\n        }\n    }\n}\n\nint main() {\n    int m1[R1][C1] = { { 1, 1 },\n                       { 2, 2 } };\n\n    int m2[R2][C2] = { { 1, 1 },\n                       { 2, 2 } };\n\n    int rslt[R1][C2]; // Result matrix\n\n    // Function call to multiply matrices\n    mulMat(m1, m2, rslt);\n\n    // Print the result matrix\n    printf(\"Result matrix is:\\n\");\n    for (int i = 0; i < R1; i++) {\n        for (int j = 0; j < C2; j++) {\n            printf(\"%d\\t\", rslt[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n\n````\n\n\n\n\n**Output**\n```\n3 3\n6 6\n```\n\n  ",
        "metadata": {
            "lesson_id": "1196e9db-ba66-4fc1-af17-824bf7fd8444",
            "course_id": "4e26b4bd-d406-4641-9d68-3ba8e1c39c97",
            "course_name": "Matrix Data Structure Guide",
            "lesson_description": "",
            "course_description": "The fundamentals and applications of the matrix as a data structure. You\u2019ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming."
        }
    },
    {
        "page_content": "Given a\n\n****sorted****\nmatrix\n\n****mat[][]****\nof size\n\n****nxm****\nand an\n\n\nelement\n\n****x****\n, the task is to find if x is\n\n****present****\nin the matrix or not. Matrix is\n\n****sorted****\nin a way such that all elements in a\n\n****row are sorted in increasing order****\nand for row i, where 1 <= i <= n-1, the\n\n****first element****\nof\n\n****row i****\nis\n\n****greater than or equal****\nto the\n\n****last element****\nof\n\n****row i-1.****\n\n\n****Examples:****\n\n> ****Input:****\n> x = 14, mat[][] = [[ 1, 5, 9],\n>\n>\n>\n> [14, 20, 21],\n>\n>\n>\n> [30, 34, 43]]\n>\n>\n>\n> ****Output:****\n> true\n>\n>\n> ****Input:****\n> x = 42, mat[][] = [[ 1, 5, 9, 11],\n>\n>\n>\n> [14, 20, 21, 26],\n>\n>\n>\n> [30, 34, 43, 50]]\n>\n>\n>\n> ****Output:****\n> false\n\nTable of Content\n\n* [[Naive Approach] Comparing with all elements \u2013 O(n\\*m) Time and O(1) Space](#naive-solution-onm-time-and-o1-space)\n* [[Better Approach] Using Binary Search Twice \u2013 O(logn + logm) Time and O(1) Space](#using-binary-search-two-times-olog-n-log-m-time-and-o1-space)\n* [[Expected Approach] Using Binary Search Once \u2013 O(log(n\\*m)) and O(1) Space](#using-one-binary-search-olognm-and-o1-space)\n### ****[Naive Approach] Comparing with all elements \u2013 O(n\\*m) Time and O(1) Space****\n\n\nIn this approach, we will iterate through the entire\n\n****matrix mat[][]****\nand compare\n\n****each element****\nwith\n\n****x****\n. If an element matches the x, we will\n\n****return true****\n. Otherwise, at the end of the traversal, we will\n\n****return false.****\nPlease refer to\n\n[Searching Algorithms for 2D Arrays (Matrix)](https://www.geeksforgeeks.org/searching-algorithms-for-a-2d-arrays-matrix/)\nto know more about the implementation.\n\n\n### ****[Better Approach] Using Binary Search Twice \u2013**** O(logn + logm) Time and O(1) Space\n\n\nFirst, we locate the row where the\n\n****target x****\nmight be by using\n\n****binary search****\n, and then we apply binary search again within that row.\n\n\n\n> To find the correct row, we perform\n>\n> ****binary search****\n> on the\n>\n> ****first****\n> elements of the middle row.\n>\n>\n>\n> Start with l\n>\n> ****ow = 0****\n> and\n>\n> ****high = n \u2013 1.****\n>\n> 1. If\n>\n>    ****x is smaller****\n>    than the\n>\n>    ****first element****\n>    of the middle row\n>\n>    ****(a[mid][0]),****\n>    then x will be smaller than all elements in rows >= mid, so update\n>\n>    ****high = mid \u2013 1.****\n> 2. If\n>\n>    ****x is greater****\n>    than the\n>\n>    ****first element****\n>    of the middle row\n>\n>    ****(a[mid][0])****\n>    , then x will be greater than all elements in rows < mid, so store the current mid row and update\n>\n>    ****low = mid + 1****\n>    .\n>\n>\n> Once we have found the\n>\n> ****correct row,****\n> we can apply\n>\n> ****binary search****\n> within that row to search for the\n>\n> ****target****\n> element\n>\n> ****x****\n> .\n\nC++\n\n````\n// C++ program to search in the sorted matrix using\n// Binary Search two times\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to binary search for x in arr[]\nbool search(vector<int> &arr, int x) {\n    int lo = 0, hi = arr.size() - 1;\n\n    while (lo <= hi) {\n        int mid = (lo + hi) / 2;\n\n        if (x == arr[mid])\n            return true;\n        if (x < arr[mid])\n            hi = mid - 1;\n        else\n            lo = mid + 1;\n    }\n    return false;\n}\n\nbool searchMatrix(vector<vector<int>> &mat, int x) {\n    int n = mat.size(), m = mat[0].size();\n    int lo = 0, hi = n - 1;\n    int row = -1;\n\n    while (lo <= hi) {\n        int mid = (lo + hi) / 2;\n\n        // If the first element of mid row is equal to x,\n        // return true\n        if (x == mat[mid][0])\n            return true;\n\n        // If x is greater than first element of mid row,\n        // store the mid row and search in lower half\n        if (x > mat[mid][0]) {\n            row = mid;\n            lo = mid + 1;\n        }\n\n        // If x is smaller than first element of mid row,\n        // search in upper half\n        else\n            hi = mid - 1;\n    }\n\n    // If x is smaller than all elements of mat[][]\n    if (row == -1)\n        return false;\n\n    return search(mat[row], x);\n}\n\nint main() {\n    vector<vector<int>> mat = {{1, 5, 9}, {14, 20, 21}, {30, 34, 43}};\n    int x = 14;\n\n    if (searchMatrix(mat, x))\n        cout << \"true\";\n    else\n        cout << \"false\";\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to search in the sorted matrix using\n// Binary Search two times\n\nclass GfG {\n\n    // Function to binary search for x in arr[]\n    static boolean search(int[] arr, int x) {\n        int lo = 0, hi = arr.length - 1;\n\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n\n            if (x == arr[mid])\n                return true;\n            if (x < arr[mid])\n                hi = mid - 1;\n            else\n                lo = mid + 1;\n        }\n        return false;\n    }\n\n    static boolean searchMatrix(int[][] mat, int x) {\n        int n = mat.length, m = mat[0].length;\n        int lo = 0, hi = n - 1;\n        int row = -1;\n\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n\n            // If the first element of mid row is equal to x,\n            // return true\n            if (x == mat[mid][0])\n                return true;\n\n            // If x is greater than first element of mid row,\n            // store the mid row and search in lower half\n            if (x > mat[mid][0]) {\n                row = mid;\n                lo = mid + 1;\n            }\n\n            // If x is smaller than first element of mid row,\n            // search in upper half\n            else\n                hi = mid - 1;\n        }\n\n        // If x is smaller than all elements of mat[][]\n        if (row == -1)\n            return false;\n\n        return search(mat[row], x);\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {\n            {1, 5, 9},\n            {14, 20, 21},\n            {30, 34, 43}\n        };\n        int x = 14;\n\n        if (searchMatrix(mat, x))\n            System.out.println(\"true\");\n        else\n            System.out.println(\"false\");\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to search in the sorted matrix using\n# Binary Search two times\n\n# Function to binary search for x in arr[]\ndef search(arr, x):\n    lo = 0\n    hi = len(arr) - 1\n\n    while lo <= hi:\n        mid = (lo + hi) // 2\n\n        if x == arr[mid]:\n            return True\n        if x < arr[mid]:\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return False\n\ndef searchMatrix(mat, x):\n    n = len(mat)\n    m = len(mat[0])\n    lo = 0\n    hi = n - 1\n    row = -1\n\n    while lo <= hi:\n        mid = (lo + hi) // 2\n\n        # If the first element of mid row is equal to x,\n        # return true\n        if x == mat[mid][0]:\n            return True\n\n        # If x is greater than first element of mid row,\n        # store the mid row and search in lower half\n        if x > mat[mid][0]:\n            row = mid\n            lo = mid + 1\n\n        # If x is smaller than first element of mid row,\n        # search in upper half\n        else:\n            hi = mid - 1\n\n    # If x is smaller than all elements of mat[][]\n    if row == -1:\n        return False\n\n    return search(mat[row], x)\n\nif __name__ == \"__main__\":\n    mat = [[1, 5, 9], [14, 20, 21], [30, 34, 43]]\n    x = 14\n\n    if searchMatrix(mat, x):\n        print(\"true\")\n    else:\n        print(\"false\")\n\n````\n\nC#\n\n````\n// C# program to search in the sorted matrix using\n// Binary Search two times\n\nusing System;\n\nclass GfG {\n\n    // Function to binary search for x in arr[]\n    static bool Search(int[] arr, int x) {\n        int lo = 0, hi = arr.Length - 1;\n\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n\n            if (x == arr[mid])\n                return true;\n            if (x < arr[mid])\n                hi = mid - 1;\n            else\n                lo = mid + 1;\n        }\n        return false;\n    }\n\n    static bool SearchMatrix(int[][] mat, int x) {\n        int n = mat.Length, m = mat[0].Length;\n        int lo = 0, hi = n - 1;\n        int row = -1;\n\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n\n            // If the first element of mid row is equal to x,\n            // return true\n            if (x == mat[mid][0])\n                return true;\n\n            // If x is greater than first element of mid row,\n            // store the mid row and search in lower half\n            if (x > mat[mid][0]) {\n                row = mid;\n                lo = mid + 1;\n            }\n\n            // If x is smaller than first element of mid row,\n            // search in upper half\n            else\n                hi = mid - 1;\n        }\n\n        // If x is smaller than all elements of mat[][]\n        if (row == -1)\n            return false;\n\n        return Search(mat[row], x);\n    }\n\n    static void Main(string[] args) {\n        int[][] mat = new int[][] {\n            new int[] {1, 5, 9},\n            new int[] {14, 20, 21},\n            new int[] {30, 34, 43}\n        };\n        int x = 14;\n\n        if (SearchMatrix(mat, x))\n            Console.WriteLine(\"true\");\n        else\n            Console.WriteLine(\"false\");\n    }\n}\n\n````\n\nJavaScript\n\n````\n// JavaScript program to search in the sorted matrix using\n// Binary Search two times\n\n// Function to binary search for x in arr[]\nfunction search(arr, x) {\n    let lo = 0, hi = arr.length - 1;\n\n    while (lo <= hi) {\n        let mid = Math.floor((lo + hi) / 2);\n\n        if (x === arr[mid])\n            return true;\n        if (x < arr[mid])\n            hi = mid - 1;\n        else\n            lo = mid + 1;\n    }\n    return false;\n}\n\nfunction searchMatrix(mat, x) {\n    let n = mat.length, m = mat[0].length;\n    let lo = 0, hi = n - 1;\n    let row = -1;\n\n    while (lo <= hi) {\n        let mid = Math.floor((lo + hi) / 2);\n\n        // If the first element of mid row is equal to x,\n        // return true\n        if (x === mat[mid][0])\n            return true;\n\n        // If x is greater than first element of mid row,\n        // store the mid row and search in lower half\n        if (x > mat[mid][0]) {\n            row = mid;\n            lo = mid + 1;\n        }\n\n        // If x is smaller than first element of mid row,\n        // search in upper half\n        else\n            hi = mid - 1;\n    }\n\n    // If x is smaller than all elements of mat[][]\n    if (row === -1)\n        return false;\n\n    return search(mat[row], x);\n}\n\n// Driver Code\nconst mat = [\n    [1, 5, 9],\n    [14, 20, 21],\n    [30, 34, 43]\n];\nconst x = 14;\n\nif (searchMatrix(mat, x))\n    console.log(\"true\");\nelse\n    console.log(\"false\");\n\n````\n\n\n\n\n**Output**\n```\ntrue\n```\n### ****[Expected Approach] Using Binary Search Once \u2013**** O(log(n\\*m)) and O(1) Space\n\n> The idea is to\n>\n> ****consider the given matrix as 1D array****\n> and\n>\n> ****apply****\n> only one\n>\n> ****binary search.****\n> For example, for a matrix of size\n>\n> ****n x m a****\n> nd we can consider it as a\n>\n> ****1D array****\n> of size n\\*m\n>\n> ****,****\n> then the\n>\n> ****first index****\n> would be\n>\n> ****0****\n> and\n>\n> ****last index****\n> would\n>\n> ****n\\*m-1.****\n> So\n>\n> ****,****\n> we need to do binary search from low = 0 to high = (n\\*m-1)\n>\n> ****.****\n>\n> ****How to find the element in 2D matrix corresponding to index = mid?****\n>\n>\n> Since each row of mat[][] will have\n>\n> ****m****\n> elements, so we can find the row of the element as\n>\n> ****(mid / m)****\n> and the column of the element as\n>\n> ****(mid % m)****\n> . Then, we can compare\n>\n> ****x****\n> with\n>\n> ****arr[mid/m][mid%m]****\n> for each mid and complete our binary search.\n\n\n\n\n\n\n\n\n\n\n\n\nC++\n\n````\n// C++ program to search in the sorted matrix using\n// binary search\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool searchMatrix(vector<vector<int>>& mat, int x) {\n    int n = mat.size(), m = mat[0].size();\n\n    int lo = 0, hi = n * m - 1;\n    while (lo <= hi) {\n        int mid = (lo + hi) / 2;\n\n        // Find row and column of element at mid index\n        int row = mid / m;\n        int col = mid % m;\n\n        // If x is found, return true\n        if (mat[row][col] == x)\n            return true;\n\n        // If x is greater than mat[row][col], search in\n        // right half\n        if (mat[row][col] < x)\n            lo = mid + 1;\n\n        // If x is less than mat[row][col], search in\n        // left half\n        else\n            hi = mid - 1;\n    }\n    return false;\n}\n\nint main() {\n    vector<vector<int>> mat = {{1, 5, 9}, {14, 20, 21}, {30, 34, 43}};\n    int x = 14;\n\n    if (searchMatrix(mat, x))\n        cout << \"true\";\n    else\n        cout << \"false\";\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to search in the sorted matrix using\n// binary search\n\nclass GfG {\n\n    // Function to search for x in the matrix using binary search\n    static boolean searchMatrix(int[][] mat, int x) {\n        int n = mat.length, m = mat[0].length;\n\n        int lo = 0, hi = n * m - 1;\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n\n            // Find row and column of element at mid index\n            int row = mid / m;\n            int col = mid % m;\n\n            // If x is found, return true\n            if (mat[row][col] == x)\n                return true;\n\n            // If x is greater than mat[row][col], search in\n            // right half\n            if (mat[row][col] < x)\n                lo = mid + 1;\n\n            // If x is less than mat[row][col], search in\n            // left half\n            else\n                hi = mid - 1;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = {{1, 5, 9}, {14, 20, 21}, {30, 34, 43}};\n        int x = 14;\n\n        if (searchMatrix(mat, x))\n            System.out.println(\"true\");\n        else\n            System.out.println(\"false\");\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to search in the sorted matrix using\n# binary search\n\n# Function to search for x in the matrix using binary search\ndef searchMatrix(mat, x):\n    n = len(mat)\n    m = len(mat[0])\n\n    lo, hi = 0, n * m - 1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n\n        # Find row and column of element at mid index\n        row = mid // m\n        col = mid % m\n\n        # If x is found, return true\n        if mat[row][col] == x:\n            return True\n\n        # If x is greater than mat[row][col], search in\n        # right half\n        if mat[row][col] < x:\n            lo = mid + 1\n\n        # If x is less than mat[row][col], search in\n        # left half\n        else:\n            hi = mid - 1\n\n    return False\n\nif __name__ == \"__main__\":\n    mat = [[1, 5, 9], [14, 20, 21], [30, 34, 43]]\n    x = 14\n\n    if searchMatrix(mat, x):\n        print(\"true\")\n    else:\n        print(\"false\")\n\n````\n\nC#\n\n````\n// C# program to search in the sorted matrix using\n// binary search\n\nusing System;\n\nclass GfG {\n\n    // Function to search for x in the matrix using binary search\n    static bool searchMatrix(int[,] mat, int x) {\n        int n = mat.GetLength(0), m = mat.GetLength(1);\n\n        int lo = 0, hi = n * m - 1;\n        while (lo <= hi) {\n            int mid = (lo + hi) / 2;\n\n            // Find row and column of element at mid index\n            int row = mid / m;\n            int col = mid % m;\n\n            // If x is found, return true\n            if (mat[row, col] == x)\n                return true;\n\n            // If x is greater than mat[row, col], search in\n            // right half\n            if (mat[row, col] < x)\n                lo = mid + 1;\n\n            // If x is less than mat[row, col], search in\n            // left half\n            else\n                hi = mid - 1;\n        }\n        return false;\n    }\n\n    static void Main() {\n        int[,] mat = { { 1, 5, 9 }, { 14, 20, 21 }, { 30, 34, 43 } };\n        int x = 14;\n\n        if (searchMatrix(mat, x))\n            Console.WriteLine(\"true\");\n        else\n            Console.WriteLine(\"false\");\n    }\n}\n\n````\n\nJavaScript\n\n````\n// JavaScript program to search in the sorted matrix using\n// binary search\n\n// Function to search for x in the matrix using binary search\nfunction searchMatrix(mat, x) {\n    let n = mat.length, m = mat[0].length;\n\n    let lo = 0, hi = n * m - 1;\n    while (lo <= hi) {\n        let mid = Math.floor((lo + hi) / 2);\n\n        // Find row and column of element at mid index\n        let row = Math.floor(mid / m);\n        let col = mid % m;\n\n        // If x is found, return true\n        if (mat[row][col] === x)\n            return true;\n\n        // If x is greater than mat[row][col], search in\n        // right half\n        if (mat[row][col] < x)\n            lo = mid + 1;\n\n        // If x is less than mat[row][col], search in\n        // left half\n        else\n            hi = mid - 1;\n    }\n    return false;\n}\n\n// Driver Code\nlet mat = [[1, 5, 9], [14, 20, 21], [30, 34, 43]];\nlet x = 14;\n\nif (searchMatrix(mat, x))\n    console.log(\"true\");\nelse\n    console.log(\"false\");\n\n````\n\n\n\n\n**Output**\n```\ntrue\n```",
        "metadata": {
            "lesson_id": "40524f43-e22b-4dcf-9a51-965bd4affe1e",
            "course_id": "4e26b4bd-d406-4641-9d68-3ba8e1c39c97",
            "course_name": "Matrix Data Structure Guide",
            "lesson_description": "",
            "course_description": "The fundamentals and applications of the matrix as a data structure. You\u2019ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming."
        }
    },
    {
        "page_content": "Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.\n\n\n> ****Input:****\n> m1 = {{1, 2},\n>\n>\n>\n> {3, 4}},\n>\n>\n>\n> m2 = {{4, 3},\n>\n>\n>\n> {2, 1}}\n>\n>\n>\n> ****Output:****\n> {{-3, -1},\n>\n>\n>\n> {1, 3}}\n>\n>\n>\n>\n>\n> ****Input:****\n> m1 = {{3, 3, 3},\n>\n>\n>\n> {3, 3, 3}},\n>\n>\n>\n> m1 = {{2, 2, 2},\n>\n>\n>\n> {1, 1, 1}},\n>\n>\n>\n> ****Output:****\n> {{1, 1, 1},\n>\n>\n>\n> {2, 2, 2}},\n\n\nWe traverse both matrices element by element and subtract m2[i][j] from m1[i][j].\n\n\nC++\n\n````\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// This function subtracts m2 from m1 and\n// stores the result in res\nvoid subtract(vector<vector<int>>& m1,\n              vector<vector<int>>& m2,\n              vector<vector<int>>& res)\n{\n    int rows = m1.size();\n    int cols = m1[0].size();\n\n    for (int i = 0; i < rows; i++)\n        for (int j = 0; j < cols; j++)\n            res[i][j] = m1[i][j] - m2[i][j];\n}\n\n// Driver code\nint main()\n{\n    // Define two rectangular matrices\n    vector<vector<int>> m1 = { {1, 2, 3},\n                                {4, 5, 6} };\n    vector<vector<int>> m2 = { {1, 1, 1},\n                                {1, 1, 1} };\n\n    // Result matrix with the same dimensions\n    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));\n\n    // Perform the subtraction\n    subtract(m1, m2, res);\n\n    // Print the result matrix\n    cout << \"Result matrix is:\" << endl;\n    for (auto& row : res)\n    {\n        for (int val : row)\n            cout << val << \" \";\n        cout << endl;\n    }\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n#define R 2 // Number of rows\n#define C 3 // Number of columns\n\n// This function subtracts m2 from m1 and\n// stores the result in res\nvoid subtract(int m1[R][C], int m2[R][C], int res[R][C]) {\n    for (int i = 0; i < R; i++)\n        for (int j = 0; j < C; j++)\n            res[i][j] = m1[i][j] - m2[i][j];\n}\n\n// Driver code\nint main() {\n\n    // Define two rectangular matrices\n    int m1[R][C] = { {1, 2, 3},\n                     {4, 5, 6} };\n    int m2[R][C] = { {1, 1, 1},\n                     {1, 1, 1} };\n\n    // Result matrix with the same dimensions\n    int res[R][C];\n\n    // Perform the subtraction\n    subtract(m1, m2, res);\n\n    // Print the result matrix\n    printf(\"Result matrix is:\\n\");\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++)\n            printf(\"%d \", res[i][j]);\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// This function subtracts m2 from m1 and\n// stores the result in res\npublic class MatrixSubtraction {\n    public static void subtract(int[][] m1, int[][] m2, int[][] res) {\n        int rows = m1.length;\n        int cols = m1[0].length;\n        for (int i = 0; i < rows; i++)\n            for (int j = 0; j < cols; j++)\n                res[i][j] = m1[i][j] - m2[i][j];\n    }\n\n    public static void main(String[] args) {\n        // Define two rectangular matrices\n        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };\n        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };\n\n        // Result matrix with the same dimensions\n        int[][] res = new int[m1.length][m1[0].length];\n\n        // Perform the subtraction\n        subtract(m1, m2, res);\n\n        // Print the result matrix\n        System.out.println(\"Result matrix is:\");\n        for (int[] row : res) {\n            for (int val : row)\n                System.out.print(val + \" \");\n            System.out.println();\n        }\n    }\n}\n\n````\n\nPython\n\n````\n# This function subtracts m2 from m1 and\n# stores the result in res\ndef subtract(m1, m2):\n    rows = len(m1)\n    cols = len(m1[0])\n    res = [[0] * cols for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            res[i][j] = m1[i][j] - m2[i][j]\n    return res\n\n# Driver code\nif __name__ == '__main__':\n\n    # Define two rectangular matrices\n    m1 = [[1, 2, 3], [4, 5, 6]]\n    m2 = [[1, 1, 1], [1, 1, 1]]\n\n    # Perform the subtraction\n    res = subtract(m1, m2)\n\n    # Print the result matrix\n    print(\"Result matrix is:\")\n    for row in res:\n        print(' '.join(map(str, row)))\n\n````\n\nC#\n\n````\nusing System;\nusing System.Collections.Generic;\n\nclass Program {\n    // This function subtracts m2 from m1 and\n    // stores the result in res\n    static void Subtract(int[,] m1, int[,] m2, int[,] res) {\n        int rows = m1.GetLength(0);\n        int cols = m1.GetLength(1);\n\n        for (int i = 0; i < rows; i++)\n            for (int j = 0; j < cols; j++)\n                res[i, j] = m1[i, j] - m2[i, j];\n    }\n\n    // Driver code\n    static void Main() {\n        // Define two rectangular matrices\n        int[,] m1 = { {1, 2, 3},\n                       {4, 5, 6} };\n        int[,] m2 = { {1, 1, 1},\n                       {1, 1, 1} };\n\n        // Result matrix with the same dimensions\n        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];\n\n        // Perform the subtraction\n        Subtract(m1, m2, res);\n\n        // Print the result matrix\n        Console.WriteLine(\"Result matrix is:\");\n        for (int i = 0; i < res.GetLength(0); i++) {\n            for (int j = 0; j < res.GetLength(1); j++)\n                Console.Write(res[i, j] + \" \");\n            Console.WriteLine();\n        }\n    }\n}\n\n````\n\nJavaScript\n\n````\n// This function subtracts m2 from m1 and\nfunction subtract(m1, m2) {\n    const rows = m1.length;\n    const cols = m1[0].length;\n    const res = Array.from({ length: rows }, () => Array(cols).fill(0));\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            res[i][j] = m1[i][j] - m2[i][j];\n        }\n    }\n    return res;\n}\n\n// Driver code\nconst m1 = [[1, 2, 3], [4, 5, 6]];\nconst m2 = [[1, 1, 1], [1, 1, 1]];\n\n// Perform the subtraction\nconst res = subtract(m1, m2);\n\n// Print the result matrix\nconsole.log('Result matrix is:');\nres.forEach(row => {\n    console.log(row.join(' '));\n});\n\n````\n\nPHP\n\n````\n<?php\n// This function subtracts m2 from m1 and\n// stores the result in res\nfunction subtract($m1, $m2) {\n    $rows = count($m1);\n    $cols = count($m1[0]);\n    $res = array();\n\n    for ($i = 0; $i < $rows; $i++) {\n        for ($j = 0; $j < $cols; $j++) {\n            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];\n        }\n    }\n    return $res;\n}\n\n// Driver code\n$m1 = array(array(1, 2, 3),\n            array(4, 5, 6));\n$m2 = array(array(1, 1, 1),\n            array(1, 1, 1));\n\n// Perform the subtraction\n$res = subtract($m1, $m2);\n\n// Print the result matrix\necho \"Result matrix is:\\n\";\nforeach ($res as $row) {\n    echo implode(' ', $row) . \"\\n\";\n}\n?>\n\n````\n\n\n\n\n**Output**\n```\nResult matrix is:\n0 1 2\n3 4 5\n\n```\n\n****Time complexity: O(n****\n****2****\n****)****\n",
        "metadata": {
            "lesson_id": "aaf04cd6-13a7-415f-ac21-67a4c001f409",
            "course_id": "4e26b4bd-d406-4641-9d68-3ba8e1c39c97",
            "course_name": "Matrix Data Structure Guide",
            "lesson_description": "",
            "course_description": "The fundamentals and applications of the matrix as a data structure. You\u2019ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming."
        }
    },
    {
        "page_content": "Collision Resolution Techniques\n-------------------------------\n\n\nThere are mainly two methods to handle collision:\n\n\n1. Separate Chaining\n2. Open Addressing\n\n![Collision-Resolution-Techniques](https://media.geeksforgeeks.org/wp-content/uploads/20240514124402/Collision-Resolution-Techniques.webp)\n\n### 1) Separate Chaining\n\n\nThe idea behind\n\n[Separate Chaining](https://www.geeksforgeeks.org/hashing-set-2-separate-chaining/)\nis to make each cell of the hash table point to a linked list of records that have the same hash function value. Chaining is simple but requires additional memory outside the table.\n\n\n****Example****\n: We have given a hash function and we have to insert some elements in the hash table using a separate chaining method for collision resolution technique.\n\n\n> Hash function = key % 5,\n>\n>\n>\n> Elements = 12, 15, 22, 25 and 37.\n\n\nLet\u2019s see step by step approach to how to solve the above problem:\n\n\n\n\n\n\n\n\n\nHence In this way, the separate chaining method is used as the collision resolution technique.\n\n\n### 2) Open Addressing\n\n\nIn\n\n[open addressing](https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/)\n, all elements are stored in the hash table itself. Each table entry contains either a record or NIL. When searching for an element, we examine the table slots one by one until the desired element is found or it is clear that the element is not in the table.\n\n\n#### 2.a) Linear Probing\n\n\nIn linear probing, the hash table is searched sequentially that starts from the original location of the hash. If in case the location that we get is already occupied, then we check for the next location.\n\n\n****Example:****\nLet us consider a simple hash function as \u201ckey mod 5\u201d and a sequence of keys that are to be inserted are 50, 70, 76, 85, 93.\n\n\n\n\n\n\n\n\n\n\n#### 2.b) Quadratic Probing\n\n\nQuadratic probing is an open addressing scheme in computer programming for resolving hash collisions in hash tables. Quadratic probing operates by taking the original hash index and adding successive values of an arbitrary quadratic polynomial until an open slot is found.\n\n\nThis method is also known as the mid-square method because in this method we look for i\n\n2\n-th probe (slot) in i-th iteration and the value of i = 0, 1, . . . n \u2013 1. We always start from the original hash location. If only the location is occupied then we check the other slots.\n\n\n\nExample: Let us consider table Size = 7, hash function as Hash(x) = x % 7 and collision resolution strategy to be f(i) = i\n\n2\n. Insert = 22, 30, and 50\n\n\n\n\n\n\n\n\n#### 2.c) Double Hashing\n\n\nDouble hashing is a collision resolving technique in\n\n[Open Addressed](https://www.geeksforgeeks.org/hashing-set-3-open-addressing/)\nHash tables. Double hashing make use of two hash function,\n\n\n* The first hash function is\n\n  ****h1(k)****\n  which takes the key and gives out a location on the hash table. But if the new location is not occupied or empty then we can easily place our key.\n* But in case the location is occupied (collision) we will use secondary hash-function\n\n  ****h2(k)****\n  in combination with the first hash-function\n\n  ****h1(k)****\n  to find the new location on the hash table.\n\n\nThis combination of hash functions is of the form\n\n\n> ****h(k, i) = (h1(k) + i \\* h2(k)) % n****\n\n\nwhere\n\n\n* i is a non-negative integer that indicates a collision number,\n* k = element/key which is being hashed\n* n = hash table size.\n\n****Complexity of the Double hashing algorithm:****\n\n> Time complexity: O(n)\n\n****Example:****\nInsert the keys 27, 43, 692, 72 into the Hash Table of size 7. where first hash-function is\n\n****h1\u200b(k) = k mod 7****\nand second hash-function is\n\n****h2(k) = 1 + (k mod 5)****\n\n",
        "metadata": {
            "lesson_id": "0436340a-ef23-4fd2-9d0b-e233b60563e6",
            "course_id": "8ff4ea92-41f2-4d49-b230-0281874efb2d",
            "course_name": "Introduction to DSA II",
            "lesson_description": "In Hashing, hash functions were used to generate hash values. The hash value is used to create an index for the keys in the hash table. The hash function may return the same hash value for two or more keys. When two or more keys have the same hash value, a collision happens. To handle this collision, we use Collision Resolution Techniques",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Basic terminologies of Array\n----------------------------\n\n* ****Array Index:****\n  In an array, elements are identified by their indexes. Array index\n  starts from 0.\n* ****Array element:**** Elements are items stored in an array and can be accessed by their\n  index.\n* ****Array Length:****\n  The length of an array is determined by the number of elements it can\n  contain.\n\nMemory representation of Array\n------------------------------\n\nIn an array, all the elements are stored in contiguous memory\nlocations. So, if we initialize an array, the elements will be allocated\nsequentially in memory. This allows for efficient access and\nmanipulation of elements.\n\n![Memory-Representation-of-Array-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240405101013/Memory-Representation-of-Array-(1).webp)\n\nDeclaration of Array\n--------------------\n\nArrays can be declared in various ways in different languages. For\nbetter illustration, below are some language-specific array\ndeclarations:\n\nC++\n````\n// This array will store integer type element\nint arr[5];\n\n// This array will store char type element\nchar arr[10];\n\n// This array will store float type element\nfloat arr[20];\n\n````\n\nC\n````\n// This array will store integer type element\nint arr[5];\n\n// This array will store char type element\nchar arr[10];\n\n// This array will store float type element\nfloat arr[20];\n\n````\n\nJava\n````\n// This array will store integer type element\nint arr[];\n\n// This array will store char type element\nchar arr[];\n\n// This array will store float type element\nfloat arr[];\n\n````\n\nPython\n````\n# In Python, all types of lists are created same way\narr = []\n\n````\n\nC#\n````\n// This array will store integer type element\nint[] arr;\n\n// This array will store char type element\nchar[] arr2;\n\n// This array will store float type element\nfloat[] arr3;\n\n````\n\n\n\n\n\n\n\nInitialization of Array\n-----------------------\n\nArrays can be initialized in different ways in different languages.\nBelow are some language-specific array initializations:\n\nC++\n````\nint arr[] = { 1, 2, 3, 4, 5 };\nchar arr[5] = { 'a', 'b', 'c', 'd', 'e' };\nfloat arr[10] = { 1.4, 2.0, 24, 5.0, 0.0 };\n\n````\n\nC\n````\nint arr[] = { 1, 2, 3, 4, 5 };\nchar arr[5] = { 'a', 'b', 'c', 'd', 'e' };\nfloat arr[10] = { 1.4, 2.0, 24, 5.0, 0.0 };\n\n````\n\nJava\n````\nint arr[] = { 1, 2, 3, 4, 5 };\nchar arr[] = { 'a', 'b', 'c', 'd', 'e' };\nfloat arr[] = { 1.4f, 2.0f, 24f, 5.0f, 0.0f };\n\n````\n\nPython\n````\n# This list will store integer type elements\narr = [1, 2, 3, 4, 5]\n\n# This list will store character type elements (strings in Python)\narr = ['a', 'b', 'c', 'd', 'e']\n\n# This list will store float type elements\narr = [1.4, 2.0, 24.0, 5.0, 0.0]  # All float values\n\n````\n\nC#\n````\nint[] arr = { 1, 2, 3, 4, 5 };\nchar[] arr = { 'a', 'b', 'c', 'd', 'e' };\nfloat[] arr = { 1.4f, 2.0f, 24f, 5.0f, 0.0f };\n\n````\n\nJavaScript\n````\nlet arr = [ 1, 2, 3, 4, 5 ];\nlet arr = [ 'a', 'b', 'c', 'd', 'e' ];\nlet arr = [ 1.4, 2.0, 24, 5.0, 0.0 ];\n\n````\n\n\n\n\nWhy do we Need Arrays?\n----------------------\n\nAssume there is a class of five students and if we have to keep records\nof their marks in examination then, we can do this by declaring five\nvariables individual and keeping track of records but what if the number\nof students becomes very large, it would be challenging to manipulate\nand maintain the data.\n\nWhat it means is that, we can use normal variables (v1, v2, v3, ..)\nwhen we have a small number of objects. But if we want to store a large\nnumber of instances, it becomes difficult to manage them with normal\nvariables. ****The idea of an array is to represent many instances in one\nvariable****.\n\n\n![Importance-of-Array](https://media.geeksforgeeks.org/wp-content/uploads/20240405123859/Importance-of-Array.webp)\n\nTypes of Arrays\n---------------\n\nArrays can be classified in two ways:\n\n* On the basis of Size\n* On the basis of Dimensions\n\n![Types-of-Arrays](https://media.geeksforgeeks.org/wp-content/uploads/20240731124259/Types-of-Arrays.webp)\n### Types of Arrays on the basis of Size:\n\n****1. Fixed Sized Arrays:****\n\nWe cannot alter or update the size of this array. Here only a fixed\nsize (i,e. the size that is mentioned in square brackets ****[]****) of memory will be allocated for storage. In case, we don\u2019t know the\nsize of the array then if we declare a larger size and store a lesser\nnumber of elements will result in a wastage of memory or we declare a\nlesser size than the number of elements then we won\u2019t get enough memory\nto store all the elements. In such cases, static memory allocation is\nnot preferred.\n\n\nC++\n````\n// Method 1 to create a fixed sized array.\n// Here the memory is allocated at compile time.\nint arr[5];\n// Another way (creation and initialization both)\nint arr2[5] = {1, 2, 3, 4, 5};\n\n// Method 2 to create a fixed sized array\n// Here memory is allocated at run time (Also\n// known as dynamically allocated arrays)\nint *arr = new int[5];\n// Method 1 to create a fixed sized array.\n// Here the memory is allocated at compile time.\nint arr[5];\n// Another way (creation and initialization both)\nint arr2[5] = {1, 2, 3, 4, 5};\n// Method 2 to create a fixed sized array\n// Here memory is allocated at run time (Also\n// known as dynamically allocated arrays)\nint *arr = new int[5];\n````\n\n\n\n\n\n\n\n\n\nC\n````\n// Method 1 to create a fixed sized array.\n// Here the memory is allocated at compile time.\nint arr1[5];\n// Another way (creation and initialization both)\nint arr2[5] = {1, 2, 3, 4, 5};\n\n\n// Method 2 to create a fixed sized array\n// Here memory is allocated at run time (Also\n// known as dynamically allocated arrays)\nint *arr = (int*)malloc(n * sizeof(int));\n\n````\n\nJava\n````\n// Fixed sized array examples\nint[] arr1 = new int [5];\n\n// Another way (Array creation and\n// initialization both)\nint[] arr2 = {1, 2, 3, 4, 5};\n\n````\n\nPython\n````\n# Create a fixed-size list of length 5,\n# initialized with zeros\narr = [0] * 5\n\n# Output the fixed-size list\nprint(arr)\n\n````\n\nC#\n````\n// Fixed sized array examples\nint[] arr1 = new int [5];\n\n// Another way (Array creation and\n// initialization both)\nint[] arr2 = {1, 2, 3, 4, 5};\n\n````\n\n\n\n\n****2. Dynamic Sized Arrays:****\n\nThe size of the array changes as per user requirements during execution\nof code so the coders do not have to worry about sizes. They can add and\nremoved the elements as per the need. The memory is mostly dynamically\nallocated and de-allocated in these arrays.\n\nC++\n````\n#include<vector>\n\n// Dynamic Integer Array\nvector<int> v;\n\n````\n\nC\n````\n// C does not seem to support\n// dynamic sized arrays as of now\n\n````\n\nJava\n````\n// Dynamic Integer Array\nArrayList<Integer> arr = new ArrayList<>();\n\n````\n\nPython\n````\n# Dynamic Array\narr = []\n\n````\n\nC#\n````\n// Similar to Java\nArrayList myList = new ArrayList();\n\n````\n\nJavaScript\n````\n// Dynamic Sized Array\nlet arr = new Array();\n\n````\n\n\n\n\n### Types of Arrays on the basis of Dimensions:\n\n****1. One-dimensional Array(1-D Array):**** You can imagine a 1d array as a row, where elements are stored one\nafter another.\n\n![One-Dimensional-Array(1-D-Array)](https://media.geeksforgeeks.org/wp-content/uploads/20240405123929/One-Dimensional-Array(1-D-Array).webp)\n\n****2. Multi-dimensional Array:****\nA multi-dimensional array is an array with more than one dimension. We\ncan use multidimensional array to store complex data in the form of\ntables, etc. We can have 2-D arrays, 3-D arrays, 4-D arrays and so on.\n\n\n* [****Two-Dimensional Array(2-D Array or Matrix):****](https://www.geeksforgeeks.org/matrix)2-D Multidimensional arrays can be considered as an array of\n  arrays or as a matrix consisting of rows and columns.\n\n![Two-Dimensional-Array(2-D-Array-or-Matrix)](https://media.geeksforgeeks.org/wp-content/uploads/20240408165401/Two-Dimensional-Array(2-D-Array-or-Matrix).webp)\n\n* ****Three-Dimensional Array(3-D Array):**** A 3-D Multidimensional array contains three dimensions, so\n  it can be considered an array of two-dimensional arrays.\n\n![Three-Dimensional-Array(3-D-Array)](https://media.geeksforgeeks.org/wp-content/uploads/20240408165421/Three-Dimensional-Array(3-D-Array).webp)\n\nOperations on Array\n-------------------\n\n### 1. Array Traversal:\n\nArray traversal involves visiting all the elements of the array once.\nBelow is the implementation of Array traversal in different\nLanguages:\n\nC++14\n````\nint arr[] = { 1, 2, 3, 4, 5 };\nint len = sizeof(arr) / sizeof(arr[0]);\n// Traversing over arr[]\nfor (int i = 0; i < len; i++) {\n    cout << arr[i] << \" \";\n\n````\n\nC\n````\nint arr[] = { 1, 2, 3, 4, 5 };\nint len = sizeof(arr) / sizeof(arr[0]);\n// Traversing over arr[]\nfor (int i = 0; i < len; i++) {\n    printf(\"%d \", arr[i]);\n}\n\n````\n\nJava\n````\nint arr[] = { 1, 2, 3, 4, 5 };\n// Traversing over arr[]\nfor (int i = 0; i < arr.length; i++) {\n    System.out.print(arr[i] + \" \");\n\n````\n\nPython\n````\n# This list will store integer type elements\narr = [1, 2, 3, 4, 5]\n\n# Traversing over arr\nfor i in range(len(arr)):\n    print(arr[i], end=\" \")\n\n````\n\nC#\n````\nint[] arr = { 1, 2, 3, 4, 5 };\n// Traversing over arr[]\nfor (int i = 0; i < arr.Length; i++)\n    Console.Write(\" \" + arr[i]);\n\n````\n\nJavaScript\n````\nlet arr = [1, 2, 3, 4, 5]\n// Traversing over arr[]\nfor (let x of arr)\n    console.log(x)\n\n````\n\n### 2. Insertion in Array:\n\nWe can insert one or multiple elements at any position in the array.\nBelow is the implementation of Insertion in Array in different\nlanguages:\n\nC++\n````\n// Function to insert element\n// at a specific position\nvoid insertElement(int arr[], int n, int x, int pos)\n{\n    // shift elements to the right\n    // which are on the right side of pos\n    for (int i = n - 1; i >= pos; i--)\n        arr[i + 1] = arr[i];\n\n    arr[pos] = x;\n}\n\n````\n\nC\n````\n// Function to insert element\n// at a specific position\nvoid insertElement(int arr[], int n, int x, int pos)\n{\n    // shift elements to the right\n    // which are on the right side of pos\n    for (int i = n - 1; i >= pos; i--)\n        arr[i + 1] = arr[i];\n\n    arr[pos] = x;\n}\n\n````\n\nJava\n````\nstatic void insertElement(int arr[], int n, int x, int pos)\n{\n    // shift elements to the right\n    // which are on the right side of pos\n    for (int i = n - 1; i >= pos; i--)\n        arr[i + 1] = arr[i];\n    arr[pos] = x;\n}\n\n````\n\nPython\n````\n# Example usage\narr = [1, 2, 3, 4, 5]\nx = 10  # Element to be inserted\npos = 2  # Position to insert the element\n\narr.insert(pos, x)\n\n# Print the updated list\nprint(\"Updated List:\", arr)\n\n````\n\nC#\n````\nstatic void insertElement(int[] arr, int n, int x, int pos)\n{\n    // shift elements to the right\n    // which are on the right side of pos\n    for (int i = n - 1; i >= pos; i--)\n        arr[i + 1] = arr[i];\n    arr[pos] = x;\n}\n\n````\n\nJavaScript\n````\n// javascript Program to Insert an element\n// at a specific position in an Array\nfunction insertElement(arr, n, x, pos)\n{\n    // shift elements to the right\n    // which are on the right side of pos\n    var i = n - 1;\n    for (i; i >= pos; i--)\n    {\n        arr[i + 1] = arr[i];\n    }\n    arr[pos] = x;\n}\n\n````\n\n\n### 3. Deletion in Array:\n\nWe can delete an element at any index in an array. Below is the\nimplementation of Deletion of element in an array:\n\nC++\n````\n// To search a key to be deleted\nint findElement(int arr[], int n, int key);\n\n// Function to delete an element\nint deleteElement(int arr[], int n, int key)\n{\n    // Find position of element to be deleted\n    int pos = findElement(arr, n, key);\n\n    if (pos == -1) {\n        cout << \"Element not found\";\n        return n;\n    }\n\n    // Deleting element\n    int i;\n    for (i = pos; i < n - 1; i++)\n        arr[i] = arr[i + 1];\n\n    return n - 1;\n}\n\n// Function to implement search operation\nint findElement(int arr[], int n, int key)\n{\n    int i;\n    for (i = 0; i < n; i++)\n        if (arr[i] == key)\n            return i;\n    // Return -1 if key is not found\n    return -1;\n}\n\n````\n\nC\n````\n// C program to implement delete operation in a\n// unsorted array\n#include <stdio.h>\n\n// To search a key to be deleted\nint findElement(int arr[], int n, int key);\n\n// Function to delete an element\nint deleteElement(int arr[], int n, int key)\n{\n    // Find position of element to be deleted\n    int pos = findElement(arr, n, key);\n\n    if (pos == -1) {\n        printf(\"Element not found\");\n        return n;\n    }\n\n    // Deleting element\n    int i;\n    for (i = pos; i < n - 1; i++)\n        arr[i] = arr[i + 1];\n\n    return n - 1;\n}\n\n// Function to implement search operation\nint findElement(int arr[], int n, int key)\n{\n    int i;\n    for (i = 0; i < n; i++)\n        if (arr[i] == key)\n            return i;\n     // Return -1 if key is not found\n    return -1;\n}\n\n````\n\nJava\n````\n// function to search a key to\n    // be deleted\n    static int findElement(int arr[], int n, int key)\n    {\n        int i;\n        for (i = 0; i < n; i++)\n            if (arr[i] == key)\n                return i;\n         // Return -1 if key is not found\n        return -1;\n    }\n\n    // Function to delete an element\n    static int deleteElement(int arr[], int n, int key)\n    {\n        // Find position of element to be\n        // deleted\n        int pos = findElement(arr, n, key);\n\n        if (pos == -1) {\n            System.out.println(\"Element not found\");\n            return n;\n        }\n\n        // Deleting element\n        int i;\n        for (i = pos; i < n - 1; i++)\n            arr[i] = arr[i + 1];\n\n        return n - 1;\n    }\n\n````\n\nPython\n````\n# Initialize a list\narr = [10, 20, 30, 40, 50]\n\n# Value to delete\nkey = 40\n\n# Remove the element with the specified value\n# if present in the list\nif key in arr:\n   arr.remove(key)\nelse:\n   print(\"Element Not Found\")\n\n# Output the modified list\nprint(arr)  # Output: [10, 20, 30, 50]\n\n````\n\nC#\n````\nint findElement(int[] arr, int n, int key)\n{\n\n    int i;\n    for (i = 0; i < n; i++)\n        if (arr[i] == key)\n            return i;\n\n    return -1;\n}\n\n// Function to delete an element\nint deleteElement(int[] arr, int n, int key)\n{\n    // Find position of element\n    // to be deleted\n    int pos = findElement(arr, n, key);\n\n    if (pos == -1) {\n        Console.WriteLine(\"Element not found\");\n        return n;\n    }\n\n    // Deleting element\n    int i;\n    for (i = pos; i < n - 1; i++)\n        arr[i] = arr[i + 1];\n\n    return n - 1;\n}\n\n````\n\nJavaScript\n````\n// function to search a key to  be deleted\nfunction findElement(arr,n,key)\n{\n    let i;\n    for (i = 0; i < n; i++)\n        if (arr[i] == key)\n            return i;\n    return -1;\n}\n\n// Function to delete an element\nfunction deleteElement(arr,n,key)\n{\n    // Find position of element to be deleted\n    let pos = findElement(arr, n, key);\n\n    if (pos == -1)\n    {\n        document.write(\"Element not found\");\n        return n;\n    }\n    // Deleting element\n    let i;\n    for (i = pos; i< n - 1; i++)\n        arr[i] = arr[i + 1];\n    return n - 1;\n}\n\n````\n\n\n\n\n\n\n### 4. Searching in Array:\n\nWe can traverse over an array and search for an element. Below is the\nimplementation of Searching of element in an array:\n\n\nC++\n````\n// Function to implement search operation\nint findElement(int arr[], int n, int key)\n{\n    int i;\n    for (i = 0; i < n; i++)\n        if (arr[i] == key)\n            return i;\n\n    // If the key is not found\n    return -1;\n}\n\n````\n\nC\n````\n// Function to implement search operation\nint findElement(int arr[], int n, int key)\n{\n    int i;\n    for (i = 0; i < n; i++)\n        if (arr[i] == key)\n            return i;\n\n    // If the key is not found\n    return -1;\n}\n\n````\n\nJava\n````\n// Function to implement search operation\nint findElement(int arr[], int n, int key)\n{\n    for (int i = 0; i < n; i++)\n        if (arr[i] == key)\n            return i;\n\n    // If the key is not found\n    return -1;\n}\n\n````\n\nPython\n````\n# Function to implement search operation\ndef find_element(arr, n, key):\n    for i in range(n):\n        if arr[i] == key:\n            return i\n    return -1\n\n````\n\nC#\n````\n// Function to implement\n// search operation\nint findElement(int[] arr, int n, int key)\n{\n    for (int i = 0; i < n; i++)\n        if (arr[i] == key)\n            return i;\n\n    // If the key is not found\n    return -1;\n}\n\n````\n\nJavaScript\n````\n// Function to implement search operation\nfunction findElement( arr, n, key)\n{\n    let i;\n    for (i = 0; i < n; i++)\n        if (arr[i] == key)\n            return i;\n\n    return -1;\n}\n\n````\n\n\nComplexity Analysis of Operations on Array\n------------------------------------------\n\n### Time Complexity:\n\n| Operation | Best Case | Average Case | Worst Case |\n| --- | --- | --- | --- |\n| ****Traversal**** | \u03b8(N) | \u03b8(N) | \u03b8((N) |\n| ****Insertion**** | \u03b8((1) | \u03b8(N) | \u03b8(N) |\n| ****Deletion**** | \u03b8(1) | \u03b8(N) | \u03b8(N) |\n| ****Searching**** | \u03b8(1) | \u03b8(N) | \u03b8(N) |\n\n### Auxiliary Space\n\n| Operation | Best Case | Average Case | Worst Case |\n| --- | --- | --- | --- |\n| ****Traversal**** | \u03b8(1) | \u03b8(1) | \u03b8(1) |\n| ****Insertion**** | \u03b8(1) | \u03b8(N) | \u03b8(N) |\n| ****Deletion**** | \u03b8(1) | \u03b8(N) | \u03b8(N) |\n| ****Searching**** | \u03b8(1) | \u03b8(1) | \u03b8(1) |\n",
        "metadata": {
            "lesson_id": "bdde6e1b-edc4-4731-a95b-bd1a61a42a7d",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "Array is a collection of items of the same variable type that are stored at\ncontiguous memory locations. It is one of the most popular and simple\ndata structures used in programming.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Given a\n\n[matrix](https://www.geeksforgeeks.org/matrix/)\n\n****mat[][]****\nof size\n\n****n x m****\n, the task is to traverse this matrix\n\n[using recursion](https://www.geeksforgeeks.org/recursion/)\n.\n\n\n\n****Examples:****\n\n\n> ****Input:****\n> mat[][] = [[1, 2, 3],\n>\n>\n>\n> [4, 5, 6],\n>\n>\n>\n> [7, 8, 9]]\n>\n>\n>\n> ****Output:****\n> 1 2 3 4 5 6 7 8 9\n>\n>\n>\n>\n>\n> ****Input:****\n> mat[][] = [[11, 12, 13],\n>\n>\n>\n> [14, 15, 16],\n>\n>\n>\n> [17, 18, 19]]\n>\n>\n>\n> ****Output:****\n> 11 12 13 14 15 16 17 18 19\n\n****Approach:****\n\n\n* Check If the current position is in the bottom-right corner of the matrix\n  + Print the value at that position\n  + End the recursion\n* Print the value at the current position\n* Check If the end of the current row has not been reached\n  + Move right\n* Check If the end of the current column has been reached\n  + Move down to the next row\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n//C++ program to traverse the matrix using recursion\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Recursive function to traverse the matrix\nvoid traverse(vector<vector<int>>& mat, int i, int j) {\n\n    // If the current position is the bottom-right\n      // corner of the matrix\n    if (i == mat.size() - 1 && j == mat[0].size() - 1) {\n        cout << mat[i][j] << endl;\n        return;\n    }\n\n    // Print the value at the current position\n    cout << mat[i][j] << \" \";\n\n    // If the end of the current row has\n      // not been reached\n    if (j < mat[0].size() - 1) {\n\n        // Move right\n        traverse(mat, i, j + 1);\n    }\n\n    // If the end of the current column has been reached\n    else if (i < mat.size() - 1) {\n\n        // Move down to the next row\n        traverse(mat, i + 1, 0);\n    }\n}\n\nint main() {\n    vector<vector<int>> mat = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };\n    traverse(mat, 0, 0);\n    return 0;\n}\n\n````\n\nJava\n\n````\n//Java program to traverse the matrix using recursion\nimport java.util.Arrays;\n\nclass GfG {\n\n    // Recursive function to traverse the matrix\n    static void traverse(int[][] mat, int i, int j) {\n\n        // If the current position is the bottom-right\n        // corner of the matrix\n        if (i == mat.length - 1 && j == mat[0].length - 1) {\n            System.out.println(mat[i][j]);\n            return;\n        }\n\n        // Print the value at the current position\n        System.out.print(mat[i][j] + \" \");\n\n        // If the end of the current row has not\n          // been reached\n        if (j < mat[0].length - 1) {\n\n            // Move right\n            traverse(mat, i, j + 1);\n        }\n\n        // If the end of the current column has been reached\n        else if (i < mat.length - 1) {\n\n            // Move down to the next row\n            traverse(mat, i + 1, 0);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[][] mat = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };\n        traverse(mat, 0, 0);\n    }\n}\n\n````\n\nPython\n\n````\n#Python program to traverse the matrix using recursion\ndef traverse(mat, i, j):\n\n    # If the current position is the bottom-\n    # right corner of the matrix\n    if i == len(mat) - 1 and j == len(mat[0]) - 1:\n        print(mat[i][j])\n        return\n\n    # Print the value at the current position\n    print(mat[i][j], end=\" \")\n\n    # If the end of the current row has not\n    # been reached\n    if j < len(mat[0]) - 1:\n\n        # Move right\n        traverse(mat, i, j + 1)\n\n    # If the end of the current column\n    # has been reached\n    elif i < len(mat) - 1:\n\n        # Move down to the next row\n        traverse(mat, i + 1, 0)\n\nmat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\ntraverse(mat, 0, 0)\n\n````\n\nC#\n\n````\n//C# program to traverse the matrix using recursion\nusing System;\n\nclass GfG {\n\n    // Recursive function to traverse the matrix\n    static void Traverse(int[,] mat, int i, int j) {\n        int rows = mat.GetLength(0);\n        int cols = mat.GetLength(1);\n\n        // If the current position is the bottom-right\n          // corner of the matrix\n        if (i == rows - 1 && j == cols - 1) {\n            Console.WriteLine(mat[i, j]);\n            return;\n        }\n\n        // Print the value at the current position\n        Console.Write(mat[i, j] + \" \");\n\n        // If the end of the current row has\n          // not been reached\n        if (j < cols - 1) {\n\n            // Move right\n            Traverse(mat, i, j + 1);\n        }\n\n        // If the end of the current column\n          // has been reached\n        else if (i < rows - 1) {\n\n            // Move down to the next row\n            Traverse(mat, i + 1, 0);\n        }\n    }\n\n    static void Main() {\n\n        int[,] mat = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };\n        Traverse(mat, 0, 0);\n    }\n}\n\n````\n\nJavaScript\n\n````\n//Javascript program to traverse the matrix using recursion\nfunction traverse(mat, i, j) {\n    const rows = mat.length;\n    const cols = mat[0].length;\n\n    // If the current position is the bottom-right\n    // corner of the matrix\n    if (i === rows - 1 && j === cols - 1) {\n        console.log(mat[i][j]);\n        return;\n    }\n\n    // Print the value at the current position\n    console.log(mat[i][j] + \" \");\n\n    // If the end of the current row has not been reached\n    if (j < cols - 1) {\n\n        // Move right\n        traverse(mat, i, j + 1);\n    }\n    // If the end of the current column has been reached\n    else if (i < rows - 1) {\n\n        // Move down to the next row\n        traverse(mat, i + 1, 0);\n    }\n}\n\nconst mat = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\ntraverse(mat, 0, 0);\n\n````\n\n\n\n\n**Output**\n```\n1 2 3 4 5 6 7 8 9\n\n```\n\n****Time Complexity:****\nO(N \\* M)\n\n\n\n****Auxiliary Space:****\nO(M), because of recursive calling\n\n",
        "metadata": {
            "lesson_id": "9d3e7774-66e8-4f47-8589-0f78ccd0f6ea",
            "course_id": "4e26b4bd-d406-4641-9d68-3ba8e1c39c97",
            "course_name": "Matrix Data Structure Guide",
            "lesson_description": "",
            "course_description": "The fundamentals and applications of the matrix as a data structure. You\u2019ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming."
        }
    },
    {
        "page_content": "\nGiven a matrix of size n X m, find the transpose of the matrix.\n\n[Transpose of a matrix](https://www.geeksforgeeks.org/transpose-of-a-matrix/)\nis obtained by changing rows to columns and columns to rows. In other words, transpose of mat[n][m] is obtained by changing mat[i][j] to mat[j][i].\n\n\n****Example:****\n\n> ![matrix-transpose](https://media.geeksforgeeks.org/wp-content/cdn-uploads/matrix-transpose.jpg)\n\n\nFollow the given steps to solve the problem:\n\n\n* Run a nested loop using two integer pointers i and j for 0 <= i < n and 0 <= j < m\n* Set mat[i][j] equal to mat[j][i]\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to store the transpose of mat in res\nvoid transpose(vector<vector<int>>& mat, vector<vector<int>>& res) {\n    int rows = mat.size();\n    int cols = mat[0].size();\n\n    // Resize res to have dimensions swapped\n    res.resize(cols, vector<int>(rows));\n\n    // Fill res with transposed values of mat\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            res[j][i] = mat[i][j];\n        }\n    }\n}\n\n// Driver code\nint main() {\n    vector<vector<int>> mat = {\n        { 1, 2, 3 },\n        { 4, 5, 6 }\n    };\n\n    // Create a result matrix for the transpose\n    vector<vector<int>> res;\n\n    // Function call to calculate the transpose\n    transpose(mat, res);\n\n    // Print the result matrix\n    cout << \"Result matrix is:\\n\";\n    for (auto& row : res) {\n        for (auto& elem : row) {\n            cout << \" \" << elem;\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n\n````\n\nC\n\n````\n// Import necessary libraries\n#include <stdio.h>\n\n// Define macros for matrix dimensions\n#define M 2  // Number of rows in the original matrix\n#define N 3  // Number of columns in the original matrix\n\n// Function to store the transpose of mat in res\nvoid transpose(int mat[M][N], int res[N][M]) {\n\n    // Fill res with transposed values of mat\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            res[j][i] = mat[i][j];\n        }\n    }\n}\n\n// Driver code\nint main() {\n    int mat[M][N] = {\n        { 1, 2, 3 },\n        { 4, 5, 6 }\n    };\n\n    // Create a result matrix for the transpose\n    int res[N][M];\n\n    // Function call to calculate the transpose\n    transpose(mat, res);\n\n    // Print the result matrix\n    printf(\"Result matrix is:\\n\");\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            printf(\"%d \", res[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Import necessary classes\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class TransposeMatrix {\n\n    // Function to store the transpose of mat in res\n    public static void transpose(int[][] mat, int[][] res) {\n        int rows = mat.length;\n        int cols = mat[0].length;\n\n        // Fill res with transposed values of mat\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                res[j][i] = mat[i][j];\n            }\n        }\n    }\n\n    // Driver code\n    public static void main(String[] args) {\n        int[][] mat = {\n            { 1, 2, 3 },\n            { 4, 5, 6 }\n        };\n\n        // Create a result matrix for the transpose\n        int[][] res = new int[mat[0].length][mat.length];\n\n        // Function call to calculate the transpose\n        transpose(mat, res);\n\n        // Print the result matrix\n        System.out.println(\"Result matrix is:\");\n        for (int[] row : res) {\n            System.out.println(Arrays.toString(row));\n        }\n    }\n}\n\n````\n\nPython\n\n````\n# Function to store the transpose of mat in res\ndef transpose(mat):\n\n    # Fill res with transposed values of mat\n    return [[mat[j][i] for j in range(len(mat))] for i in range(len(mat[0]))]\n\n# Driver code\nif __name__ == '__main__':\n    mat = [\n        [1, 2, 3],\n        [4, 5, 6]\n    ]\n\n    # Function call to calculate the transpose\n    res = transpose(mat)\n\n    # Print the result matrix\n    print(\"Result matrix is:\")\n    for row in res:\n        print(\" \".join(map(str, row)))\n\n````\n\nC#\n\n````\n// Function to store the transpose of mat in res\nvoid Transpose(int[][] mat, out int[][] res) {\n    int rows = mat.Length;\n    int cols = mat[0].Length;\n\n    // Resize res to have dimensions swapped\n    res = new int[cols][];\n    for (int i = 0; i < cols; i++) {\n        res[i] = new int[rows];\n    }\n\n    // Fill res with transposed values of mat\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            res[j][i] = mat[i][j];\n        }\n    }\n}\n\n// Driver code\npublic static void Main() {\n    int[][] mat = {\n        new int[] { 1, 2, 3 },\n        new int[] { 4, 5, 6 }\n    };\n\n    // Create a result matrix for the transpose\n    int[][] res;\n\n    // Function call to calculate the transpose\n    Transpose(mat, out res);\n\n    // Print the result matrix\n    Console.WriteLine(\"Result matrix is:\");\n    foreach (var row in res) {\n        foreach (var elem in row) {\n            Console.Write(\" \" + elem);\n        }\n        Console.WriteLine();\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Function to store the transpose of mat in res\nfunction transpose(mat) {\n    let rows = mat.length;\n    let cols = mat[0].length;\n\n    // Create a result matrix for the transpose\n    let res = Array.from({ length: cols }, () => new Array(rows));\n\n    // Fill res with transposed values of mat\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            res[j][i] = mat[i][j];\n        }\n    }\n    return res;\n}\n\n// Driver code\nlet mat = [\n    [ 1, 2, 3 ],\n    [ 4, 5, 6 ]\n];\n\n// Function call to calculate the transpose\nlet res = transpose(mat);\n\n// Print the result matrix\nconsole.log(\"Result matrix is:\");\nfor (let row of res) {\n    console.log(\" \"+ row.join(' '));\n}\n\n````\n\n\n\n\n**Output**\n```\nResult matrix is\n 1 2 3 4\n 1 2 3 4\n 1 2 3 4\n 1 2 3 4\n\n```\n\n****Time complexity:****\nO(m x n).\n\n\n\n****Auxiliary Space:****\nO(m x n)\n\n\n### ****Approach using constant space for Square Matrix****\n\n**This approach works only for square matrices (i.e., \u2013 where no. of rows are equal to the number of columns). This algorithm is also known as an \u201cin-place\u201d algorithm as it uses no extra space to solve the problem.**\n\n\nFollow the given steps to solve the problem:\n\n\n* Run a nested loop using two integer pointers i and j for 0 <= i < N and i+1 <= j < N\n* Swap mat[i][j] with mat[j][i]\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to convert mat to its transpose\nvoid transpose(vector<vector<int>>& mat) {\n    int n = mat.size();\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            swap(mat[i][j], mat[j][i]);\n        }\n    }\n}\n\n// Driver code\nint main() {\n    vector<vector<int>> mat = {\n        { 1, 1, 1, 1 },\n        { 2, 2, 2, 2 },\n        { 3, 3, 3, 3 },\n        { 4, 4, 4, 4 }\n    };\n\n    transpose(mat);\n\n    cout << \"Modified matrix is:\" << endl;\n    for (const auto& row : mat) {\n        for (int elem : row) {\n            cout << elem << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#define N 4\n\n// Function to convert mat to its transpose\nvoid transpose(int mat[N][N]) {\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int temp = mat[i][j];\n            mat[i][j] = mat[j][i];\n            mat[j][i] = temp;\n        }\n    }\n}\n\n// Driver code\nint main() {\n    int mat[N][N] = {\n        { 1, 1, 1, 1 },\n        { 2, 2, 2, 2 },\n        { 3, 3, 3, 3 },\n        { 4, 4, 4, 4 }\n    };\n\n    transpose(mat);\n\n    printf(\"Modified matrix is:\\n\");\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            printf(\"%d \", mat[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n\n````\n\nJava\n\n````\nimport java.util.Arrays;\n\npublic class GfG {\n    static void transpose(int[][] mat) {\n        int n = mat.length;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int temp = mat[i][j];\n                mat[i][j] = mat[j][i];\n                mat[j][i] = temp;\n            }\n        }\n    }\n\n    // Driver code\n    public static void main(String[] args) {\n        int[][] mat = {\n            { 1, 1, 1, 1 },\n            { 2, 2, 2, 2 },\n            { 3, 3, 3, 3 },\n            { 4, 4, 4, 4 }\n        };\n\n        transpose(mat);\n\n        System.out.println(\"Modified matrix is:\");\n        for (int[] row : mat) {\n            System.out.println(Arrays.toString(row));\n        }\n    }\n}\n\n````\n\nPython\n\n````\n# Function to convert mat to its transpose\n\ndef transpose(mat):\n    n = len(mat)\n    for i in range(n):\n        for j in range(i + 1, n):\n            mat[i][j], mat[j][i] = mat[j][i], mat[i][j]\n\n# Driver code\nif __name__ == '__main__':\n    mat = [\n        [1, 1, 1, 1],\n        [2, 2, 2, 2],\n        [3, 3, 3, 3],\n        [4, 4, 4, 4]\n    ]\n\n    transpose(mat)\n\n    print(\"Modified matrix is:\")\n    for row in mat:\n        print(' '.join(map(str, row)))\n\n````\n\nC#\n\n````\nusing System;\n\nclass Program {\n\n    // Function to convert mat to its transpose\n    static void Transpose(int[,] mat) {\n        int n = mat.GetLength(0);\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int temp = mat[i, j];\n                mat[i, j] = mat[j, i];\n                mat[j, i] = temp;\n            }\n        }\n    }\n\n    // Driver code\n    static void Main() {\n        int[,] mat = {\n            { 1, 1, 1, 1 },\n            { 2, 2, 2, 2 },\n            { 3, 3, 3, 3 },\n            { 4, 4, 4, 4 }\n        };\n\n        Transpose(mat);\n\n        Console.WriteLine(\"Modified matrix is:\");\n        for (int i = 0; i < mat.GetLength(0); i++) {\n            for (int j = 0; j < mat.GetLength(1); j++) {\n                Console.Write(mat[i, j] + \" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Function to convert mat to its transpose\nfunction transpose(mat) {\n    let n = mat.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            [mat[i][j], mat[j][i]] = [mat[j][i], mat[i][j]];\n        }\n    }\n}\n\n// Driver code\nconst mat = [\n    [1, 1, 1, 1],\n    [2, 2, 2, 2],\n    [3, 3, 3, 3],\n    [4, 4, 4, 4]\n];\n\ntranspose(mat);\n\nconsole.log(\"Modified matrix is:\");\nmat.forEach(row => {\n    console.log(row.join(' '));\n});\n\n````\n\n\n\n\n**Output**\n```\nModified matrix is\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\n\n```\n\n****Time complexity:****\nO(n\n\n2\n).\n\n\n\n****Auxiliary Space:****\nO(1)\n",
        "metadata": {
            "lesson_id": "86b60543-2809-4779-a1f3-bb6d01a8db8b",
            "course_id": "4e26b4bd-d406-4641-9d68-3ba8e1c39c97",
            "course_name": "Matrix Data Structure Guide",
            "lesson_description": "",
            "course_description": "The fundamentals and applications of the matrix as a data structure. You\u2019ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming."
        }
    },
    {
        "page_content": "\n****Determinant of 2 x 2 Matrix:****\n------------------------------------\n\n![](https://media.geeksforgeeks.org/wp-content/uploads/20220822110357/2x2.png)\n\nDeterminant of 2 x 2 matrix\n\n****Determinant of 3 x 3 Matrix:****\n------------------------------------\n\n![](https://media.geeksforgeeks.org/wp-content/uploads/20220822110402/3x3.png)\n\nDeterminant of 3 x 3 matrix\n\n****How to calculate?****\n-------------------------\n\n\nThe value of the determinant of a matrix can be calculated by the following procedure:\n\n\n* For each element of the first row or first column get the cofactor of those elements.\n* Then multiply the element with the determinant of the corresponding cofactor.\n* Finally, add them with alternate signs. As a base case, the value of the determinant of a 1\\*1 matrix is the single value itself.\n\n\nThe\n\n****cofactor****\nof an element is a matrix that we can get by removing the row and column of that element from that matrix.\n\n\nC++\n\n````\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function for finding the determinant of a matrix.\nint getDet(vector<vector<int>>& mat, int n) {\n\n    // Base case: if the matrix is 1x1\n    if (n == 1) {\n        return mat[0][0];\n    }\n\n    // Base case for 2x2 matrix\n    if (n == 2) {\n        return mat[0][0] * mat[1][1] -\n               mat[0][1] * mat[1][0];\n    }\n\n    // Recursive case for larger matrices\n    int res = 0;\n    for (int col = 0; col < n; ++col) {\n\n        // Create a submatrix by removing the first\n        // row and the current column\n        vector<vector<int>> sub(n - 1, vector<int>(n - 1));\n        for (int i = 1; i < n; ++i) {\n            int subcol = 0;\n            for (int j = 0; j < n; ++j) {\n\n                // Skip the current column\n                if (j == col) continue;\n\n                // Fill the submatrix\n                sub[i - 1][subcol++] = mat[i][j];\n            }\n        }\n\n        // Cofactor expansion\n        int sign = (col % 2 == 0) ? 1 : -1;\n        res += sign * mat[0][col] * getDet(sub, n - 1);\n    }\n\n    return res;\n}\n\n// Driver program to test the above function\nint main() {\n    vector<vector<int>> mat = { { 1, 0, 2, -1 },\n                                 { 3, 0, 0, 5 },\n                                 { 2, 1, 4, -3 },\n                                 { 1, 0, 5, 0 } };\n    cout << getDet(mat, mat.size()) << endl;\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 4\n\n// Function for finding the determinant of a matrix.\nint getDet(int mat[N][N], int n) {\n\n    // Base case: if the matrix is 1x1\n    if (n == 1) {\n        return mat[0][0];\n    }\n\n    // Base case for 2x2 matrix\n    if (n == 2) {\n        return mat[0][0] * mat[1][1] -\n               mat[0][1] * mat[1][0];\n    }\n\n    // Recursive case for larger matrices\n    int res = 0;\n    for (int col = 0; col < n; ++col) {\n\n        // Create a submatrix by removing the\n        // first row and the current column\n        int sub[N][N]; // Submatrix\n        for (int i = 1; i < n; ++i) {\n            int subcol = 0;\n            for (int j = 0; j < n; ++j) {\n\n                // Skip the current column\n                if (j == col) continue;\n\n                // Fill the submatrix\n                sub[i - 1][subcol++] = mat[i][j];\n            }\n        }\n\n        // Cofactor expansion\n        int sign = (col % 2 == 0) ? 1 : -1;\n        res += sign * mat[0][col] * getDet(sub, n - 1);\n    }\n\n    return res;\n}\n\n// Driver program to test the above function\nint main() {\n    int mat[N][N] = { { 1, 0, 2, -1 },\n                      { 3, 0, 0, 5 },\n                      { 2, 1, 4, -3 },\n                      { 1, 0, 5, 0 } };\n    printf(\"%d\\n\", getDet(mat, N));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Function for finding the determinant of a matrix.\npublic class GfG {\n    public static int getDet(int[][] mat, int n) {\n\n        // Base case: if the matrix is 1x1\n        if (n == 1) {\n            return mat[0][0];\n        }\n\n        // Base case for 2x2 matrix\n        if (n == 2) {\n            return mat[0][0] * mat[1][1] -\n                   mat[0][1] * mat[1][0];\n        }\n\n        // Recursive case for larger matrices\n        int res = 0;\n        for (int col = 0; col < n; ++col) {\n\n            // Create a submatrix by removing the first\n            // row and the current column\n            int[][] sub = new int[n - 1][n - 1];\n            for (int i = 1; i < n; ++i) {\n                int subcol = 0;\n                for (int j = 0; j < n; ++j) {\n\n                    // Skip the current column\n                    if (j == col) continue;\n\n                    // Fill the submatrix\n                    sub[i - 1][subcol++] = mat[i][j];\n                }\n            }\n\n            // Cofactor expansion\n            int sign = (col % 2 == 0) ? 1 : -1;\n            res += sign * mat[0][col] * getDet(sub, n - 1);\n        }\n\n        return res;\n    }\n\n    // Driver program to test the above function\n    public static void main(String[] args) {\n        int[][] mat = { { 1, 0, 2, -1 },\n                         { 3, 0, 0, 5 },\n                         { 2, 1, 4, -3 },\n                         { 1, 0, 5, 0 } };\n        System.out.println(getDet(mat, mat.length));\n    }\n}\n\n````\n\nPython\n\n````\n# Function for finding the determinant of a matrix.\ndef getDet(mat, n):\n\n    # Base case: if the matrix is 1x1\n    if n == 1:\n        return mat[0][0]\n\n    # Base case for 2x2 matrix\n    if n == 2:\n        return mat[0][0] * mat[1][1] - \\\n               mat[0][1] * mat[1][0]\n\n    # Recursive case for larger matrices\n    res = 0\n    for col in range(n):\n\n        # Create a submatrix by removing the first\n        # row and the current column\n        sub = [[0] * (n - 1) for _ in range(n - 1)]\n        for i in range(1, n):\n            subcol = 0\n            for j in range(n):\n\n                # Skip the current column\n                if j == col:\n                    continue\n\n                # Fill the submatrix\n                sub[i - 1][subcol] = mat[i][j]\n                subcol += 1\n\n        # Cofactor expansion\n        sign = 1 if col % 2 == 0 else -1\n        res += sign * mat[0][col] * getDet(sub, n - 1)\n\n    return res\n\n# Driver program to test the above function\nmat = [[1, 0, 2, -1],\n       [3, 0, 0, 5],\n       [2, 1, 4, -3],\n       [1, 0, 5, 0]]\nprint(getDet(mat, len(mat)))\n\n````\n\nC#\n\n````\n// Function for finding the determinant of a matrix.\nusing System;\nusing System.Linq;\n\nclass Determinant {\n    public static int GetDet(int[,] mat, int n) {\n\n        // Base case: if the matrix is 1x1\n        if (n == 1) {\n            return mat[0, 0];\n        }\n\n        // Base case for 2x2 matrix\n        if (n == 2) {\n            return mat[0, 0] * mat[1, 1] -\n                   mat[0, 1] * mat[1, 0];\n        }\n\n        // Recursive case for larger matrices\n        int res = 0;\n        for (int col = 0; col < n; col++) {\n\n            // Create a submatrix by removing the first\n            // row and the current column\n            int[,] sub = new int[n - 1, n - 1];\n            for (int i = 1; i < n; i++) {\n                int subcol = 0;\n                for (int j = 0; j < n; j++) {\n\n                    // Skip the current column\n                    if (j == col) continue;\n\n                    // Fill the submatrix\n                    sub[i - 1, subcol++] = mat[i, j];\n                }\n            }\n\n            // Cofactor expansion\n            int sign = (col % 2 == 0) ? 1 : -1;\n            res += sign * mat[0, col] * GetDet(sub, n - 1);\n        }\n\n        return res;\n    }\n\n    // Driver program to test the above function\n    static void Main() {\n        int[,] mat = { { 1, 0, 2, -1 },\n                        { 3, 0, 0, 5 },\n                        { 2, 1, 4, -3 },\n                        { 1, 0, 5, 0 } };\n        Console.WriteLine(GetDet(mat, mat.GetLength(0)));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Function for finding the determinant of a matrix.\nfunction getDet(mat, n) {\n\n    // Base case: if the matrix is 1x1\n    if (n === 1) {\n        return mat[0][0];\n    }\n\n    // Base case for 2x2 matrix\n    if (n === 2) {\n        return mat[0][0] * mat[1][1] -\n               mat[0][1] * mat[1][0];\n    }\n\n    // Recursive case for larger matrices\n    let res = 0;\n    for (let col = 0; col < n; col++) {\n\n        // Create a submatrix by removing the first\n        // row and the current column\n        let sub = Array.from({ length: n - 1 }, () => new Array(n - 1));\n        for (let i = 1; i < n; i++) {\n            let subcol = 0;\n            for (let j = 0; j < n; j++) {\n\n                // Skip the current column\n                if (j === col) continue;\n\n                // Fill the submatrix\n                sub[i - 1][subcol++] = mat[i][j];\n            }\n        }\n\n        // Cofactor expansion\n        let sign = (col % 2 === 0) ? 1 : -1;\n        res += sign * mat[0][col] * getDet(sub, n - 1);\n    }\n\n    return res;\n}\n\n// Driver program to test the above function\nlet mat = [ [ 1, 0, 2, -1 ],\n            [ 3, 0, 0, 5 ],\n            [ 2, 1, 4, -3 ],\n            [ 1, 0, 5, 0 ] ];\nconsole.log(getDet(mat, mat.length));\n\n````\n\n\n\n\n\n\n**Output**\n```\nDeterminant of the matrix is : 30\n```\n\n****Time Complexity:****\nO(n\n\n4\n)\n\n\n\n****Space Complexity:****\nO(n\n\n2\n), Auxiliary space used for storing cofactors.\n\n\n****Note:****\nIn the above recursive approach when the size of the matrix is large it consumes more stack size.\n\n\nDeterminant of a Matrix using Determinant properties:\n-----------------------------------------------------\n\n\nWe calculates the determinant of an\n\n`N x N`\nmatrix using Gaussian elimination and a series of transformations that reduce the matrix to upper triangular form.\n\n\n\n> * Converting the given matrix into an\n>\n>   ****upper triangular matrix****\n>   using determinant properties\n> * The determinant of the upper triangular matrix is the product of all diagonal elements.\n> * Iterating every diagonal element and making all the elements down the diagonal as zero using determinant properties\n> * If the diagonal element is zero then search for the next non-zero element in the same column.\n\n\nThere exist two cases:\n\n\n* ****Case 1:****\n  If there is no non-zero element. In this case, the determinant of a matrix is zero\n* ****Case 2:****\n  If there exists a non-zero element there exist two cases\n  + ****Case A:****\n    If the index is with a respective diagonal row element. Using the determinant properties make all the column elements down to it zero\n  + ****Case B:****\n    Swap the row with respect to the diagonal element column and continue the\n\n    ****Case A****\n    operation.\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n#include <iostream>\n#include <vector>\n#include <cmath> // For pow function\nusing namespace std;\n\n// Function to get determinant of a matrix\nint getDet(vector<vector<int>>& mat) {\n\n    int n = mat.size();\n\n    int num1, num2, det = 1, index, total = 1;\n\n    // Temporary array for storing row\n    vector<int> temp(n + 1);\n\n    // Loop for traversing the diagonal elements\n    for (int i = 0; i < n; i++) {\n        index = i;\n\n        // Finding the index which has non-zero value\n        while (index < n && mat[index][i] == 0) {\n            index++;\n        }\n\n        if (index == n) // If there is no non-zero element\n        {\n            continue; // The determinant of the matrix is zero\n        }\n        if (index != i) {\n\n            // Loop for swapping the diagonal element row and index row\n            for (int j = 0; j < n; j++) {\n                swap(mat[index][j], mat[i][j]);\n            }\n\n            // Determinant sign changes when we shift rows\n            det *= pow(-1, index - i);\n        }\n\n        // Storing the values of diagonal row elements\n        for (int j = 0; j < n; j++) {\n            temp[j] = mat[i][j];\n        }\n\n        // Traversing every row below the diagonal element\n        for (int j = i + 1; j < n; j++) {\n            num1 = temp[i]; // Value of diagonal element\n            num2 = mat[j][i]; // Value of next row element\n\n            // Traversing every column of row and\n            // multiplying to every row\n            for (int k = 0; k < n; k++) {\n\n                // Making the diagonal element and next row element equal\n                mat[j][k] = (num1 * mat[j][k]) - (num2 * temp[k]);\n            }\n            total *= num1;\n        }\n    }\n\n    // Multiplying the diagonal elements to get determinant\n    for (int i = 0; i < n; i++) {\n        det *= mat[i][i];\n    }\n\n    return (det / total); // Det(kA)/k = Det(A);\n}\n\n// Driver code\nint main() {\n    vector<vector<int>> mat = {\n        { 1, 0, 2, -1 },\n        { 3, 0, 0, 5 },\n        { 2, 1, 4, -3 },\n        { 1, 0, 5, 0 }\n    };\n    cout << getDet(mat) << endl;\n    return 0;\n}\n\n````\n\nJava\n\n````\nimport java.util.Arrays;\n\npublic class GfG {\n\n    // Function to get the determinant of a matrix\n    static int getDet(int[][] mat) {\n        int n = mat.length;\n\n        int num1, num2, det = 1, index, total = 1;\n\n        // Temporary array for storing row\n        int[] temp = new int[n + 1];\n\n        // Loop for traversing the diagonal elements\n        for (int i = 0; i < n; i++) {\n            index = i;\n\n            // Finding the index which has a non-zero value\n            while (index < n && mat[index][i] == 0) {\n                index++;\n            }\n            if (index == n) { // If there is no non-zero element\n                continue; // The determinant of the matrix is zero\n            }\n            if (index != i) {\n\n                // Loop for swapping the diagonal element\n                // row and index row\n                for (int j = 0; j < n; j++) {\n                    int tempSwap = mat[index][j];\n                    mat[index][j] = mat[i][j];\n                    mat[i][j] = tempSwap;\n                }\n                // Determinant sign changes when we shift rows\n                det *= Math.pow(-1, index - i);\n            }\n\n            // Storing the values of diagonal row elements\n            for (int j = 0; j < n; j++) {\n                temp[j] = mat[i][j];\n            }\n            // Traversing every row below the diagonal element\n            for (int j = i + 1; j < n; j++) {\n                num1 = temp[i]; // Value of diagonal element\n                num2 = mat[j][i]; // Value of next row element\n\n                // Traversing every column of row and multiplying\n                // to every row\n                for (int k = 0; k < n; k++) {\n\n                    // Making the diagonal element and next row\n                    // element equal\n                    mat[j][k] = (num1 * mat[j][k]) - (num2 * temp[k]);\n                }\n                total *= num1;\n            }\n        }\n\n        // Multiplying the diagonal elements to get determinant\n        for (int i = 0; i < n; i++) {\n            det *= mat[i][i];\n        }\n\n        return (det / total); // Det(kA)/k = Det(A);\n    }\n\n    // Driver code\n    public static void main(String[] args) {\n        int[][] mat = {\n            { 1, 0, 2, -1 },\n            { 3, 0, 0, 5 },\n            { 2, 1, 4, -3 },\n            { 1, 0, 5, 0 }\n        };\n        System.out.println(getDet(mat));\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to find Determinant of a matrix\ndef getDet(mat):\n\n    n  = len(mat)\n    temp = [0]*n  # temporary array for storing row\n    total = 1\n    det = 1  # initialize result\n\n    # loop for traversing the diagonal elements\n    for i in range(0, n):\n        index = i  # initialize the index\n\n        # finding the index which has non zero value\n        while(index < n and mat[index][i] == 0):\n            index += 1\n\n        if(index == n):  # if there is non zero element\n            # the determinant of matrix as zero\n            continue\n\n        if(index != i):\n\n            # loop for swapping the diagonal element\n            # row and index row\n            for j in range(0, n):\n                mat[index][j], mat[i][j] = mat[i][j], mat[index][j]\n\n            # determinant sign changes when we shift rows\n            # go through determinant properties\n            det = det*int(pow(-1, index-i))\n\n        # storing the values of diagonal row elements\n        for j in range(0, n):\n            temp[j] = mat[i][j]\n\n        # traversing every row below the diagonal element\n        for j in range(i+1, n):\n            num1 = temp[i]     # value of diagonal element\n            num2 = mat[j][i]   # value of next row element\n\n            # traversing every column of row\n            # and multiplying to every row\n            for k in range(0, n):\n\n                # multiplying to make the diagonal\n                # element and next row element equal\n                mat[j][k] = (num1*mat[j][k]) - (num2*temp[k])\n\n            total = total * num1  # Det(kA)=kDet(A);\n\n    # multiplying the diagonal elements to get determinant\n    for i in range(0, n):\n        det = det*mat[i][i]\n\n    return int(det/total)  # Det(kA)/k=Det(A);\n\n\n# Drivers code\nif __name__ == \"__main__\":\n    # mat=[[6 1 1][4 -2 5][2 8 7]]\n\n    mat = [[1, 0, 2, -1], [3, 0, 0, 5], [2, 1, 4, -3], [1, 0, 5, 0]]\n\n    print(getDet(mat))\n\n````\n\nC#\n\n````\nusing System;\n\nclass MatrixDeterminant\n{\n    // Function to get the determinant of a matrix\n    static int getDet(int[,] mat)\n    {\n        int n = mat.GetLength(0);\n\n        int num1, num2, det = 1, index, total = 1;\n\n        // Temporary array for storing row\n        int[] temp = new int[n + 1];\n\n        // Loop for traversing the diagonal elements\n        for (int i = 0; i < n; i++)\n        {\n            index = i;\n\n            // Finding the index which has a non-zero value\n            while (index < n && mat[index, i] == 0)\n            {\n                index++;\n            }\n\n             // If there is no non-zero element\n            if (index == n)\n            {\n                // The determinant of the matrix is zero\n                continue;\n            }\n            if (index != i)\n            {\n                // Loop for swapping the diagonal element\n                // row and index row\n                for (int j = 0; j < n; j++)\n                {\n                    int tempSwap = mat[index, j];\n                    mat[index, j] = mat[i, j];\n                    mat[i, j] = tempSwap;\n                }\n\n                // Determinant sign changes when we shift rows\n                det *= (int)Math.Pow(-1, index - i);\n            }\n\n            // Storing the values of diagonal row elements\n            for (int j = 0; j < n; j++)\n            {\n                temp[j] = mat[i, j];\n            }\n\n            // Traversing every row below the diagonal element\n            for (int j = i + 1; j < n; j++)\n            {\n                num1 = temp[i]; // Value of diagonal element\n                num2 = mat[j, i]; // Value of next row element\n\n                // Traversing every column of row and multiplying\n                // to every row\n                for (int k = 0; k < n; k++)\n                {\n                    // Making the diagonal element and next row\n                    // element equal\n                    mat[j, k] = (num1 * mat[j, k]) - (num2 * temp[k]);\n                }\n                total *= num1;\n            }\n        }\n\n        // Multiplying the diagonal elements to get determinant\n        for (int i = 0; i < n; i++)\n        {\n            det *= mat[i, i];\n        }\n\n        return (det / total); // Det(kA)/k = Det(A);\n    }\n\n    // Driver code\n    static void Main()\n    {\n        int[,] mat = {\n            { 1, 0, 2, -1 },\n            { 3, 0, 0, 5 },\n            { 2, 1, 4, -3 },\n            { 1, 0, 5, 0 }\n        };\n        Console.WriteLine(getDet(mat));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Function to get the determinant of a matrix\nfunction determinantOfMatrix(mat) {\n    const n = mat.length;\n    let det = 1;\n    let total = 1;\n\n    // Temporary array for storing row\n    const temp = new Array(n + 1).fill(0);\n\n    // Loop for traversing the diagonal elements\n    for (let i = 0; i < n; i++) {\n        let index = i;\n\n        // Finding the index which has a non-zero value\n        while (index < n && mat[index][i] === 0) {\n            index++;\n        }\n        if (index === n) {\n            continue; // The determinant of the matrix is zero\n        }\n        if (index !== i) {\n\n            // Swapping the diagonal element row and index row\n            for (let j = 0; j < n; j++) {\n                [mat[index][j], mat[i][j]] = [mat[i][j], mat[index][j]];\n            }\n\n            // Determinant sign changes when we shift rows\n            det *= Math.pow(-1, index - i);\n        }\n\n        // Storing the values of diagonal row elements\n        for (let j = 0; j < n; j++) {\n            temp[j] = mat[i][j];\n        }\n\n        // Traversing every row below the diagonal element\n        for (let j = i + 1; j < n; j++) {\n            const num1 = temp[i]; // Value of diagonal element\n            const num2 = mat[j][i]; // Value of next row element\n\n            // Traversing every column of row and multiplying\n            // to every row\n            for (let k = 0; k < n; k++) {\n\n                // Making the diagonal element and next row\n                // element equal\n                mat[j][k] = (num1 * mat[j][k]) - (num2 * temp[k]);\n            }\n            total *= num1;\n        }\n    }\n\n    // Multiplying the diagonal elements to get determinant\n    for (let i = 0; i < n; i++) {\n        det *= mat[i][i];\n    }\n\n    return (det / total); // Det(kA)/k = Det(A);\n}\n\n// Driver code\nconst mat = [\n    [1, 0, 2, -1],\n    [3, 0, 0, 5],\n    [2, 1, 4, -3],\n    [1, 0, 5, 0]\n];\nconsole.log(determinantOfMatrix(mat));\n\n````\n\n\n\n\n**Output**\n```\nDeterminant of the matrix is : 30\n```\n\n****Time complexity:****\nO(n\n\n3\n)\n\n\n\n****Auxiliary Space:****\nO(n), Space used for storing row.\n\n\n\n\n\n****Determinant of a Matrix****\n-------------------------------\n\n\nThere is a built-in function or method in\n\n****linalg****\nmodule of\n\n****NumPy****\npackage in python. It can be called\n\n****numpy.linalg.det(mat)****\nwhich returns the determinant value of the matrix mat passed in the argument.\n\n\nPython\n\n````\n# importing the numpy package\n# as np\nimport numpy as np\n\ndef determinant(mat):\n\n    # calling the det() method\n    det = np.linalg.det(mat)\n    return round(det)\n\n# Driver Code\n# declaring the matrix\nmat = [[1, 0, 2, -1],\n       [3, 0, 0, 5],\n       [2, 1, 4, -3],\n       [1, 0, 5, 0]]\n\n# Function call\nprint('Determinant of the matrix is:',\n      determinant(mat))\n\n````\n\n****Output:****\n\n```\nDeterminant of the matrix is: 30\n```\n\n****Time Complexity:****\nO(n\n\n3\n), as the time complexity of np.linalg.det is O(n\n\n3\n) for an n x n order matrix.\n\n\n\n****Auxiliary Space:****\nO(1)\n",
        "metadata": {
            "lesson_id": "ea4cc83e-26cf-46c3-84f6-5b4086825afb",
            "course_id": "4e26b4bd-d406-4641-9d68-3ba8e1c39c97",
            "course_name": "Matrix Data Structure Guide",
            "lesson_description": "The determinant of a Matrix is defined as a special number that is defined only for square matrices (matrices that have the same number of rows and columns). A determinant is used in many places in calculus and other matrices related to algebra, it actually represents the matrix in terms of a real number which can be used in solving a system of a linear equation and finding the inverse of a matrix.",
            "course_description": "The fundamentals and applications of the matrix as a data structure. You\u2019ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming."
        }
    },
    {
        "page_content": "Given a square matrix, find the adjoint and\n\n[inverse](https://www.geeksforgeeks.org/inverse-of-matrix/)\nof the matrix. We strongly recommend you to refer\n\n[determinant of matrix](https://www.geeksforgeeks.org/determinant-of-a-matrix/)\nas a prerequisite for this.\n\n\n****Adjoint****\n(or Adjugate) of a matrix is the matrix obtained by taking the transpose of the cofactor matrix of a given square matrix is called its Adjoint or Adjugate matrix. The Adjoint of any square matrix \u2018A\u2019 (say) is represented as Adj(A).\n\n\n****Example:****\n\n\n```\n5  -2  2  7\n1   0  0  3\n-3  1  5  0\n3  -1 -9  4\nFor instance, the cofactor of the top left corner '5' is\n + |0   0   3|\n...|1   5   0| = 3(1 * -9 - (-1) * 5) = -12.\n...|-1 -9   4|\n(The minor matrix is formed by deleting the row\n and column of the given entry.)\nAs another sample, the cofactor of the top row corner '-2' is\n  -|1   0  3|\n...|-3  5  0| = - [1 (20 - 0) - 0 + 3 (27 - 15)] = -56.\n...|3  -9  4|\nProceeding like this, we obtain the matrix\n[-12  -56   4   4]\n[76   208   4   4]\n[-60  -82  -2  20]\n[-36  -58  -10 12]\nFinally, to get the adjoint, just take the previous\nmatrix's transpose:\n[-12   76 -60  -36]\n[-56  208 -82  -58]\n[4     4   -2  -10]\n[4     4   20   12]\n```\n\n****Important properties:****\n\n\nProduct of a square matrix A with its adjoint yields a diagonal matrix, where each diagonal entry is equal to determinant of A.\n\n\n\ni.e.\n\n\n```\nA.adj(A) = det(A).I\nI  => Identity matrix of same order as of A.\ndet(A) => Determinant value of A\n```\n\n\nA non-zero square matrix \u2018A\u2019 of order n is said to be\n\n****invertible****\nif there exists a unique square matrix \u2018B\u2019 of order n such that,\n\n\n```\nA.B = B.A = I\nThe matrix 'B' is said to be inverse of 'A'.\ni.e.,  B = A-1\n    ```\n\n* adj(AB) = (adj B).(adj A)\n* adj( k A) = k\n\n  n-1\n  adj(A)\n* A\n\n  -1\n  = (adj A) / |A|\n* (A\n\n  -1\n  )\n\n  -1\n  = A\n* (AB)\n\n  -1\n  = B\n\n  -1\n  A\n\n  -1\n\n****How to find Adjoint?****\n\n\n\nWe follow the definition given above.\n\n\n```\nLet A[N][N] be input matrix.\n1) Create a matrix adj[N][N] store the adjoint matrix.\n2) For every entry A[i][j] in input matrix where 0 <= i < N\n                                             and 0 <= j < N.\n    a) Find cofactor of A[i][j]\n    b) Find sign of entry.  Sign is + if (i+j) is even else\n    sign is odd.\n    c) Place the cofactor at adj[j][i]\n    ```\n\n    ****How to find Inverse?****\n\n\n    Inverse of a matrix exists only if the matrix is non-singular i.e., determinant should not be 0.\n\n\n\n    Using determinant and adjoint, we can easily find the inverse of a square matrix using the below formula,\n\n\n    ```\n    If det(A) != 0\n    A-1 = adj(A)/det(A)\n    Else\n    \"Inverse doesn't exist\"\n    ```\n\n\n    Inverse is used to find the solution to a system of linear equations.\n\n\n    Below are implementations for finding adjoint and inverse of a matrix.\n\n\n    C++\n\n    ````\n    #include <iostream>\n    #include <vector>\n    using namespace std;\n\n    // Function to get cofactor of mat[p][q] in cof[][]. n is\n    // current dimension of mat[][]\n    void getCof(vector<vector<int>>& mat, vector<vector<int>>& cof,\n                                            int p, int q, int n) {\n        int i = 0, j = 0;\n        for (int row = 0; row < n; row++) {\n            for (int col = 0; col < n; col++) {\n                if (row != p && col != q) {\n                    cof[i][j++] = mat[row][col];\n                    if (j == n - 1) {\n                        j = 0;\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n\n    // Recursive function for finding determinant\n    // of matrix mat of dimension n\n    int getDet(vector<vector<int>>& mat, int n) {\n        if (n == 1) return mat[0][0];\n\n        int det = 0;\n\n        // To store cofactors\n        vector<vector<int>> cof(mat.size(), vector<int>(mat.size()));\n\n        int sign = 1;\n        for (int f = 0; f < n; f++) {\n            getCof(mat, cof, 0, f, n);\n            det += sign * mat[0][f] * getDet(cof, n - 1);\n            sign = -sign;\n        }\n        return det;\n    }\n\n    // Function to get adjoint of mat in adj\n    void adjoint(vector<vector<int>>& mat, vector<vector<int>>& adj) {\n        int n = mat.size();\n        if (n == 1) {\n            adj[0][0] = 1;\n            return;\n        }\n\n        int sign = 1;\n        vector<vector<int>> cof(n, vector<int>(n));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                getCof(mat, cof, i, j, n);\n                sign = ((i + j) % 2 == 0) ? 1 : -1;\n                adj[j][i] = sign * getDet(cof, n - 1);\n            }\n        }\n    }\n\n    // Function to calculate and store inverse, returns\n    // false if matrix is singular\n    bool inverse(vector<vector<int>>& mat, vector<vector<float>>& inv) {\n        int n = mat.size();\n        int det = getDet(mat, n);\n        if (det == 0) {\n            cout << \"Singular matrix, can't find its inverse\";\n            return false;\n        }\n\n        vector<vector<int>> adj(n, vector<int>(n));\n        adjoint(mat, adj);\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                inv[i][j] = adj[i][j] / float(det);\n\n        return true;\n    }\n\n    int main() {\n        vector<vector<int>> mat = { { 5, -2, 2, 7 },\n                                    { 1, 0, 0, 3 },\n                                    { -3, 1, 5, 0 },\n                                    { 3, -1, -9, 4 } };\n\n        int n = mat.size();\n        vector<vector<int>> adj(n, vector<int>(n)); // To store adjoint\n        vector<vector<float>> inv(n, vector<float>(n)); // To store inverse\n\n        // Print the input matrix\n        cout << \"Input matrix is:\\n\";\n        for (auto& row : mat) {\n            for (int val : row) cout << val << \" \";\n            cout << endl;\n        }\n\n        // Print the adjoint matrix\n        cout << \"\\nThe Adjoint is:\\n\";\n        adjoint(mat, adj);\n        for (auto& row : adj) {\n            for (int val : row) cout << val << \" \";\n            cout << endl;\n        }\n\n        // Print the inverse matrix if it exists\n        cout << \"\\nThe Inverse is:\\n\";\n        if (inverse(mat, inv)) {\n            for (auto& row : inv) {\n                for (float val : row) cout << val << \" \";\n                cout << endl;\n            }\n        }\n\n        return 0;\n    }\n\n    ````\n\n    C\n\n    ````\n    #include <stdio.h>\n\n    #define N 4\n\n    // Function to get cofactor of mat[p][q] in cof[][]. n is\n    // current dimension of mat[][]\n    void getCof(int mat[N][N], int cof[N][N], int p, int q, int n) {\n        int i = 0, j = 0;\n        for (int row = 0; row < n; row++) {\n            for (int col = 0; col < n; col++) {\n                if (row != p && col != q) {\n                    cof[i][j++] = mat[row][col];\n                    if (j == n - 1) {\n                        j = 0;\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n\n    // Recursive function for finding determinant of matrix mat of dimension n\n    int getDet(int mat[N][N], int n) {\n        if (n == 1) return mat[0][0];\n        int det = 0;\n\n        int cof[N][N];\n        int sign = 1;\n        for (int f = 0; f < n; f++) {\n            getCof(mat, cof, 0, f, n);\n            det += sign * mat[0][f] * getDet(cof, n - 1);\n            sign = -sign;\n        }\n        return det;\n    }\n\n    // Function to get adjoint of mat in adj\n    void adjoint(int mat[N][N], double adj[N][N]) {\n        if (N == 1) {\n            adj[0][0] = 1;\n            return;\n        }\n\n        int sign = 1;\n        int cof[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                getCof(mat, cof, i, j, N);\n                sign = ((i + j) % 2 == 0) ? 1 : -1;\n                adj[j][i] = sign * getDet(cof, N - 1);\n            }\n        }\n    }\n\n    // Function to calculate and store inverse, returns 0 if matrix is singular\n    int inverse(int mat[N][N], double inv[N][N]) {\n        int det = getDet(mat, N);\n        if (det == 0) {\n            printf(\"Singular matrix, can't find its inverse\\n\");\n            return 0;\n        }\n\n        double adj[N][N];\n        adjoint(mat, adj);\n\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                inv[i][j] = adj[i][j] / det;\n\n        return 1;\n    }\n\n    int main() {\n        int mat[N][N] = { { 5, -2, 2, 7 },\n                          { 1, 0, 0, 3 },\n                          { -3, 1, 5, 0 },\n                          { 3, -1, -9, 4 } };\n\n        double adj[N][N];\n        double inv[N][N];\n\n        // Print the input matrix\n        printf(\"Input matrix is:\\n\");\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                printf(\"%d \", mat[i][j]);\n            }\n            printf(\"\\n\");\n        }\n\n        // Print the adjoint matrix\n        printf(\"\\nThe Adjoint is:\\n\");\n        adjoint(mat, adj);\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                printf(\"%lf \", adj[i][j]);\n            }\n            printf(\"\\n\");\n        }\n\n        // Print the inverse matrix if it exists\n        printf(\"\\nThe Inverse is:\\n\");\n        if (inverse(mat, inv)) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    printf(\"%lf \", inv[i][j]);\n                }\n                printf(\"\\n\");\n            }\n        }\n        return 0;\n    }\n\n    ````\n\n    Java\n\n    ````\n    // Importing required classes\n    import java.util.Arrays;\n    import java.util.Scanner;\n\n    public class GfG {\n\n        // Function to get cofactor of mat[p][q] in cof[][]\n        static void getCof(int[][] mat, int[][] cof, int p, int q, int n) {\n            int i = 0, j = 0;\n            for (int row = 0; row < n; row++) {\n                for (int col = 0; col < n; col++) {\n                    if (row != p && col != q) {\n                        cof[i][j++] = mat[row][col];\n                        if (j == n - 1) {\n                            j = 0;\n                            i++;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Recursive function for finding determinant of\n        // matrix mat of dimension n\n        static int getDet(int[][] mat, int n) {\n            if (n == 1) return mat[0][0];\n            int det = 0;\n            int[][] cof = new int[n][n];\n            int sign = 1;\n            for (int f = 0; f < n; f++) {\n                getCof(mat, cof, 0, f, n);\n                det += sign * mat[0][f] * getDet(cof, n - 1);\n                sign = -sign;\n            }\n            return det;\n        }\n\n        // Function to get adjoint of mat in adj\n        static void adjoint(int[][] mat, int[][] adj) {\n            int n = mat.length;\n            if (n == 1) {\n                adj[0][0] = 1;\n                return;\n            }\n            int sign;\n            int[][] cof = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    getCof(mat, cof, i, j, n);\n                    sign = ((i + j) % 2 == 0) ? 1 : -1;\n                    adj[j][i] = sign * getDet(cof, n - 1);\n                }\n            }\n        }\n\n        // Function to calculate and store inverse, returns\n        // false if matrix is singular\n        static boolean inverse(int[][] mat, float[][] inv) {\n            int n = mat.length;\n            int det = getDet(mat, n);\n            if (det == 0) {\n                System.out.println(\"Singular matrix, can't find its inverse\");\n                return false;\n            }\n            int[][] adj = new int[n][n];\n            adjoint(mat, adj);\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    inv[i][j] = (float) adj[i][j] / det;\n            return true;\n        }\n\n        public static void main(String[] args) {\n            int[][] mat = { { 5, -2, 2, 7 }, { 1, 0, 0, 3 },\n                            { -3, 1, 5, 0 }, { 3, -1, -9, 4 } };\n            int n = mat.length;\n            int[][] adj = new int[n][n]; // To store adjoint\n            float[][] inv = new float[n][n]; // To store inverse\n\n            // Print the input matrix\n            System.out.println(\"Input matrix is:\");\n            for (int[] row : mat) {\n                System.out.println(Arrays.toString(row));\n            }\n\n            // Print the adjoint matrix\n            System.out.println(\"\\nThe Adjoint is:\");\n            adjoint(mat, adj);\n            for (int[] row : adj) {\n                System.out.println(Arrays.toString(row));\n            }\n\n            // Print the inverse matrix if it exists\n            System.out.println(\"\\nThe Inverse is:\");\n            if (inverse(mat, inv)) {\n                for (float[] row : inv) {\n                    System.out.println(Arrays.toString(row));\n                }\n            }\n        }\n    }\n\n    ````\n\n    Python\n\n    ````\n    # Function to get cofactor of mat[p][q] in cof[][]\n    def get_cof(mat, cof, p, q, n):\n        i = 0\n        j = 0\n        for row in range(n):\n            for col in range(n):\n                if row != p and col != q:\n                    cof[i][j] = mat[row][col]\n                    j += 1\n                    if j == n - 1:\n                        j = 0\n                        i += 1\n\n    # Recursive function for finding determinant\n    # of matrix mat of dimension n\n    def get_det(mat, n):\n        if n == 1:\n            return mat[0][0]\n        det = 0\n        cof = [[0] * n for _ in range(n)]  # To store cofactors\n        sign = 1\n        for f in range(n):\n            get_cof(mat, cof, 0, f, n)\n            det += sign * mat[0][f] * get_det(cof, n - 1)\n            sign = -sign\n        return det\n\n    # Function to get adjoint of mat in adj\n    def adjoint(mat, adj):\n        n = len(mat)\n        if n == 1:\n            adj[0][0] = 1\n            return\n        sign = 1\n        cof = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                get_cof(mat, cof, i, j, n)\n                sign = 1 if (i + j) % 2 == 0 else -1\n                adj[j][i] = sign * get_det(cof, n - 1)\n\n    # Function to calculate and store inverse, returns\n    # false if matrix is singular\n    def inverse(mat):\n        n = len(mat)\n        det = get_det(mat, n)\n        if det == 0:\n            print(\"Singular matrix, can't find its inverse\")\n            return None\n        adj = [[0] * n for _ in range(n)]\n        adjoint(mat, adj)\n        inv = [[adj[i][j] / det for j in range(n)] for i in range(n)]\n        return inv\n\n    if __name__ == '__main__':\n        mat = [[5, -2, 2, 7], [1, 0, 0, 3], [-3, 1, 5, 0], [3, -1, -9, 4]]\n        n = len(mat)\n        adj = [[0] * n for _ in range(n)]  # To store adjoint\n\n        # Print the input matrix\n        print(\"Input matrix is:\")\n        for row in mat:\n            print(row)\n\n        # Print the adjoint matrix\n        print(\"\\nThe Adjoint is:\")\n        adjoint(mat, adj)\n        for row in adj:\n            print(row)\n\n        # Print the inverse matrix if it exists\n        print(\"\\nThe Inverse is:\")\n        inv = inverse(mat)\n        if inv:\n            for row in inv:\n                print(row)\n\n    ````\n\n    C#\n\n    ````\n    using System;\n\n    class MatrixOperations {\n\n        // Function to get cofactor of mat[p][q] in cof[][]. n is\n        // current dimension of mat[][]\n        static void GetCof(int[,] mat, int[,] cof, int p, int q, int n) {\n            int i = 0, j = 0;\n            for (int row = 0; row < n; row++) {\n                for (int col = 0; col < n; col++) {\n                    if (row != p && col != q) {\n                        cof[i, j++] = mat[row, col];\n                        if (j == n - 1) {\n                            j = 0;\n                            i++;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Recursive function for finding determinant of matrix mat of dimension n\n        static int GetDet(int[,] mat, int n) {\n            if (n == 1) return mat[0, 0];\n            int det = 0;\n\n            // To store cofactors\n            int[,] cof = new int[n, n];\n\n            int sign = 1;\n            for (int f = 0; f < n; f++) {\n                GetCof(mat, cof, 0, f, n);\n                det += sign * mat[0, f] * GetDet(cof, n - 1);\n                sign = -sign;\n            }\n            return det;\n        }\n\n        // Function to get adjoint of mat in adj\n        static void Adjoint(int[,] mat, double[,] adj) {\n            int n = mat.GetLength(0);\n            if (n == 1) {\n                adj[0, 0] = 1;\n                return;\n            }\n\n            int sign = 1;\n            int[,] cof = new int[n, n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    GetCof(mat, cof, i, j, n);\n                    sign = ((i + j) % 2 == 0) ? 1 : -1;\n                    adj[j, i] = sign * GetDet(cof, n - 1);\n                }\n            }\n        }\n\n        // Function to calculate and store inverse, returns false if matrix is singular\n        static bool Inverse(int[,] mat, double[,] inv) {\n            int n = mat.GetLength(0);\n            int det = GetDet(mat, n);\n            if (det == 0) {\n                Console.WriteLine(\"Singular matrix, can't find its inverse\");\n                return false;\n            }\n\n            double[,] adj = new double[n, n];\n            Adjoint(mat, adj);\n\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    inv[i, j] = adj[i, j] / det;\n\n            return true;\n        }\n\n        static void Main() {\n            int[,] mat = new int[,] { { 5, -2, 2, 7 },\n                                       { 1, 0, 0, 3 },\n                                       { -3, 1, 5, 0 },\n                                       { 3, -1, -9, 4 } };\n            int n = mat.GetLength(0);\n            double[,] adj = new double[n, n]; // To store adjoint\n            double[,] inv = new double[n, n]; // To store inverse\n\n            // Print the input matrix\n            Console.WriteLine(\"Input matrix is:\");\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    Console.Write(mat[i, j] + \" \");\n                }\n                Console.WriteLine();\n            }\n\n            // Print the adjoint matrix\n            Console.WriteLine(\"\\nThe Adjoint is:\");\n            Adjoint(mat, adj);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    Console.Write(adj[i, j] + \" \");\n                }\n                Console.WriteLine();\n            }\n\n            // Print the inverse matrix if it exists\n            Console.WriteLine(\"\\nThe Inverse is:\");\n            if (Inverse(mat, inv)) {\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        Console.Write(inv[i, j] + \" \");\n                    }\n                    Console.WriteLine();\n                }\n            }\n        }\n    }\n\n    ````\n\n    JavaScript\n\n    ````\n    // Function to get cofactor of mat[p][q] in cof[][]. n is\n    // current dimension of mat[][]\n    function getCof(mat, cof, p, q, n) {\n        let i = 0, j = 0;\n        for (let row = 0; row < n; row++) {\n            for (let col = 0; col < n; col++) {\n                if (row !== p && col !== q) {\n                    cof[i][j++] = mat[row][col];\n                    if (j === n - 1) {\n                        j = 0;\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n\n    // Recursive function for finding determinant\n    // of matrix mat of dimension n\n    function getDet(mat, n) {\n        if (n === 1) return mat[0][0];\n        let det = 0;\n\n        // To store cofactors\n        let cof = Array.from({ length: mat.length }, () => Array(mat.length).fill(0));\n\n        let sign = 1;\n        for (let f = 0; f < n; f++) {\n            getCof(mat, cof, 0, f, n);\n            det += sign * mat[0][f] * getDet(cof, n - 1);\n            sign = -sign;\n        }\n        return det;\n    }\n\n    // Function to get adjoint of mat in adj\n    function adjoint(mat, adj) {\n        let n = mat.length;\n        if (n === 1) {\n            adj[0][0] = 1;\n            return;\n        }\n\n        let sign = 1;\n        let cof = Array.from({ length: n }, () => Array(n).fill(0));\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                getCof(mat, cof, i, j, n);\n                sign = ((i + j) % 2 === 0) ? 1 : -1;\n                adj[j][i] = sign * getDet(cof, n - 1);\n            }\n        }\n    }\n\n    // Function to calculate and store inverse, returns\n    // false if matrix is singular\n    function inverse(mat, inv) {\n        let n = mat.length;\n        let det = getDet(mat, n);\n        if (det === 0) {\n            console.log(\"Singular matrix, can't find its inverse\");\n            return false;\n        }\n\n        let adj = Array.from({ length: n }, () => Array(n).fill(0));\n        adjoint(mat, adj);\n\n        for (let i = 0; i < n; i++)\n            for (let j = 0; j < n; j++)\n                inv[i][j] = adj[i][j] / det;\n\n        return true;\n    }\n\n    let mat = [ [ 5, -2, 2, 7 ],\n                [ 1, 0, 0, 3 ],\n                [ -3, 1, 5, 0 ],\n                [ 3, -1, -9, 4 ] ];\n\n    let n = mat.length;\n    let adj = Array.from({ length: n }, () => Array(n).fill(0)); // To store adjoint\n    let inv = Array.from({ length: n }, () => Array(n).fill(0)); // To store inverse\n\n    // Print the input matrix\n    console.log(\"Input matrix is:\");\n    mat.forEach(row => {\n        console.log(row.join(' '));\n    });\n\n    // Print the adjoint matrix\n    console.log(\"\\nThe Adjoint is:\");\n    adjoint(mat, adj);\n    adj.forEach(row => {\n        console.log(row.join(' '));\n    });\n\n    // Print the inverse matrix if it exists\n    console.log(\"\\nThe Inverse is:\");\n    if (inverse(mat, inv)) {\n        inv.forEach(row => {\n            console.log(row.join(' '));\n        });\n    }\n\n    ````\n\n\n\n\n    **Output**\n    ```\n    Input matrix is:\n    5 -2 2 7\n    1 0 0 3\n    -3 1 5 0\n    3 -1 -9 4\n\n    The Adjoint is:\n    -12 76 -60 -36\n    -56 208 -82 -58\n    4 4 -2 -10\n    4 4 20 12\n\n    The Inverse is:\n    -0.136364 0.863636 -0.681818 -0.409091\n    -0.636364 2.36364 -0.931818 -0.659091\n    0.0454545 0.0454545 -0.0227273 -0.113636\n    0.0454545 0.0454545 0.227273 0.136364\n\n    ```\n    ",
        "metadata": {
            "lesson_id": "9d98daa6-0e42-485d-be16-d4ef0b03c5c6",
            "course_id": "4e26b4bd-d406-4641-9d68-3ba8e1c39c97",
            "course_name": "Matrix Data Structure Guide",
            "lesson_description": "",
            "course_description": "The fundamentals and applications of the matrix as a data structure. You\u2019ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming."
        }
    },
    {
        "page_content": "****Examples:****\n\n    ```\n    Input: board[] =  {'X', 'X', 'O',\n    'O', 'O', 'X',\n    'X', 'O', 'X'};\nOutput: Valid\nInput: board[] =  {'O', 'X', 'X',\n'O', 'X', 'X',\n'O', 'O', 'X'};\nOutput: Invalid\n(Both X and O cannot win)\nInput: board[] =  {'O', 'X', ' ',\n' ', ' ', ' ',\n' ', ' ', ' '};\nOutput: Valid\n(Valid board with only two moves played)\n\n```\nRecommended Practice\n\n[Tic Tac Toe](https://www.geeksforgeeks.org/problems/tic-tac-toe2412/1/)\n\n\n[Try It!](https://www.geeksforgeeks.org/problems/tic-tac-toe2412/1/)\n\n\nBasically, to find the validity of an input grid, we can think of the conditions when an input grid is invalid. Let no. of \u201cX\u201ds be countX and no. of \u201cO\u201ds be countO. Since we know that the game starts with X, a given grid of Tic-Tac-Toe game would be definitely invalid if following two conditions meet\n\n\n1. countX != countO AND\n2. countX != countO + 1\n   * Since \u201cX\u201d is always the first move, second condition is also required.\n   * Now does it mean that all the remaining board positions are valid one? The answer is NO. Think of the cases when input grid is such that both X and O are making straight lines. This is also not\n   * valid position because the game ends when one player wins. So we need to check the following condition as well\n3. If input grid shows that both the players are in winning situation, it\u2019s an invalid position.\n4. If input grid shows that the player with O has put a straight-line (i.e. is in win condition) and countX != countO, it\u2019s an invalid position. The reason is that O plays his move only after X plays his\n   * move. Since X has started the game, O would win when both X and O has played equal no. of moves.\n5. If input grid shows that X is in winning condition than xCount must be one greater that oCount.\n   * Armed with above conditions i.e. a), b), c) and d), we can now easily formulate an algorithm/program to check the validity of a given Tic-Tac-Toe board position.\n\n```\n1)  countX == countO or countX == countO + 1\n2)  If O is in win condition then check\n     a)     If X also wins, not valid\n     b)     If xbox != obox , not valid\n3)  If X is in win condition then check if xCount is\n     one more than oCount or not\n\n```\n\n\nAnother way to find the validity of a given board is using \u2018inverse method\u2019 i.e. rule out all the possibilities when a given board is invalid.\n\n\nC++\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// C++ program to check whether a given tic tac toe\n// board is valid or not\n#include <iostream>\nusing namespace std;\n\n// This matrix is used to find indexes to check all\n// possible winning triplets in board[0..8]\nint win[8][3] = {{0, 1, 2}, // Check first row.\n{3, 4, 5}, // Check second Row\n{6, 7, 8}, // Check third Row\n{0, 3, 6}, // Check first column\n{1, 4, 7}, // Check second Column\n{2, 5, 8}, // Check third Column\n{0, 4, 8}, // Check first Diagonal\n{2, 4, 6}}; // Check second Diagonal\n\n// Returns true if character 'c' wins. c can be either\n// 'X' or 'O'\nbool isCWin( char *board, char c)\n{\n// Check all possible winning combinations\nfor ( int i=0; i<8; i++)\nif (board[win[i][0]] == c &&\nboard[win[i][1]] == c &&\nboard[win[i][2]] == c )\nreturn true ;\nreturn false ;\n}\n\n// Returns true if given board is valid, else returns false\nbool isValid( char board[9])\n{\n// Count number of 'X' and 'O' in the given board\nint xCount=0, oCount=0;\nfor ( int i=0; i<9; i++)\n{\nif (board[i]== 'X' ) xCount++;\nif (board[i]== 'O' ) oCount++;\n}\n\n// Board can be valid only if either xCount and oCount\n// is same or count is one more than oCount\nif (xCount==oCount || xCount==oCount+1)\n{\n// Check if 'O' is winner\nif (isCWin(board, 'O' ))\n{\n// Check if 'X' is also winner, then\n// return false\nif (isCWin(board, 'X' ))\nreturn false ;\n\n// Else return true xCount and yCount are same\nreturn (xCount == oCount);\n}\n\n// If 'X' wins, then count of X must be greater\nif (isCWin(board, 'X' ) && xCount != oCount + 1)\nreturn false ;\n\n// If 'O' is not winner, then return true\nreturn true ;\n}\nreturn false ;\n}\n\n// Driver program\nint main()\n{\nchar board[] = { 'X' , 'X' , 'O' ,\n'O' , 'O' , 'X' ,\n'X' , 'O' , 'X' };\n(isValid(board))? cout << \"Given board is valid\" :\ncout << \"Given board is not valid\" ;\nreturn 0;\n}\n```\n\n\n\n\n\nJava\n----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// Java program to check whether a given tic tac toe\n// board is valid or not\nimport java.io.*;\nclass GFG {\n\n// This matrix is used to find indexes to check all\n// possible winning triplets in board[0..8]\nstatic int win[][] = {{ 0 , 1 , 2 }, // Check first row.\n{ 3 , 4 , 5 }, // Check second Row\n{ 6 , 7 , 8 }, // Check third Row\n{ 0 , 3 , 6 }, // Check first column\n{ 1 , 4 , 7 }, // Check second Column\n{ 2 , 5 , 8 }, // Check third Column\n{ 0 , 4 , 8 }, // Check first Diagonal\n{ 2 , 4 , 6 }}; // Check second Diagonal\n\n// Returns true if character 'c' wins. c can be either\n// 'X' or 'O'\nstatic boolean isCWin( char [] board, char c) {\n// Check all possible winning combinations\nfor ( int i = 0 ; i < 8 ; i++) {\nif (board[win[i][ 0 ]] == c\n&& board[win[i][ 1 ]] == c\n&& board[win[i][ 2 ]] == c) {\nreturn true ;\n}\n}\nreturn false ;\n}\n\n// Returns true if given board is valid, else returns false\nstatic boolean isValid( char board[]) {\n// Count number of 'X' and 'O' in the given board\nint xCount = 0 , oCount = 0 ;\nfor ( int i = 0 ; i < 9 ; i++) {\nif (board[i] == 'X' ) {\nxCount++;\n}\nif (board[i] == 'O' ) {\noCount++;\n}\n}\n\n// Board can be valid only if either xCount and oCount\n// is same or count is one more than oCount\nif (xCount == oCount || xCount == oCount + 1 ) {\n// Check if 'O' is winner\nif (isCWin(board, 'O' )) {\n// Check if 'X' is also winner, then\n// return false\nif (isCWin(board, 'X' )) {\nreturn false ;\n}\n\n// Else return true xCount and yCount are same\nreturn (xCount == oCount);\n}\n\n// If 'X' wins, then count of X must be greater\nif (isCWin(board, 'X' ) && xCount != oCount + 1 ) {\nreturn false ;\n}\n\n// If 'O' is not winner, then return true\nreturn true ;\n}\nreturn false ;\n}\n\n// Driver program\npublic static void main(String[] args) {\nchar board[] = { 'X' , 'X' , 'O' , 'O' , 'O' , 'X' , 'X' , 'O' , 'X' };\n\nif ((isValid(board))) {\nSystem.out.println( \"Given board is valid\" );\n} else {\nSystem.out.println( \"Given board is not valid\" );\n}\n}\n}\n//this code contributed by PrinciRaj1992\n```\n\n\n\n\n\nPython3\n-------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n# Python3 program to check whether a given tic tac toe\n# board is valid or not\n\n# Returns true if char wins. Char can be either\n# 'X' or 'O'\ndef win_check(arr, char):\n# Check all possible winning combinations\nmatches = [[ 0 , 1 , 2 ], [ 3 , 4 , 5 ],\n[ 6 , 7 , 8 ], [ 0 , 3 , 6 ],\n[ 1 , 4 , 7 ], [ 2 , 5 , 8 ],\n[ 0 , 4 , 8 ], [ 2 , 4 , 6 ]]\n\nfor i in range ( 8 ):\nif (arr[(matches[i][ 0 ])] = = char and\narr[(matches[i][ 1 ])] = = char and\narr[(matches[i][ 2 ])] = = char):\nreturn True\nreturn False\n\ndef is_valid(arr):\n# Count number of 'X' and 'O' in the given board\nxcount = arr.count( 'X' )\nocount = arr.count( 'O' )\n\n# Board can be valid only if either xcount and ocount\n# is same or count is one more than oCount\nif (xcount = = ocount + 1 or xcount = = ocount):\n# Check if O wins\nif win_check(arr, 'O' ):\n# Check if X wins, At a given point only one can win,\n# if X also wins then return Invalid\nif win_check(arr, 'X' ):\nreturn \"Invalid\"\n\n# O can only win if xcount == ocount in case where whole\n# board has values in each position.\nif xcount = = ocount:\nreturn \"Valid\"\n\n# If X wins then it should be xc == oc + 1,\n# If not return Invalid\nif win_check(arr, 'X' ) and xcount ! = ocount + 1 :\nreturn \"Invalid\"\n\n# if O is not the winner return Valid\nif not win_check(arr, 'O' ):\nreturn \"valid\"\n\n# If nothing above matches return invalid\nreturn \"Invalid\"\n\n\n# Driver Code\narr = [ 'X' , 'X' , 'O' ,\n'O' , 'O' , 'X' ,\n'X' , 'O' , 'X' ]\nprint ( \"Given board is \" + is_valid(arr))\n```\n\n\n\n\n\nC#\n--\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// C# program to check whether a given\n// tic tac toe board is valid or not\nusing System;\n\nclass GFG\n{\n\n// This matrix is used to find indexes\n// to check all possible winning triplets\n// in board[0..8]\npublic static int [][] win = new int [][]\n{\nnew int [] {0, 1, 2},\nnew int [] {3, 4, 5},\nnew int [] {6, 7, 8},\nnew int [] {0, 3, 6},\nnew int [] {1, 4, 7},\nnew int [] {2, 5, 8},\nnew int [] {0, 4, 8},\nnew int [] {2, 4, 6}\n};\n\n// Returns true if character 'c'\n// wins. c can be either 'X' or 'O'\npublic static bool isCWin( char [] board,\nchar c)\n{\n// Check all possible winning\n// combinations\nfor ( int i = 0; i < 8; i++)\n{\nif (board[win[i][0]] == c &&\nboard[win[i][1]] == c &&\nboard[win[i][2]] == c)\n{\nreturn true ;\n}\n}\nreturn false ;\n}\n\n// Returns true if given board\n// is valid, else returns false\npublic static bool isValid( char [] board)\n{\n// Count number of 'X' and\n// 'O' in the given board\nint xCount = 0, oCount = 0;\nfor ( int i = 0; i < 9; i++)\n{\nif (board[i] == 'X' )\n{\nxCount++;\n}\nif (board[i] == 'O' )\n{\noCount++;\n}\n}\n\n// Board can be valid only if either\n// xCount and oCount is same or count\n// is one more than oCount\nif (xCount == oCount ||\nxCount == oCount + 1)\n{\n// Check if 'O' is winner\nif (isCWin(board, 'O' ))\n{\n// Check if 'X' is also winner,\n// then return false\nif (isCWin(board, 'X' ))\n{\nreturn false ;\n}\n\n// Else return true xCount\n// and yCount are same\nreturn (xCount == oCount);\n}\n\n// If 'X' wins, then count of\n// X must be greater\nif (isCWin(board, 'X' ) &&\nxCount != oCount + 1)\n{\nreturn false ;\n}\n\n// If 'O' is not winner,\n// then return true\nreturn true ;\n}\nreturn false ;\n}\n\n// Driver Code\npublic static void Main( string [] args)\n{\nchar [] board = new char [] { 'X' , 'X' , 'O' , 'O' , 'O' ,\n'X' , 'X' , 'O' , 'X' };\n\nif ((isValid(board)))\n{\nConsole.WriteLine( \"Given board is valid\" );\n}\nelse\n{\nConsole.WriteLine( \"Given board is not valid\" );\n}\n}\n}\n\n// This code is contributed by Shrikant13\n```\n\n\n\n\n\nJavascript\n----------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n<script>\n// Javascript program to check whether a given\n// tic tac toe board is valid or not\n\n// This matrix is used to find indexes\n// to check all possible winning triplets\n// in board[0..8]\n\n// Returns true if character 'c' wins.\n// c can be either 'X' or 'O'\nfunction isCWin(board, c)\n{\nlet win = new Array( new Array(0, 1, 2), // Check first row.\nnew Array(3, 4, 5), // Check second Row\nnew Array(6, 7, 8), // Check third Row\nnew Array(0, 3, 6), // Check first column\nnew Array(1, 4, 7), // Check second Column\nnew Array(2, 5, 8), // Check third Column\nnew Array(0, 4, 8), // Check first Diagonal\nnew Array(2, 4, 6)); // Check second Diagonal\n\n// Check all possible winning combinations\nfor (let i = 0; i < 8; i++)\nif (board[win[i][0]] == c &&\nboard[win[i][1]] == c &&\nboard[win[i][2]] == c )\nreturn true ;\nreturn false ;\n}\n\n// Returns true if given board is\n// valid, else returns false\nfunction isValid(board)\n{\n// Count number of 'X' and 'O'\n// in the given board\nlet xCount = 0;\nlet oCount = 0;\nfor (let i = 0; i < 9; i++)\n{\nif (board[i] == 'X' ) xCount++;\nif (board[i] == 'O' ) oCount++;\n}\n\n// Board can be valid only if either\n// xCount and oCount is same or count\n// is one more than oCount\nif (xCount == oCount || xCount == oCount + 1)\n{\n// Check if 'O' is winner\nif (isCWin(board, 'O' ))\n{\n// Check if 'X' is also winner,\n// then return false\nif (isCWin(board, 'X' ))\nreturn false ;\n\n// Else return true xCount and\n// yCount are same\nreturn (xCount == oCount);\n}\n\n// If 'X' wins, then count of X\n// must be greater\nif (isCWin(board, 'X' ) &&\nxCount != oCount + 1)\nreturn false ;\n\n// If 'O' is not winner, then\n// return true\nreturn true ;\n}\nreturn false ;\n}\n\n// Driver Code\nlet board = new Array( 'X' , 'X' , 'O' , 'O' ,\n'O' , 'X' , 'X' , 'O' , 'X' );\nif (isValid(board))\ndocument.write( \"Given board is valid\" );\nelse\ndocument.write( \"Given board is not valid\" );\n\n// This code is contributed\n// by Saurabh Jaiswal\n</script>\n```\n\n\n\n\n\nPHP\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n<?php\n// PHP program to check whether a given\n// tic tac toe board is valid or not\n\n// This matrix is used to find indexes\n// to check all possible winning triplets\n// in board[0..8]\n\n// Returns true if character 'c' wins.\n// c can be either 'X' or 'O'\nfunction isCWin( $board , $c )\n{\n$win = array ( array (0, 1, 2), // Check first row.\narray (3, 4, 5), // Check second Row\narray (6, 7, 8), // Check third Row\narray (0, 3, 6), // Check first column\narray (1, 4, 7), // Check second Column\narray (2, 5, 8), // Check third Column\narray (0, 4, 8), // Check first Diagonal\narray (2, 4, 6)); // Check second Diagonal\n\n// Check all possible winning combinations\nfor ( $i = 0; $i < 8; $i ++)\nif ( $board [ $win [ $i ][0]] == $c &&\n$board [ $win [ $i ][1]] == $c &&\n$board [ $win [ $i ][2]] == $c )\nreturn true;\nreturn false;\n}\n\n// Returns true if given board is\n// valid, else returns false\nfunction isValid(& $board )\n{\n// Count number of 'X' and 'O'\n// in the given board\n$xCount = 0;\n$oCount = 0;\nfor ( $i = 0; $i < 9; $i ++)\n{\nif ( $board [ $i ] == 'X' ) $xCount ++;\nif ( $board [ $i ] == 'O' ) $oCount ++;\n}\n\n// Board can be valid only if either\n// xCount and oCount is same or count\n// is one more than oCount\nif ( $xCount == $oCount || $xCount == $oCount + 1)\n{\n// Check if 'O' is winner\nif (isCWin( $board , 'O' ))\n{\n// Check if 'X' is also winner,\n// then return false\nif (isCWin( $board , 'X' ))\nreturn false;\n\n// Else return true xCount and\n// yCount are same\nreturn ( $xCount == $oCount );\n}\n\n// If 'X' wins, then count of X\n// must be greater\nif (isCWin( $board , 'X' ) &&\n$xCount != $oCount + 1)\nreturn false;\n\n// If 'O' is not winner, then\n// return true\nreturn true;\n}\nreturn false;\n}\n\n// Driver Code\n$board = array ( 'X' , 'X' , 'O' , 'O' ,\n'O' , 'X' , 'X' , 'O' , 'X' );\nif (isValid( $board ))\necho ( \"Given board is valid\" );\nelse\necho ( \"Given board is not valid\" );\n\n// This code is contributed\n// by Shivi_Aggarwal\n?>\n```\n\n\n\n\n\n\n\n**Output**\n\n```\nGiven board is valid\n\n\n\n\n\n\n\n```\n\n****Time complexity:****\nO(1)\n\n\n\n****Auxiliary Space:****\nO(1), since no extra space has been taken.\n\n\n****Approach 2:****\n\n\nThe algorithm to check if a Tic-Tac-Toe board is valid or not is as follows:\n\n\n* Initialize a 2D array win of size 8\u00d73, which contains all possible winning combinations in Tic-Tac-Toe. Each row of the win array represents a winning combination, and each element in a row represents a cell index on the board.\n* Define a function isCWin(board, c) which takes a board configuration board and a character c (\u2018X\u2019 or \u2018O\u2019) as inputs, and returns true if character c has won on the board.\n* Inside the isCWin function, iterate over each row of the win array. Check if the board has the same character c at all three cell indices of the current row. If yes, return true, as the character c has won.\n* Define a function isValid(board) which takes a board configuration board as input, and returns true if the board is valid, else returns false.\n* Inside the isValid function, count the number of \u2018X\u2019 and \u2018O\u2019 characters on the board, and store them in xCount and oCount variables, respectively.\n* The board can be valid only if either xCount and oCount are the same, or xCount is one more than oCount.\n* If \u2018O\u2019 is a winner on the board, check if \u2018X\u2019 is also a winner. If yes, return false as both \u2018X\u2019 and \u2018O\u2019 cannot win at the same time. If not, return true if xCount and oCount are the same, else return false.\n* If \u2018X\u2019 is a winner on the board, then xCount must be one more than oCount. If not, return false.\n* If \u2018O\u2019 is not a winner, return true as the board is valid.\n\n\nHere is the code of the above approach:\n\n\nC++\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// Returns true if character 'c' wins. c can be either\n// 'X' or 'O'\n#include<bits/stdc++.h>\nusing namespace std;\nbool isWinner( char *board, char c)\n{\n// Check all possible winning combinations\nif ((board[0] == c && board[1] == c && board[2] == c) ||\n(board[3] == c && board[4] == c && board[5] == c) ||\n(board[6] == c && board[7] == c && board[8] == c) ||\n(board[0] == c && board[3] == c && board[6] == c) ||\n(board[1] == c && board[4] == c && board[7] == c) ||\n(board[2] == c && board[5] == c && board[8] == c) ||\n(board[0] == c && board[4] == c && board[8] == c) ||\n(board[2] == c && board[4] == c && board[6] == c))\nreturn true ;\n\nreturn false ;\n}\n\n// Returns true if given board is valid, else returns false\nbool isValid( char board[9])\n{\n// Count number of 'X' and 'O' in the given board\nint xCount=0, oCount=0;\nfor ( int i=0; i<9; i++)\n{\nif (board[i]== 'X' ) xCount++;\nif (board[i]== 'O' ) oCount++;\n}\n\n// Board can be valid only if either xCount and oCount\n// is same or count is one more than oCount\nif (xCount==oCount || xCount==oCount+1)\n{\n// Check if there is only one winner\nif (isWinner(board, 'X' ) && isWinner(board, 'O' ))\nreturn false ;\n\n// If 'X' wins, then count of X must be greater\nif (isWinner(board, 'X' ) && xCount != oCount + 1)\nreturn false ;\n\n// If 'O' wins, then count of X must be same as oCount\nif (isWinner(board, 'O' ) && xCount != oCount)\nreturn false ;\n\nreturn true ;\n}\nreturn false ;\n}\n\n// Driver program\nint main()\n{\nchar board[] = { 'X' , 'X' , 'O' ,\n'O' , 'O' , 'X' ,\n'X' , 'O' , 'X' };\n(isValid(board))? cout << \"Given board is valid\" :\ncout << \"Given board is not valid\" ;\nreturn 0;\n}\n```\n\n\n\n\n\nJava\n----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nimport java.util.Arrays;\n\npublic class TicTacToe {\n\n// Returns true if character 'c' wins. c can be either 'X' or 'O'\npublic static boolean isWinner( char [] board, char c) {\n// Check all possible winning combinations\nif ((board[ 0 ] == c && board[ 1 ] == c && board[ 2 ] == c) ||\n(board[ 3 ] == c && board[ 4 ] == c && board[ 5 ] == c) ||\n(board[ 6 ] == c && board[ 7 ] == c && board[ 8 ] == c) ||\n(board[ 0 ] == c && board[ 3 ] == c && board[ 6 ] == c) ||\n(board[ 1 ] == c && board[ 4 ] == c && board[ 7 ] == c) ||\n(board[ 2 ] == c && board[ 5 ] == c && board[ 8 ] == c) ||\n(board[ 0 ] == c && board[ 4 ] == c && board[ 8 ] == c) ||\n(board[ 2 ] == c && board[ 4 ] == c && board[ 6 ] == c))\nreturn true ;\n\nreturn false ;\n}\n\n// Returns true if given board is valid, else returns false\npublic static boolean isValid( char [] board) {\n// Count number of 'X' and 'O' in the given board\nint xCount = 0 , oCount = 0 ;\nfor ( int i = 0 ; i < 9 ; i++) {\nif (board[i] == 'X' )\nxCount++;\nif (board[i] == 'O' )\noCount++;\n}\n\n// Board can be valid only if either xCount and oCount is same or count is one more than oCount\nif (xCount == oCount || xCount == oCount + 1 ) {\n// Check if there is only one winner\nif (isWinner(board, 'X' ) && isWinner(board, 'O' ))\nreturn false ;\n\n// If 'X' wins, then count of X must be greater\nif (isWinner(board, 'X' ) && xCount != oCount + 1 )\nreturn false ;\n\n// If 'O' wins, then count of X must be same as oCount\nif (isWinner(board, 'O' ) && xCount != oCount)\nreturn false ;\n\nreturn true ;\n}\nreturn false ;\n}\n\n// Driver program\npublic static void main(String[] args) {\nchar [] board = { 'X' , 'X' , 'O' ,\n'O' , 'O' , 'X' ,\n'X' , 'O' , 'X' };\n\nif (isValid(board))\nSystem.out.println( \"Given board is valid\" );\nelse\nSystem.out.println( \"Given board is not valid\" );\n}\n}\n```\n\n\n\n\n\nPython3\n-------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n# Python Program for the above approach\ndef isWinner(board, c):\n# Check all possible winning combinations\nif (board[ 0 ] = = c and board[ 1 ] = = c and board[ 2 ] = = c) or \\\n(board[ 3 ] = = c and board[ 4 ] = = c and board[ 5 ] = = c) or \\\n(board[ 6 ] = = c and board[ 7 ] = = c and board[ 8 ] = = c) or \\\n(board[ 0 ] = = c and board[ 3 ] = = c and board[ 6 ] = = c) or \\\n(board[ 1 ] = = c and board[ 4 ] = = c and board[ 7 ] = = c) or \\\n(board[ 2 ] = = c and board[ 5 ] = = c and board[ 8 ] = = c) or \\\n(board[ 0 ] = = c and board[ 4 ] = = c and board[ 8 ] = = c) or \\\n(board[ 2 ] = = c and board[ 4 ] = = c and board[ 6 ] = = c):\nreturn True\n\nreturn False\n\n\ndef isValid(board):\n# Count number of 'X' and 'O' in the given board\nxCount = 0\noCount = 0\nfor i in range ( 9 ):\nif board[i] = = 'X' :\nxCount + = 1\nif board[i] = = 'O' :\noCount + = 1\n\n# Board can be valid only if either xCount and oCount\n# is same or count is one more than oCount\nif xCount = = oCount or xCount = = oCount + 1 :\n# Check if there is only one winner\nif isWinner(board, 'X' ) and isWinner(board, 'O' ):\nreturn False\n\n# If 'X' wins, then count of X must be greater\nif isWinner(board, 'X' ) and xCount ! = oCount + 1 :\nreturn False\n\n# If 'O' wins, then count of X must be same as oCount\nif isWinner(board, 'O' ) and xCount ! = oCount:\nreturn False\n\nreturn True\n\nreturn False\n\n\n# Driver program\nboard = [ 'X' , 'X' , 'O' ,\n'O' , 'O' , 'X' ,\n'X' , 'O' , 'X' ]\n\nif isValid(board):\nprint ( \"Given board is valid\" )\nelse :\nprint ( \"Given board is not valid\" )\n# THIS CODE IS CONTRIBUTED BY KIRTI AGARWAL\n```\n\n\n\n\n\nC#\n--\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\nusing System;\n\npublic class TicTacToe {\n\n// Returns true if character 'c' wins. c can be either 'X' or 'O'\npublic static bool IsWinner( char [] board, char c) {\n// Check all possible winning combinations\nif ((board[0] == c && board[1] == c && board[2] == c) ||\n(board[3] == c && board[4] == c && board[5] == c) ||\n(board[6] == c && board[7] == c && board[8] == c) ||\n(board[0] == c && board[3] == c && board[6] == c) ||\n(board[1] == c && board[4] == c && board[7] == c) ||\n(board[2] == c && board[5] == c && board[8] == c) ||\n(board[0] == c && board[4] == c && board[8] == c) ||\n(board[2] == c && board[4] == c && board[6] == c))\nreturn true ;\n\nreturn false ;\n}\n\n// Returns true if given board is valid, else returns false\npublic static bool IsValid( char [] board) {\n// Count number of 'X' and 'O' in the given board\nint xCount = 0, oCount = 0;\nfor ( int i = 0; i < 9; i++) {\nif (board[i] == 'X' )\nxCount++;\nif (board[i] == 'O' )\noCount++;\n}\n\n// Board can be valid only if either xCount and oCount is same or count is one more than oCount\nif (xCount == oCount || xCount == oCount + 1) {\n// Check if there is only one winner\nif (IsWinner(board, 'X' ) && IsWinner(board, 'O' ))\nreturn false ;\n\n// If 'X' wins, then count of X must be greater\nif (IsWinner(board, 'X' ) && xCount != oCount + 1)\nreturn false ;\n\n// If 'O' wins, then count of X must be same as oCount\nif (IsWinner(board, 'O' ) && xCount != oCount)\nreturn false ;\n\nreturn true ;\n}\nreturn false ;\n}\n\n// Driver program\npublic static void Main( string [] args) {\nchar [] board = { 'X' , 'X' , 'O' ,\n'O' , 'O' , 'X' ,\n'X' , 'O' , 'X' };\n\nif (IsValid(board))\nConsole.WriteLine( \"Given board is valid\" );\nelse\nConsole.WriteLine( \"Given board is not valid\" );\n}\n}\n```\n\n\n\n\n\nJavascript\n----------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n// Returns true if character 'c' wins. c can be either 'X' or 'O'\nfunction isWinner(board, c) {\n// Check all possible winning combinations\nif (\n(board[0] === c && board[1] === c && board[2] === c) ||\n(board[3] === c && board[4] === c && board[5] === c) ||\n(board[6] === c && board[7] === c && board[8] === c) ||\n(board[0] === c && board[3] === c && board[6] === c) ||\n(board[1] === c && board[4] === c && board[7] === c) ||\n(board[2] === c && board[5] === c && board[8] === c) ||\n(board[0] === c && board[4] === c && board[8] === c) ||\n(board[2] === c && board[4] === c && board[6] === c)\n) {\nreturn true ;\n}\n\nreturn false ;\n}\n\n// Returns true if given board is valid, else returns false\nfunction isValid(board) {\n// Count number of 'X' and 'O' in the given board\nlet xCount = 0;\nlet oCount = 0;\nfor (let i = 0; i < 9; i++) {\nif (board[i] === 'X' ) xCount++;\nif (board[i] === 'O' ) oCount++;\n}\n\n// Board can be valid only if either xCount and oCount\n// is same or count is one more than oCount\nif (xCount == oCount || xCount == oCount + 1) {\n// Check if there is only one winner\nif (isWinner(board, 'X' ) && isWinner(board, 'O' )) {\nreturn false ;\n}\n\n// If 'X' wins, then count of X must be greater\nif (isWinner(board, 'X' ) && xCount !== oCount + 1) {\nreturn false ;\n}\n\n// If 'O' wins, then count of X must be same as oCount\nif (isWinner(board, 'O' ) && xCount !== oCount) {\nreturn false ;\n}\n\nreturn true ;\n}\n\nreturn false ;\n}\n\n// Driver program\nconst board = [ 'X' , 'X' , 'O' , 'O' , 'O' , 'X' , 'X' , 'O' , 'X' ];\nisValid(board) ? console.log( 'Given board is valid' ) : console.log( 'Given board is not valid' );\n```\n\n\n\n\n\n\n\n**Output**\n```\nGiven board is valid\n\n\n\n\n\n\n\n```\n\n****Time complexity: O(N^2)****\n\n\n****Auxiliary Space: O(N)****\n",
        "metadata": {
            "lesson_id": "610cd734-a640-4ad0-9ed2-9360a01d068a",
            "course_id": "4e26b4bd-d406-4641-9d68-3ba8e1c39c97",
            "course_name": "Matrix Data Structure Guide",
            "lesson_description": "A Tic-Tac-Toe board is given after some moves are played. Find out if the given board is valid, i.e., is it possible to reach this board position after some moves or not.\n",
            "course_description": "The fundamentals and applications of the matrix as a data structure. You\u2019ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming."
        }
    },
    {
        "page_content": "\n****Enqueue**** and when an element is deleted from the queue, then the operation is known as ****Dequeue.**** It is important to know that we cannot insert an element if the size of the queue is full and cannot delete an element when the queue itself is empty. If we try to insert an element even after the queue is full, then such a condition is known as overflow whereas, if we try to delete an element even after the queue is empty then such a condition is known as underflow.\n\n****Primary Queue Operations:****\n\n* ****void enqueue(int Element):**** When this operation is performed, an element is inserted in the queue\n  at the end i.e. at the rear end. (Where T is Generic i.e we can define\n  Queue of any type of data structure.) This operation take ****constant time i.e O(1).****\n* ****int dequeue():****\n  When this operation is performed, an element is removed from the front\n  end and is returned. This operation take ****constant time i.e O(1).****\n\n****Auxiliary Queue Operations:****\n\n* ****int front():**** This operation will return the element at the front without removing\n  it and it take O(1) time.\n* ****int rear():**** This operation will return the element at the rear without removing\n  it, Its Time Complexity is O(1).\n* ****int isEmpty():**** This operation indicates whether the queue is empty or not. This\n  Operation also done in O(1).\n* ****int size():**** This operation will return the size of the queue i.e. the total\n  number of elements present in the queue and it\u2019s time complexity is\n  O(1).\n\n****Types of Queues:****\n\n* ****Simple Queue:**** Simple queue also known as a linear queue is the most basic version\n  of a queue. Here, insertion of an element i.e. the Enqueue operation\n  takes place at the rear end and removal of an element i.e. the Dequeue\n  operation takes place at the front end.\n* ****Circular Queue:****This is mainly an efficient array implementation of Simple Queue. In\n  a circular queue, the element of the queue act as a circular ring. The\n  working of a circular queue is similar to the linear queue except for\n  the fact that the last element is connected to the first element. Its\n  advantage is that the memory is utilized in a better way. This is\n  because if there is an empty space i.e. if no element is present at a\n  certain position in the queue, then an element can be easily added at\n  that position.\n* ****Priority Queue:**** This queue is a special type of queue. Its specialty is that it\n  arranges the elements in a queue based on some priority. The priority\n  can be something where the element with the highest value has the\n  priority so it creates a queue with decreasing order of values. The\n  priority can also be such that the element with the lowest value gets\n  the highest priority so in turn it creates a queue with increasing\n  order of values.\n* ****Dequeue:**** Dequeue is also known as Double Ended Queue. As the name suggests\n  double ended, it means that an element can be inserted or removed from\n  both the ends of the queue unlike the other queues in which it can be\n  done only from one end. Because of this property it may not obey the\n  First In First Out property.\n\n****Implementation of Queue:****\n\n* ****Sequential allocation:**** A queue can be implemented using an array. It can organize a limited\n  number of elements.\n* ****Linked list allocation:****\n  A queue can be implemented using a linked list. It can organize an\n  unlimited number of elements.\n\n****Applications of Queue:****\n\n* ****Multi programming:**** Multi programming means when multiple programs are running in the\n  main memory. It is essential to organize these multiple programs and\n  these multiple programs are organized as queues.\n* ****Network:**** In a network, a queue is used in devices such as a router or a\n  switch. another application of a queue is a mail queue which is a\n  directory that stores data and controls files for mail messages.\n* ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that\n  are scheduled to be executed one after another. These jobs are\n  assigned to the processor one by one which is organized using a\n  queue.\n* ****Shared resources:**** Queues are used as waiting lists for a single shared resource.\n\n****Real-time application of Queue:****\n\n* Working as a buffer between a slow and a fast device. For example\n  keyboard and CPU, and two devices on network.\n* ATM Booth Line\n* Ticket Counter Line\n* CPU task scheduling\n* Waiting time of each customer at call centers.\n\n****Advantages of Queue:****\n\n* A large amount of data can be managed efficiently with ease.\n* Operations such as insertion and deletion can be performed with ease\n  as it follows the first in first out rule.\n* Queues are useful when a particular service is used by multiple\n  consumers.\n* Queues are fast in speed for data inter-process communication.\n* Queues can be used in the implementation of other data\n  structures.\n\n****Disadvantages of Queue:****\n\n* The operations such as insertion and deletion of elements from the\n  middle are time consuming.\n* In a classical queue, a new element can only be inserted when the\n  existing elements are deleted from the queue.\n* Searching an element takes O(N) time.\n* Maximum size of a queue must be defined prior in case of array\n  implementation.\n\n",
        "metadata": {
            "lesson_id": "0f01db32-ffc7-4834-9e6c-2ac158bdbac3",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "A Queue\nis a linear data structure. This data structure follows a particular\norder in which the operations are performed. The order is First In First Out (FIFO). It means that the element that is inserted first in the queue will\ncome out first and the element that is inserted last will come out last.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "What is a Circular Linked List?\n-------------------------------\n\n\nA\n\n****circular linked list****\nis a special type of linked list where all the nodes are connected to form a circle. Unlike a regular linked list, which ends with a node pointing to\n\n****NULL****\n, the last node in a circular linked list points back to the first node. This means that you can keep traversing the list without ever reaching a\n\n****NULL****\nvalue.\n\n\nTypes of Circular Linked Lists\n------------------------------\n\n\nWe can create a circular linked list from both\n\n[singly linked lists](https://www.geeksforgeeks.org/introduction-to-singly-linked-list/)\nand\n\n[doubly linked lists](https://www.geeksforgeeks.org/doubly-linked-list-tutorial-2/)\n. So, circular linked list are basically of two types:\n\n\n### 1. Circular Singly Linked List\n\n\nIn\n\n****Circular Singly Linked List****\n, each node has just one pointer called the \u201c\n\n****next****\n\u201d pointer. The next pointer of\n\n****last node****\npoints back to the\n\n****first node****\nand this results in forming a circle. In this type of Linked list we can only move through the list in one direction.\n\n\n![Representation-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806130914/Representation-of-circular-linked-list.webp)\n\nRepresentation of Circular Singly Linked List\n\n### 2. Circular Doubly Linked List:\n\n\nIn\n\n****circular doubly linked****\n\n****list,****\neach node has two pointers\n\n****prev****\nand\n\n****next,****\nsimilar to doubly linked list. The\n\n****prev****\npointer points to the previous node and the\n\n****next****\npoints to the next node. Here, in addition to the\n\n****last****\nnode storing the address of the first node, the\n\n****first node****\nwill also store the address of the\n\n****last node****\n.\n\n\n![Representation-of-circular-doubly-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806145223/Representation-of-circular-doubly-linked-list.webp)\n\nRepresentation of Circular Doubly Linked List\n\n****Note:****\nIn this article, we will use the circular singly linked list to explain the working of circular linked lists.\n\n\nRepresentation of a Circular Singly Linked List\n-----------------------------------------------\n\n\nLet\u2019s take a look on the structure of a circular linked list.\n\n\n\n\n![Node-structure-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806145414/Node-structure-of-circular-linked-list.webp)\n\nRepresentation of a Circular Singly Linked List\n\n### Create/Declare a Node of Circular Linked List\n\n\nSyntax to Declare a Circular Linked List in Different Languages:\n\n\n\nC++\n\n````\n// Node structure\nstruct Node {\n    int data;\n    Node* next;\n\n    Node(int value){\n        data = value;\n        next = nullptr;\n    }\n};\n\n````\n\nC\n\n````\n// Node structure\nstruct Node\n{\n    int data;\n    struct Node *next;\n};\n\n// Function to create a new node\nstruct Node *createNode(int value){\n\n    // Allocate memory\n    struct Node *newNode =\n      (struct Node *)malloc(sizeof(struct Node));\n\n    // Set the data\n    newNode->data = value;\n\n    // Initialize next to NULL\n    newNode->next = NULL;\n\n    // Return the new node\n    return newNode;\n}\n\n````\n\nJava\n\n````\nclass Node {\n    int data;\n    Node next;\n\n    Node(int data)\n    {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n````\n\nPython\n\n````\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n````\n\nC#\n\n````\npublic class Node {\n    public int data;\n    public Node next;\n\n    public Node(int data){\n        this.data = data;\n        this.next = null;\n    }\n}\n\n````\n\nJavaScript\n\n````\nclass Node {\n    constructor(data)\n    {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n````\n\n\nIn the code above, each node has\n\n****data****\nand a\n\n****pointer****\nto the next node. When we create multiple nodes for a circular linked list, we only need to connect the last node back to the first one.\n\n\nExample of Creating a Circular Linked List\n------------------------------------------\n\n\nHere\u2019s an example of creating a circular linked list with three nodes (2, 3, 4):\n\n\n![Circular-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240806111438/Circular-Linked-List.png)\n\nCreated a circular linked list with 3 nodes\n\n\nC++\n\n````\n// Initilize and allocate memory for nodes\nfirst = new Node(2);\nsecond = new Node(3);\nlast = new Node(4);\n\n// Connect nodes\nfirst->next = second;\nsecond->next = last;\n\n// Connect last node to first node\nlast->next = first;\n\n````\n\nC\n\n````\n// Allocate memory for nodes\nstruct Node *first =\n  (struct Node *)malloc(sizeof(struct Node));\nstruct Node *second =\n  (struct Node *)malloc(sizeof(struct Node));\nstruct Node *last =\n  (struct Node *)malloc(sizeof(struct Node));\n\n// Initilize nodes\nfirst->data = 2;\nsecond->data = 3;\nlast->data = 4;\n\n// Connect nodes\nfirst->next = second;\nsecond->next = last;\nlast->next = first;\n\n````\n\nJava\n\n````\n// Initilize and allocate memory for nodes\nNode first = new Node(2);\nNode second = new Node(3);\nNode last = new Node(4);\n\n// Connect nodes\nfirst.next = second;\nsecond.next = last;\nlast.next = first;\n\n````\n\nPython\n\n````\n# Initilize and allocate memory for nodes\nfirst = Node(2)\nsecond = Node(3)\nlast = Node(4)\n\n# Connect nodes\nfirst.next = second\nsecond.next = last\nlast.next = first\n\n````\n\nC#\n\n````\n// Initilize and allocate memory for nodes\nNode first = new Node(2);\nNode second = new Node(3);\nNode last = new Node(4);\n\n// Connect nodes\nfirst.next = second;\nsecond.next = last;\nlast.next = first;\n\n````\n\nJavaScript\n\n````\n// Initilize and allocate memory for nodes\nlet first = new Node(2);\nlet second = new Node(3);\nlet last = new Node(4);\n\n// Connect nodes\nfirst.next = second;\nsecond.next = last;\nlast.next = first;\n\n````\n\n\n\nIn the above code, we have created three nodes\n\n****first, second,****\nand\n\n****last****\nhaving values\n\n****2, 3,****\nand\n\n****4****\nrespectively.\n\n\n* After creating three nodes, we have connected these node in a series.\n* Connect the first node \u201c\n\n  ****first\u201d****\n  to \u201c\n\n  ****second\u201d****\n  node by\n\n  ****s****\n  toring the address of \u201c\n\n  ****second\u201d****\n  node\n\n\n  into\n\n  ****first\u2019s****\n  next\n* Connect the second node \u201c\n\n  ****second\u201d****\n  to \u201c\n\n  ****second\u201d****\n  node by\n\n  ****s****\n  toring the address of \u201c\n\n  ****third****\n  \u201d node into\n\n  ****second\u2019s****\n  next\n* After connecting all the nodes, we reach the key characteristic of a circular linked list:\n\n  linking the last node back to the first node\n\n\n  . Therefore, we store the address of the \u201c\n\n  ****first****\n  \u201d node in the \u201c\n\n  ****last****\n  \u201d node.\n\n### Why have we taken a pointer that points to the last node instead of the first node?\n\n\nFor the insertion of a node at the beginning, we need to traverse the whole list. Also, for insertion at the end, the whole list has to be traversed. If instead of the start pointer, we take a pointer to the last node, then in both cases there won\u2019t be any need to traverse the whole list. So insertion at the beginning or at the end takes constant time, irrespective of the length of the list.\n\n\nOperations on the Circular Linked list:\n---------------------------------------\n\n\nWe can do some operations on the circular linked list similar to the singly and doubly linked list which are:\n\n\n* ****Insertion****\n  + Insertion at the empty list\n  + Insertion at the beginning\n  + Insertion at the end\n  + Insertion at the given position\n* ****Deletion****\n  + Delete the first node\n  + Delete the last node\n  + Delete the node from any position\n* ****Searching****\n\n****Note:****\nWe will be using the circular singly linked list to represent the working of the circular linked list.\n\n\n[Insertion in the circular linked list:](https://www.geeksforgeeks.org/circular-singly-linked-list-insertion/)\n--------------------------------------------------------------------------------------------------------------\n\n\nInsertion is a fundamental operation in linked lists that involves adding a new node to the list. The only extra step is connecting the last node to the first one. In the circular linked list mentioned below, we can insert nodes in four ways:\n\n\n### 1. Insertion in an empty List in the circular linked list\n\n> To insert a node in empty circular linked list, creates a\n>\n> ****new node****\n> with the given data, sets its next pointer to point to itself, and updates the\n>\n> ****last****\n> pointer to reference this\n>\n> ****new node****\n> .\n\n![Insertion-in-an-empty-list-in-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806193408/Insertion-in-an-empty-list-in-circular-linked-list.webp)\n\nInsertion in an empty List\n\n\nC++\n\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node{\n    int data;\n    Node *next;\n    Node(int value){\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to insert a node into an empty circular singly linked list\nNode *insertInEmptyList(Node *last, int data){\n    if (last != nullptr) return last;\n\n    // Create a new node\n    Node *newNode = new Node(data);\n\n    // Point newNode to itself\n    newNode->next = newNode;\n\n    // Update last to point to the new node\n    last = newNode;\n    return last;\n}\n\nvoid printList(Node* last){\n    if(last == NULL) return;\n\n    // Start from the head node\n    Node* head = last->next;\n    while (true) {\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next) break;\n    }\n    cout << endl;\n}\n\nint main(){\n    Node *last = nullptr;\n\n    // Insert a node into the empty list\n    last = insertInEmptyList(last, 1);\n\n    // Print the list\n    cout << \"List after insertion: \";\n    printList(last);\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the Node structure\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int value);\n\n// Function to insert a node into an empty\n// circular singly linked list\nstruct Node* insertInEmptyList(struct Node* last, int data) {\n    if (last != NULL) return last;\n\n    // Create a new node\n    struct Node* newNode = createNode(data);\n\n    // Update last to point to the new node\n    last = newNode;\n    return last;\n}\n\nvoid printList(struct Node* last) {\n    if (last == NULL) return;\n\n    // Start from the head node\n    struct Node* head = last->next;\n    while (1) {\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next) break;\n    }\n    printf(\"\\n\");\n}\n\nstruct Node* createNode(int value) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = newNode;\n    return newNode;\n}\n\nint main() {\n    struct Node* last = NULL;\n\n    // Insert a node into the empty list\n    last = insertInEmptyList(last, 1);\n\n    // Print the list\n    printf(\"List after insertion: \");\n    printList(last);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\nclass Node {\n    int data;\n    Node next;\n\n    Node(int value) {\n        data = value;\n        next = null;\n    }\n}\n\npublic class Main {\n    // Function to insert a node into an empty\n    // circular singly linked list\n    static Node insertInEmptyList(Node last, int data) {\n        if (last != null) return last;\n\n        // Create a new node\n        Node newNode = new Node(data);\n\n        // Point newNode to itself\n        newNode.next = newNode;\n\n        // Update last to point to the new node\n        last = newNode;\n        return last;\n    }\n\n    // Function to print the list\n    static void printList(Node last) {\n        if (last == null) return;\n\n        // Start from the head node\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next) break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        Node last = null;\n\n        // Insert a node into the empty list\n        last = insertInEmptyList(last, 1);\n\n        // Print the list\n        System.out.print(\"List after insertion: \");\n        printList(last);\n    }\n}\n\n````\n\nPython\n\n````\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = self  # Point to itself\n\ndef insertInEmptyList(last, data):\n    if last is not None:\n        return last\n\n    # Create a new node\n    new_node = Node(data)\n\n    # Update last to point to the new node\n    last = new_node\n    return last\n\ndef printList(last):\n    if last is None:\n        return\n\n    # Start from the head node\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\nif __name__ == \"__main__\":\n    last = None\n\n    # Insert a node into the empty list\n    last = insertInEmptyList(last, 1)\n\n    # Print the list\n    print(\"List after insertion: \", end=\"\")\n    printList(last)\n\n````\n\nJavaScript\n\n````\nclass Node {\n    constructor(value)\n    {\n        this.data = value;\n        this.next = null;\n    }\n}\n\nfunction insertInEmptyList(last, data)\n{\n    if (last !== null)\n        return last;\n\n    // Create a new node\n    let newNode = new Node(data);\n\n    // Point newNode to itself\n    newNode.next = newNode;\n\n    // Update last to point to the new node\n    last = newNode;\n    return last;\n}\n\nfunction printList(last)\n{\n    if (last === null)\n        return;\n\n    // Start from the head node\n    let head = last.next;\n    while (true) {\n        console.log(head.data);\n        head = head.next;\n        if (head === last.next)\n            break;\n    }\n}\n\n// Main function\n\nlet last = null;\n\n// Insert a node into the empty list\nlast = insertInEmptyList(last, 1);\n\n// Print the list\nconsole.log(\"List after insertion:\");\nprintList(last);\n\n````\n\n\n\n\n**Output**\n```\nList after insertion: 1\n\n```\n### 2. Insertion at the beginning in circular linked list\n\n> To insert a new node at the beginning of a circular linked list, we first create the\n>\n> ****new node****\n> and allocate memory for it. If the list is empty (indicated by the last pointer being\n>\n> ****NULL****\n> ), we make the\n>\n> ****new node****\n> point to itself. If the list already contains nodes then we set the\n>\n> ****new node\u2019s****\n> next pointer to point to the\n>\n> ****current head****\n> of the list (which is\n>\n> ****last->next****\n> ), and then update the last node\u2019s next pointer to point to the\n>\n> ****new node****\n> . This maintains the circular structure of the list.\n\n![Insertion-at-the-beginning-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150314/Insertion-at-the-beginning-of-circular-linked-list.webp)\n\nInsertion at the beginning in circular linked list\n\n\nC++\n\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n\n    Node(int value)\n    {\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to insert a node at the beginning of the\n// circular linked list\nNode* insertAtBeginning(Node* last, int value){\n    // Allocate memory for the new node and set its data\n    Node* newNode = new Node(value);\n\n    // If the list is empty, make the new node point to\n    // itself and set it as last\n    if (last == nullptr) {\n        newNode->next = newNode;\n        return newNode;\n    }\n\n    // Insert the new node at the beginning\n    newNode->next = last->next;\n    last->next = newNode;\n\n    return last;\n}\n\nvoid printList(Node* last){\n  if(last == NULL) return;\n\n    // Start from the head node\n    Node* head = last->next;\n    while (true) {\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next)\n            break;\n    }\n    cout << endl;\n}\n\nint main(){\n\n    // Create circular linked list: 2, 3, 4\n    Node* first = new Node(2);\n    first->next = new Node(3);\n    first->next->next = new Node(4);\n\n    Node* last = first->next->next;\n    last->next = first;\n\n    cout << \"Original list: \";\n    printList(last);\n\n    // Insert 5 at the beginning\n    last = insertAtBeginning(last, 5);\n\n    cout << \"List after inserting 5 at the beginning: \";\n    printList(last);\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the Node structure\nstruct Node\n{\n    int data;\n    struct Node *next;\n};\n\n// Function to create a new node\nstruct Node *createNode(int value)\n{\n    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// Function to insert a node at the beginning\n// of the circular linked list\nstruct Node *insertAtBeginning(struct Node *last, int value)\n{\n    struct Node *newNode = createNode(value);\n\n    // If the list is empty, make the new node point to itself\n    // and set it as last\n    if (last == NULL)\n    {\n        newNode->next = newNode;\n        return newNode;\n    }\n\n    // Insert the new node at the beginning\n    newNode->next = last->next;\n    last->next = newNode;\n\n    return last;\n}\n\nvoid printList(struct Node *last)\n{\n    if (last == NULL) return;\n\n    struct Node *head = last->next;\n    while (1){\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next)\n            break;\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    // Create circular linked list: 2, 3, 4\n    struct Node *first = createNode(2);\n    first->next = createNode(3);\n    first->next->next = createNode(4);\n    struct Node *last = first->next->next;\n    last->next = first;\n\n    printf(\"Original list: \");\n    printList(last);\n\n    // Insert 5 at the beginning\n    last = insertAtBeginning(last, 5);\n\n    printf(\"List after inserting 5 at the beginning: \");\n    printList(last);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\nclass Node {\n    int data;\n    Node next;\n\n    Node(int value){\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n\n    // Function to insert a node at the beginning of the\n    // circular linked list\n    public static Node insertAtBeginning(Node last,\n                                         int value){\n        Node newNode = new Node(value);\n\n        // If the list is empty, make the new node point to\n        // itself and set it as last\n        if (last == null) {\n            newNode.next = newNode;\n            return newNode;\n        }\n\n        // Insert the new node at the beginning\n        newNode.next = last.next;\n        last.next = newNode;\n\n        return last;\n    }\n\n    // Function to print the circular linked list\n    public static void printList(Node last){\n        if (last == null)\n            return;\n\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next) break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args){\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n        Node last = first.next.next;\n        last.next = first;\n\n        System.out.print(\"Original list: \");\n        printList(last);\n\n        // Insert 5 at the beginning\n        last = insertAtBeginning(last, 5);\n\n        System.out.print(\n            \"List after inserting 5 at the beginning: \");\n        printList(last);\n    }\n}\n\n````\n\nPython\n\n````\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n# Function to insert a node at the beginning of the circular linked list\ndef insert_at_beginning(last, value):\n    new_node = Node(value)\n\n    # If the list is empty, make the new node point to itself and set it as last\n    if last is None:\n        new_node.next = new_node\n        return new_node\n\n    # Insert the new node at the beginning\n    new_node.next = last.next\n    last.next = new_node\n\n    return last\n\n# Function to print the circular linked list\ndef print_list(last):\n    if last is None:\n        return\n\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\n# Create circular linked list: 2, 3, 4\nfirst = Node(2)\nfirst.next = Node(3)\nfirst.next.next = Node(4)\nlast = first.next.next\nlast.next = first\n\nprint(\"Original list: \", end=\"\")\nprint_list(last)\n\n# Insert 5 at the beginning\nlast = insert_at_beginning(last, 5)\n\nprint(\"List after inserting 5 at the beginning: \", end=\"\")\nprint_list(last)\n\n````\n\nC#\n\n````\nusing System;\n\npublic class Node\n{\n    public int data;\n    public Node next;\n\n    public Node(int value)\n    {\n        data = value;\n        next = null;\n    }\n}\n\npublic class CircularLinkedList\n{\n    // Function to insert a node at the beginning of the circular linked list\n    public static Node InsertAtBeginning(Node last, int value)\n    {\n        Node newNode = new Node(value);\n\n        // If the list is empty, make the new node point to itself and set it as last\n        if (last == null)\n        {\n            newNode.next = newNode;\n            return newNode;\n        }\n\n        // Insert the new node at the beginning\n        newNode.next = last.next;\n        last.next = newNode;\n\n        return last;\n    }\n\n    // Function to print the circular linked list\n    public static void PrintList(Node last)\n    {\n        if (last == null)\n            return;\n\n        Node head = last.next;\n        while (true)\n        {\n            Console.Write(head.data + \" \");\n            head = head.next;\n            if (head == last.next)\n                break;\n        }\n        Console.WriteLine();\n    }\n\n    public static void Main(string[] args)\n    {\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n        Node last = first.next.next;\n        last.next = first;\n\n        Console.Write(\"Original list: \");\n        PrintList(last);\n\n        // Insert 5 at the beginning\n        last = InsertAtBeginning(last, 5);\n\n        Console.Write(\"List after inserting 5 at the beginning: \");\n        PrintList(last);\n    }\n}\n\n````\n\nJavaScript\n\n````\nclass Node {\n    constructor(data)\n    {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// Function to insert a node at the beginning of the\n// circular linked list\nfunction insertAtBeginning(last, value)\n{\n    const newNode = new Node(value);\n\n    // If the list is empty, make the new node point to\n    // itself and set it as last\n    if (last === null) {\n        newNode.next = newNode;\n        return newNode;\n    }\n\n    // Insert the new node at the beginning\n    newNode.next = last.next;\n    last.next = newNode;\n\n    return last;\n}\n\n// Function to print the circular linked list\nfunction printList(last)\n{\n    if (last === null)\n        return;\n\n    let head = last.next;\n    while (true) {\n        console.log(head.data + \" \");\n        head = head.next;\n        if (head === last.next)\n            break;\n    }\n    console.log();\n}\n\n// Create circular linked list: 2, 3, 4\nconst first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\nlet last\n    = first.next.next; // Using let to allow reassignment\nlast.next = first;\n\nconsole.log(\"Original list: \");\nprintList(last);\n\n// Insert 5 at the beginning\nlast = insertAtBeginning(last, 5);\n\nconsole.log(\"List after inserting 5 at the beginning: \");\nprintList(last);\n\n````\n\n\n\n\n**Output**\n```\nOriginal list: 2 3 4\nList after inserting 5 at the beginning: 5 2 3 4\n\n```\n### 3. Insertion at the end in circular linked list\n\n> To insert a new node at the end of a circular linked list, we first create the new node and allocate memory for it. If the list is empty (mean,\n>\n> ****last****\n> or\n>\n> ****tail****\n> pointer being\n>\n> ****NULL****\n> ), we initialize the list with the\n>\n> ****new node****\n> and making it point to itself to form a circular structure. If the list already contains nodes then we set the\n>\n> ****new node\u2019s****\n> next pointer to point to the\n>\n> ****current head****\n> (which is\n>\n> ****tail->next****\n> ), then update the\n>\n> ****current tail\u2019s****\n> next pointer to point to the\n>\n> ****new node****\n> . Finally, we update the\n>\n> ****tail pointer****\n> to the\n>\n> ****new node.****\n> This will ensure that the\n>\n> ****new node****\n> is now the\n>\n> ****last node****\n> in the list while maintaining the circular linkage.\n\n![Insertion-at-the-end-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150353/Insertion-at-the-end-of-circular-linked-list.webp)\n\nInsertion at the end in circular linked list\n\n\nC++\n\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node{\n    int data;\n    Node *next;\n    Node(int value)\n    {\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to insert a node at the end of a circular linked list\nNode *insertEnd(Node *tail, int value)\n{\n    Node *newNode = new Node(value);\n    if (tail == nullptr){\n        // If the list is empty, initialize it with the new node\n        tail = newNode;\n\n        // Point to itself to form a circular structure\n        newNode->next = newNode;\n    }\n    else{\n        // Insert new node after the current tail\n        // and update the tail pointer.\n        // New node points to the head node\n        newNode->next = tail->next;\n\n        // Tail node points to the new node\n        tail->next = newNode;\n\n        // Update tail to be the new node\n        tail = newNode;\n    }\n    return tail;\n}\n\nvoid printList(Node *last){\n  if(last == NULL) return;\n\n    // Start from the head node\n    Node *head = last->next;\n    while (true){\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next)\n            break;\n    }\n    cout << endl;\n}\n\nint main(){\n    // Create circular linked list: 2, 3, 4\n    Node *first = new Node(2);\n    first->next = new Node(3);\n    first->next->next = new Node(4);\n\n    Node *last = first->next->next;\n    last->next = first;\n\n    cout << \"Original list: \";\n    printList(last);\n\n    // Insert elements at the end of the circular linked list\n    last = insertEnd(last, 5);\n    last = insertEnd(last, 6);\n\n    cout << \"List after inserting 5 and 6: \";\n    printList(last);\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the Node structure\nstruct Node\n{\n    int data;\n    struct Node *next;\n};\n\n// Function to create a new node\nstruct Node *createNode(int value);\n\n// Function to insert a node at the end of a circular linked list\nstruct Node *insertEnd(struct Node *tail, int value)\n{\n    struct Node *newNode = createNode(value);\n    if (tail == NULL)\n    {\n        // If the list is empty, initialize it with the new node\n        tail = newNode;\n        newNode->next = newNode;\n    }\n    else\n    {\n        // Insert new node after the current tail and update the tail pointer\n        newNode->next = tail->next;\n        tail->next = newNode;\n        tail = newNode;\n    }\n    return tail;\n}\n\n// Function to print the circular linked list\nvoid printList(struct Node *last)\n{\n    if (last == NULL)\n        return;\n\n    struct Node *head = last->next;\n    while (1)\n    {\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next)\n            break;\n    }\n    printf(\"\\n\");\n}\n\nstruct Node *createNode(int value)\n{\n    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main()\n{\n    // Create circular linked list: 2, 3, 4\n    struct Node *first = createNode(2);\n    first->next = createNode(3);\n    first->next->next = createNode(4);\n\n    struct Node *last = first->next->next;\n    last->next = first;\n\n    printf(\"Original list: \");\n    printList(last);\n\n    // Insert elements at the end of the circular linked list\n    last = insertEnd(last, 5);\n    last = insertEnd(last, 6);\n\n    printf(\"List after inserting 5 and 6: \");\n    printList(last);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\nclass Node {\n    int data;\n    Node next;\n\n    Node(int value){\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n\n    // Function to insert a node at the end of a circular\n    // linked list\n    static Node insertEnd(Node tail, int value){\n        Node newNode = new Node(value);\n        if (tail == null) {\n            // If the list is empty, initialize it with the\n            // new node\n            tail = newNode;\n            newNode.next = newNode;\n        }\n        else {\n            // Insert new node after the current tail and\n            // update the tail pointer\n            newNode.next = tail.next;\n            tail.next = newNode;\n            tail = newNode;\n        }\n        return tail;\n    }\n\n    // Function to print the circular linked list\n    static void printList(Node last){\n        if (last == null) return;\n\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next) break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args){\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n\n        Node last = first.next.next;\n        last.next = first;\n\n        System.out.print(\"Original list: \");\n        printList(last);\n\n        // Insert elements at the end of the circular linked\n        // list\n        last = insertEnd(last, 5);\n        last = insertEnd(last, 6);\n\n        System.out.print(\"List after inserting 5 and 6: \");\n        printList(last);\n    }\n}\n\n````\n\nPython\n\n````\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\n# Function to insert a node at the end of a circular linked list\n\n\ndef insert_end(tail, value):\n    new_node = Node(value)\n    if tail is None:\n        # If the list is empty, initialize\n        # it with the new node\n        tail = new_node\n        new_node.next = new_node\n    else:\n        # Insert new node after the current tail\n        # and update the tail pointer\n        new_node.next = tail.next\n        tail.next = new_node\n        tail = new_node\n    return tail\n\n# Function to print the circular linked list\n\n\ndef print_list(last):\n    if last is None:\n        return\n\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\n\nif __name__ == \"__main__\":\n    # Create circular linked list: 2, 3, 4\n    first = Node(2)\n    first.next = Node(3)\n    first.next.next = Node(4)\n\n    last = first.next.next\n    last.next = first\n\n    print(\"Original list: \", end=\"\")\n    print_list(last)\n\n    # Insert elements at the end of the circular linked list\n    last = insert_end(last, 5)\n    last = insert_end(last, 6)\n\n    print(\"List after inserting 5 and 6: \", end=\"\")\n    print_list(last)\n\n````\n\nJavaScript\n\n````\nclass Node {\n    constructor(value){\n        this.data = value;\n        this.next = null;\n    }\n}\n\n// Function to insert a node at the end of a circular linked\n// list\nfunction insertEnd(tail, value){\n    let newNode = new Node(value);\n    if (tail === null) {\n        // If the list is empty, initialize it with the new\n        // node\n        tail = newNode;\n        newNode.next = newNode;\n    }\n    else {\n        // Insert new node after the current tail and update\n        // the tail pointer\n        newNode.next = tail.next;\n        tail.next = newNode;\n        tail = newNode;\n    }\n    return tail;\n}\n\n// Function to print the circular linked list\nfunction printList(last)\n{\n    if (last === null)\n        return;\n\n    let head = last.next;\n    while (true) {\n        console.log(head.data + \" \");\n        head = head.next;\n        if (head === last.next)\n            break;\n    }\n    console.log();\n}\n\n// Create circular linked list: 2, 3, 4\nlet first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\n\nlet last = first.next.next;\nlast.next = first;\n\nconsole.log(\"Original list: \");\nprintList(last);\n\n// Insert elements at the end of the circular linked\n// list\nlast = insertEnd(last, 5);\nlast = insertEnd(last, 6);\n\nconsole.log(\"List after inserting 5 and 6: \");\nprintList(last);\n\n````\n\n\n\n\n**Output**\n```\nOriginal list: 2 3 4\nList after inserting 5 and 6: 2 3 4 5 6\n\n```\n### 4. Insertion at specific position in circular linked list\n\n> To insert a new node at a specific position in a circular linked list, we first check if the list is empty. If it is and the\n>\n> ****position****\n> is not\n>\n> ****1****\n> then we print an error message because the position doesn\u2019t exist in the list. If the\n>\n> ****position****\n> is\n>\n> ****1****\n> then we create the\n>\n> ****new node****\n> and make it point to itself. If the list is not empty, we create the\n>\n> ****new node****\n> and traverse the list to find the correct insertion point. If the\n>\n> ****position****\n> is\n>\n> ****1****\n> , we insert the\n>\n> ****new node****\n> at the beginning by adjusting the pointers accordingly. For other positions, we traverse through the list until we reach the desired position and inserting the\n>\n> ****new node****\n> by updating the pointers. If the new node is inserted at the end, we also update the\n>\n> ****last****\n> pointer to reference the new node, maintaining the circular structure of the list.\n\n![Insertion-at-specific-position-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150431/Insertion-at-specific-position-of-circular-linked-list.webp)\n\nInsertion at specific position in circular linked list\n\n\nC++\n\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node{\n    int data;\n    Node *next;\n    Node(int value){\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to insert a node at a specific position in a circular linked list\nNode *insertAtPosition(Node *last, int data, int pos){\n    if (last == nullptr){\n        // If the list is empty\n        if (pos != 1){\n            cout << \"Invalid position!\" << endl;\n            return last;\n        }\n        // Create a new node and make it point to itself\n        Node *newNode = new Node(data);\n        last = newNode;\n        last->next = last;\n        return last;\n    }\n\n    // Create a new node with the given data\n    Node *newNode = new Node(data);\n\n    // curr will point to head initially\n    Node *curr = last->next;\n\n    if (pos == 1){\n        // Insert at the beginning\n        newNode->next = curr;\n        last->next = newNode;\n        return last;\n    }\n\n    // Traverse the list to find the insertion point\n    for (int i = 1; i < pos - 1; ++i) {\n        curr = curr->next;\n\n        // If position is out of bounds\n        if (curr == last->next){\n            cout << \"Invalid position!\" << endl;\n            return last;\n        }\n    }\n    // Insert the new node at the desired position\n    newNode->next = curr->next;\n    curr->next = newNode;\n\n    // Update last if the new node is inserted at the end\n    if (curr == last) last = newNode;\n\n    return last;\n}\n\nvoid printList(Node *last){\n    if (last == NULL) return;\n\n    Node *head = last->next;\n    while (true){\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next) break;\n    }\n    cout << endl;\n}\n\nint main(){\n    // Create circular linked list: 2, 3, 4\n    Node *first = new Node(2);\n    first->next = new Node(3);\n    first->next->next = new Node(4);\n\n    Node *last = first->next->next;\n    last->next = first;\n\n    cout << \"Original list: \";\n    printList(last);\n\n    // Insert elements at specific positions\n    int data = 5, pos = 2;\n    last = insertAtPosition(last, data, pos);\n    cout << \"List after insertions: \";\n    printList(last);\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the Node structure\nstruct Node {\n    int data;\n    struct Node *next;\n};\n\nstruct Node* createNode(int value);\n\n// Function to insert a node at a specific position in a circular linked list\nstruct Node* insertAtPosition(struct Node *last, int data, int pos) {\n    if (last == NULL) {\n        // If the list is empty\n        if (pos != 1) {\n            printf(\"Invalid position!\\n\");\n            return last;\n        }\n        // Create a new node and make it point to itself\n        struct Node *newNode = createNode(data);\n        last = newNode;\n        last->next = last;\n        return last;\n    }\n\n    // Create a new node with the given data\n    struct Node *newNode = createNode(data);\n\n    // curr will point to head initially\n    struct Node *curr = last->next;\n\n    if (pos == 1) {\n        // Insert at the beginning\n        newNode->next = curr;\n        last->next = newNode;\n        return last;\n    }\n\n    // Traverse the list to find the insertion point\n    for (int i = 1; i < pos - 1; ++i) {\n        curr = curr->next;\n\n        // If position is out of bounds\n        if (curr == last->next) {\n            printf(\"Invalid position!\\n\");\n            return last;\n        }\n    }\n\n    // Insert the new node at the desired position\n    newNode->next = curr->next;\n    curr->next = newNode;\n\n    // Update last if the new node is inserted at the end\n    if (curr == last) last = newNode;\n\n    return last;\n}\n\n// Function to print the circular linked list\nvoid printList(struct Node *last) {\n    if (last == NULL) return;\n\n    struct Node *head = last->next;\n    while (1) {\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next) break;\n    }\n    printf(\"\\n\");\n}\n\n// Function to create a new node\nstruct Node* createNode(int value) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    // Create circular linked list: 2, 3, 4\n    struct Node *first = createNode(2);\n    first->next = createNode(3);\n    first->next->next = createNode(4);\n\n    struct Node *last = first->next->next;\n    last->next = first;\n\n    printf(\"Original list: \");\n    printList(last);\n\n    // Insert elements at specific positions\n    int data = 5, pos = 2;\n    last = insertAtPosition(last, data, pos);\n    printf(\"List after insertions: \");\n    printList(last);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\nclass Node {\n    int data;\n    Node next;\n\n    Node(int value){\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n\n    // Function to insert a node at a specific position in a\n    // circular linked list\n    static Node insertAtPosition(Node last, int data,\n                                 int pos){\n        if (last == null) {\n            // If the list is empty\n            if (pos != 1) {\n                System.out.println(\"Invalid position!\");\n                return last;\n            }\n            // Create a new node and make it point to itself\n            Node newNode = new Node(data);\n            last = newNode;\n            last.next = last;\n            return last;\n        }\n\n        // Create a new node with the given data\n        Node newNode = new Node(data);\n\n        // curr will point to head initially\n        Node curr = last.next;\n\n        if (pos == 1) {\n            // Insert at the beginning\n            newNode.next = curr;\n            last.next = newNode;\n            return last;\n        }\n\n        // Traverse the list to find the insertion point\n        for (int i = 1; i < pos - 1; ++i) {\n            curr = curr.next;\n\n            // If position is out of bounds\n            if (curr == last.next) {\n                System.out.println(\"Invalid position!\");\n                return last;\n            }\n        }\n\n        // Insert the new node at the desired position\n        newNode.next = curr.next;\n        curr.next = newNode;\n\n        // Update last if the new node is inserted at the\n        // end\n        if (curr == last)\n            last = newNode;\n\n        return last;\n    }\n\n    static void printList(Node last){\n        if (last == null)\n            return;\n\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next)\n                break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args)\n    {\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n\n        Node last = first.next.next;\n        last.next = first;\n\n        System.out.print(\"Original list: \");\n        printList(last);\n\n        // Insert elements at specific positions\n        int data = 5, pos = 2;\n        last = insertAtPosition(last, data, pos);\n        System.out.print(\"List after insertions: \");\n        printList(last);\n    }\n}\n\n````\n\nPython\n\n````\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\n# Function to insert a node at a specific position in a circular linked list\ndef insertAtPosition(last, data, pos):\n    if last is None:\n        # If the list is empty\n        if pos != 1:\n            print(\"Invalid position!\")\n            return last\n        # Create a new node and make it point to itself\n        new_node = Node(data)\n        last = new_node\n        last.next = last\n        return last\n\n    # Create a new node with the given data\n    new_node = Node(data)\n\n    # curr will point to head initially\n    curr = last.next\n\n    if pos == 1:\n        # Insert at the beginning\n        new_node.next = curr\n        last.next = new_node\n        return last\n\n    # Traverse the list to find the insertion point\n    for i in range(1, pos - 1):\n        curr = curr.next\n\n        # If position is out of bounds\n        if curr == last.next:\n            print(\"Invalid position!\")\n            return last\n\n    # Insert the new node at the desired position\n    new_node.next = curr.next\n    curr.next = new_node\n\n    # Update last if the new node is inserted at the end\n    if curr == last:\n        last = new_node\n\n    return last\n\n# Function to print the circular linked list\ndef print_list(last):\n    if last is None:\n        return\n\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\nif __name__ == \"__main__\":\n    # Create circular linked list: 2, 3, 4\n    first = Node(2)\n    first.next = Node(3)\n    first.next.next = Node(4)\n\n    last = first.next.next\n    last.next = first\n\n    print(\"Original list: \", end=\"\")\n    print_list(last)\n\n    # Insert elements at specific positions\n    data = 5\n    pos = 2\n    last = insertAtPosition(last, data, pos)\n    print(\"List after insertions: \", end=\"\")\n    print_list(last)\n\n````\n\nJavaScript\n\n````\nclass Node {\n    constructor(value){\n        this.data = value;\n        this.next = null;\n    }\n}\n\n// Function to insert a node at a specific position in a\n// circular linked list\nfunction insertAtPosition(last, data, pos)\n{\n    if (last === null) {\n        // If the list is empty\n        if (pos !== 1) {\n            console.log(\"Invalid position!\");\n            return last;\n        }\n        // Create a new node and make it point to itself\n        let newNode = new Node(data);\n        last = newNode;\n        last.next = last;\n        return last;\n    }\n\n    // Create a new node with the given data\n    let newNode = new Node(data);\n\n    // curr will point to head initially\n    let curr = last.next;\n\n    if (pos === 1) {\n        // Insert at the beginning\n        newNode.next = curr;\n        last.next = newNode;\n        return last;\n    }\n\n    // Traverse the list to find the insertion point\n    for (let i = 1; i < pos - 1; ++i) {\n        curr = curr.next;\n\n        // If position is out of bounds\n        if (curr === last.next) {\n            console.log(\"Invalid position!\");\n            return last;\n        }\n    }\n\n    // Insert the new node at the desired position\n    newNode.next = curr.next;\n    curr.next = newNode;\n\n    // Update last if the new node is inserted at the end\n    if (curr === last)\n        last = newNode;\n\n    return last;\n}\n\n// Function to print the circular linked list\nfunction printList(last){\n    if (last === null)\n        return;\n\n    let head = last.next;\n    while (true) {\n        console.log(head.data + \" \");\n        head = head.next;\n        if (head === last.next)\n            break;\n    }\n    console.log();\n}\n\n// Create circular linked list: 2, 3, 4\nlet first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\n\nlet last = first.next.next;\nlast.next = first;\n\nconsole.log(\"Original list: \");\nprintList(last);\n\n// Insert elements at specific positions\nlet data = 5;\nlet pos = 2;\nlast = insertAtPosition(last, data, pos);\nconsole.log(\"List after insertions: \");\nprintList(last);\n\n````\n\n\n\n\n**Output**\n```\nOriginal list: 2 3 4\nList after insertions: 2 5 3 4\n\n```\n\n[Deletion from a Circular Linked List](https://www.geeksforgeeks.org/deletion-circular-linked-list/?ref=ml_lbp)\n---------------------------------------------------------------------------------------------------------------\n\n\nDeletion involves removing a node from the linked list. The main difference is that we need to ensure the list remains circular after the deletion. We can delete a node in a circular linked list in three ways:\n\n\n### 1. Delete the first node in circular linked list\n\n> To delete the first node of a circular linked list, we first check if the list is empty. If it is then we print a message and return\n>\n> ****NULL****\n> . If the list contains only one node (the\n>\n> ****head****\n> is the same as the\n>\n> ****last****\n> ) then we delete that node and set the\n>\n> ****last****\n> pointer to\n>\n> ****NULL****\n> . If there are multiple nodes then we update the\n>\n> ****last->next****\n> pointer to skip the\n>\n> ****head****\n> node and effectively removing it from the list. We then delete the\n>\n> ****head****\n> node to free the allocated memory. Finally, we return the updated\n>\n> ****last****\n> pointer, which still points to the\n>\n> ****last****\n> node in the list.\n\n![Deletion-from-the-beginning-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150500/Deletion-from-the-beginning-of-circular-linked-list.webp)\n\nDelete the first node in circular linked list\n\n\nC++\n\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int value) {\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to delete the first node of the circular linked list\nNode* deleteFirstNode(Node* last) {\n    if (last == nullptr) {\n        // If the list is empty\n        cout << \"List is empty\" << endl;\n        return nullptr;\n    }\n\n    Node* head = last->next;\n\n    if (head == last) {\n        // If there is only one node in the list\n        delete head;\n        last = nullptr;\n    } else {\n        // More than one node in the list\n        last->next = head->next;\n        delete head;\n    }\n\n    return last;\n}\n\nvoid printList(Node* last) {\n    if(last == NULL) return ;\n\n    Node *head = last->next;\n    while (true){\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next) break;\n    }\n    cout << endl;\n}\n\nint main() {\n    // Create circular linked list: 2, 3, 4\n    Node* first = new Node(2);\n    first->next = new Node(3);\n    first->next->next = new Node(4);\n\n    Node* last = first->next->next;\n    last->next = first;\n\n    cout << \"Original list: \";\n    printList(last);\n\n    // Delete the first node\n    last = deleteFirstNode(last);\n\n    cout << \"List after deleting first node: \";\n    printList(last);\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* deleteFirstNode(struct Node* last) {\n    if (last == NULL) {\n        // If the list is empty\n        printf(\"List is empty\\n\");\n        return NULL;\n    }\n\n    struct Node* head = last->next;\n\n    if (head == last) {\n        // If there is only one node in the list\n        free(head);\n        last = NULL;\n    } else {\n        // More than one node in the list\n        last->next = head->next;\n        free(head);\n    }\n\n    return last;\n}\n\nvoid printList(struct Node* last) {\n    if (last == NULL) return;\n\n    struct Node* head = last->next;\n    while (1) {\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next) break;\n    }\n    printf(\"\\n\");\n}\n\nstruct Node* createNode(int value) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    struct Node* first = createNode(2);\n    first->next = createNode(3);\n    first->next->next = createNode(4);\n\n    struct Node* last = first->next->next;\n    last->next = first;\n\n    printf(\"Original list: \");\n    printList(last);\n\n    last = deleteFirstNode(last);\n\n    printf(\"List after deleting first node: \");\n    printList(last);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\nclass Node {\n    int data;\n    Node next;\n\n    Node(int value) {\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n    public static Node deleteFirstNode(Node last) {\n        if (last == null) {\n            // If the list is empty\n            System.out.println(\"List is empty\");\n            return null;\n        }\n\n        Node head = last.next;\n\n        if (head == last) {\n            // If there is only one node in the list\n            last = null;\n        } else {\n            // More than one node in the list\n            last.next = head.next;\n        }\n\n        return last;\n    }\n\n    public static void printList(Node last) {\n        if (last == null) return;\n\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next) break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n\n        Node last = first.next.next;\n        last.next = first;\n\n        System.out.print(\"Original list: \");\n        printList(last);\n\n        // Delete the first node\n        last = deleteFirstNode(last);\n\n        System.out.print(\"List after deleting first node: \");\n        printList(last);\n    }\n}\n\n````\n\nPython\n\n````\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef deleteFirstNode(last):\n    if last is None:\n        # If the list is empty\n        print(\"List is empty\")\n        return None\n\n    head = last.next\n\n    if head == last:\n        # If there is only one node in the list\n        last = None\n    else:\n        # More than one node in the list\n        last.next = head.next\n\n    return last\n\ndef print_list(last):\n    if last is None:\n        return\n\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\n# Create circular linked list: 2, 3, 4\nfirst = Node(2)\nfirst.next = Node(3)\nfirst.next.next = Node(4)\n\nlast = first.next.next\nlast.next = first\n\nprint(\"Original list: \", end=\"\")\nprint_list(last)\n\n# Delete the first node\nlast = deleteFirstNode(last)\n\nprint(\"List after deleting first node: \", end=\"\")\nprint_list(last)\n\n````\n\nJavaScript\n\n````\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nfunction deleteFirstNode(last) {\n    if (last === null) {\n        // If the list is empty\n        console.log(\"List is empty\");\n        return null;\n    }\n\n    let head = last.next;\n\n    if (head === last) {\n        // If there is only one node in the list\n        last = null;\n    } else {\n        // More than one node in the list\n        last.next = head.next;\n    }\n\n    return last;\n}\n\nfunction printList(last) {\n    if (last === null) return;\n\n    let head = last.next;\n    while (true) {\n        console.log(head.data + \" \");\n        head = head.next;\n        if (head === last.next) break;\n    }\n    console.log();\n}\n\n// Create circular linked list: 2, 3, 4\nlet first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\n\nlet last = first.next.next;\nlast.next = first;\n\nconsole.log(\"Original list: \");\nprintList(last);\n\n// Delete the first node\nlast = deleteFirstNode(last);\n\nconsole.log(\"List after deleting first node: \");\nprintList(last);\n\n````\n\n\n\n\n**Output**\n```\nOriginal list: 2 3 4\nList after deleting first node: 3 4\n\n```\n### 2. Delete a specific node in circular linked list\n\n> To delete a specific node from a circular linked list, we first check if the list is empty. If it is then we print a message and return\n>\n> ****nullptr****\n> . If the list contains only one node and it matches the\n>\n> ****key****\n> then we delete that node and set\n>\n> ****last****\n> to\n>\n> ****nullptr****\n> . If the node to be deleted is the first node then we update the\n>\n> ****next****\n> pointer of the\n>\n> ****last****\n> node to skip the\n>\n> ****head****\n> node and delete the\n>\n> ****head****\n> . For other nodes, we traverse the list using two pointers:\n>\n> ****curr****\n> (to find the node) and\n>\n> ****prev****\n> (to keep track of the previous node). If we find the node with the matching key then we update the next pointer of\n>\n> ****prev****\n> to skip the\n>\n> ****curr****\n> node and delete it. If the node is found and it is the last node, we update the\n>\n> ****last****\n> pointer accordingly. If the node is not found then do nothing and\n>\n> ****tail****\n> or\n>\n> ****last****\n> as it is. Finally, we return the updated\n>\n> ****last****\n> pointer.\n\n![Delete-a-specific-node-in-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150531/Delete-a-specific-node-in-circular-linked-list.webp)\n\nDelete a specific node in circular linked list\n\n\nC++\n\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int value) {\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to delete a specific node in the circular linked list\nNode* deleteSpecificNode(Node* last, int key) {\n    if (last == nullptr) {\n        // If the list is empty\n        cout << \"List is empty, nothing to delete.\" << endl;\n        return nullptr;\n    }\n\n    Node* curr = last->next;\n    Node* prev = last;\n\n    // If the node to be deleted is the only node in the list\n    if (curr == last && curr->data == key) {\n        delete curr;\n        last = nullptr;\n        return last;\n    }\n\n    // If the node to be deleted is the first node\n    if (curr->data == key) {\n        last->next = curr->next;\n        delete curr;\n        return last;\n    }\n\n    // Traverse the list to find the node to be deleted\n    while (curr != last && curr->data != key) {\n        prev = curr;\n        curr = curr->next;\n    }\n\n    // If the node to be deleted is found\n    if (curr->data == key) {\n        prev->next = curr->next;\n        if (curr == last) {\n            last = prev;\n        }\n        delete curr;\n    } else {\n        // If the node to be deleted is not found\n        cout << \"Node with data \" << key\n          << \" not found.\" << endl;\n    }\n\n    return last;\n}\n\n// Function to print the circular linked list\nvoid printList(Node* last) {\n     if (last == NULL){\n        cout << \"List is Empty\";\n        return;\n    }\n\n    Node *head = last->next;\n    while (true){\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next) break;\n    }\n    cout << endl;\n}\n\nint main() {\n    // Create circular linked list: 2, 3, 4\n    Node* first = new Node(2);\n    first->next = new Node(3);\n    first->next->next = new Node(4);\n\n    Node* last = first->next->next;\n    last->next = first;\n\n    cout << \"Original list: \";\n    printList(last);\n\n    // Delete a specific node\n    int key = 3;\n    last = deleteSpecificNode(last, key);\n\n    cout << \"List after deleting node \" << key << \": \";\n    printList(last);\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the structure for a node in the circular linked list\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to delete a specific node in the circular linked list\nstruct Node* deleteSpecificNode(struct Node* last, int key) {\n    if (last == NULL) {\n        // If the list is empty\n        printf(\"List is empty, nothing to delete.\\n\");\n        return NULL;\n    }\n\n    struct Node* curr = last->next;\n    struct Node* prev = last;\n\n    // If the node to be deleted is the only node in the list\n    if (curr == last && curr->data == key) {\n        free(curr);\n        last = NULL;\n        return last;\n    }\n\n    // If the node to be deleted is the first node\n    if (curr->data == key) {\n        last->next = curr->next;\n        free(curr);\n        return last;\n    }\n\n    // Traverse the list to find the node to be deleted\n    while (curr != last && curr->data != key) {\n        prev = curr;\n        curr = curr->next;\n    }\n\n    // If the node to be deleted is found\n    if (curr->data == key) {\n        prev->next = curr->next;\n        if (curr == last) {\n            last = prev;\n        }\n        free(curr);\n    } else {\n        // If the node to be deleted is not found\n        printf(\"Node with data %d not found.\\n\", key);\n    }\n\n    return last;\n}\n\nvoid printList(struct Node* last) {\n    if (last == NULL) {\n        printf(\"List is Empty\");\n        return;\n    }\n\n    struct Node* head = last->next;\n    while (1) {\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next) break;\n    }\n    printf(\"\\n\");\n}\n\nstruct Node* createNode(int value) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    // Create circular linked list: 2, 3, 4\n    struct Node* first = createNode(2);\n    first->next = createNode(3);\n    first->next->next = createNode(4);\n\n    struct Node* last = first->next->next;\n    last->next = first;\n\n    printf(\"Original list: \");\n    printList(last);\n\n    // Delete a specific node\n    int key = 3;\n    last = deleteSpecificNode(last, key);\n\n    printf(\"List after deleting node %d: \", key);\n    printList(last);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\nclass Node {\n    int data;\n    Node next;\n    Node(int value){\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n    public static Node deleteSpecificNode(Node last,\n                                          int key){\n        if (last == null) {\n            // If the list is empty\n            System.out.println(\n                \"List is empty, nothing to delete.\");\n            return null;\n        }\n        Node curr = last.next;\n        Node prev = last;\n\n        // If the node to be deleted is the only node in the\n        // list\n        if (curr == last && curr.data == key) {\n            last = null;\n            return last;\n        }\n\n        // If the node to be deleted is the first node\n        if (curr.data == key) {\n            last.next = curr.next;\n            return last;\n        }\n\n        // Traverse the list to find the node to be deleted\n        while (curr != last && curr.data != key) {\n            prev = curr;\n            curr = curr.next;\n        }\n\n        // If the node to be deleted is found\n        if (curr.data == key) {\n            prev.next = curr.next;\n            if (curr == last) {\n                last = prev;\n            }\n        }\n        else {\n            // If the node to be deleted is not found\n            System.out.println(\"Node with data \" + key\n                               + \" not found.\");\n        }\n        return last;\n    }\n\n    public static void printList(Node last){\n        if (last == null) {\n            System.out.println(\"List is Empty\");\n            return;\n        }\n\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next)\n                break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args){\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n\n        Node last = first.next.next;\n        last.next = first;\n\n        System.out.print(\"Original list: \");\n        printList(last);\n\n        // Delete a specific node\n        int key = 3;\n        last = deleteSpecificNode(last, key);\n\n        System.out.print(\"List after deleting node \" + key\n                         + \": \");\n        printList(last);\n    }\n}\n\n````\n\nPython\n\n````\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef deleteSpecificNode(last, key):\n    if last is None:\n        # If the list is empty\n        print(\"List is empty, nothing to delete.\")\n        return None\n\n    curr = last.next\n    prev = last\n\n    # If the node to be deleted is the only node in the list\n    if curr == last and curr.data == key:\n        last = None\n        return last\n\n    # If the node to be deleted is the first node\n    if curr.data == key:\n        last.next = curr.next\n        return last\n\n    # Traverse the list to find the node to be deleted\n    while curr != last and curr.data != key:\n        prev = curr\n        curr = curr.next\n\n    # If the node to be deleted is found\n    if curr.data == key:\n        prev.next = curr.next\n        if curr == last:\n            last = prev\n    else:\n        # If the node to be deleted is not found\n        print(f\"Node with data {key} not found.\")\n\n    return last\n\ndef printList(last):\n    if last is None:\n        print(\"List is Empty\")\n        return\n\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\n# Create circular linked list: 2, 3, 4\nfirst = Node(2)\nfirst.next = Node(3)\nfirst.next.next = Node(4)\n\nlast = first.next.next\nlast.next = first\n\nprint(\"Original list: \", end=\"\")\nprintList(last)\n\n# Delete a specific node\nkey = 3\nlast = deleteSpecificNode(last, key)\n\nprint(f\"List after deleting node {key}: \", end=\"\")\nprintList(last)\n\n````\n\nJavaScript\n\n````\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nfunction deleteSpecificNode(last, key) {\n    if (last === null) {\n        // If the list is empty\n        console.log(\"List is empty, nothing to delete.\");\n        return null;\n    }\n\n    let curr = last.next;\n    let prev = last;\n\n    // If the node to be deleted is the only node in the list\n    if (curr === last && curr.data === key) {\n        last = null;\n        return last;\n    }\n\n    // If the node to be deleted is the first node\n    if (curr.data === key) {\n        last.next = curr.next;\n        return last;\n    }\n\n    // Traverse the list to find the node to be deleted\n    while (curr !== last && curr.data !== key) {\n        prev = curr;\n        curr = curr.next;\n    }\n\n    // If the node to be deleted is found\n    if (curr.data === key) {\n        prev.next = curr.next;\n        if (curr === last) {\n            last = prev;\n        }\n    } else {\n        // If the node to be deleted is not found\n        console.log(\"Node with data \" + key + \" not found.\");\n    }\n\n    return last;\n}\n\nfunction printList(last) {\n    if (last === null) {\n        console.log(\"List is Empty\");\n        return;\n    }\n\n    let head = last.next;\n    while (true) {\n        console.log(head.data + \" \");\n        head = head.next;\n        if (head === last.next) break;\n    }\n    console.log();\n}\n\n// Create circular linked list: 2, 3, 4\nlet first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\n\nlet last = first.next.next;\nlast.next = first;\n\nconsole.log(\"Original list: \");\nprintList(last);\n\n// Delete a specific node\nlet key = 3;\nlast = deleteSpecificNode(last, key);\n\nconsole.log(\"List after deleting node \" + key + \": \");\nprintList(last);\n\n````\n\n\n\n\n**Output**\n```\nOriginal list: 2 3 4\nList after deleting node 3: 2 4\n\n```\n### 3. Deletion at the end of Circular linked list\n\n> To delete the last node in a circular linked list, we first check if the list is empty. If it is, we print a message and return\n>\n> ****nullptr****\n> . If the list contains only one node (where the\n>\n> ****head****\n> is the same as the\n>\n> ****last****\n> ), we delete that node and set\n>\n> ****last****\n> to\n>\n> ****nullptr****\n> . For lists with multiple nodes, we need to traverse the list to find the\n>\n> ****second last node****\n> . We do this by starting from the\n>\n> ****head****\n> and moving through the list until we reach the node whose next pointer points to\n>\n> ****last****\n> . Once we find the\n>\n> ****second last****\n> node then we update its next pointer to point back to the\n>\n> ****head,****\n> this effectively removing the last node from the list. We then delete the last node to free up memory and return the updated\n>\n> ****last****\n> pointer, which now points to the last node.\n\n![Deletion-at-the-end-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150601/Deletion-at-the-end-of-circular-linked-list.webp)\n\nDeletion at the end of Circular linked list\n\n\nC++\n\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int value) {\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to delete the last node in the circular linked list\nNode* deleteLastNode(Node* last) {\n    if (last == nullptr) {\n        // If the list is empty\n        cout << \"List is empty, nothing to delete.\" << endl;\n        return nullptr;\n    }\n    Node* head = last->next;\n\n    // If there is only one node in the list\n    if (head == last) {\n        delete last;\n        last = nullptr;\n        return last;\n    }\n    // Traverse the list to find the second last node\n    Node* curr = head;\n    while (curr->next != last) {\n        curr = curr->next;\n    }\n    // Update the second last node's next pointer\n    // to point to head\n    curr->next = head;\n    delete last;\n    last = curr;\n\n    return last;\n}\n\nvoid printList(Node* last) {\n   if(last == NULL) return;\n\n    Node *head = last->next;\n    while (true){\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next) break;\n    }\n    cout << endl;\n}\n\nint main() {\n    // Create circular linked list: 2, 3, 4\n    Node* first = new Node(2);\n    first->next = new Node(3);\n    first->next->next = new Node(4);\n\n    Node* last = first->next->next;\n    last->next = first;\n\n    cout << \"Original list: \";\n    printList(last);\n\n    // Delete the last node\n    last = deleteLastNode(last);\n\n    cout << \"List after deleting last node: \";\n    printList(last);\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the structure for a node in the circular linked list\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to delete the last node in the circular linked list\nstruct Node* deleteLastNode(struct Node* last) {\n    if (last == NULL) {\n        // If the list is empty\n        printf(\"List is empty, nothing to delete.\\n\");\n        return NULL;\n    }\n    struct Node* head = last->next;\n\n    // If there is only one node in the list\n    if (head == last) {\n        free(last);\n        last = NULL;\n        return last;\n    }\n    // Traverse the list to find the second last node\n    struct Node* curr = head;\n    while (curr->next != last) {\n        curr = curr->next;\n    }\n    // Update the second last node's next pointer to point to head\n    curr->next = head;\n    free(last);\n    last = curr;\n\n    return last;\n}\n\nvoid printList(struct Node* last) {\n    if (last == NULL) return;\n\n    struct Node* head = last->next;\n    while (1) {\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next) break;\n    }\n    printf(\"\\n\");\n}\n\nstruct Node* createNode(int value) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    // Create circular linked list: 2, 3, 4\n    struct Node* first = createNode(2);\n    first->next = createNode(3);\n    first->next->next = createNode(4);\n\n    struct Node* last = first->next->next;\n    last->next = first;\n\n    printf(\"Original list: \");\n    printList(last);\n\n    // Delete the last node\n    last = deleteLastNode(last);\n\n    printf(\"List after deleting last node: \");\n    printList(last);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\nclass Node {\n    int data;\n    Node next;\n\n    Node(int value){\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n    public static Node deleteLastNode(Node last){\n        if (last == null) {\n            // If the list is empty\n            System.out.println(\n                \"List is empty, nothing to delete.\");\n            return null;\n        }\n        Node head = last.next;\n\n        // If there is only one node in the list\n        if (head == last) {\n            last = null;\n            return last;\n        }\n        // Traverse the list to find the second last node\n        Node curr = head;\n        while (curr.next != last) {\n            curr = curr.next;\n        }\n        // Update the second last node's next pointer to\n        // point to head\n        curr.next = head;\n        last = curr;\n\n        return last;\n    }\n\n    public static void printList(Node last){\n        if (last == null)\n            return;\n\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next)\n                break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args){\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n\n        Node last = first.next.next;\n        last.next = first;\n\n        System.out.print(\"Original list: \");\n        printList(last);\n\n        // Delete the last node\n        last = deleteLastNode(last);\n\n        System.out.print(\"List after deleting last node: \");\n        printList(last);\n    }\n}\n\n````\n\nPython\n\n````\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef deleteLastNode(last):\n    if last is None:\n        # If the list is empty\n        print(\"List is empty, nothing to delete.\")\n        return None\n\n    head = last.next\n\n    # If there is only one node in the list\n    if head == last:\n        last = None\n        return last\n\n    # Traverse the list to find the second last node\n    curr = head\n    while curr.next != last:\n        curr = curr.next\n\n    # Update the second last node's next pointer to point to head\n    curr.next = head\n    last = curr\n\n    return last\n\ndef printList(last):\n    if last is None:\n        return\n\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\n# Create circular linked list: 2, 3, 4\nfirst = Node(2)\nfirst.next = Node(3)\nfirst.next.next = Node(4)\n\nlast = first.next.next\nlast.next = first\n\nprint(\"Original list: \", end=\"\")\nprintList(last)\n\n# Delete the last node\nlast = deleteLastNode(last)\n\nprint(\"List after deleting last node: \", end=\"\")\nprintList(last)\n\n````\n\nC#\n\n````\nusing System;\n\npublic class Node {\n    public int data;\n    public Node next;\n\n    public Node(int value)\n    {\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n    // Function to delete the last node in the circular\n    // linked list\n    public static Node deleteLastNode(Node last)\n    {\n        if (last == null) {\n            // If the list is empty\n            Console.WriteLine(\n                \"List is empty, nothing to delete.\");\n            return null;\n        }\n        Node head = last.next;\n\n        // If there is only one node in the list\n        if (head == last) {\n            last = null;\n            return last;\n        }\n        // Traverse the list to find the second last node\n        Node curr = head;\n        while (curr.next != last) {\n            curr = curr.next;\n        }\n        // Update the second last node's next pointer\n        // to point to head\n        curr.next = head;\n        last = curr;\n\n        return last;\n    }\n\n    // Function to print the circular linked list\n    public static void printList(Node last)\n    {\n        if (last == null) {\n            Console.WriteLine(\"List is Empty\");\n            return;\n        }\n\n        Node head = last.next;\n        while (true) {\n            Console.Write(head.data + \" \");\n            head = head.next;\n            if (head == last.next)\n                break;\n        }\n        Console.WriteLine();\n    }\n\n    public static void Main(string[] args)\n    {\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n\n        Node last = first.next.next;\n        last.next = first;\n\n        Console.Write(\"Original list: \");\n        printList(last);\n\n        // Delete the last node\n        last = deleteLastNode(last);\n\n        Console.Write(\"List after deleting last node: \");\n        printList(last);\n    }\n}\n\n````\n\nJavaScript\n\n````\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nfunction deleteLastNode(last) {\n    if (last === null) {\n        // If the list is empty\n        console.log(\"List is empty, nothing to delete.\");\n        return null;\n    }\n    let head = last.next;\n\n    // If there is only one node in the list\n    if (head === last) {\n        last = null;\n        return last;\n    }\n    // Traverse the list to find the second last node\n    let curr = head;\n    while (curr.next !== last) {\n        curr = curr.next;\n    }\n    // Update the second last node's next pointer to point to head\n    curr.next = head;\n    last = curr;\n\n    return last;\n}\n\nfunction printList(last) {\n    if (last === null) return;\n\n    let head = last.next;\n    while (true) {\n        process.stdout.write(head.data + \" \");\n        head = head.next;\n        if (head === last.next) break;\n    }\n    console.log();\n}\n\n// Create circular linked list: 2, 3, 4\nlet first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\n\nlet last = first.next.next;\nlast.next = first;\n\nconsole.log(\"Original list: \");\nprintList(last);\n\n// Delete the last node\nlast = deleteLastNode(last);\n\nconsole.log(\"List after deleting last node: \");\nprintList(last);\n\n````\n\n\n\n\n**Output**\n```\nOriginal list: 2 3 4\nList after deleting last node: 2 3\n\n```\n\n[Searching in Circular Linked list](https://www.geeksforgeeks.org/searching-in-circular-linked-list/?ref=ml_lbp)\n----------------------------------------------------------------------------------------------------------------\n\n\nSearching in a circular linked list is similar to searching in a regular linked list. We start at a given node and traverse the list until you either find the target value or return to the starting node. Since the list is circular, make sure to keep track of where you started to avoid an infinite loop.\n\n\n> To search for a specific value in a circular linked list, we first check if the list is empty. If it is then we return\n>\n> ****false****\n> . If the list contains nodes then we start from the\n>\n> ****head****\n> node (which is the\n>\n> ****last->next****\n> ) and traverse the list. We use a pointer\n>\n> ****curr****\n> to iterate through the nodes until we reach back to the\n>\n> ****head****\n> . During traversal, if we find a node whose\n>\n> ****data****\n> matches the given\n>\n> ****key****\n> then we return\n>\n> ****true****\n> to indicating that the value was found. After the loop, we also check the last node to ensure we don\u2019t miss it. If the\n>\n> ****key****\n> is not found after traversing the entire list then we return\n>\n> ****false****\n> .\n\nC++\n\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int value) {\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to search for a specific value in the\n// circular linked list\nbool search(Node* last, int key) {\n    if (last == nullptr) {\n        // If the list is empty\n        return false;\n    }\n\n    Node* head = last->next;\n    Node* curr = head;\n\n    // Traverse the list to find the key\n    while (curr != last) {\n        if (curr->data == key) {\n          // Key found\n            return true;\n        }\n        curr = curr->next;\n    }\n\n    // Check the last node\n    if (last->data == key) {\n      // Key found\n        return true;\n    }\n    // Key not found\n    return false;\n}\n\nvoid printList(Node* last) {\n   if(last == NULL) return;\n\n    Node *head = last->next;\n    while (true){\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next) break;\n    }\n    cout << endl;\n}\n\nint main() {\n    // Create circular linked list: 2, 3, 4\n    Node* first = new Node(2);\n    first->next = new Node(3);\n    first->next->next = new Node(4);\n\n    Node* last = first->next->next;\n    last->next = first;\n\n    cout << \"Original list: \";\n    printList(last);\n\n    // Search for a specific value\n    int key = 3;\n    bool found = search(last, key);\n    if (found) {\n        cout << \"Value \" << key << \" found in the list.\" << endl;\n    } else {\n        cout << \"Value \" << key << \" not found in the list.\" << endl;\n    }\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Definition of the Node structure\nstruct Node{\n    int data;\n    struct Node *next;\n};\n\n// Function to search for a specific value in the circular linked list\nint search(struct Node *last, int key){\n    if (last == NULL){\n        // If the list is empty\n        return 0;\n    }\n\n    struct Node *head = last->next;\n    struct Node *curr = head;\n\n    // Traverse the list to find the key\n    while (curr != last){\n        if (curr->data == key){\n            // Key found\n            return 1;\n        }\n        curr = curr->next;\n    }\n\n    // Check the last node\n    if (last->data == key){\n        // Key found\n        return 1;\n    }\n    // Key not found\n    return 0;\n}\n\n// Function to print the circular linked list\nvoid printList(struct Node *last){\n    if (last == NULL) return;\n\n    struct Node *head = last->next;\n    while (1){\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next)\n            break;\n    }\n    printf(\"\\n\");\n}\n// Function to create a new node\nstruct Node *createNode(int value){\n    struct Node *temp = (struct Node *)malloc(sizeof(struct Node));\n    temp->data = value;\n    temp->next = NULL;\n    return temp;\n}\n\nint main(){\n    // Create circular linked list: 2, 3, 4\n    struct Node *first = createNode(2);\n    first->next = createNode(3);\n    first->next->next = createNode(4);\n\n    struct Node *last = first->next->next;\n    last->next = first;\n\n    printf(\"Original list: \");\n    printList(last);\n\n    // Search for a specific value\n    int key = 3;\n    int found = search(last, key);\n    if (found){\n        printf(\"Value %d found in the list.\\n\", key);\n    }\n    else{\n        printf(\"Value %d not found in the list.\\n\", key);\n    }\n\n    return 0;\n}\n\n````\n\nJava\n\n````\nclass Node {\n    int data;\n    Node next;\n    Node(int value) {\n        data = value;\n        next = null;\n    }\n}\n\npublic class CircularLinkedList {\n    // Function to search for a specific value\n    // in the circular linked list\n    static boolean search(Node last, int key) {\n        if (last == null) {\n            // If the list is empty\n            return false;\n        }\n\n        Node head = last.next;\n        Node curr = head;\n\n        // Traverse the list to find the key\n        while (curr != last) {\n            if (curr.data == key) {\n                // Key found\n                return true;\n            }\n            curr = curr.next;\n        }\n\n        // Check the last node\n        if (last.data == key) {\n            // Key found\n            return true;\n        }\n        // Key not found\n        return false;\n    }\n\n    static void printList(Node last) {\n        if (last == null) return;\n\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next) break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n\n        Node last = first.next.next;\n        last.next = first;\n\n        System.out.print(\"Original list: \");\n        printList(last);\n\n        // Search for a specific value\n        int key = 3;\n        boolean found = search(last, key);\n        if (found) {\n            System.out.println(\"Value \" + key\n                               + \" found in the list.\");\n        } else {\n            System.out.println(\"Value \" + key +\n                               \" not found in the list.\");\n        }\n    }\n}\n\n````\n\nPython\n\n````\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\ndef search(last, key):\n    if last is None:\n        # If the list is empty\n        return False\n\n    head = last.next\n    curr = head\n\n    # Traverse the list to find the key\n    while curr != last:\n        if curr.data == key:\n            # Key found\n            return True\n        curr = curr.next\n\n    # Check the last node\n    if last.data == key:\n        # Key found\n        return True\n    # Key not found\n    return False\n\ndef print_list(last):\n    if last is None:\n        return\n\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\nif __name__ == \"__main__\":\n    # Create circular linked list: 2, 3, 4\n    first = Node(2)\n    first.next = Node(3)\n    first.next.next = Node(4)\n\n    last = first.next.next\n    last.next = first\n\n    print(\"Original list:\", end=\" \")\n    print_list(last)\n\n    # Search for a specific value\n    key = 3\n    found = search(last, key)\n    if found:\n        print(f\"Value {key} found in the list.\")\n    else:\n        print(f\"Value {key} not found in the list.\")\n\n````\n\nC#\n\n````\nusing System;\n\npublic class Node {\n    public int data;\n    public Node next;\n    public Node(int value){\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n    // Function to search for a specific value in the\n    // circular linked list\n    public static bool Search(Node last, int key){\n        if (last == null) {\n            // If the list is empty\n            return false;\n        }\n\n        Node head = last.next;\n        Node curr = head;\n\n        // Traverse the list to find the key\n        while (curr != last) {\n            if (curr.data == key) {\n                // Key found\n                return true;\n            }\n            curr = curr.next;\n        }\n\n        // Check the last node\n        if (last.data == key) {\n            // Key found\n            return true;\n        }\n        // Key not found\n        return false;\n    }\n\n    public static void PrintList(Node last){\n        if (last == null)\n            return;\n\n        Node head = last.next;\n        while (true) {\n            Console.Write(head.data + \" \");\n            head = head.next;\n            if (head == last.next)\n                break;\n        }\n        Console.WriteLine();\n    }\n\n    public static void Main(string[] args){\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n\n        Node last = first.next.next;\n        last.next = first;\n\n        Console.Write(\"Original list: \");\n        PrintList(last);\n\n        // Search for a specific value\n        int key = 3;\n        bool found = Search(last, key);\n        if (found) {\n            Console.WriteLine(\"Value \" + key\n                              + \" found in the list.\");\n        }\n        else {\n            Console.WriteLine(\"Value \" + key\n                              + \" not found in the list.\");\n        }\n    }\n}\n\n````\n\nJavaScript\n\n````\nclass Node {\n    constructor(value){\n        this.data = value;\n        this.next = null;\n    }\n}\n\nfunction search(last, key){\n    if (last === null) {\n        // If the list is empty\n        return false;\n    }\n\n    let head = last.next;\n    let curr = head;\n\n    // Traverse the list to find the key\n    while (curr !== last) {\n        if (curr.data === key) {\n            // Key found\n            return true;\n        }\n        curr = curr.next;\n    }\n\n    // Check the last node\n    if (last.data === key) {\n        // Key found\n        return true;\n    }\n    // Key not found\n    return false;\n}\n\nfunction printList(last){\n    if (last === null)\n        return;\n\n    let head = last.next;\n    while (true) {\n        process.stdout.write(head.data + \" \");\n        head = head.next;\n        if (head === last.next)\n            break;\n    }\n    console.log();\n}\n\n// Create circular linked list: 2, 3, 4\nlet first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\n\nlet last = first.next.next;\nlast.next = first;\n\nconsole.log(\"Original list:\");\nprintList(last);\n\n// Search for a specific value\nlet key = 3;\nlet found = search(last, key);\nif (found) {\n    console.log(`Value ${key} found in the list.`);\n}\nelse {\n    console.log(`Value ${key} not found in the list.`);\n}\n\n````\n\n\n\n\n**Output**\n```\nOriginal list: 2 3 4\nValue 3 found in the list.\n\n```\n\nAdvantages of Circular Linked Lists\n-----------------------------------\n\n* In circular linked list, the last node points to the first node. There are no null references, making traversal easier and reducing the chances of encountering null pointer exceptions.\n* We can traverse the list from any node and return to it without needing to restart from the head, which is useful in applications requiring a circular iteration.\n* Circular linked lists can easily implement circular queues, where the last element connects back to the first, allowing for efficient resource management.\n* In a circular linked list, each node has a reference to the next node in the sequence. Although it doesn\u2019t have a direct reference to the previous node like a doubly linked list, we can still find the previous node by traversing the list.\n\nDisadvantages of Circular Linked Lists\n--------------------------------------\n\n* Circular linked lists are more complex to implement than singly linked lists.\n* Traversing a circular linked list without a clear stopping condition can lead to infinite loops if not handled carefully.\n* Debugging can be more challenging due to the circular nature, as traditional methods of traversing linked lists may not apply.\n\nApplications of Circular Linked Lists\n-------------------------------------\n\n* It is used for time-sharing among different users, typically through a\n\n  ****Round-Robin scheduling mechanism.****\n* In multiplayer games, a circular linked list can be used to switch between players. After the last player\u2019s turn, the list cycles back to the first player.\n* Circular linked lists are often used in buffering applications, such as streaming data, where data is continuously produced and consumed.\n* In media players, circular linked lists can manage playlists, this allowing users to loop through songs continuously.\n* Browsers use circular linked lists to manage the cache. This allows you to navigate back through your browsing history efficiently by pressing the BACK button.\n",
        "metadata": {
            "lesson_id": "4cd8171b-fbfb-4ac2-bd58-4d59d056750d",
            "course_id": "bd157822-862c-4b14-80e0-791fb1f7f1f6",
            "course_name": "Linked List Data Structure Guide",
            "lesson_description": "A circular linked list is a data structure where the last node connects back to the first, forming a loop. This structure allows for continuous traversal without any interruptions. Circular linked lists are especially helpful for tasks like scheduling and managing playlists, this allowing for smooth navigation. In this tutorial, we\u2019ll cover the basics of circular linked lists, how to work with them, their advantages and disadvantages, and their applications.",
            "course_description": "An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving."
        }
    },
    {
        "page_content": "Advantages of Linked Lists (or Most Common Use Cases):\n------------------------------------------------------\n\n* Linked Lists are mostly used because of their effective insertion and deletion.  We only need to change few pointers (or references) to insert (or delete) an item in the middle\n* [Insertion and deletion](https://www.geeksforgeeks.org/insertion-deletion-stl-set-c/)\n  at any point in a linked list take O(1) time. Whereas in an\n\n  [array](https://www.geeksforgeeks.org/array-data-structure/)\n  data structure, insertion / deletion in the middle takes O(n) time.\n* This data structure is simple and can be also used to implement\n\n  [a stack](https://www.geeksforgeeks.org/stack-data-structure/)\n  ,\n\n  [queues,](https://www.geeksforgeeks.org/queue-data-structure/)\n  and other\n\n  [abstract data structures](https://www.geeksforgeeks.org/abstract-data-types/)\n  .\n* Implementation of Queue and Deque data structures : Simple array implementation is not efficient at all. We must use circular array to efficiently implement which is complex. But with linked list, it is easy and straightforward. That is why most of the language libraries use Linked List internally to implement these data structures..\n* Linked List might turn out to be more space efficient compare to arrays in cases where we cannot guess the number of elements in advance. In case of arrays, the whole memory for items is allocated together. Even with dynamic sized arrays like vector in C++ or list in Python or ArrayList in Java. the internal working involves de-allocation of whole memory and allocation of a bigger chunk when insertions happen beyond the current capacity.\n\nApplications of Linked Lists:\n-----------------------------\n\n* Linked Lists can be used to implement stacks, queue, deque,\n\n  [sparse matrices](https://www.geeksforgeeks.org/sparse-matrix-representation/)\n  and adjacency list representation of graphs.\n* [Dynamic memory allocation](https://www.geeksforgeeks.org/what-is-dynamic-memory-allocation/)\n  in operating systems and compilers (linked list of free blocks).\n* Manipulation of polynomials\n* Arithmetic operations on long integers.\n* In operating systems, they can be used in Memory management, process scheduling (for example circular linked list for round robin scheduling) and file system.\n* Algorithms that need to frequently insert or delete items from large collections of data.\n* LRU cache, which uses a doubly linked list to keep track of the most recently used items in a cache.\n\nApplications of Linked Lists in real world:\n-------------------------------------------\n\n* The list of songs in the music player are linked to the previous and next songs.\n* In a web browser, previous and next web page URLs can be linked through the previous and next buttons (Doubly Linked List)\n* In image viewer, the previous and next images can be linked with the help of the previous and next buttons (Doubly Linked List)\n* Circular Linked Lists can be used to implement things in round manner where we go to every element one by one.\n* Linked List are preferred over arrays for implementations of Queue and Deque data structures because of fast deletions (or insertions) from the front of the linked lists.\n\nDisadvantages of Linked Lists:\n------------------------------\n\n\nLinked lists are a popular data structure in computer science, but like any other data structure, they have certain disadvantages as well. Some of the key disadvantages of linked lists are:\n\n\n* ****Slow Access Time:****\n  Accessing elements in a linked list can be slow, as you need to traverse the linked list to find the element you are looking for, which is an O(n) operation. This makes linked lists a poor choice for situations where you need to access elements quickly.\n* ****Pointers or References:****\n  Linked lists use pointers or references to access the next node, which can make them more complex to understand and use compared to arrays. This complexity can make linked lists more difficult to debug and maintain.\n* ****Higher overhead:****\n  Linked lists have a higher overhead compared to arrays, as each node in a linked list requires extra memory to store the reference to the next node.\n* ****Cache Inefficiency:****\n  Linked lists are cache-inefficient because the memory is not contiguous. This means that when you traverse a linked list, you are not likely to get the data you need in the cache, leading to cache misses and slow performance.\n\n\nIn conclusion, linked lists are a powerful and flexible data structure, but they have certain disadvantages that need to be taken into consideration when deciding whether to use them or not. For example, if you need fast access time, arrays might be a better choice, but if you need to insert or delete elements frequently, linked lists might be the better choice.\n",
        "metadata": {
            "lesson_id": "184c2a73-cbb4-45dd-9892-6ee6acc78a7b",
            "course_id": "bd157822-862c-4b14-80e0-791fb1f7f1f6",
            "course_name": "Linked List Data Structure Guide",
            "lesson_description": "A Linked List is a linear data structure that is used to store a collection of data with the help of nodes. Please remember the following points before moving forward.",
            "course_description": "An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving."
        }
    },
    {
        "page_content": "Given a Singly Linked List, the task is to find the Length of the Linked List.\n\n\n****Examples:****\n\n\n> ****Input:****\n> LinkedList = 1->3->1->2->1\n>\n>\n>\n> ****Output:****\n> 5\n>\n>\n> ****Input:****\n> LinkedList = 2->4->1->9->5->3->6\n>\n>\n>\n> ****Output:****\n> 7\n\nIterative Approach to Find the Length of a Linked List:\n-------------------------------------------------------\n\n> The idea is similar to\n>\n> [traversal of Linked List](https://www.geeksforgeeks.org/traversal-of-singly-linked-list/)\n> with an additional variable\n>\n>\n> to count the number of nodes in the Linked List.\n\n\nFollowing is the approach to find the length of the Linked List:\n\n\n* Initialize count as 0.\n* Initialize a node pointer, curr = head.\n* Do following while curr is not NULL\n  + curr = curr -> next\n  + Increment count by 1.\n* Return count.\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n// Iterative C++ program to find length\n// or count of nodes in a linked list\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Link list node\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    // Constructor to initialize a new node with data\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\n\n// Counts number of nodes in linked list\nint countNodes(Node* head) {\n\n    // Initialize count with 0\n    int count = 0;\n\n    // Initialize curr with head of Linked List\n    Node* curr = head;\n\n    // Traverse till we reach nullptr\n    while (curr != nullptr) {\n\n          // Increment count by 1\n        count++;\n\n          // Move pointer to next node\n        curr = curr->next;\n    }\n\n      // Return the count of nodes\n    return count;\n}\n\n// Driver code\nint main() {\n\n    // Create a hard-coded linked list:\n    // 1 -> 3 -> 1 -> 2 -> 1\n    Node* head = new Node(1);\n    head->next = new Node(3);\n    head->next->next = new Node(1);\n    head->next->next->next = new Node(2);\n    head->next->next->next->next = new Node(1);\n\n    // Function call to count the number of nodes\n    cout << \"Count of nodes is \" << countNodes(head);\n    return 0;\n}\n\n````\n\nC\n\n````\n// Iterative C program to find length or count of nodes in a\n// linked list\n\n#include <stdio.h>\n#include <stdlib.h>\n\n// Link list node\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to create a new node\nstruct Node* createNode(int new_data) {\n    struct Node* new_node =\n       (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\n\n// Counts number of nodes in linked list\nint countNodes(struct Node* head) {\n    // Initialize count with 0\n    int count = 0;\n\n    // Initialize curr with head of Linked List\n    struct Node* curr = head;\n\n    // Traverse till we reach NULL\n    while (curr != NULL) {\n\n        // Increment count by 1\n        count++;\n\n          // Move pointer to next node\n        curr = curr->next;\n    }\n\n    // Return the count of nodes\n    return count;\n}\n\n// Driver code\nint main() {\n\n    // Create a hard-coded linked list:\n    // 1 -> 3 -> 1 -> 2 -> 1\n    struct Node* head = createNode(1);\n    head->next = createNode(3);\n    head->next->next = createNode(1);\n    head->next->next->next = createNode(2);\n    head->next->next->next->next = createNode(1);\n\n    // Function call\n    printf(\"Count of nodes is %d\", countNodes(head));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Iterative Java program to count the number of\n// nodes in a linked list\n\n// Node class to define a linked list node\nclass Node {\n    int data;\n    Node next;\n\n    // Constructor to initialize a new node with data\n    Node(int newData) {\n        data = newData;\n        next = null;\n    }\n}\n\n// Class to define methods related to the linked list\npublic class GFG {\n\n    // Counts number of nodes in linked list\n    public static int countNodes(Node head) {\n\n        // Initialize count with 0\n        int count = 0;\n\n        // Initialize curr with head of Linked List\n        Node curr = head;\n\n        // Traverse till we reach null\n        while (curr != null) {\n\n            // Increment count by 1\n            count++;\n\n            // Move pointer to next node\n            curr = curr.next;\n        }\n        // Return the count of nodes\n        return count;\n    }\n\n    // Driver code\n    public static void main(String[] args) {\n\n        // Create a hard-coded linked list:\n        // 1 -> 3 -> 1 -> 2 -> 1\n        Node head = new Node(1);\n        head.next = new Node(3);\n        head.next.next = new Node(1);\n        head.next.next.next = new Node(2);\n        head.next.next.next.next = new Node(1);\n\n        // Function call to count the number of nodes\n        System.out.println(\"Count of nodes is \"\n                           + countNodes(head));\n    }\n}\n\n````\n\nPython\n\n````\n# Iterative Python program to count the number of nodes\n# in a linked list\n\n\nclass Node:\n    def __init__(self, new_data):\n\n        # Constructor to initialize a new node with data\n        self.data = new_data\n        self.next = None\n\n\ndef count_nodes(head):\n\n    # Counts number of nodes in linked list\n    # Initialize count with 0\n    count = 0\n\n    # Initialize curr with head of Linked List\n    curr = head\n\n    # Traverse till we reach None\n    while curr is not None:\n        # Increment count by 1\n        count += 1\n\n        # Move pointer to next node\n        curr = curr.next\n\n    # Return the count of nodes\n    return count\n\n\n# Driver code\nif __name__ == \"__main__\":\n\n    # Create a hard-coded linked list:\n    # 1 -> 3 -> 1 -> 2 -> 1\n    head = Node(1)\n    head.next = Node(3)\n    head.next.next = Node(1)\n    head.next.next.next = Node(2)\n    head.next.next.next.next = Node(1)\n\n    # Function call to count the number of nodes\n    print(\"Count of nodes is\", count_nodes(head))\n\n````\n\nC#\n\n````\n// Iterative C# program to find length or count of nodes\n// in a linked list\n\nusing System;\n\n// Link list node\nclass Node {\n    public int Data;\n    public Node Next;\n\n    // Constructor to initialize a new node with data\n    public Node(int newData) {\n        Data = newData;\n        Next = null;\n    }\n}\n\nclass GFG {\n\n    // Counts number of nodes in linked list\n    static int CountNodes(Node head) {\n\n          // Initialize count with 0\n        int count = 0;\n\n        // Initialize curr with head of Linked List\n        Node curr = head;\n\n        // Traverse till we reach null\n        while (curr != null) {\n            // Increment count by 1\n            count++;\n\n            // Move pointer to next node\n            curr = curr.Next;\n        }\n\n        // Return the count of nodes\n        return count;\n    }\n\n    static void Main() {\n\n        // Create a hard-coded linked list:\n        // 1 -> 3 -> 1 -> 2 -> 1\n        Node head = new Node(1);\n        head.Next = new Node(3);\n        head.Next.Next = new Node(1);\n        head.Next.Next.Next = new Node(2);\n        head.Next.Next.Next.Next = new Node(1);\n\n        // Function call to count the number of nodes\n        Console.WriteLine(\"Count of nodes is \"\n                          + CountNodes(head));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Iterative JavaScript program to find length\n// or count of nodes in a linked list\n\n// Linked List Node\nclass Node {\n\n    // Constructor to initialize a new node\n    // with data\n    constructor(newData) {\n        this.data = newData;\n        this.next = null;\n    }\n}\n\n// Counts number of nodes in linked list\nfunction countNodes(head) {\n    // Initialize count with 0\n    let count = 0;\n\n    // Initialize curr with head of Linked List\n    let curr = head;\n\n    // Traverse till we reach null\n    while (curr !== null) {\n\n        // Increment count by 1\n        count++;\n\n        // Move pointer to next node\n        curr = curr.next;\n    }\n\n    // Return the count of nodes\n    return count;\n}\n\n// Driver code\n\n// Create a hard-coded linked list:\n// 1 -> 3 -> 1 -> 2 -> 1\nlet head = new Node(1);\nhead.next = new Node(3);\nhead.next.next = new Node(1);\nhead.next.next.next = new Node(2);\nhead.next.next.next.next = new Node(1);\n\n// Function call to count the number of nodes\nconsole.log(\"Count of nodes is \" + countNodes(head));\n\n````\n\n\n\n\n**Output**\n```\nCount of nodes is 5\n```\n\n****Time complexity:****\nO(N), Where\n\n****N****\nis the size of the linked list\n\n\n\n****Auxiliary Space:****\nO(1), As constant extra space is used.\n\n\nRecursive Approach to Find the Length of a Linked List:\n-------------------------------------------------------\n\n> The idea is to use\n>\n> [recursion](https://www.geeksforgeeks.org/introduction-to-recursion-data-structure-and-algorithm-tutorials/)\n> by maintaining a function, say\n>\n> ****countNodes(node)****\n> which takes a node as an argument and calls itself with the next node until we reach the end of the Linked List. Each of the recursive call returns\n>\n> ****1 + count of remaining nodes****\n> .\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n// Recursive C++ program to find length\n// or count of nodes in a linked list\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Link list node\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    // Constructor to initialize a new node with data\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\n\n// Recursively count number of nodes in linked list\nint countNodes(Node* head) {\n\n    // Base Case\n    if (head == NULL) {\n        return 0;\n    }\n\n    // Count this node plus the rest of the list\n    return 1 + countNodes(head->next);\n}\n\n// Driver code\nint main() {\n\n    // Create a hard-coded linked list:\n    // 1 -> 3 -> 1 -> 2 -> 1\n    Node* head = new Node(1);\n    head->next = new Node(3);\n    head->next->next = new Node(1);\n    head->next->next->next = new Node(2);\n    head->next->next->next->next = new Node(1);\n\n    // Function call to count the number of nodes\n    cout << \"Count of nodes is \" << countNodes(head);\n    return 0;\n}\n\n````\n\nC\n\n````\n// Recursive C program to find length\n// or count of nodes in a linked list\n\n#include <stdio.h>\n#include <stdlib.h>\n\n// Link list node\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Constructor to initialize a new node with data\nstruct Node* createNode(int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\n\n// Recursively count number of nodes in linked list\nint countNodes(struct Node* head) {\n\n    // Base Case\n    if (head == NULL) {\n        return 0;\n    }\n\n    // Count this node plus the rest of the list\n    return 1 + countNodes(head->next);\n}\n\n// Driver code\nint main() {\n\n    // Create a hard-coded linked list:\n    // 1 -> 3 -> 1 -> 2 -> 1\n    struct Node* head = createNode(1);\n    head->next = createNode(3);\n    head->next->next = createNode(1);\n    head->next->next->next = createNode(2);\n    head->next->next->next->next = createNode(1);\n\n    // Function call to count the number of nodes\n    printf(\"Count of nodes is %d\\n\", countNodes(head));\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Recursive Java program to find length\n// or count of nodes in a linked list\n\n// Link list node\nclass Node {\n    int data;\n    Node next;\n\n    // Constructor to initialize a new node with data\n    Node(int new_data) {\n        data = new_data;\n        next = null;\n    }\n}\n\n// Recursively count number of nodes in linked list\npublic class GFG {\n    public static int countNodes(Node head) {\n\n        // Base Case\n        if (head == null) {\n            return 0;\n        }\n\n        // Count this node plus the rest of the list\n        return 1 + countNodes(head.next);\n    }\n\n    public static void main(String[] args) {\n\n        // Create a hard-coded linked list:\n        // 1 -> 3 -> 1 -> 2 -> 1\n        Node head = new Node(1);\n        head.next = new Node(3);\n        head.next.next = new Node(1);\n        head.next.next.next = new Node(2);\n        head.next.next.next.next = new Node(1);\n\n        // Function call to count the number of nodes\n        System.out.println(\"Count of nodes is \"\n                           + countNodes(head));\n    }\n}\n\n````\n\nPython\n\n````\n# Recursive Python program to find length\n# or count of nodes in a linked list\n\n# Linked List Node\nclass Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n\n# Recursively count number of nodes in linked list\ndef count_nodes(head):\n    # Base Case\n    if head is None:\n        return 0\n\n    # Count this node plus the rest of the list\n    return 1 + count_nodes(head.next)\n\n\n# Driver code\nif __name__ == \"__main__\":\n\n    # Create a hard-coded linked list:\n    # 1 -> 3 -> 1 -> 2 -> 1\n    head = Node(1)\n    head.next = Node(3)\n    head.next.next = Node(1)\n    head.next.next.next = Node(2)\n    head.next.next.next.next = Node(1)\n\n    # Function call to count the number of nodes\n    print(\"Count of nodes is\", count_nodes(head))\n\n````\n\nC#\n\n````\n// Recursive C# program to find length\n// or count of nodes in a linked list\n\nusing System;\n\n// Link list node\npublic class Node {\n    public int Data;\n    public Node Next;\n\n    // Constructor to initialize a new node with data\n    public Node(int new_data) {\n        Data = new_data;\n        Next = null;\n    }\n}\n\n// Recursively count number of nodes in linked list\npublic class GFG {\n    public static int CountNodes(Node head) {\n\n        // Base Case\n        if (head == null) {\n            return 0;\n        }\n\n        // Count this node plus the rest of the list\n        return 1 + CountNodes(head.Next);\n    }\n\n    // Driver code\n    public static void Main() {\n\n        // Create a hard-coded linked list:\n        // 1 -> 3 -> 1 -> 2 -> 1\n        Node head = new Node(1);\n        head.Next = new Node(3);\n        head.Next.Next = new Node(1);\n        head.Next.Next.Next = new Node(2);\n        head.Next.Next.Next.Next = new Node(1);\n\n        // Function call to count the number of nodes\n        Console.WriteLine(\"Count of nodes is \" + CountNodes(head));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Recursive Javascript program to find length\n// or count of nodes in a linked list\n\n// Link list node\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// Recursively count number of nodes in linked list\nfunction countNodes(head) {\n\n    // Base Case\n    if (head === null) {\n        return 0;\n    }\n\n    // Count this node plus the rest of the list\n    return 1 + countNodes(head.next);\n}\n\n// Driver code\n// Create a hard-coded linked list:\n// 1 -> 3 -> 1 -> 2 -> 1\nlet head = new Node(1);\nhead.next = new Node(3);\nhead.next.next = new Node(1);\nhead.next.next.next = new Node(2);\nhead.next.next.next.next = new Node(1);\n\n// Function call to count the number of nodes\nconsole.log(\"Count of nodes is \" + countNodes(head));\n\n````\n\n\n\n\n**Output**\n```\nCount of nodes is 5\n```\n\n****Time Complexity:****\nO(N), where\n\n****N****\nis the length of Linked List.\n\n\n\n****Auxiliary Space:****\nO(N), Extra space is used in the recursion call stack.",
        "metadata": {
            "lesson_id": "e6b3784f-3ef1-4b59-896b-06430bafe574",
            "course_id": "bd157822-862c-4b14-80e0-791fb1f7f1f6",
            "course_name": "Linked List Data Structure Guide",
            "lesson_description": "",
            "course_description": "An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving."
        }
    },
    {
        "page_content": "Given a Singly Linked List, the task is to print all the elements in the list.\n\n\n****Examples:****\n\n> ****Input:****\n> 1->2->3->4->5->null\n>\n>\n>\n> ****Output:****\n> 1 2 3 4 5\n>\n>\n>\n> ****Explanation:****\n> Every element of each node from head node to last node is printed.\n>\n>\n> ****Input:****\n> 10->20->30->40->50->null\n>\n>\n>\n> ****Output:****\n> 10 20 30 40 50\n>\n>\n>\n> ****Explanation:****\n> Every element of each node from head node to last node is printed.\n\nTable of Content\n\n* [Iterative Approach - O(n) Time and O(1) Space](#iterative-approach-on-time-and-o1-space)\n* [Recursive Approach - O(n) Time and O(n) Memory Space](#recursive-approach-on-time-and-on-memory-space)\n### Iterative Approach - O(n) Time and O(1) Space\n\n\nThe process of printing a\n\n****singly linked list****\ninvolves printing the value of each node and then going on to the next node and print that node's value also and so on, till we reach the last node in the singly linked list, whose next node points towards the null.\n\n\n****Step-by-Step Algorithm****\n\n> * We will initialize a temporary pointer to the head node of the singly linked list.\n> * After that, we will check if that pointer is null or not null, if it is null, then return.\n> * While the pointer is not null, we will access and print the data of the current node, then we move the pointer to next node.\n\n\nProgram to Print the Singly Linked List using Iteration.\n\n\nC++\n\n````\n//Driver Code Starts{\n#include <iostream>\n\nusing namespace std;\n\n//Driver Code Ends }\n\n// A linked list node\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    // Constructor to initialize a new node with data\n    Node(int new_data) {\n        this->data = new_data;\n        this->next = nullptr;\n    }\n};\n\n// Function to print the singly linked list\nvoid printList(Node* head) {\n\n    // A loop that runs till head is nullptr\n    while (head != nullptr) {\n\n        // Printing data of current node\n        cout << head->data << \" \";\n\n        // Moving to the next node\n        head = head->next;\n    }\n}\n\n//Driver Code Starts{\n\nint main() {\n\n    // Create a linked list: 10 -> 20 -> 30 -> 40\n    Node* head = new Node(10);\n    head->next = new Node(20);\n    head->next->next = new Node(30);\n    head->next->next->next = new Node(40);\n\n    printList(head);\n\n    return 0;\n}\n\n//Driver Code Ends }\n\n````\n\nC\n\n````\n//Driver Code Starts{\n#include <stdio.h>\n#include <stdlib.h>\n\n//Driver Code Ends }\n\n// A linked list node\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to create a new node\nstruct Node* createNode(int new_data) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node->data = new_data;\n    node->next = NULL;\n    return node;\n}\n\n// Function to print the singly linked list\nvoid printList(struct Node* head) {\n\n    // A loop that runs till head is NULL\n    while (head != NULL) {\n\n        // Printing data of current node\n        printf(\"%d \", head->data);\n\n        // Moving to the next node\n        head = head->next;\n    }\n}\n\n//Driver Code Starts{\n\nint main() {\n\n    // Create a linked list: 10 -> 20 -> 30 -> 40\n    struct Node* head = createNode(10);\n    head->next = createNode(20);\n    head->next->next = createNode(30);\n    head->next->next->next = createNode(40);\n\n    printList(head);\n\n    return 0;\n}\n\n//Driver Code Ends }\n\n````\n\nJava\n\n````\nclass Node {\n    int data;\n    Node next;\n\n    // Constructor to initialize a new node with data\n    Node(int newData) {\n        this.data = newData;\n        this.next = null;\n    }\n}\n\nclass GfG {\n\n    // Function to print the singly linked list\n    static void printList(Node head) {\n\n        // A loop that runs till head is null\n        while (head != null) {\n\n            // Printing data of current node\n            System.out.print(head.data + \" \");\n\n            // Moving to the next node\n            head = head.next;\n        }\n    }\n\n//Driver Code Starts{\n    public static void main(String[] args) {\n\n        // Create a linked list: 10 -> 20 -> 30 -> 40\n        Node head = new Node(10);\n        head.next = new Node(20);\n        head.next.next = new Node(30);\n        head.next.next.next = new Node(40);\n\n        printList(head);\n    }\n}\n\n//Driver Code Ends }\n\n````\n\nPython\n\n````\n# A linked list node\nclass Node:\n    def __init__(self, newData):\n        # Constructor to initialize a new node with data\n        self.data = newData\n        self.next = None\n\n# Function to print the singly linked list\ndef printList(head):\n\n    # A loop that runs till head is None\n    while head is not None:\n\n        # Printing data of current node\n        print(head.data, end=\" \")\n\n        # Moving to the next node\n        head = head.next\n\nif __name__ == \"__main__\":\n\n#Driver Code Starts{\n    # Create a linked list: 10 -> 20 -> 30 -> 40\n    head = Node(10)\n    head.next = Node(20)\n    head.next.next = Node(30)\n    head.next.next.next = Node(40)\n\n    printList(head)\n\n#Driver Code Ends }\n\n````\n\nC#\n\n````\n//Driver Code Starts{\nusing System;\n\n//Driver Code Ends }\n\nclass Node {\n    public int data;\n    public Node next;\n\n    // Constructor to initialize a new node with data\n    public Node(int new_data) {\n        this.data = new_data;\n        this.next = null;\n    }\n}\n\nclass GfG {\n\n    // Function to print the singly linked list\n    static void printList(Node head) {\n\n        // A loop that runs till head is null\n        while (head != null) {\n\n            // Printing data of current node\n            Console.Write(head.data + \" \");\n\n            // Moving to the next node\n            head = head.next;\n        }\n    }\n\n//Driver Code Starts{\n\n    static void Main(string[] args) {\n\n        // Create a linked list: 10 -> 20 -> 30 -> 40\n        Node head = new Node(10);\n        head.next = new Node(20);\n        head.next.next = new Node(30);\n        head.next.next.next = new Node(40);\n\n        printList(head);\n    }\n}\n\n//Driver Code Ends }\n\n````\n\nJavaScript\n\n````\nclass Node {\n    constructor(newData) {\n        // Constructor to initialize a new node with data\n        this.data = newData;\n        this.next = null;\n    }\n}\n\n// Function to print the singly linked list\nfunction printList(head) {\n\n\tlet result = '';\n\n    // A loop that runs till head is null\n    while (head !== null) {\n\n        // Printing data of current node\n        result += head.data + ' ';\n\n        // Moving to the next node\n        head = head.next;\n    }\n\n    console.log(result.trim());\n}\n\n//Driver Code Starts{\n// Driver Code\n\n// Create a linked list: 10 -> 20 -> 30 -> 40\nconst head = new Node(10);\nhead.next = new Node(20);\nhead.next.next = new Node(30);\nhead.next.next.next = new Node(40);\n\nprintList(head);\n\n\n//Driver Code Ends }\n\n````\n\n\n\n\n**Output**\n```\n10 20 30 40\n\n```\n\n****Time Complexity:****\nO(n), where\n\n****n****\nis the number of nodes in the linked list.\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n### Recursive Approach - O(n) Time and O(n) Memory Space\n\n\nWe can also traverse the singly linked list using recursion. We start at the head node of the singly linked list, check if it is null or not and print its value. We then call the traversal function again with the next node passed as pointer.\n\n\n****Step-by-Step Algorithm****\n\n> * Firstly, we define a recursive method to traverse the singly linked list, which takes a node as a parameter.\n> * In this function, the base case is that if the node is null then we will return from the recursive method.\n> * We then pass the head node as the parameter to this function.\n> * After that, we access and print the data of the current node.\n> * At last, we will make a recursive call to this function with the next node as the parameter.\n\n\nProgram to Print the Singly Linked List using Recursion.\n\n\nC++\n\n````\n#include <iostream>\nusing namespace std;\n\n// A linked list node\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    // Constructor to initialize a new node with data\n    Node(int new_data) {\n        this->data = new_data;\n        this->next = nullptr;\n    }\n};\n\n// Function to print the singly linked list\nvoid printList(Node* head) {\n\n    // Base condition is when the head is nullptr\n    if (head == nullptr) {\n        return;\n    }\n\n    // Printing the current node data\n    cout << head->data << \" \";\n\n    // Moving to the next node\n    printList(head->next);\n}\n\nint main() {\n\n    // Create a linked list: 10 -> 20 -> 30 -> 40\n    Node* head = new Node(10);\n    head->next = new Node(20);\n    head->next->next = new Node(30);\n    head->next->next->next = new Node(40);\n\n    printList(head);\n\n    return 0;\n}\n\n````\n\nC\n\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// A linked list node\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to create a new node with given data\nstruct Node* createNode(int new_data) {\n    struct Node* new_node\n        = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\n\n// Function to print the singly linked list\nvoid printList(struct Node* head) {\n\n    // Base condition is when the head is nullptr\n    if (head == NULL) {\n        return;\n    }\n\n    // Printing the current node data\n    printf(\"%d \", head->data);\n\n    // Moving to the next node\n    printList(head->next);\n}\n\nint main() {\n\n    // Create a linked list: 10 -> 20 -> 30 -> 40\n    struct Node* head = createNode(10);\n    head->next = createNode(20);\n    head->next->next = createNode(30);\n    head->next->next->next = createNode(40);\n\n    printList(head);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// A linked list node\nclass Node {\n    int data;\n    Node next;\n\n    // Constructor to initialize a new node with data\n    Node(int new_data) {\n        data = new_data;\n        next = null;\n    }\n}\n\nclass GfG {\n\n    // Function to print the singly linked list\n    static void printList(Node head) {\n\n        // Base condition is when the head is nullptr\n        if (head == null) {\n            return;\n        }\n\n        // Printing the current node data\n        System.out.print(head.data + \" \");\n\n        // Moving to the next node\n        printList(head.next);\n    }\n\n    public static void main(String[] args) {\n\n        // Create a linked list: 10 -> 20 -> 30 -> 40\n        Node head = new Node(10);\n        head.next = new Node(20);\n        head.next.next = new Node(30);\n        head.next.next.next = new Node(40);\n\n        printList(head);\n    }\n}\n\n````\n\nPython\n\n````\n# A linked list node\nclass Node:\n    def __init__(self, data):\n\n        # Constructor to initialize a new node with data\n        self.data = data\n        self.next = None\n\n# Function to print the singly linked list\ndef printList(head):\n\n    # Base condition is when the head is nullptr\n    if head is None:\n        return\n\n    # Printing the current node data\n    print(head.data, end=\" \")\n\n    # Moving to the next node\n    printList(head.next)\n\nif __name__ == \"__main__\":\n\n    # Create a linked list: 10 -> 20 -> 30 -> 40\n    head = Node(10)\n    head.next = Node(20)\n    head.next.next = Node(30)\n    head.next.next.next = Node(40)\n\n    printList(head)\n\n````\n\nC#\n\n````\nusing System;\n\n// A linked list node\nclass Node {\n    public int Data { get;set; }\n    public Node Next { get;set; }\n\n    // Constructor to initialize a new node with data\n    public Node(int newData) {\n        Data = newData;\n        Next = null;\n    }\n}\n\nclass GfG {\n\n    // Function to print the singly linked list\n    static void printList(Node head) {\n\n        // Base condition is when the head is nullptr\n        if (head == null) {\n            return;\n        }\n\n        // Printing the current node data\n        Console.Write(head.Data + \" \");\n\n        // Moving to the next node\n        printList(head.Next);\n    }\n\n    static void Main() {\n\n        // Create a linked list: 10 -> 20 -> 30 -> 40\n        Node head = new Node(10);\n        head.Next = new Node(20);\n        head.Next.Next = new Node(30);\n        head.Next.Next.Next = new Node(40);\n\n        printList(head);\n    }\n}\n\n````\n\n\n\n\n**Output**\n```\n10 20 30 40\n\n```\n\n****Time Complexity:****\nO(n), where\n\n****n****\nis number of nodes in the linked list.\n\n\n\n****Space complexity:****\nO(n) because of recursive stack space.",
        "metadata": {
            "lesson_id": "522fe91a-61af-4a65-9b20-bb62618061e5",
            "course_id": "bd157822-862c-4b14-80e0-791fb1f7f1f6",
            "course_name": "Linked List Data Structure Guide",
            "lesson_description": "",
            "course_description": "An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving."
        }
    },
    {
        "page_content": "Given a linked list and a\n\n****key****\n, the task is to check if\n\n****key****\nis present in the linked list or not.\n\n\n****Examples:****\n\n> ****Input:****\n> 14 -> 21 -> 11 -> 30 -> 10, key = 14\n>\n>\n>\n> ****Output:****\n> Yes\n>\n>\n>\n> ****Explanation:****\n> 14 is present in the linked list.\n>\n>\n> ****Input:****\n> 6 -> 21 -> 17 -> 30 -> 10 -> 8, key = 13\n>\n>\n>\n> ****Output:****\n> No\n>\n>\n>\n> ****Explanation:****\n> No node in the linked list has value = 13.\n\nTable of Content\n\n* [Search an element in a Linked List (Iterative Approach) \u2013 O(N) Time and O(1) Space](#search-an-element-in-a-linked-list-iterative-approach)\n* [Search an element in a Linked List (Recursive Approach) \u2013 O(N) Time and O(N) Space](#search-an-element-in-a-linked-list-recursive-approach)\n\nSearch an element in a Linked List (Iterative Approach) \u2013 O(N) Time and O(1) Space:\n-----------------------------------------------------------------------------------\n\n> The idea is to traverse all the nodes of the linked list, starting from the\n>\n> ****head****\n> . While traversing, if we find a node whose value is equal to\n>\n> ****key****\n> then print \u201cYes\u201d, otherwise print \u201cNo\u201d.\n\n\nFollow the below steps to solve the problem:\n\n\n\n* Initialize a node pointer,\n\n  ****curr = head****\n  .\n* Do following while current is not NULL\n  + If the current value (i.e.,\n\n    ****curr->key****\n    ) is equal to the key being searched return true.\n  + Otherwise, move to the next node (\n\n    ****curr = curr->next****\n    ).\n* If the key is not found, return false\n\n\nBelow is the implementation of the above approach.\n\n\n\nC++\n\n````\n// Iterative C++ program to search\n// an element in linked list\n\n#include <iostream>\nusing namespace std;\n\n// A linked list node\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    // Constructor to initialize a new node with data\n    Node(int new_data)\n    {\n        data = new_data;\n        next = nullptr;\n    }\n};\n\n// Checks whether key is present in linked list\nbool searchKey(Node* head, int key) {\n\n    // Initialize curr with the head of linked list\n    Node* curr = head;\n\n    // Iterate over all the nodes\n    while (curr != NULL) {\n\n        // If the current node's value is equal to key,\n        // return true\n        if (curr->data == key)\n            return true;\n\n        // Move to the next node\n        curr = curr->next;\n    }\n\n    // If there is no node with value as key, return false\n    return false;\n}\n\n// Driver code\nint main() {\n\n    // Create a hard-coded linked list:\n    // 14 -> 21 -> 13 -> 30 -> 10\n    Node* head = new Node(14);\n    head->next = new Node(21);\n    head->next->next = new Node(13);\n    head->next->next->next = new Node(30);\n    head->next->next->next->next = new Node(10);\n\n      // Key to search in the linked list\n      int key = 14;\n\n    if (searchKey(head, key))\n        cout << \"Yes\";\n    else\n        cout << \"No\";\n\n    return 0;\n}\n\n````\n\nC\n\n````\n// Iterative C program to search\n// an element in linked list\n\n#include <stdio.h>\n#include <stdbool.h>\n\n// A linked list node\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to create a new node\nstruct Node* createNode(int new_data) {\n    struct Node* new_node =\n       (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\n\n// Checks whether key is present in linked list\nbool searchKey(struct Node* head, int key) {\n\n    // Initialize curr with the head of linked list\n    struct Node* curr = head;\n\n    // Iterate over all the nodes\n    while (curr != NULL) {\n\n        // If the current node's value is equal to key,\n        // return true\n        if (curr->data == key)\n            return true;\n\n        // Move to the next node\n        curr = curr->next;\n    }\n\n    // If there is no node with value as key, return false\n    return false;\n}\n\n// Driver code\nint main() {\n\n    // Create a hard-coded linked list:\n    // 14 -> 21 -> 13 -> 30 -> 10\n    struct Node* head = createNode(14);\n    head->next = createNode(21);\n    head->next->next = createNode(13);\n    head->next->next->next = createNode(30);\n    head->next->next->next->next = createNode(10);\n\n      // Key to search in the linked list\n      int key = 14;\n\n    if (searchKey(head, key))\n        printf(\"Yes\");\n    else\n        printf(\"No\");\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Iterative Java program to search\n// an element in linked list\n\n// A Linked List Node\nclass Node {\n    int data;\n    Node next;\n\n    // Constructor to initialize a new node with data\n    Node(int new_data) {\n        data = new_data;\n        next = null;\n    }\n}\n\npublic class GFG {\n\n    // Checks whether key is present in linked list\n    static boolean searchKey(Node head, int key) {\n\n        // Initialize curr with the head of linked list\n        Node curr = head;\n\n        // Iterate over all the nodes\n        while (curr != null) {\n\n            // If the current node's value is equal to key,\n            // return true\n            if (curr.data == key)\n                return true;\n\n            // Move to the next node\n            curr = curr.next;\n        }\n\n        // If there is no node with value as key, return\n        // false\n        return false;\n    }\n\n      // Driver code\n    public static void main(String[] args) {\n\n        // Create a hard-coded linked list:\n        // 14 -> 21 -> 13 -> 30 -> 10\n        Node head = new Node(14);\n        head.next = new Node(21);\n        head.next.next = new Node(13);\n        head.next.next.next = new Node(30);\n        head.next.next.next.next = new Node(10);\n\n        // Key to search in the linked list\n        int key = 14;\n\n        if (searchKey(head, key))\n            System.out.println(\"Yes\");\n        else\n            System.out.println(\"No\");\n    }\n}\n\n````\n\nPython\n\n````\n# Iterative Python program to search\n# an element in linked list\n\n# A Linked List Node\nclass Node:\n\n      # Constructor to intialize a node with data\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n\n# Checks whether key is present in linked list\ndef search_key(head, key):\n\n    # Initialize curr with the head of linked list\n    curr = head\n\n    # Iterate over all the nodes\n    while curr is not None:\n\n        # If the current node's value is equal to key,\n        # return true\n        if curr.data == key:\n            return True\n\n        # Move to the next node\n        curr = curr.next\n\n    # If there is no node with value as key, return false\n    return False\n\n# Driver code\nif __name__ == \"__main__\":\n\n    # Create a hard-coded linked list:\n    # 14 -> 21 -> 13 -> 30 -> 10\n    head = Node(14)\n    head.next = Node(21)\n    head.next.next = Node(13)\n    head.next.next.next = Node(30)\n    head.next.next.next.next = Node(10)\n\n    # Key to search in the linked list\n    key = 14\n\n    if search_key(head, key):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n````\n\nC#\n\n````\n// Iterative C# program to search\n// an element in linked list\n\nusing System;\n\n// A Linked List Node\nclass Node {\n    public int Data;\n    public Node Next;\n\n    // Constructor to initialize a new node with data\n    public Node(int new_data) {\n        Data = new_data;\n        Next = null;\n    }\n}\n\n// Driver code\nclass GFG {\n\n    // Checks whether key is present in linked list\n    static bool SearchKey(Node head, int key) {\n\n        // Initialize curr with the head of linked list\n        Node curr = head;\n\n        // Iterate over all the nodes\n        while (curr != null) {\n\n            // If the current node's value is equal to key,\n            // return true\n            if (curr.Data == key)\n                return true;\n\n            // Move to the next node\n            curr = curr.Next;\n        }\n\n        // If there is no node with value as key, return\n        // false\n        return false;\n    }\n\n    static void Main() {\n\n        // Create a hard-coded linked list:\n        // 14 -> 21 -> 13 -> 30 -> 10\n        Node head = new Node(14);\n        head.Next = new Node(21);\n        head.Next.Next = new Node(13);\n        head.Next.Next.Next = new Node(30);\n        head.Next.Next.Next.Next = new Node(10);\n\n        // Key to search in the linked list\n        int key = 14;\n\n        if (SearchKey(head, key))\n            Console.WriteLine(\"Yes\");\n        else\n            Console.WriteLine(\"No\");\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Iterative JavaScript program to search\n// an element in linked list\n\n// A Linked List Node\nclass Node {\n\n    // Constructor to initialize a new node with data\n    constructor(new_data) {\n        this.data = new_data;\n        this.next = null;\n    }\n}\n\n// Checks whether key is present in linked list\nfunction searchKey(head, key) {\n\n    // Initialize curr with the head of linked list\n    let curr = head;\n\n    // Iterate over all the nodes\n    while (curr !== null) {\n\n        // If the current node's value is equal to key,\n        // return true\n        if (curr.data === key)\n            return true;\n\n        // Move to the next node\n        curr = curr.next;\n    }\n\n    // If there is no node with value as key, return false\n    return false;\n}\n\n// Driver code\n\n// Create a hard-coded linked list:\n// 14 -> 21 -> 13 -> 30 -> 10\nlet head = new Node(14);\nhead.next = new Node(21);\nhead.next.next = new Node(13);\nhead.next.next.next = new Node(30);\nhead.next.next.next.next = new Node(10);\n\n// Key to search in the linked list\nlet key = 14;\n\nif (searchKey(head, key))\nconsole.log(\"Yes\");\nelse\nconsole.log(\"No\");\n\n````\n\n\n\n\n**Output**\n```\nYes\n```\n\n****Time Complexity:****\nO(N), Where\n\n****N****\nis the number of nodes in the Linked List.\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\nSearch an element in a Linked List (Recursive Approach) \u2013 O(N) Time and O(N) Space:\n-----------------------------------------------------------------------------------\n\n> The idea is to recursively traverse all the nodes starting from the\n>\n> ****head****\n> of linked list. For any node, if the value is equal to\n>\n> ****key****\n> , then return true. Otherwise, recursively search the next node. If at any point the head reaches\n>\n> ****NULL****\n> , it means that we have reached the end of linked list so return\n>\n> ****false****\n> .\n\n\nFollow the below steps to solve the problem:\n\n\n* If the head is NULL, return false.\n* If the head\u2019s key is the same as\n\n  ****X****\n  , return true;\n* Else recursively search in the next node.\n\n\nBelow is the recursive implementation of the above algorithm.\n\n\nC++\n\n````\n// Recursive C++ program to search\n// an element in linked list\n\n#include <iostream>\nusing namespace std;\n\n// A Linked List Node\nstruct Node {\n    int data;\n    Node* next;\n\n      // Constructor to initialize a new node with data\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\n\n// Checks whether the key is present in linked list\nbool searchKey(struct Node* head, int key) {\n\n    // Base case\n    if (head == NULL)\n        return false;\n\n    // If key is present in current node, return true\n    if (head->data == key)\n        return true;\n\n    // Recur for remaining list\n    return searchKey(head->next, key);\n}\n\n// Driver code\nint main() {\n\n    // Create a hard-coded linked list:\n    // 14 -> 21 -> 13 -> 30 -> 10\n    struct Node* head = new Node(14);\n    head->next = new Node(21);\n    head->next->next = new Node(13);\n    head->next->next->next = new Node(30);\n    head->next->next->next->next = new Node(10);\n\n      // Key to search in the linked list\n      int key = 14;\n\n    if (searchKey(head, key))\n        printf(\"Yes\");\n    else\n        printf(\"No\");\n\n    return 0;\n}\n\n````\n\nC\n\n````\n// Recursive C program to search\n// an element in linked list\n\n#include <stdio.h>\n#include <stdbool.h>\n\n// A linked list node\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to create a new node\nstruct Node* createNode(int new_data) {\n    struct Node* new_node =\n       (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\n\n// Checks whether the key is present in linked list\nbool searchKey(struct Node* head, int key) {\n\n    // Base case\n    if (head == NULL)\n        return 0;\n\n    // If key is present in current node, return true\n    if (head->data == key)\n        return 1;\n\n    // Recur for remaining list\n    return searchKey(head->next, key);\n}\n\n// Driver code\nint main() {\n\n    // Create a hard-coded linked list:\n    // 14 -> 21 -> 13 -> 30 -> 10\n    struct Node* head = createNode(14);\n    head->next = createNode(21);\n    head->next->next = createNode(13);\n    head->next->next->next = createNode(30);\n    head->next->next->next->next = createNode(10);\n\n      // Key to search in the linked list\n      int key = 14;\n\n    if (searchKey(head, key))\n        printf(\"Yes\");\n    else\n        printf(\"No\");\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Recursive Java program to search\n// an element in linked list\n\n// A Linked List Node\nclass Node {\n    int data;\n    Node next;\n\n    // Constructor to initialize a new node with data\n    Node(int new_data) {\n        data = new_data;\n        next = null;\n    }\n}\n\n// Driver code\npublic class GFG {\n\n    // Checks whether the key is present in linked list\n    static boolean searchKey(Node head, int key) {\n\n        // Base case\n        if (head == null)\n            return false;\n\n        // If key is present in current node, return true\n        if (head.data == key)\n            return true;\n\n        // Recur for remaining list\n        return searchKey(head.next, key);\n    }\n\n    public static void main(String[] args) {\n\n        // Create a hard-coded linked list:\n        // 14 -> 21 -> 13 -> 30 -> 10\n        Node head = new Node(14);\n        head.next = new Node(21);\n        head.next.next = new Node(13);\n        head.next.next.next = new Node(30);\n        head.next.next.next.next = new Node(10);\n\n        // Key to search in the linked list\n        int key = 14;\n\n        if (searchKey(head, key))\n            System.out.println(\"Yes\");\n        else\n            System.out.println(\"No\");\n    }\n}\n\n````\n\nPython\n\n````\n# Recursive Python program to search\n# an element in linked list\n\n# A Linked List Node\nclass Node:\n\n      # Constructor to initialize a new node with data\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n\n# Checks whether the key is present in linked list\ndef searchKey(head, key):\n\n    # Base case\n    if head is None:\n        return False\n\n    # If key is present in current node, return true\n    if head.data == key:\n        return True\n\n    # Recur for remaining list\n    return searchKey(head.next, key)\n\n# Driver code\nif __name__ == \"__main__\":\n\n    # Create a hard-coded linked list:\n    # 14 -> 21 -> 13 -> 30 -> 10\n    head = Node(14)\n    head.next = Node(21)\n    head.next.next = Node(13)\n    head.next.next.next = Node(30)\n    head.next.next.next.next = Node(10)\n\n    # Key to search in the linked list\n    key = 14\n\n    if searchKey(head, key):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n````\n\nC#\n\n````\n// Recursive C# program to search\n// an element in linked list\n\nusing System;\n\n// A Linked List Node\nclass Node {\n    public int data;\n    public Node next;\n\n    // Constructor to initialize a new node with data\n    public Node(int new_data) {\n        data = new_data;\n        next = null;\n    }\n}\n\n// Checks whether the key is present in linked list\nclass GFG {\n\n      // Checks whether the key is present in linked list\n    static bool SearchKey(Node head, int key) {\n\n        // Base case\n        if (head == null)\n            return false;\n\n        // If key is present in current node, return true\n        if (head.data == key)\n            return true;\n\n        // Recur for remaining list\n        return SearchKey(head.next, key);\n    }\n\n    static void Main() {\n\n        // Create a hard-coded linked list:\n        // 14 -> 21 -> 13 -> 30 -> 10\n        Node head = new Node(14);\n        head.next = new Node(21);\n        head.next.next = new Node(13);\n        head.next.next.next = new Node(30);\n        head.next.next.next.next = new Node(10);\n\n        // Key to search in the linked list\n        int key = 14;\n\n        if (SearchKey(head, key))\n            Console.WriteLine(\"Yes\");\n        else\n            Console.WriteLine(\"No\");\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Recursive Javascript program to search\n// an element in linked list\n\n\n// A Linked List Node\nclass Node {\n\n    // Constructor to initialize a new node with data\n    constructor(new_data) {\n        this.data = new_data;\n        this.next = null;\n    }\n}\n\n// Checks whether the key is present in linked list\nfunction searchKey(head, key) {\n\n    // Base case\n    if (head === null)\n        return false;\n\n    // If key is present in current node, return true\n    if (head.data === key)\n        return true;\n\n    // Recur for remaining list\n    return searchKey(head.next, key);\n}\n\n// Create a hard-coded linked list:\n// 14 -> 21 -> 13 -> 30 -> 10\nlet head = new Node(14);\nhead.next = new Node(21);\nhead.next.next = new Node(13);\nhead.next.next.next = new Node(30);\nhead.next.next.next.next = new Node(10);\n\n// Key to search in the linked list\nlet key = 14;\n\nif (searchKey(head, key))\nconsole.log(\"Yes\");\nelse\nconsole.log(\"No\");\n\n````\n\n\n\n\n**Output**\n```\nYes\n```\n\n****Time Complexity:****\nO(N), where\n\n****N****\nis the number of nodes in the linked list.\n\n\n\n****Auxiliary Space:****\nO(N), Stack space used by recursive calls",
        "metadata": {
            "lesson_id": "52d5e2e5-8598-413c-be15-d5c2a0db1948",
            "course_id": "bd157822-862c-4b14-80e0-791fb1f7f1f6",
            "course_name": "Linked List Data Structure Guide",
            "lesson_description": "",
            "course_description": "An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving."
        }
    },
    {
        "page_content": "Given a singly linked list and a position (1-based indexing), the task is to delete a linked list node at the given position.\n\n\n****Note:****\nPosition will be valid (i.e, 1 <= position <= linked list length)\n\n\n****Example:****\n\n\n> ****Input:****\n> position = 2, Linked List = 8->2->3->1->7\n>\n>\n>\n> ****Output:****\n> Linked List =  8->3->1->7\n>\n>\n> ****Input:****\n> position = 1, Linked List = 8->2->3->1->7\n>\n>\n>\n> ****Output:****\n> Linked List = 2->3->1->7\n\n****Approach:****\n\n\nDeletion at a specified position in a linked list involves removing a node from a specific index/position, which can be the first, middle, or last node.\n\n\n> To perform the deletion, If the position is 1, we update the\n>\n> ****head****\n> to point to the\n>\n> ****next node****\n> and delete the current head. For other positions, we traverse the list to reach the node just before the specified\n>\n> ****position****\n> . If the target node exists, we adjust the next of this previous node to point to next of\n>\n> ****next nodes****\n> , which will result in skipping the target node.\n\n![Deletion-specific-At-End--](https://media.geeksforgeeks.org/wp-content/uploads/20240729185435/Deletion-specific-At-End--.webp)\n\nDelete a Linked List node at a given position\n\n\nStep-by-step approach:\n\n\n* If list is empty (\n\n  ****head****\n  ==\n\n  ****NULL)****\n  , returns the\n\n  ****head****\n  .\n* If the\n\n  ****position****\n  to delete is\n\n  ****1****\n  (the head node):\n  + Update\n\n    ****head = temp->next****\n* Traverse the list until reaching the desired position:\n  + Initialize\n\n    ****prev****\n    to keep track of the previous node.\n  + Move\n\n    ****temp****\n    through the list until the position is reached.\n* Check for Valid Position:\n  + If\n\n    ****temp****\n    becomes\n\n    ****NULL****\n    , it means the position exceeds the number of nodes in the list. Print a message and return the\n\n    ****head****\n    .\n* If the node to delete is found:\n  + Set\n\n    ****prev->next****\n    to\n\n    ****temp->next****\n    , effectively skipping over the node to be deleted.\n\n****Code Implementation:****\n\nC++14\n\n````\n// C++ program to delete a linked list node at a given\n// position\n#include <iostream>\nusing namespace std;\n\n// Node structure for the linked list\nstruct Node {\n    int data;\n    Node* next;\n    Node(int data)\n        : data(data)\n        , next(nullptr)\n    {\n    }\n};\n\n// Function to delete a node at a given position\nNode* deleteNode(Node* head, int position)\n{\n    // previous of node to be deleted\n    Node* prev;\n    Node* temp = head;\n\n    // Base case if linked list is empty\n    if (temp == NULL)\n        return head;\n\n    // Case 1: Head is to be deleted\n    if (position == 1) {\n        // make next node as head and free old head\n        head = temp->next;\n        free(temp);\n        return head;\n    }\n\n    // Case 2: Node to be deleted is in middle\n    // Traverse till given position\n    for (int i = 1; i != position; i++) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    // If given position is found, delete node\n    if (temp != NULL) {\n        prev->next = temp->next;\n        free(temp);\n    }\n    // If given position is not present\n    else {\n        cout << \"Data not present\\n\";\n    }\n\n    return head;\n}\n\nvoid printList(Node* head)\n{\n    while (head != nullptr) {\n        cout << head->data << \" -> \";\n        head = head->next;\n    }\n    cout << \"nullptr\" << endl;\n}\n\n// Driver code\nint main()\n{\n    // Creating a static linked list\n    // 1 -> 2 -> 3 -> 4 -> 5 -> nullptr\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n\n    cout << \"Original list: \";\n    printList(head);\n\n    // Deleting node at position 2\n    int position = 2;\n    head = deleteNode(head, position);\n\n    cout << \"List after deletion : \";\n    printList(head);\n\n    // Cleanup remaining nodes\n    while (head != nullptr) {\n        Node* temp = head;\n        head = head->next;\n        delete temp;\n    }\n\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to delete a linked list node at a given\n// position\n\n#include <stdio.h>\n#include <stdlib.h>\n\n// Node structure for the linked list\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* newNode(int data)\n{\n    struct Node* node\n        = (struct Node*)malloc(sizeof(struct Node));\n    node->data = data;\n    node->next = NULL;\n    return node;\n}\n\n// Function to delete a node at a given position\nstruct Node* deleteNode(struct Node* head, int position)\n{\n    struct Node* temp = head;\n    struct Node* prev = NULL;\n\n    // Base case if linked list is empty\n    if (temp == NULL)\n        return head;\n\n    // Case 1: Head is to be deleted\n    if (position == 1) {\n        head = temp->next;\n        free(temp);\n        return head;\n    }\n\n    // Case 2: Node to be deleted is in middle\n    // Traverse till given position\n    for (int i = 1; temp != NULL && i < position; i++) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    // If given position is found, delete node\n    if (temp != NULL) {\n        prev->next = temp->next;\n        free(temp);\n    }\n    else {\n        printf(\"Data not present\\n\");\n    }\n\n    return head;\n}\n\nvoid printList(struct Node* head)\n{\n    while (head != NULL) {\n        printf(\"%d -> \", head->data);\n        head = head->next;\n    }\n    printf(\"NULL\\n\");\n}\n\n// Driver code\nint main()\n{\n    struct Node* head = newNode(1);\n    head->next = newNode(2);\n    head->next->next = newNode(3);\n    head->next->next->next = newNode(4);\n    head->next->next->next->next = newNode(5);\n\n    printf(\"Original list: \");\n    printList(head);\n\n    int position = 2;\n    head = deleteNode(head, position);\n\n    printf(\"List after deletion: \");\n    printList(head);\n\n    // Cleanup remaining nodes\n    while (head != NULL) {\n        struct Node* temp = head;\n        head = head->next;\n        free(temp);\n    }\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to delete a linked list node at a given\n// position\n\n// Node class to define a linked list node\nclass Node {\n    int data;\n    Node next;\n\n    Node(int data)\n    {\n        this.data = data;\n        this.next = null;\n    }\n}\n\npublic class LinkedList {\n    // Function to delete a node at a given position\n    public static Node deleteNode(Node head, int position)\n    {\n        Node temp = head;\n        Node prev = null;\n\n        // Base case if linked list is empty\n        if (temp == null)\n            return head;\n\n        // Case 1: Head is to be deleted\n        if (position == 1) {\n            head = temp.next;\n            return head;\n        }\n\n        // Case 2: Node to be deleted is in middle\n        // Traverse till given position\n        for (int i = 1; temp != null && i < position; i++) {\n            prev = temp;\n            temp = temp.next;\n        }\n\n        // If given position is found, delete node\n        if (temp != null) {\n            prev.next = temp.next;\n        }\n        else {\n            System.out.println(\"Data not present\");\n        }\n\n        return head;\n    }\n\n    // Function to print the linked list\n    public static void printList(Node head)\n    {\n        while (head != null) {\n            System.out.print(head.data + \" -> \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n\n    // Driver code\n    public static void main(String[] args)\n    {\n        // Creating a static linked list\n        // 1 -> 2 -> 3 -> 4 -> 5 -> null\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n        // Print original list\n        System.out.print(\"Original list: \");\n        printList(head);\n\n        // Deleting node at position 2\n        int position = 2;\n        head = deleteNode(head, position);\n\n        // Print list after deletion\n        System.out.print(\"List after deletion: \");\n        printList(head);\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to delete a linked list node at\n# a given position\n\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n# Function to delete a node at a given position\n\n\ndef deleteNode(head, position):\n    temp = head\n    prev = None\n\n    # Base case if linked list is empty\n    if temp is None:\n        return head\n\n    # Case 1: Head is to be deleted\n    if position == 1:\n        head = temp.next\n        return head\n\n    # Case 2: Node to be deleted is in middle\n    # Traverse till given position\n    for i in range(1, position):\n        prev = temp\n        temp = temp.next\n        if temp is None:\n            print(\"Data not present\")\n            return head\n\n    # If given position is found, delete node\n    if temp is not None:\n        prev.next = temp.next\n\n    return head\n\n# Function to print the linked list\n\n\ndef printList(head):\n    while head:\n        print(f\"{head.data} -> \", end=\"\")\n        head = head.next\n    print(\"None\")\n\n\n# Driver code\nif __name__ == \"__main__\":\n    # Creating a static linked list\n    # 1 -> 2 -> 3 -> 4 -> 5 -> None\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n\n    # Print original list\n    print(\"Original list: \", end=\"\")\n    printList(head)\n\n    # Deleting node at position 2\n    position = 2\n    head = deleteNode(head, position)\n\n    # Print list after deletion\n    print(\"List after deletion: \", end=\"\")\n    printList(head)\n\n````\n\nJavaScript\n\n````\n// Javascript program to delete a linked list node at a\n// given position\nclass Node {\n    constructor(data)\n    {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// Function to delete a node at a given position\nfunction deleteNode(head, position)\n{\n    let temp = head;\n    let prev = null;\n\n    // Base case if linked list is empty\n    if (temp === null)\n        return head;\n\n    // Case 1: Head is to be deleted\n    if (position === 1) {\n        head = temp.next;\n        return head;\n    }\n\n    // Case 2: Node to be deleted is in middle\n    // Traverse till given position\n    for (let i = 1; temp !== null && i < position; i++) {\n        prev = temp;\n        temp = temp.next;\n    }\n\n    // If given position is found, delete node\n    if (temp !== null) {\n        prev.next = temp.next;\n    }\n    else {\n        console.log(\"Data not present\");\n    }\n\n    return head;\n}\n\n// Function to print the linked list\nfunction printList(head)\n{\n    while (head !== null) {\n        process.stdout.write(head.data + \" -> \");\n        head = head.next;\n    }\n    console.log(\"null\");\n}\n\n// Driver code\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.next = new Node(3);\nhead.next.next.next = new Node(4);\nhead.next.next.next.next = new Node(5);\n\n// Print original list\nconsole.log(\"Original list: \");\nprintList(head);\n\n// Deleting node at position 2\nlet position = 2;\nhead = deleteNode(head, position);\n\n// Print list after deletion\nconsole.log(\"List after deletion: \");\nprintList(head);\n\n````\n\n\n\n\n**Output**\n```\nOriginal list: 1 -> 2 -> 3 -> 4 -> 5 -> nullptr\nList after deletion : 1 -> 3 -> 4 -> 5 -> nullptr\n\n```\n\n****Time Complexity****\n: O(n), where n is the number of nodes in the list\n\n\n\n****Auxiliary Space:****\nO(1)\n",
        "metadata": {
            "lesson_id": "cf626aff-7b6c-4197-a2cb-c8365f512ec8",
            "course_id": "bd157822-862c-4b14-80e0-791fb1f7f1f6",
            "course_name": "Linked List Data Structure Guide",
            "lesson_description": "",
            "course_description": "An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving."
        }
    },
    {
        "page_content": "Given a\n\n****linked list****\n, the task is to\n\n****delete****\nthe linked list completely.\n\n\n****Examples:****\n\n> ****Input:****\n> head: 1 -> 2 -> 3 -> 4 -> 5 -> NULL\n>\n>\n>\n> ****Output:****\n> NULL\n>\n>\n>\n> ****Explanation:****\n> Linked List is Deleted.\n>\n>\n>\n>\n>\n> ****Input:****\n> head: 1 -> 12 -> 1 -> 4 -> 1 -> NULL\n>\n>\n>\n> ****Output:****\n> NULL\n>\n>\n>\n> ****Explanation:****\n> Linked List is Deleted.\n\nTable of Content\n\n* [[Expected Approach \u2013 1] Using Recursion \u2013 O(n) Time and O(n) Space](#expected-approach-1-using-recursion-on-time-and-on-space)\n* [[Expected Approach \u2013 2] Using Iteration \u2013 O(n) Time and O(1) Space](#expected-approach-2-using-iteration-on-time-and-o1-space)\n### [Expected Approach \u2013 1] Using Recursion \u2013 O(n) Time and O(n) Space:\n\n> The idea is to use\n>\n> [****recursion****](https://www.geeksforgeeks.org/introduction-to-recursion-2/)\n> to delete the entire linked list. Traverse from the\n>\n> ****head****\n> to the\n>\n> ****end****\n> of the list recursively. While backtracking, delete the\n>\n> ****currrent****\n> node. This ensures that each node is processed after its subsequent nodes.\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n// C++ program to delete a linked list\n// using recursion\n#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    Node(int x) {\n        data = x;\n        next = nullptr;\n    }\n};\n\n// Given the head of a list, delete the list\n// using recursion\nvoid deleteList(Node* curr) {\n\n    // Base case: If the list is empty, return\n    if (curr == nullptr) {\n        return;\n    }\n\n    // Recursively delete the next node\n    deleteList(curr->next);\n\n    // Delete the current node\n    delete curr;\n}\n\nint main() {\n\n    // Create a hard-coded linked list:\n    // 1 -> 2 -> 3 -> 4 -> 5\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n\n    deleteList(head);\n    cout << \"NULL\";\n\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to delete a linked list\n// using recursion\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Given the head of a list, delete the list\n// using recursion\nvoid deleteList(struct Node* curr) {\n\n    // Base case: If the list is empty, return\n    if (curr == NULL) {\n        return;\n    }\n\n    // Recursively delete the next node\n    deleteList(curr->next);\n\n    // Delete the current node\n    free(curr);\n}\n\nstruct Node* createNode(int new_data) {\n    struct Node* new_node =\n        (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\n\nint main() {\n\n    // Create a hard-coded linked list:\n    // 1 -> 2 -> 3 -> 4 -> 5\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n\n    deleteList(head);\n    printf(\"NULL\");\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to delete a linked list\nclass Node {\n    int data;\n    Node next;\n\n    Node(int x) {\n        data = x;\n        next = null;\n    }\n}\n\n\npublic class GfG {\n\n    public static void main(String[] args) {\n\n        // Create a hard-coded linked list:\n        // 1 -> 2 -> 3 -> 4 -> 5\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n           // Set head to null to remove the reference to the linked list.\n        // This allows Java's garbage collector to automatically clean up\n        // the memory used by the nodes, as there are no more references\n        // to the nodes in the linked list.\n          head = null;\n          System.out.print(\"NULL\");\n    }\n\n}\n\n````\n\nPython\n\n````\n# Python program to delete a linked list\n\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\n\n\nif __name__ == \"__main__\":\n\n    # Create a hard-coded linked list:\n    # 1 -> 2 -> 3 -> 4 -> 5\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n\n    # Set head to None to remove the reference to the linked list.\n    # This allows Python's garbage collector to automatically reclaim\n    # the memory used by the nodes, as there are no more references\n    # to the nodes in the linked list.\n    head = None\n    print(\"NULL\")\n\n````\n\nC#\n\n````\n// C# program to delete a linked list\n\nusing System;\n\nclass Node {\n    public int Data;\n    public Node next;\n\n    public Node(int x) {\n        Data = x;\n        next = null;\n    }\n}\n\nclass GfG {\n\n    static void Main() {\n\n        // Create a hard-coded linked list:\n        // 1 -> 2 -> 3 -> 4 -> 5\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n           // Set head to null to remove the reference to the linked list.\n        // This allows C#'s garbage collector to automatically reclaim\n        // the memory used by the nodes, as there are no more references\n        // to the nodes in the linked list.\n        head = null;\n        Console.WriteLine(\"NULL\");\n    }\n}\n\n````\n\nJavaScript\n\n````\n// JavaScript program to delete a linked list\n\nclass Node {\n    constructor(x) {\n        this.data = x;\n        this.next = null;\n    }\n}\n\n// Create a hard-coded linked list:\n// 1 -> 2 -> 3 -> 4 -> 5\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.next = new Node(3);\nhead.next.next.next = new Node(4);\nhead.next.next.next.next = new Node(5);\n\n// Set head to null to remove the reference to the linked list.\n// This allows JavaScript's garbage collector to automatically reclaim\n// the memory used by the nodes, as there are no more references\n// to the nodes in the linked list.\nhead = null;\nconsole.log(\"NULL\");\n\n````\n\n\n\n\n**Output**\n```\nNULL\n```\n\n****Time Complexity:****\nO(n), where\n\n****n****\nis the number of nodes in the given linked list.\n\n\n\n****Auxiliary Space:****\nO(n)\n\n\n### [Expected Approach \u2013 2] Using Iteration \u2013 O(n) Time and O(1) Space:\n\n> The idea is to\n>\n> ****iteratively****\n> delete the list by starting from the\n>\n> ****head****\n> and moving towards the\n>\n> ****end****\n> . At each step, the function stores a\n>\n> ****reference****\n> to the\n>\n> ****next****\n> node, deletes the\n>\n> ****current****\n> node, and\n>\n> ****moves****\n> to the next node. This continues until all nodes are deleted.\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n// C++ program to delete a linked list\n// using iteration\n#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    Node(int x) {\n        data = x;\n        next = nullptr;\n    }\n};\n\n// Given the head of a list, delete the list\n// using iteration\nvoid deleteList(Node* curr) {\n\n    // Iterate through the list until it becomes empty\n    while (curr != nullptr) {\n\n        // Store the next node before deleting current\n        Node* temp = curr->next;\n\n        // Delete the current node\n        delete curr;\n\n        // Move to the next node\n        curr = temp;\n    }\n}\n\nint main() {\n\n    // Create a hard-coded linked list:\n    // 1 -> 2 -> 3 -> 4 -> 5\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n\n    deleteList(head);\n    head = nullptr;\n\n    cout << \"NULL\";\n\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to delete a linked list\n// using iteration\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Given the head of a list, delete the list\n// using iteration\nvoid deleteList(struct Node* curr) {\n\n    // Iterate through the list until it becomes empty\n    while (curr != NULL) {\n\n        // Store the next node before deleting current\n        struct Node* temp = curr->next;\n\n        // Delete the current node\n        free(curr);\n\n        // Move to the next node\n        curr = temp;\n    }\n}\n\nstruct Node* createNode(int new_data) {\n    struct Node* new_node =\n        (struct Node*)malloc(sizeof(struct Node));\n\n    new_node->data = new_data;\n    new_node->next = NULL;\n\n    return new_node;\n}\n\nint main() {\n\n    // Create a hard-coded linked list:\n    // 1 -> 2 -> 3 -> 4 -> 5\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n\n    deleteList(head);\n    head = NULL;\n\n    printf(\"NULL\");\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to delete a linked list\nclass Node {\n    int data;\n    Node next;\n\n    Node(int x) {\n        data = x;\n        next = null;\n    }\n}\n\npublic class GfG {\n\n    public static void main(String[] args) {\n\n        // Create a hard-coded linked list:\n        // 1 -> 2 -> 3 -> 4 -> 5\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n           // Set head to null to remove the reference to the linked list.\n        // This allows Java's garbage collector to automatically clean up\n        // the memory used by the nodes, as there are no more references\n        // to the nodes in the linked list.\n          head = null;\n          System.out.print(\"NULL\");\n    }\n\n}\n\n````\n\nPython\n\n````\n# Python program to delete a linked list\n\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\n\n\nif __name__ == \"__main__\":\n\n    # Create a hard-coded linked list:\n    # 1 -> 2 -> 3 -> 4 -> 5\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n\n    # Set head to None to remove the reference to the linked list.\n    # This allows Python's garbage collector to automatically reclaim\n    # the memory used by the nodes, as there are no more references\n    # to the nodes in the linked list.\n    head = None\n    print(\"NULL\")\n\n````\n\nC#\n\n````\n// C# program to delete a linked list\n\nusing System;\n\nclass Node {\n    public int Data;\n    public Node next;\n\n    public Node(int x) {\n        Data = x;\n        next = null;\n    }\n}\n\n\nclass GfG {\n\n    static void Main() {\n\n        // Create a hard-coded linked list:\n        // 1 -> 2 -> 3 -> 4 -> 5\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n           // Set head to null to remove the reference to the linked list.\n        // This allows C#'s garbage collector to automatically reclaim\n        // the memory used by the nodes, as there are no more references\n        // to the nodes in the linked list.\n        head = null;\n        Console.WriteLine(\"NULL\");\n    }\n}\n\n````\n\nJavaScript\n\n````\n// JavaScript program to delete a linked list\n\nclass Node {\n    constructor(x) {\n        this.data = x;\n        this.next = null;\n    }\n}\n\n// Create a hard-coded linked list:\n// 1 -> 2 -> 3 -> 4 -> 5\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.next = new Node(3);\nhead.next.next.next = new Node(4);\nhead.next.next.next.next = new Node(5);\n\n// Set head to null to remove the reference to the linked list.\n// This allows JavaScript's garbage collector to automatically reclaim\n// the memory used by the nodes, as there are no more references\n// to the nodes in the linked list.\nhead = null;\nconsole.log(\"NULL\");\n\n````\n\n\n\n\n**Output**\n```\nNULL\n```\n\n****Time Complexity:****\nO(n), where\n\n****n****\nis the number of nodes in the given linked list.\n\n\n\n****Auxiliary Space:****\nO(1)",
        "metadata": {
            "lesson_id": "21a97134-4f54-443f-870a-71183556f602",
            "course_id": "bd157822-862c-4b14-80e0-791fb1f7f1f6",
            "course_name": "Linked List Data Structure Guide",
            "lesson_description": "",
            "course_description": "An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving."
        }
    },
    {
        "page_content": "Given a\n\n****LinkedList****\nand an\n\n****index****\n(1-based). The task is to find the\n\n****data value****\nstored in the node at that\n\n****kth****\nposition. If no such node exists whose index is\n\n****k****\nthen\n\n****return -1.****\n\n****Example:****\n\n\n> ****Input****\n> : 1->10->30->14, index = 2\n>\n>\n>\n> ****Output****\n> : 10\n>\n>\n>\n> ****Explanation****\n> : The node value at index 2 is 10\n>\n>\n> ![Maximum-of-all-subarrays-of-size-K](https://media.geeksforgeeks.org/wp-content/uploads/20240822110836/Maximum-of-all-subarrays-of-size-K.webp)\n>\n>\n>\n> ****Input****\n> : 1->32->12->10->30->14->100, index = 8\n>\n>\n>\n> ****Output****\n> : -1\n>\n>\n>\n> ****Explanation****\n> : No such node exists at index = 8.\n\nTable of Content\n\n* [[Naive Approach] Recursive Method \u2013 O(n) Time and O(n) Space](#approach-1-using-recursion-on-time-and-on-space)\n* [[Expected Approach-2] Iterative Method \u2013 O(n) Time and O(1) Space](#approach-2-using-iterative-method-on-time-and-o1-space)\n### ****[Naive Approach] Recursive Method \u2013 O(n) Time and O(n) Space****\n\n> The idea is to use the\n>\n> [****recursive****](https://www.geeksforgeeks.org/introduction-to-recursion-2/)\n> ****method****\n> to find the value of\n>\n> ****index****\n> node\n>\n> ****(1- based)****\n> . Call the function\n>\n> ****GetNth(head,index)****\n> recusively, where\n>\n> ****head****\n> will represent the\n>\n> ****current head****\n> node . Decrement the index\n>\n> ****value by 1****\n> on every recursion call. When the\n>\n> ****n reaches 1****\n> ,we will return the\n>\n> ****data****\n> of current node.\n\n\nBelow is the implementation of above approach:\n\n\nC++\n\n````\n//C++ program to find the data at nth node\n//recursively\n\n#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n    int data;\n    Node* next;\n    Node(int x) {\n      data = x;\n      next = NULL;\n    }\n};\n\n// Takes head pointer of the linked list and index\n// as arguments and returns data at index.\nint GetNth(Node* head, int index) {\n\n    // If the list is empty or index is out of bounds\n    if (head == NULL)\n        return -1;\n\n    // If index equals 1, return node's data\n    if (index == 1)\n        return head->data;\n\n    // Recursively move to the next node\n    return GetNth(head->next, index - 1);\n}\n\n\nint main() {\n\n    // Create a hard-coded linked list:\n    // 1 -> 2 -> 3 -> 4 -> 5\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n\n    cout << \"Element at index 3 is \" << GetNth(head, 3) << endl;\n\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find the data at nth node\n// recursively\n\n#include <stdio.h>\nstruct Node {\n    int data;\n    struct Node *next;\n};\n\n// Takes head pointer of the linked list and index\n// as arguments and returns data at index.\nint GetNth(struct Node *head, int index) {\n\n    // If the list is empty or index is out of bounds\n    if (head == NULL)\n        return -1;\n\n    // If index equals 1, return node's data\n    if (index == 1)\n        return head->data;\n\n    // Recursively move to the next node\n    return GetNth(head->next, index - 1);\n}\n\nstruct Node *createNode(int new_data) {\n    struct Node *new_node =\n      (struct Node *)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\n\nint main() {\n\n    // Create a hard-coded linked list:\n    // 1 -> 2 -> 3 -> 4 -> 5\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n    printf(\"Element at index 3 is %d\\n\", GetNth(head, 3));\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find n'th node in linked list\n// using recursion\n\nimport java.io.*;\nclass Node {\n    int data;\n    Node next;\n\n    Node(int x){\n        data = x;\n        next = null;\n    }\n}\n\nclass GfG {\n\n    // Takes head pointer of the linked list and index\n    // as arguments and return data at index*/\n    static int GetNth(Node head, int index) {\n\n        if (head == null)\n            return -1;\n\n        // if index equal to 1 return node.data\n        if (index == 1)\n            return head.data;\n\n        // recursively decrease n and increase\n        // head to next pointer\n        return GetNth(head.next, index - 1);\n    }\n\n    public static void main(String args[]) {\n\n        // Create a hard-coded linked list:\n        // 1 -> 2 -> 3 -> 4 -> 5\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n        System.out.printf(\"Element at index 3 is %d\",\n                          GetNth(head, 3));\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to find the Nth node in\n# linked list using recursion\n\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\n\n# Recursive method to find the Nth node\ndef get_nth_node(head, index):\n\n    # Helper function to handle recursion\n    #and count tracking\n        if head is None:\n            print(-1)\n\n        if index == 1:\n            print(head.data)\n        else:\n            get_nth_node(head.next, index-1)\n\nif __name__ == \"__main__\":\n\n    # Create a linked list: 1 -> 2 -> 3 -> 4 -> 5\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    print(\"Element at index 3 is\", end=\" \")\n    get_nth_node(head, 3)\n\n````\n\nC#\n\n````\n// C# program to find the Nth node in\n// linked list using recursion\n\nusing System;\n\nclass Node {\n    public int Data;\n    public Node Next;\n\n    public Node(int x) {\n        Data = x;\n        Next = null;\n    }\n}\n\nclass GfG {\n\n    // Takes head pointer of the linked list and index\n    // as arguments and returns data at index\n    static int GetNth(Node head, int index) {\n\n        // Base Condition\n        if (head == null)\n            return -1;\n\n        // If n equals 0, return the node's data\n        if (index == 1)\n            return head.Data;\n\n        // Recursively move to the next node\n        return GetNth(head.Next, index - 1);\n    }\n\n    public static void Main() {\n\n        // Create a hard-coded linked list:\n        // 1 -> 2 -> 3 -> 4 -> 5\n        Node head = new Node(1);\n        head.Next = new Node(2);\n        head.Next.Next = new Node(3);\n        head.Next.Next.Next = new Node(4);\n        head.Next.Next.Next.Next = new Node(5);\n\n        Console.WriteLine(\"Element at index 3 is {0}\", GetNth(head, 3));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// JavaScript program to find the n'th node in\n// a linked list using recursion\n\nclass Node {\n    constructor(new_data) {\n        this.data = new_data;\n        this.next = null;\n    }\n}\n\nfunction GetNth(head, index) {\n\n    // Base case: if the list is empty or index is out of\n    // bounds\n    if (head === null) {\n        return -1;\n    }\n\n    // Base case: if count equals n, return node's data\n    if (index === 1) {\n        return head.data;\n    }\n\n    // Recursive case: move to the next node and decrease\n    // index\n    return GetNth(head.next, index - 1);\n}\n\n// Create a hard-coded linked list:\n// 1 -> 2 -> 3 -> 4 -> 5\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.next = new Node(3);\nhead.next.next.next = new Node(4);\nhead.next.next.next.next = new Node(5);\nconsole.log(\"Element at index 3 is\", GetNth(head, 3));\n\n````\n\n\n\n\n**Output**\n```\nElement at index 3 is 3\n\n```\n\n****Time Complexity :****\nO(n)\n\n****,****\nwhere n is the nth node of linked list.\n\n\n\n****Auxiliary Space:****\nO(n), for recursive call stack\n\n\n### ****[Expected Approach-2] Iterative Method \u2013 O(n) Time and O(1) Space****\n\n> The idea is similar to recursive\n>\n> ****approach to find****\n> the value at\n>\n> ****index****\n> node\n>\n> ****(1- based)****\n> .We will use a variable say,\n>\n> ****count = 1****\n> to track the node\n>\n> ****s.****\n> Traverse the list until\n>\n> ****curr != NULL****\n> . Increment the\n>\n>\n> count\n>\n>\n> if count is\n>\n> ****not equal****\n> to\n>\n> ****index****\n> node\n>\n> ****(1- based) ,****\n> else if count equals to the\n>\n> ****index****\n> node, return data at\n>\n> ****current****\n> node.\n\n\nBelow is the implementation of above approach :\n\n\nC++\n\n````\n// C++ program to find n'th\n// node in linked list (iteratively)\n\n#include <iostream>\nusing namespace std;\n\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node(int x) {\n        data = x;\n        next = nullptr;\n    }\n};\n\n// Function to find the nth node in the list\nint GetNth(Node *head, int index) {\n    Node *curr = head;\n    int count = 1;\n\n    while (curr != nullptr) {\n        if (count == index)\n            return curr->data;\n        count++;\n        curr = curr->next;\n    }\n\n    return -1;\n}\n\nint main() {\n\n    // Create a hard-coded linked list:\n    // 1 -> 2 -> 3 -> 4 -> 5\n    Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n\n    cout << \"Element at index 3 is \" << GetNth(head, 3) << endl;\n\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find n'th\n// node in linked list (iteratively)\n\n#include <stdio.h>\nstruct Node {\n    int data;\n    struct Node *next;\n};\n\n// Function to find the nth node in the list\nint GetNth(struct Node *head, int index)\n{\n    struct Node *curr = head;\n    int count = 1;\n    while (curr != NULL) {\n        if (count == index)\n            return curr->data;\n        count++;\n        curr = curr->next;\n    }\n\n    return -1;\n}\n\nstruct Node *createNode(int new_data) {\n    struct Node *new_node =\n      (struct Node *)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\n\nint main() {\n\n    // Create a hard-coded linked list:\n    // 1 -> 2 -> 3 -> 4 -> 5\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n    printf(\"Element at index 3 is %d\\n\", GetNth(head, 3));\n}\n\n````\n\nJava\n\n````\n// Java program to find the Nth node in\n// a linked list iteratively\n\nclass Node {\n    int data;\n    Node next;\n    Node(int x) {\n        data = x;\n        next = null;\n    }\n}\n\nclass GfG {\n\n    // Function to find the nth node in the list iteratively\n    static int getNthNodeIterative(Node head, int index) {\n        Node current = head;\n        int count = 1;\n\n        // Traverse the list until the end or until the nth\n        // node is reached\n        while (current != null) {\n            if (count == index) {\n                return current.data;\n            }\n            count++;\n            current = current.next;\n        }\n\n        // Return -1 if the index is out of bounds\n        return -1;\n    }\n\n    public static void main(String[] args) {\n\n        // Create a hard-coded linked list:\n        // 1 -> 2 -> 3 -> 4 -> 5\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n        int index = 3;\n        int result = getNthNodeIterative(head, index);\n        if (result != -1) {\n            System.out.println(\"Element at index \" + index\n                               + \" is \" + result);\n        }\n        else {\n            System.out.println(\"Index \" + index\n                               + \" is out of bounds\");\n        }\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to find the Nth node in\n# a linked list iteratively\n\nclass Node:\n    def __init__(self, x):\n        self.data = x\n        self.next = None\n\n# Function to find the nth node in the list iteratively\ndef get_nth_node_iterative(head, n):\n    current = head\n    count = 1\n\n    # Traverse the list until the end or until the nth node is reached\n    while current is not None:\n        if count == n:\n            return current.data\n        count += 1\n        current = current.next\n\n    # Return -1 if the index is out of bounds\n    return -1\n\nif __name__ == \"__main__\":\n\n    # Create a hard-coded linked list:\n    # 1 -> 2 -> 3 -> 4 -> 5\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    index = 3\n    result = get_nth_node_iterative(head, index)\n    if result != -1:\n        print(f\"Element at index {index} is {result}\")\n    else:\n        print(f\"Index {index} is out of bounds\")\n\n````\n\nC#\n\n````\n// Iterative C# program to find the nth node in\n// a linked list\n\nusing System;\n\nclass Node {\n    public int Data;\n    public Node Next;\n    public Node(int x) {\n        Data = x;\n        Next = null;\n    }\n}\n\nclass GfG {\n\n    // Given the head of a list and index, find the nth node\n    // and return its data\n    static int GetNthNode(Node head, int n) {\n        Node current = head;\n        int count = 1;\n\n        // Traverse the list until the nth node is found or\n        // end of the list is reached\n        while (current != null) {\n            if (count == n) {\n                return current.Data;\n            }\n            count++;\n            current = current.Next;\n        }\n\n        // Return -1 if the index is out of bounds\n        return -1;\n    }\n\n   public static void Main() {\n\n        // Create a hard-coded linked list:\n        // 1 -> 2 -> 3 -> 4 -> 5\n        Node head = new Node(1);\n        head.Next = new Node(2);\n        head.Next.Next = new Node(3);\n        head.Next.Next.Next = new Node(4);\n        head.Next.Next.Next.Next = new Node(5);\n        int index = 3;\n        int result = GetNthNode(head, index);\n        if (result != -1) {\n            Console.WriteLine($\"Element at index {index} is {result}\");\n        }\n        else {\n            Console.WriteLine($\"Index {index} is out of bounds\");\n        }\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Iterative JavaScript program to find the Nth node in a\n// linked list\n\nclass Node {\n    constructor(x) {\n        this.data = x;\n        this.next = null;\n    }\n}\n\n// Given the head of a list and an index, return the data at\n// the index\nfunction getNth(head, index) {\n    let current = head;\n    let count = 1;\n\n    // Traverse the linked list\n    while (current !== null) {\n        if (count === index) {\n            // Return data at the current\n            // node if index matches\n            return current.data;\n        }\n        count++;\n        current = current.next;\n    }\n\n    // Return -1 if index is out of bounds\n    return -1;\n}\n\n// Create a hard-coded linked list:\n// 1 -> 2 -> 3 -> 4 -> 5\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.next = new Node(3);\nhead.next.next.next = new Node(4);\nhead.next.next.next.next = new Node(5);\nlet index = 3;\nlet result = getNth(head, index);\nif (result !== -1) {\n    console.log(`Element at index ${index} is ${result}`);\n}\nelse {\n    console.log(`Index ${index} is out of bounds`);\n}\n\n````\n\n\n\n\n**Output**\n```\nElement at index 3 is 3\n\n```\n\n****Time Complexity :****\nO(n)\n\n****,****\nwhere n is the nth node of linked list.\n\n\n\n****Auxiliary Space:****\nO(1)",
        "metadata": {
            "lesson_id": "a904febf-06a7-4308-ad85-436b2ed04ba7",
            "course_id": "bd157822-862c-4b14-80e0-791fb1f7f1f6",
            "course_name": "Linked List Data Structure Guide",
            "lesson_description": "",
            "course_description": "An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving."
        }
    },
    {
        "page_content": "Given a Linked List of\n\n****M****\nnodes and a number\n\n****N****\n, find the value at the Nth node from the end of the Linked List. If there is no Nth node from the end, print -1.\n\n\n****Examples:****\n\n> ****Input:****\n> 1 -> 2 -> 3 -> 4, N = 3\n>\n>\n>\n> ****Output:****\n> 2\n>\n>\n>\n> ****Explanation:****\n> Node 2 is the third node from the end of the linked list.\n>\n>\n> ****Input:****\n> 35 -> 15 -> 4 -> 20, N = 4\n>\n>\n>\n> ****Output:****\n> 35\n>\n>\n>\n> ****Explanation:****\n> Node 35 is the fourth node from the end of the linked list.\n\nTable of Content\n\n* [[Naive Approach] By Finding the length of list \u2013 Two Pass \u2013 O(M) Time and O(1) Space](#naive-approach-finding-the-length-of-list-and-return-the-node-two-pass-om-time-and-o1-space)\n* [[Expected Approach] Using Two Pointers \u2013 One Pass \u2013 O(M) Time and O(1) Space](#expected-approach-using-two-pointers-one-pass-om-time-and-o1-space)\n### ****[Naive Approach]**** Finding the length of list \u2013 Two Pass \u2013 O(M) Time and O(1) Space\n\n> The idea is to count the number of nodes in linked list in the first pass, say\n>\n> ****len****\n> . In the second pass, return the\n>\n> ****(len \u2013 n + 1)th****\n> nodes from beginning of the Linked List.\n\nC++14\n\n````\n// C++ program to find Nth node from end of linked list\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Link list node\nstruct Node {\n    int data;\n    Node* next;\n\n      // Constructor to initialize a new node with data\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\n\n// Function to find the Nth node from the last of a linked list\nint findNthFromLast(Node* head, int N) {\n    int len = 0, i;\n\n      // Pointer to store the copy of head\n    Node* temp = head;\n\n    // Count the number of nodes in Linked List\n    while (temp != NULL) {\n        temp = temp->next;\n        len++;\n    }\n\n    // Check if value of N is not\n    // more than length of the linked list\n    if (len < N)\n        return -1;\n\n    temp = head;\n\n    // Get the (len - N + 1)th node from the beginning\n    for (i = 1; i < len - N + 1; i++)\n        temp = temp->next;\n\n    return temp->data;\n}\n\nint main() {\n\n    // Create a hard-coded linked list:\n    // 35 -> 15 -> 4 -> 20\n    Node* head = new Node(35);\n    head->next = new Node(15);\n    head->next->next = new Node(4);\n    head->next->next->next = new Node(20);\n\n    // Function Call to find the 4th node from end\n    cout << findNthFromLast(head, 4);\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find Nth node from end of linked list\n\n#include <stdio.h>\n\n// Link list node\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to find the Nth node from the last of a linked list\nint findNthFromLast(struct Node* head, int N) {\n    int len = 0, i;\n\n    // Pointer to store the copy of head\n    struct Node* temp = head;\n\n    // Count the number of nodes in Linked List\n    while (temp != NULL) {\n        temp = temp->next;\n        len++;\n    }\n\n    // Check if value of N is not more than length of the linked list\n    if (len < N)\n        return -1;\n\n    temp = head;\n\n    // Get the (len - N + 1)th node from the beginning\n    for (i = 1; i < len - N + 1; i++)\n        temp = temp->next;\n\n    return temp->data;\n}\n\n// Function to create a new node\nstruct Node* createNode(int new_data) {\n    struct Node* new_node =\n       (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\n\nint main() {\n\n    // Create a hard-coded linked list:\n    // 35 -> 15 -> 4 -> 20\n    struct Node* head = createNode(35);\n    head->next = createNode(15);\n    head->next->next = createNode(4);\n    head->next->next->next = createNode(20);\n\n    // Function Call to find the 4th node from end\n    printf(\"%d\\n\", findNthFromLast(head, 4));\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find Nth node from\n// end of linked list\n\n// Link list node\nclass Node {\n    int data;\n    Node next;\n\n    // Constructor to initialize a new node with data\n    Node(int new_data) {\n        data = new_data;\n        next = null;\n    }\n}\n\npublic class GFG {\n      // Function to find the Nth node from the last of a linked list\n    static int findNthFromLast(Node head, int N) {\n        int len = 0, i;\n\n        // Pointer to store the copy of head\n        Node temp = head;\n\n        // Count the number of nodes in Linked List\n        while (temp != null) {\n            temp = temp.next;\n            len++;\n        }\n\n        // Check if value of N is not more than length of the linked list\n        if (len < N)\n            return -1;\n\n        temp = head;\n\n        // Get the (len - N + 1)th node from the beginning\n        for (i = 1; i < len - N + 1; i++)\n            temp = temp.next;\n\n        return temp.data;\n    }\n\n    public static void main(String[] args) {\n\n        // Create a hard-coded linked list:\n        // 35 -> 15 -> 4 -> 20\n        Node head = new Node(35);\n        head.next = new Node(15);\n        head.next.next = new Node(4);\n        head.next.next.next = new Node(20);\n\n        // Function Call to find the 4th node from end\n        System.out.println(findNthFromLast(head, 4));\n    }\n}\n\n````\n\nPython\n\n````\n# Python3 program to find Nth node from end of linked list\n\n# Link list node\nclass Node:\n\n   # Constructor to initialize a new node with data\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n\n# Function to find the Nth node from the last of a linked list\ndef findNthFromLast(head, N):\n    length = 0\n    temp = head\n\n    # Count the number of nodes in Linked List\n    while temp is not None:\n        temp = temp.next\n        length += 1\n\n    # Check if value of N is not more than length of the linked list\n    if length < N:\n        return -1\n\n    temp = head\n\n    # Get the (length - N + 1)th node from the beginning\n    for _ in range(1, length - N + 1):\n        temp = temp.next\n\n    return temp.data\n\nif __name__ == \"__main__\":\n\n    # Create a hard-coded linked list:\n    # 35 -> 15 -> 4 -> 20\n    head = Node(35)\n    head.next = Node(15)\n    head.next.next = Node(4)\n    head.next.next.next = Node(20)\n\n    # Function Call to find the 4th node from end\n    print(findNthFromLast(head, 4))\n\n````\n\nC#\n\n````\n// C# program to find N'th node from end of linked list\nusing System;\n\n// Link list node\nclass Node {\n    public int data;\n    public Node next;\n\n    // Constructor to initialize a new node with data\n    public Node(int new_data) {\n        data = new_data;\n        next = null;\n    }\n}\n\n// Function to find the Nth node from the last of a linked list\nclass GFG {\n    static int FindNthFromLast(Node head, int N) {\n        int len = 0;\n        Node temp = head;\n\n        // Count the number of nodes in Linked List\n        while (temp != null) {\n            temp = temp.next;\n            len++;\n        }\n\n        // Check if value of N is not more than length of the linked list\n        if (len < N)\n            return -1;\n\n        temp = head;\n\n        // Get the (len - N + 1)th node from the beginning\n        for (int i = 1; i < len - N + 1; i++)\n            temp = temp.next;\n\n        return temp.data;\n    }\n\n    static void Main() {\n\n        // Create a hard-coded linked list:\n        // 35 -> 15 -> 4 -> 20\n        Node head = new Node(35);\n        head.next = new Node(15);\n        head.next.next = new Node(4);\n        head.next.next.next = new Node(20);\n\n        // Function Call to find the 4th node from end\n        Console.WriteLine(FindNthFromLast(head, 4));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Javascript program to find N'th node from end of linked list\n\n// Link list node\nclass Node {\n\n    // Constructor to initialize a new node with data\n    constructor(new_data) {\n        this.data = new_data;\n        this.next = null;\n    }\n}\n\n// Function to find the Nth node from the last of a linked list\nfunction findNthFromLast(head, N) {\n    let len = 0;\n    let temp = head;\n\n    // Count the number of nodes in Linked List\n    while (temp !== null) {\n        temp = temp.next;\n        len++;\n    }\n\n    // Check if value of N is not more than length of the linked list\n    if (len < N) {\n        return -1;\n    }\n\n    temp = head;\n\n    // Get the (len - N + 1)th node from the beginning\n    for (let i = 1; i < len - N + 1; i++) {\n        temp = temp.next;\n    }\n\n    return temp.data;\n}\n\n// Create a hard-coded linked list:\n// 35 -> 15 -> 4 -> 20\nlet head = new Node(35);\nhead.next = new Node(15);\nhead.next.next = new Node(4);\nhead.next.next.next = new Node(20);\n\n// Function Call to find the 4th node from end\nconsole.log(findNthFromLast(head, 4));\n\n````\n\n\n\n\n**Output**\n```\n35\n```\n\n****Time complexity:****\nO(M) where\n\n****M****\nis the size of the linked list\n\n\n\n****Auxiliary Space:****\nO(1)\n\n\n### [Expected Approach] Using Two Pointers \u2013 One Pass \u2013 O(M) Time and O(1) Space\n\n> The idea is to maintain two pointers, say\n>\n> ****main\\_ptr****\n> and\n>\n> ****ref\\_ptr****\n> point to the head of Linked List and move\n>\n> ****ref\\_ptr****\n> to the Nth node from the head to ensure that the distance between main\\_ptr and ref\\_ptr is\n>\n> ****(N \u2013 1)****\n> . Now, move both the pointers simultaneously until ref\\_ptr reaches the last node. Since the distance between main\\_ptr and ref\\_ptr is (N \u2013 1), so when ref\\_ptr will reach the\n>\n> ****last node****\n> , main\\_ptr will reach\n>\n> ****Nth****\n> node from the end of Linked List. Return the value of node pointed by main\\_ptr.\n\n\nBelow image is a dry run of the above approach:\n\n\n\n\n\n\n\n\nFollow the given steps to solve the problem:\n\n\n* Maintain two pointers\n\n  ****main\\_ptr****\n  and\n\n  ****ref\\_ptr****\n* Move ref\\_ptr to the Nth node from the start\n* Now move both main\\_ptr and ref\\_ptr, until the ref\\_ptr reaches the last node\n* Now return the data of the main\\_ptr, as it is at the Nth node from the end\n\nC++\n\n````\n// C++ program to find Nth node from end of linked list\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Link list node\nstruct Node {\n    int data;\n    Node* next;\n\n    // Constructor to initialize a new node with data\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr;\n    }\n};\n\n// function to find Nth node from the end of linked list\nint nthFromEnd(Node *head, int N) {\n\n    // create two pointers main_ptr and ref_ptr\n    // initially pointing to head.\n    Node* main_ptr = head;\n    Node* ref_ptr = head;\n\n    // move ref_ptr to the n-th node from beginning.\n    for (int i = 1; i < N; i++) {\n        ref_ptr = ref_ptr->next;\n\n          // If the ref_ptr reaches NULL, then it means\n          // N > length of linked list\n        if (ref_ptr == NULL) {\n            return -1;\n        }\n    }\n\n    // move ref_ptr and main_ptr by one node until\n    // ref_ptr reaches last node of the list.\n    while (ref_ptr->next != NULL) {\n        ref_ptr = ref_ptr->next;\n        main_ptr = main_ptr->next;\n    }\n\n    return main_ptr->data;\n}\n\nint main() {\n\n    // Create a hard-coded linked list:\n    // 35 -> 15 -> 4 -> 20\n    Node* head = new Node(35);\n    head->next = new Node(15);\n    head->next->next = new Node(4);\n    head->next->next->next = new Node(20);\n\n    // Function Call to find the 4th node from end\n    cout << nthFromEnd(head, 4);\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find Nth node from end of linked list\n\n#include <stdio.h>\n\n// Link list node\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to find the Nth node from the last of a linked\n// list\nint findNthFromLast(struct Node* head, int N) {\n\n    // Create two pointers main_ptr and ref_ptr initially\n    // pointing to head\n    struct Node* main_ptr = head;\n    struct Node* ref_ptr = head;\n\n    // Move ref_ptr to the N-th node from the beginning\n    for (int i = 1; i < N; i++) {\n        ref_ptr = ref_ptr->next;\n\n        // If the ref_ptr reaches NULL, then it means\n        // N > length of linked list\n        if (ref_ptr == NULL) {\n            return -1;\n        }\n    }\n\n    // Move ref_ptr and main_ptr by one node until ref_ptr\n    // reaches the last node of the list\n    while (ref_ptr->next != NULL) {\n        ref_ptr = ref_ptr->next;\n        main_ptr = main_ptr->next;\n    }\n\n    return main_ptr->data;\n}\n\n// Function to create a new node\nstruct Node* createNode(int new_data) {\n    struct Node* new_node\n        = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\n\nint main() {\n\n    // Create a hard-coded linked list:\n    // 35 -> 15 -> 4 -> 20\n    struct Node* head = createNode(35);\n    head->next = createNode(15);\n    head->next->next = createNode(4);\n    head->next->next->next = createNode(20);\n\n    // Function Call to find the 4th node from end\n    printf(\"%d\\n\", findNthFromLast(head, 4));\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to find Nth node from end of linked list\n\n// Link list node\nclass Node {\n    int data;\n    Node next;\n\n    // Constructor to initialize a new node with data\n    Node(int new_data) {\n        data = new_data;\n        next = null;\n    }\n}\n\npublic class GFG {\n\n    // Function to find Nth node from the end of linked list\n    static int nthFromEnd(Node head, int N) {\n\n        // Create two pointers main_ptr and ref_ptr\n        // initially pointing to head.\n        Node main_ptr = head;\n        Node ref_ptr = head;\n\n        // Move ref_ptr to the N-th node from beginning.\n        for (int i = 1; i < N; i++) {\n            ref_ptr = ref_ptr.next;\n\n            // If the ref_ptr reaches NULL, then it means\n            // N > length of linked list\n            if (ref_ptr == null) {\n                return -1;\n            }\n        }\n\n        // Move ref_ptr and main_ptr by one node until\n        // ref_ptr reaches last node of the list.\n        while (ref_ptr.next != null) {\n            ref_ptr = ref_ptr.next;\n            main_ptr = main_ptr.next;\n        }\n\n        return main_ptr.data;\n    }\n\n    public static void main(String[] args) {\n\n        // Create a hard-coded linked list:\n        // 35 -> 15 -> 4 -> 20\n        Node head = new Node(35);\n        head.next = new Node(15);\n        head.next.next = new Node(4);\n        head.next.next.next = new Node(20);\n\n        // Function Call to find the 4th node from end\n        System.out.println(nthFromEnd(head, 4));\n    }\n}\n\n````\n\nPython\n\n````\n# Python3 program to find Nth node from end of linked list\n\n# Link list node\nclass Node:\n\n      # Constructor to initialize a new node with data\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n\n# Function to find Nth node from the end of linked list\ndef nth_from_end(head, N):\n\n    # Create two pointers main_ptr and ref_ptr\n    # initially pointing to head.\n    main_ptr = head\n    ref_ptr = head\n\n    # Move ref_ptr to the N-th node from beginning.\n    for _ in range(1, N):\n        ref_ptr = ref_ptr.next\n\n        # If the ref_ptr reaches None, then it means\n        # N > length of linked list\n        if ref_ptr is None:\n            return -1\n\n    # Move ref_ptr and main_ptr by one node until\n    # ref_ptr reaches last node of the list.\n    while ref_ptr.next is not None:\n        ref_ptr = ref_ptr.next\n        main_ptr = main_ptr.next\n\n    return main_ptr.data\n\nif __name__ == \"__main__\":\n\n    # Create a hard-coded linked list:\n    # 35 -> 15 -> 4 -> 20\n    head = Node(35)\n    head.next = Node(15)\n    head.next.next = Node(4)\n    head.next.next.next = Node(20)\n\n    # Function Call to find the 4th node from end\n    print(nth_from_end(head, 4))\n\n````\n\nC#\n\n````\n// C# program to find Nth node from end of linked list\nusing System;\n\nclass GFG {\n\n    // Node class for the linked list\n    class Node {\n        public int Data;\n        public Node Next;\n\n          // Constructor to initialize a new node with data\n        public Node(int newData) {\n            Data = newData;\n            Next = null;\n        }\n    }\n\n    // Function to find the Nth node from the end of the\n    // linked list\n    static int NthFromEnd(Node head, int N) {\n        Node mainPtr = head;\n        Node refPtr = head;\n\n        // Move refPtr to the N-th node from the beginning\n        for (int i = 1; i < N; i++) {\n            refPtr = refPtr ?.Next;\n\n            // If the refPtr reaches null, then N > length\n            // of linked list\n            if (refPtr == null) {\n                return -1;\n            }\n        }\n\n        // Move refPtr and mainPtr by one node until refPtr\n        // reaches the last node\n        while (refPtr?.Next != null) {\n            refPtr = refPtr.Next;\n            mainPtr = mainPtr.Next;\n        }\n\n        return mainPtr.Data;\n    }\n\n    static void Main() {\n\n        // Create a hard-coded linked list:\n        // 35 -> 15 -> 4 -> 20\n        Node head = new Node(35);\n        head.Next = new Node(15);\n        head.Next.Next = new Node(4);\n        head.Next.Next.Next = new Node(20);\n\n        // Function call to find the 4th node from the end\n        Console.WriteLine(NthFromEnd(head, 4));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// javascript program to find n'th\n// node from end of linked list\n\n// Linked List Node\nclass Node {\n\n    // Constructor to initialize a new node with data\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// Function to find Nth node from the end of linked list\nfunction nthFromEnd(head, N) {\n    let mainPtr = head;\n    let refPtr = head;\n\n    // Move refPtr to the N-th node from the beginning\n    for (let i = 1; i < N; i++) {\n        refPtr = refPtr.next;\n\n        if (refPtr === null) {\n\n            // If N is greater than the length of the linked list\n            return -1;\n        }\n    }\n\n    // Move refPtr and mainPtr by one node until refPtr reaches the last node\n    while (refPtr.next !== null) {\n        refPtr = refPtr.next;\n        mainPtr = mainPtr.next;\n    }\n\n    return mainPtr.data;\n}\n\n// Create a hard-coded linked list:\n// 35 -> 15 -> 4 -> 20\nconst head = new Node(35);\nhead.next = new Node(15);\nhead.next.next = new Node(4);\nhead.next.next.next = new Node(20);\n\n// Function call to find the 4th node from end\nconsole.log(nthFromEnd(head, 4));\n\n````\n\n\n\n\n**Output**\n```\nNode no. 4 from end is: 35\n\n```\n\n****Time Complexity:****\nO(M) where\n\n****M****\nis the length of the linked list\n\n\n\n****Auxiliary Space:****\nO(1)",
        "metadata": {
            "lesson_id": "c4109005-926f-4553-bb7a-e8751a632d01",
            "course_id": "bd157822-862c-4b14-80e0-791fb1f7f1f6",
            "course_name": "Linked List Data Structure Guide",
            "lesson_description": "",
            "course_description": "An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving."
        }
    },
    {
        "page_content": "Given a\n\n[doubly linked list](https://www.geeksforgeeks.org/doubly-linked-list/)\n, The task is to find the\n\n****number of nodes in****\nthe given doubly linked list.\n\n\nExample:\n\n\n> ****Input****\n> : 1<->2<->3<->4\n>\n>\n>\n> ****output****\n> : 4\n>\n>\n> ****Input****\n> : 1<->2\n>\n>\n>\n> ****output****\n> : 2\n\n### By Traversing the Doubly linked list \u2013 O(n) Time and O(1) Space\n\n> The idea is to traverse the doubly linked list starting from the\n>\n> ****head****\n> node. Increment the\n>\n> ****size****\n> variable until we reaches end.\n\n\nAlgorithm :\n\n\n* Initialize a variable\n\n  ****size****\n  to 0\n* Initialize a\n\n  ****curr****\n  node to\n\n  ****head****\n* Do the following while the\n\n  ****curr node****\n  is not NULL\n  + ****curr = curr -> next****\n  + ****size++;****\n* Return\n\n  ****size****\n  .\n\n\nBelow is the implementation of above approach:\n\n\nC++\n\n````\n// C++ program to\n// find size of doubly linked list.\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node *prev;\n    Node(int val) {\n        data = val;\n        next = nullptr;\n        prev = nullptr;\n    }\n};\n\n// This function returns size of linked list\nint findSize(Node *curr) {\n    int size = 0;\n    while (curr != NULL) {\n        size++;\n        curr = curr->next;\n    }\n    return size;\n}\n\nint main() {\n\n    // Create a hard-coded doubly linked list:\n    // 1 <-> 2 <-> 3 <-> 4\n    Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->prev = head;\n    head->next->next = new Node(3);\n    head->next->next->prev = head->next;\n    head->next->next->next = new Node(4);\n    head->next->next->next->prev = head->next->next;\n\n    cout << findSize(head);\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to find size of doubly linked list.\n#include <stdio.h>\n\nstruct Node {\n  int data;\n  struct Node* prev;\n  struct Node* next;\n};\n\n\nint findSize(struct Node* curr) {\n  int size = 0;\n  while (curr != NULL) {\n    size++;\n    curr = curr->next;\n  }\n  return size;\n}\n\nstruct Node *createNode(int new_data) {\n    struct Node *new_node =\n      (struct Node *)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    new_node->prev = NULL;\n    return new_node;\n}\n\nint main() {\n\n    // Create a hard-coded doubly linked list:\n    // 1 <-> 2 <-> 3 <-> 4\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->prev = head;\n    head->next->next = createNode(3);\n    head->next->next->prev = head->next;\n    head->next->next->next = createNode(4);\n    head->next->next->next->prev = head->next->next;\n      printf(\"%d\", findSize(head));\n\n  return 0;\n}\n\n````\n\nJava\n\n````\n// A complete working Java program to\n// find the size of a doubly linked list.\nclass Node {\n    int data;\n    Node next;\n    Node prev;\n\n    Node(int val) {\n        data = val;\n        next = null;\n        prev = null;\n    }\n}\n\npublic class GfG {\n\n    // This function returns the size of\n      // the linked list\n    static int findSize(Node curr) {\n        int size = 0;\n        while (curr != null) {\n            size++;\n            curr = curr.next;\n        }\n        return size;\n    }\n\n    public static void main(String[] args) {\n\n        // Create a hard-coded doubly linked list:\n        // 1 <-> 2 <-> 3 <-> 4\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.prev = head;\n        head.next.next = new Node(3);\n        head.next.next.prev = head.next;\n        head.next.next.next = new Node(4);\n        head.next.next.next.prev = head.next.next;\n\n        System.out.println(findSize(head));\n    }\n}\n\n````\n\nPython\n\n````\n# A complete working Python program to\n# find the size of a doubly linked list.\n\nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.next = None\n        self.prev = None\n\n# This function returns the size of\n# the linked list\ndef find_size(curr):\n    size = 0\n    while curr:\n        size += 1\n        curr = curr.next\n    return size\n\nif __name__ == \"__main__\":\n\n    # Create a hard-coded doubly linked list:\n    # 1 <-> 2 <-> 3 <-> 4\n    head = Node(1)\n    head.next = Node(2)\n    head.next.prev = head\n    head.next.next = Node(3)\n    head.next.next.prev = head.next\n    head.next.next.next = Node(4)\n    head.next.next.next.prev = head.next.next\n\n    print(find_size(head))\n\n````\n\nC#\n\n````\n// A complete working C# program to\n// find the size of a doubly linked list.\nusing System;\n\nclass Node {\n    public int data;\n    public Node next;\n    public Node prev;\n\n    public Node(int val) {\n        data = val;\n        next = null;\n        prev = null;\n    }\n}\n\nclass GfG {\n\n    // This function returns the size of\n      // the linked list\n    static int FindSize(Node curr) {\n        int size = 0;\n        while (curr != null) {\n            size++;\n            curr = curr.next;\n        }\n        return size;\n    }\n\n    static void Main() {\n\n        // Create a hard-coded doubly linked list:\n        // 1 <-> 2 <-> 3 <-> 4\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.prev = head;\n        head.next.next = new Node(3);\n        head.next.next.prev = head.next;\n        head.next.next.next = new Node(4);\n        head.next.next.next.prev = head.next.next;\n\n        Console.WriteLine(FindSize(head));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// A complete working JavaScript program to\n// find the size of a doubly linked list.\n\nclass Node {\n    constructor(val) {\n        this.data = val;\n        this.next = null;\n        this.prev = null;\n    }\n}\n\n// This function returns the size\n// of the linked list\nfunction findSize(curr) {\n    let size = 0;\n    while (curr !== null) {\n        size++;\n        curr = curr.next;\n    }\n    return size;\n}\n\n// Create a hard-coded doubly linked list:\n// 1 <-> 2 <-> 3 <-> 4\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.prev = head;\nhead.next.next = new Node(3);\nhead.next.next.prev = head.next;\nhead.next.next.next = new Node(4);\nhead.next.next.next.prev = head.next.next;\n\nconsole.log(findSize(head));\n\n````\n\n\n\n\n**Output**\n```\n4\n```\n\n****Time Complexity: O(n),****\nwhere n is the number of nodes in the linked list.\n\n\n\n****Auxiliary Space:****\n\n****O(1)****",
        "metadata": {
            "lesson_id": "0f29c6e9-3edb-43c1-b60d-41e4c65c90e0",
            "course_id": "bd157822-862c-4b14-80e0-791fb1f7f1f6",
            "course_name": "Linked List Data Structure Guide",
            "lesson_description": "",
            "course_description": "An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving."
        }
    },
    {
        "page_content": "Given a\n\n****singly linked list,****\nthe task is to remove every k\n\nth\nnode of the linked list. Assume that k is always less than or equal to the length of the Linked List.\n\n\n****Examples :****\n\n\n> ****Input:****\n> LinkedList: 1 -> 2 -> 3 -> 4 -> 5 -> 6, k = 2\n>\n>\n>\n> ****Output:****\n> 1 -> 3 -> 5\n>\n>\n>\n> ****Explanation:****\n> After removing every 2nd node of the linked list, the resultant linked list will be: 1 -> 3 -> 5 .\n>\n>\n> ****Input:****\n> LinkedList: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10, k = 3\n>\n>\n>\n> ****Output:****\n> 1 -> 2 -> 4 -> 5 -> 7 -> 8 -> 10\n>\n>\n>\n> ****Explanation:****\n> After removing every 3rd node of the linked list, the resultant linked list will be: 1 -> 2 -> 4 -> 5 -> 7 -> 8 -> 10.\n\n### [Expected Approach \u2013 1] Iterative Approach \u2013 O(n) Time and O(1) Space\n\n> The idea is to traverse the linked list while maintaining a\n>\n> ****counter****\n> to track node positions. Every time the counter reaches\n>\n> ****k,****\n> update the next pointer of the\n>\n> ****previous****\n> node to\n>\n> ****skip****\n> the current k\n>\n> th\n> node, effectively removing it from the list. Continue this process until reaching the\n>\n> ****end****\n> of the list. This method ensures that the\n>\n> ****k****\n> ****th****\n>\n> nodes are removed as required while\n>\n> ****preserving****\n> the rest of the list structure.\n\n\nBelow is the implementation of the above approach:\n\n\nC++\n\n````\n// C++ program to delete every k-th Node of\n// a singly linked list.\n#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    Node(int x) {\n        data = x;\n        next = nullptr;\n    }\n};\n\n// Function to remove every kth node in the linked list\nNode* deleteK(Node* head, int k) {\n\n    // If list is empty or k is 0, return the head\n    if (head == nullptr || k <= 0)\n        return head;\n\n    Node* curr = head;\n    Node* prev = nullptr;\n\n    // Initialize counter to track node positions\n    int count = 0;\n\n    // Traverse the linked list\n    while (curr != nullptr) {\n        count++;\n\n        // If count is a multiple of k, remove current node\n        if (count % k == 0) {\n\n            // skip the current node\n            if (prev != nullptr) {\n                prev->next = curr->next;\n            }\n            else {\n\n                head = curr->next;\n            }\n        }\n        else {\n\n            // Update previous node pointer only if\n            // we do not remove the node\n            prev = curr;\n        }\n        curr = curr->next;\n    }\n\n    return head;\n}\n\nvoid printList(Node* head) {\n\n    Node* curr = head;\n    while (curr != nullptr) {\n        cout << curr->data << \" \";\n        curr = curr->next;\n    }\n}\n\nint main() {\n\n    // Create a hard-coded linked list:\n    // 1 -> 2 -> 3 -> 4 -> 5 -> 6\n    Node* head = new Node(1);\n    head->next = new Node(2);\n    head->next->next = new Node(3);\n    head->next->next->next = new Node(4);\n    head->next->next->next->next = new Node(5);\n    head->next->next->next->next->next = new Node(6);\n    int k = 2;\n    head = deleteK(head, k);\n    printList(head);\n\n    return 0;\n}\n\n````\n\nC\n\n````\n// C program to delete every k-th Node of\n// a singly linked list.\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to remove every kth node in the linked list\nstruct Node* deleteK(struct Node* head, int k) {\n\n    // If list is empty or k is 0, return the head\n    if (head == NULL || k <= 0)\n        return head;\n\n    struct Node* curr = head;\n    struct Node* prev = NULL;\n\n    int count = 0;\n\n    while (curr != NULL) {\n        count++;\n\n        // If count is a multiple of k, remove\n        // current node\n        if (count % k == 0) {\n\n            // skip the current node\n            if (prev != NULL) {\n                prev->next = curr->next;\n            }\n            else {\n\n                head = curr->next;\n            }\n            free(curr);\n            curr = prev != NULL ? prev->next : head;\n        }\n        else {\n\n            // Update previous node pointer only if\n            // we do not remove the node\n            prev = curr;\n            curr = curr->next;\n        }\n    }\n    return head;\n}\n\nvoid printList(struct Node* node) {\n   struct Node* curr = node;\n    while (curr != NULL) {\n        printf(\"%d \", curr->data);\n        curr = curr->next;\n    }\n    printf(\"\\n\");\n}\n\nstruct Node* createNode(int new_data) {\n    struct Node* new_node =\n        (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\n\n\nint main() {\n\n    // Create a hard-coded linked list:\n    // 1 -> 2 -> 3 -> 4 -> 5 -> 6\n    struct Node* head = createNode(1);\n    head->next = createNode(2);\n    head->next->next = createNode(3);\n    head->next->next->next = createNode(4);\n    head->next->next->next->next = createNode(5);\n    head->next->next->next->next->next = createNode(6);\n\n    int k = 2;\n    head = deleteK(head, k);\n\n    printList(head);\n\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java program to delete every k-th Node of\n// a singly linked list.\nclass Node {\n    int data;\n    Node next;\n\n    Node(int newData) {\n        data = newData;\n        next = null;\n    }\n}\n\npublic class GfG {\n\n    // Function to remove every kth node in the\n    // linked list\n    static Node deleteK(Node head, int k) {\n\n        // If list is empty or k is 0, return the head\n        if (head == null || k <= 0)\n            return head;\n\n        Node curr = head;\n\n        Node prev = null;\n\n        int count = 0;\n\n        // Traverse the linked list\n        while (curr != null) {\n\n            // Increment the counter for each node\n            count++;\n\n            // If count is a multiple of k, remove\n            // current node\n            if (count % k == 0) {\n\n                // skip the current node\n                if (prev != null) {\n                    prev.next = curr.next;\n                }\n               else {\n\n                    // If removing the head node\n                    head = curr.next;\n                }\n            }\n           else {\n\n                // Update previous node pointer only if\n                // we do not remove the node\n                prev = curr;\n            }\n            curr = curr.next;\n        }\n\n        return head;\n    }\n\n    static void printList(Node head) {\n\n        Node curr = head;\n        while (curr != null) {\n            System.out.print(curr.data + \" \");\n            curr = curr.next;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n\n        // Create a hard-coded linked list:\n        // 1 -> 2 -> 3 -> 4 -> 5 -> 6\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n        head.next.next.next.next.next = new Node(6);\n        int k = 2;\n\n        head = deleteK(head, k);\n\n        printList(head);\n    }\n}\n\n````\n\nPython\n\n````\n# Python program to delete every k-th Node of\n# a singly linked list.\nclass Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n\n# Function to remove every kth node in the linked list\ndef delete_k(head, k):\n\n    # If list is empty or k is 0, return the head\n    if head is None or k <= 0:\n        return head\n\n    curr = head\n    prev = None\n\n    count = 0\n\n    while curr is not None:\n        count += 1\n\n        # If count is a multiple of k, remove current node\n        if count % k == 0:\n\n            # Bypass the current node\n            if prev is not None:\n                prev.next = curr.next\n            else:\n\n                # If removing the head node\n                head = curr.next\n        else:\n\n            # Update previous node pointer only if\n            # we do not remove the node\n            prev = curr\n\n        curr = curr.next\n\n    return head\n\ndef print_list(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\" \")\n        curr = curr.next\n    print()\n\nif __name__ == \"__main__\":\n\n    # Create a hard-coded linked list:\n    # 1 -> 2 -> 3 -> 4 -> 5 -> 6\n    head = Node(1)\n    head.next = Node(2)\n    head.next.next = Node(3)\n    head.next.next.next = Node(4)\n    head.next.next.next.next = Node(5)\n    head.next.next.next.next.next = Node(6)\n    k = 2\n    head = delete_k(head, k)\n    print_list(head)\n\n````\n\nC#\n\n````\n// C# program to delete every k-th Node of\n// a singly linked list.\nusing System;\n\nclass Node {\n    public int Data;\n    public Node next;\n\n    public Node(int newData) {\n        Data = newData;\n        next = null;\n    }\n}\n\nclass GfG {\n\n    // Function to remove every kth node in the linked list\n    static Node DeleteK(Node head, int k) {\n\n        // If list is empty or k is 0, return the head\n        if (head == null || k <= 0)\n            return head;\n\n        Node curr = head;\n        Node prev = null;\n\n        int count = 0;\n\n        while (curr != null) {\n            count++;\n\n            // If count is a multiple of k, remove\n            // current node\n            if (count % k == 0) {\n\n                // Bypass the current node\n                if (prev != null) {\n                    prev.next = curr.next;\n                }\n                else {\n\n                    // If removing the head node\n                    head = curr.next;\n                }\n            }\n            else {\n\n                // Update previous node pointer only if\n                // we do not remove the node\n                prev = curr;\n            }\n            curr = curr.next;\n        }\n        return head;\n    }\n\n    static void PrintList(Node curr) {\n        while (curr != null) {\n            Console.Write(curr.Data + \" \");\n            curr = curr.next;\n        }\n        Console.WriteLine();\n    }\n\n    static void Main() {\n\n        // Create a hard-coded linked list:\n        // 1 -> 2 -> 3 -> 4 -> 5 -> 6\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n        head.next.next.next.next.next = new Node(6);\n\n        int k = 2;\n        head = DeleteK(head, k);\n\n        PrintList(head);\n    }\n}\n\n````\n\nJavaScript\n\n````\n// Javascript program to delete every k-th Node of\n// a singly linked list.\nclass Node {\n    constructor(newData) {\n        this.data = newData;\n        this.next = null;\n    }\n}\n\n// Function to remove every kth node in the linked list\nfunction deleteK(head, k) {\n\n    // If list is empty or k is 0, return the head\n    if (head === null || k <= 0) {\n        return head;\n    }\n\n    let curr = head;\n    let prev = null;\n    let count = 0;\n\n    // Traverse the linked list\n    while (curr !== null) {\n        count++;\n\n        // If count is a multiple of k, remove\n        // current node\n        if (count % k === 0) {\n\n            // skip the current node\n            if (prev !== null) {\n                prev.next = curr.next;\n            }\n            else {\n\n                // If removing the head node\n                head = curr.next;\n            }\n        }\n        else {\n\n            // Update previous node pointer only if\n            // we do not remove the node\n            prev = curr;\n        }\n        curr = curr.next;\n    }\n    return head;\n}\n\nfunction printList(curr) {\n    let output = \"\";\n    while (curr !== null) {\n        output += curr.data + \" \";\n        curr = curr.next;\n    }\n    console.log(output.trim());\n}\n\n// Create a hard-coded linked list:\n// 1 -> 2 -> 3 -> 4 -> 5 -> 6\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.next = new Node(3);\nhead.next.next.next = new Node(4);\nhead.next.next.next.next = new Node(5);\nhead.next.next.next.next.next = new Node(6);\n\nlet k = 2;\nhead = deleteK(head, k);\n\nprintList(head);\n\n````\n\n\n\n\n**Output**\n```\n1 3 5\n```\n\n****Time Complexity :****\nO(n),\n\n\nwhere\n\n****n****\nis the number of nodes.\n\n\n\n****Auxiliary Space :****\nO(1)",
        "metadata": {
            "lesson_id": "0c68fc2c-a6d9-4306-a996-07fbf5dccb2e",
            "course_id": "bd157822-862c-4b14-80e0-791fb1f7f1f6",
            "course_name": "Linked List Data Structure Guide",
            "lesson_description": "",
            "course_description": "An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving."
        }
    },
    {
        "page_content": "Understanding Node Structure\n----------------------------\n\nIn a singly linked list, each node consists of two parts: data and a\npointer to the next node. This structure allows nodes to be dynamically\nlinked together, forming a chain-like sequence.\n\n\n![Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240917161540/Singly-Linked-List.webp)\n\nSingly Linked List\n\n\n\nC++\n````\n// Definition of a Node in a singly linked list\nstruct Node {\n\n    // Data part of the node\n    int data;\n\n    // Pointer to the next node in the list\n    Node* next;\n\n    // Constructor to initialize the node with data\n    Node(int data)\n    {\n        this->data = data;\n        this->next = nullptr;\n    }\n};\n\n````\n\nC\n````\n// Definition of a Node in a singly linked list\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to create a new Node\nstruct Node* newNode(int data) {\n    struct Node* temp =\n      (struct Node*)malloc(sizeof(struct Node));\n    temp->data = data;\n    temp->next = NULL;\n    return temp;\n}\n\n````\n\nJava\n````\n// Definition of a Node in a singly linked list\npublic class Node {\n    int data;\n    Node next;\n\n    // Constructor to initialize the node with data\n    public Node(int data)\n    {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n````\n\nPython\n````\n# Definition of a Node in a singly linked list\nclass Node:\n    def __init__(self, data):\n       # Data part of the node\n        self.data = data\n        self.next = None\n\n````\n\nJavaScript\n````\n// Definition of a Node in a singly linked list\nclass Node {\n    constructor(data) {\n    // Data part of the node\n        this.data = data;\n        this.next = null;\n    }\n}\n\n````\n\n\n\nIn this example, the Node class contains an integer data field (****data****) to store the information and a pointer to another Node (****next****) to establish the link to the next node in the list.\n\nOperations on Singly Linked List\n--------------------------------\n\n* ****Traversal****\n* ****Searching****\n* ****Length****\n* ****Insertion:****\n  + Insert at the beginning\n  + Insert at the end\n  + Insert at a specific position\n* ****Deletion:****\n  + Delete from the beginning\n  + Delete from the end\n  + Delete a specific node\n\nLet's go through each of the operations mentioned above, one by\none.\n\n[****Traversal**** of Singly Linked List](https://www.geeksforgeeks.org/traversal-of-singly-linked-list/)\n---------------------------------------------------------------------------------------------------------\n\nTraversal involves visiting each node in the linked list and performing\nsome operation on the data. A simple traversal function would print or\nprocess the data of each node.\n\nStep-by-step approach:\n\n* Initialize a pointer current to the head of the list.\n* Use a while loop to iterate through the list until the current\n  pointer reaches NULL.\n* Inside the loop, print the data of the current node and move the\n  current pointer to the next node.\n\nBelow is the function for traversal in singly Linked List:\n\nC++\n````\n// C++ Function to traverse and print the elements of the linked\n// list\nvoid traverseLinkedList(Node* head)\n{\n    // Start from the head of the linked list\n    Node* current = head;\n\n    // Traverse the linked list until reaching the end\n    // (nullptr)\n    while (current != nullptr) {\n\n        // Print the data of the current node\n        cout << current->data << \" \";\n\n        // Move to the next node\n        current = current->next;\n    }\n\n    cout << std::endl;\n}\n\n````\n\nC\n````\n// Function to traverse and print the elements\n// of the linked list\nvoid traverseLinkedList(struct Node* head)\n{\n    // Start from the head of the linked list\n    struct Node* current = head;\n\n    // Traverse the linked list until reaching the end (NULL)\n    while (current != NULL) {\n\n        // Print the data of the current node\n        printf(\"%d \", current->data);\n\n        // Move to the next node\n        current = current->next;\n    }\n\n    printf(\"\\n\");\n}\n\n````\n\nJava\n````\n// Java Function to traverse and print the elements of the\n// linked list\npublic static void traverseLinkedList(Node head)\n{\n    // Start from the head of the linked list\n    Node current = head;\n\n    // Traverse the linked list until reaching the end\n    // (null)\n    while (current != null) {\n\n        // Print the data of the current node\n        System.out.print(current.data + \" \");\n\n        // Move to the next node\n        current = current.next;\n    }\n\n    System.out.println();\n}\n\n````\n\nPython\n````\n# Python Function to traverse and print the elements of the linked list\ndef traverse_linked_list(head):\n    # Start from the head of the linked list\n    current = head\n\n    # Traverse the linked list until reaching the end (None)\n    while current is not None:\n\n        # Print the data of the current node followed by a space\n        print(current.data),\n\n        # Move to the next node\n        current = current.next\n\n    print()  # Print a new line after traversing the linked list\n\n````\n\nJavaScript\n````\n// Javascript Function to traverse and print the elements\n// of the linked list\nfunction traverseLinkedList(head) {\n\n    // Start from the head of the linked list\n    let current = head;\n\n    // Traverse the linked list until reaching the\n    // end (null)\n    while (current !== null) {\n\n        // Print the data of the current node\n        console.log(current.data + \" \");\n\n        // Move to the next node\n        current = current.next;\n    }\n\n    console.log();\n}\n\n````\n\n**Output**\n```\n\n1 2 3\n\n```\n\n[Searching in Singly Linked List](https://www.geeksforgeeks.org/search-an-element-in-a-linked-list-iterative-and-recursive/)\n----------------------------------------------------------------------------------------------------------------------------\n\nSearching in a Singly Linked List refers to the process of looking for\na specific element or value within the elements of the linked list.\n\n\nStep-by-step approach:\n\n1. Traverse the Linked List starting from the head.\n2. Check if the current node's data matches the target value.\n   * If a match is found, return ****true****.\n3. Otherwise, Move to the next node and repeat steps 2.\n4. If the end of the list is reached without finding a match, return ****false****.\n\nBelow is the function for searching in singly linked list:\n\nC++\n````\n// Function to search for a value in the Linked List\nbool searchLinkedList(struct Node* head, int target)\n{\n    // Traverse the Linked List\n    while (head != nullptr) {\n\n        // Check if the current node's\n        // data matches the target value\n        if (head->data == target) {\n            return true; // Value found\n        }\n\n        // Move to the next node\n        head = head->next;\n    }\n\n    return false; // Value not found\n}\n\n````\n\nC\n````\n// Function to search for a value in the Linked List\nbool searchLinkedList(struct Node* head, int target)\n{\n    // Traverse the Linked List\n    while (head != NULL) {\n\n        // Check if the current node's\n        // data matches the target value\n        if (head->data == target) {\n            return true; // Value found\n        }\n\n        // Move to the next node\n        head = head->next;\n    }\n\n    return false; // Value not found\n}\n\n````\n\nJava\n````\n// Java function to search for a value in the Linked List\npublic boolean searchLinkedList(Node head, int target)\n{\n    // Traverse the Linked List\n    while (head != null) {\n\n        // Check if the current node's data matches the\n        // target value\n        if (head.data == target) {\n\n            // Value found\n            return true;\n        }\n\n        // Move to the next node\n        head = head.next;\n    }\n\n    // Value not found\n    return false;\n}\n\n````\n\nPython\n````\n# Python function to search for a value in the Linked List\ndef search_linked_list(head, target):\n\n    # Traverse the Linked List\n    while head is not None:\n\n        # Check if the current node's data matches the target value\n        if head.data == target:\n\n            return True  # Value found\n        # Move to the next node\n        head = head.next\n\n    return False  # Value not found\n\n````\n\nJavaScript\n````\n// Javascript function to search for a value in the Linked List\nfunction searchLinkedList(head, target) {\n\n    // Traverse the Linked List\n    while (head !== null) {\n\n        // Check if the current node's data matches the target value\n        if (head.data === target) {\n            return true;  // Value found\n        }\n\n        // Move to the next node\n        head = head.next;\n    }\n\n    return false;  // Value not found\n}\n\n````\n\n\n\n[Length of Singly Linked List](https://www.geeksforgeeks.org/find-length-of-a-linked-list-iterative-and-recursive)\n------------------------------------------------------------------------------------------------------------------\n\nFinding Length in Singly Linked List refers to the process of\ndetermining the total number of nodes in a singly linked list.\n\nStep-by-step approach:\n\n* Initialize a counter ****length**** to 0.\n* Start from the head of the list, assign it to current.\n* Traverse the list:\n  + Increment ****length**** for each node.\n  + Move to the next node (****current = current->next****).\n* Return the final value of ****length****.\n\nBelow is the function for finding length in Singly Linked List:\n\nC++\n````\n// C++ function to find the length of the linked list\nint findLength(Node* head)\n{\n    // Initialize a counter for the length\n    int length = 0;\n\n    // Start from the head of the list\n    Node* current = head;\n\n    // Traverse the list and increment the length for each\n    // node\n    while (current != nullptr) {\n        length++;\n        current = current->next;\n    }\n\n    // Return the final length of the linked list\n    return length;\n}\n\n````\n\nC\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Definition of a Node in a singly linked list\nstruct Node {\n    int data;          // Data part of the node\n    struct Node* next; // Pointer to the next node in the list\n};\n\n// Function to find the length of the linked list\nint findLength(struct Node* head)\n{\n    // Initialize a counter for the length\n    int length = 0;\n\n    // Start from the head of the list\n    struct Node* curr = head;\n\n    // Traverse the list and increment\n    // the length for each node\n    while (curr != NULL) {\n        length++;\n        curr = curr->next;\n    }\n\n    // Return the final length of the linked list\n    return length;\n}\n\n````\n\nJava\n````\n// Java function to find the length of the linked list\npublic int findLength(Node head) {\n\n    // Initialize a counter for the length\n    int length = 0;\n\n    // Start from the head of the list\n    Node current = head;\n\n    // Traverse the list and increment the length for each\n    // node\n    while (current != null) {\n        length++;\n        current = current.next;\n    }\n\n    // Return the final length of the linked list\n    return length;\n}\n\n````\n\nPython\n````\n# Python function to find the length of the linked list\ndef find_length(head):\n\n    # Initialize a counter for the length\n    length = 0\n\n    # Start from the head of the list\n    current = head\n\n    # Traverse the list and increment the length for each\n    # node\n    while current is not None:\n        length += 1\n        current = current.next\n\n    # Return the final length of the linked list\n    return length\n\n````\n\nJavaScript\n````\n// Javascript function to find the length of the linked list\nfunction findLength(head) {\n\n    // Initialize a counter for the length\n    let length = 0;\n\n    // Start from the head of the list\n    let current = head;\n\n    // Traverse the list and increment the length for each\n    // node\n    while (current !== null) {\n        length++;\n        current = current.next;\n    }\n\n    // Return the final length of the linked list\n    return length;\n}\n\n````\n\n\n\n\n[Insertion in Singly Linked List](https://www.geeksforgeeks.org/insertion-in-linked-list)\n-----------------------------------------------------------------------------------------\n\nInsertion is a fundamental operation in linked lists that involves\nadding a new node to the list. There are several scenarios for\ninsertion:\n\n### a. [Insertion at the Beginning of Singly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-front-beginning-of-a-linked-list):\n\n![Insertion-at-the-Beginning-of-Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20241022163445386036/Insertion-at-the-Beginning-of-Singly-Linked-List.webp)\n\n\nInsert a Node at the Front/Beginning of Linked List\n\n\n\nStep-by-step approach:\n\n* Create a new node with the given value.\n* Set the ****next**** pointer of the new node to the current head.\n* Move the head to point to the new node.\n* Return the new head of the linked list.\n\nBelow is the function for insertion at the beginning of singly linked\nlist:\n\nC++\n````\n// C++ function to insert a new node at the beginning of the\n// linked list\nNode* insertAtBeginning(Node* head, int value)\n{\n    // Create a new node with the given value\n    Node* newNode = new Node(value);\n\n    // Set the next pointer of the new node to the current\n    // head\n    newNode->next = head;\n\n    // Move the head to point to the new node\n    head = newNode;\n\n    // Return the new head of the linked list\n    return head;\n}\n\n````\n\nC\n````\n// Function to insert a new node at the beginning of the linked list\nstruct Node* insertAtBeginning(struct Node* head, int value)\n{\n    // Create a new node with the given value\n    struct Node* new_node = newNode(value);\n\n    // Set the next pointer of the new node to the current head\n    new_node->next = head;\n\n    // Move the head to point to the new node\n    head = new_node;\n\n    // Return the new head of the linked list\n    return head;\n}\n\n````\n\nJava\n````\n// Java function to insert a new node at the beginning of the\n// linked list\npublic Node insertAtBeginning(Node head, int value) {\n    // Create a new node with the given value\n    Node newNode = new Node(value);\n\n    // Set the next pointer of the new node to the current\n    // head\n    newNode.next = head;\n\n    // Move the head to point to the new node\n    head = newNode;\n\n    // Return the new head of the linked list\n    return head;\n}\n\n````\n\nPython\n````\n# Python function to insert a new node at the beginning of the\n# linked list\ndef insert_at_beginning(head, value):\n\n    # Create a new node with the given value\n    new_node = Node(value)\n\n    # Set the next pointer of the new node to the current\n    # head\n    new_node.next = head\n\n    # Move the head to point to the new node\n    head = new_node\n\n    # Return the new head of the linked list\n    return head\n\n````\n\nJavaScript\n````\n// Javascript function to insert a new node at the beginning of the\n// linked list\nfunction insertAtBeginning(head, value) {\n\n    // Create a new node with the given value\n    let newNode = new Node(value);\n\n    // Set the next pointer of the new node to the current\n    // head\n    newNode.next = head;\n\n    // Move the head to point to the new node\n    head = newNode;\n\n    // Return the new head of the linked list\n    return head;\n}\n\n````\n\n\n### b. [Insertion at the End of Singly Linked List:](https://www.geeksforgeeks.org/insert-node-at-the-end-of-a-linked-list)\n\nTo insert a node at the end of the list, traverse the list until the\nlast node is reached, and then link the new node to the current last\nnode-\n\n![Insertion-at-the-End-of-Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20241022163601409037/Insertion-at-the-End-of-Singly-Linked-List.webp)\n\nInsertion at end of Linked List\n\n\nStep-by-step approach:\n\n* Create a new node with the given value.\n* Check if the list is empty:\n  + If it is, make the new node the head and return.\n* Traverse the list until the last node is reached.\n* Link the new node to the current last node by setting the last node's\n  next pointer to the new node.\n\nBelow is the function for insertion at the end of singly linked\nlist:\n\nC++\n````\n// C++ Function to insert a node at the end of the linked\n// list\nNode* insertAtEnd(Node* head, int value)\n{\n    // Create a new node with the given value\n    Node* newNode = new Node(value);\n\n    // If the list is empty, make the new node the head\n    if (head == nullptr)\n        return newNode;\n\n    // Traverse the list until the last node is reached\n    Node* curr = head;\n    while (curr->next != nullptr) {\n        curr = curr->next;\n    }\n\n    // Link the new node to the current last node\n    curr->next = newNode;\n    return head;\n}\n\n````\n\nC\n````\n// Function to insert a node at the end of the linked list\nstruct Node* insertAtEnd(struct Node* head, int value)\n{\n    // Create a new node with the given value\n    struct Node* new_node = newNode(value);\n\n    // If the list is empty, make the new node the head\n    if (head == NULL)\n        return new_node;\n\n    // Traverse the list until the last node is reached\n    struct Node* curr = head;\n    while (curr->next != NULL) {\n        curr = curr->next;\n    }\n\n    // Link the new node to the current last node\n    curr->next = new_node;\n\n    return head;\n}\n\n````\n\nJava\n````\n// Function to insert a node at the end of the linked list\npublic static Node insertAtEnd(Node head, int value)\n{\n    // Create a new node with the given value\n    Node newNode = new Node(value);\n\n    // If the list is empty, make the new node the head\n    if (head == null)\n        return newNode;\n\n    // Traverse the list until the last node is reached\n    Node curr = head;\n    while (curr.next != null) {\n        curr = curr.next;\n    }\n\n    // Link the new node to the current last node\n    curr.next = newNode;\n\n    return head;\n}\n\n````\n\nPython\n````\n# Python function to insert a node at the end of the linked\n# list\ndef insert_at_end(head, value):\n\n    # Create a new node with the given value\n    new_node = Node(value)\n\n    # If the list is empty, make the new node the head\n    if head is None:\n        return new_node\n\n    # Traverse the list until the last node is reached\n    current = head\n    while current.next is not None:\n        current = current.next\n\n    # Link the new node to the current last node\n    current.next = new_node\n\n    return head\n\n````\n\nJavaScript\n````\n// Javascript function to insert a node at the end of the linked\n// list\nfunction insertAtEnd(head, value) {\n\n    // Create a new node with the given value\n    let newNode = new Node(value);\n\n    // If the list is empty, make the new node the head\n    if (head === null) {\n        return newNode;\n    }\n\n    // Traverse the list until the last node is reached\n    let current = head;\n    while (current.next !== null) {\n        current = current.next;\n    }\n\n    // Link the new node to the current last node\n    current.next = newNode;\n\n    return head;\n}\n\n````\n\n\n\n\n\n### c. [Insertion at a Specific Position of the Singly Linked List:](https://www.geeksforgeeks.org/insert-a-node-at-a-specific-position-in-a-linked-list)\n\nTo insert a node at a specific position, traverse the list to the\ndesired position, link the new node to the next node, and update the\nlinks accordingly.\n\n![Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy](https://media.geeksforgeeks.org/wp-content/uploads/20241022163649252002/Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy.webp)\n\n\n\n\nWe mainly find the node after which we need to insert the new node. If\nwe encounter a NULL before reaching that node, it means that the given\nposition is invalid.\n\nBelow is the function for insertion at a specific position of the\nsingly linked list:\n\nC++\n````\n// Function to insert a Node at a specified position\n// without using a double pointer\nNode* insertPos(Node* head, int pos, int data)\n{\n    if (pos < 1) {\n        cout << \"Invalid position!\" << endl;\n        return head;\n    }\n\n    // Special case for inserting at the head\n    if (pos == 1) {\n        Node* temp = new Node(data);\n        temp->next = head;\n        return temp;\n    }\n\n    // Traverse the list to find the node\n    // before the insertion point\n    Node* prev = head;\n    int count = 1;\n    while (count < pos - 1 && prev != nullptr) {\n        prev = prev->next;\n        count++;\n    }\n\n    // If position is greater than the number of nodes\n    if (prev == nullptr) {\n        cout << \"Invalid position!\" << endl;\n        return head;\n    }\n\n    // Insert the new node at the specified position\n    Node* temp = new Node(data);\n    temp->next = prev->next;\n    prev->next = temp;\n\n    return head;\n}\n\n````\n\nC\n````\n// Function to insert a node at a specified position\nstruct Node* insertPos(struct Node* head, int pos, int data) {\n    if (pos < 1) {\n        printf(\"Invalid position!\\n\");\n        return head;\n    }\n\n    // Special case for inserting at the head\n    if (pos == 1) {\n        struct Node* temp = getNode(data);\n        temp->next = head;\n        return temp;\n    }\n\n    // Traverse the list to find the node\n    // before the insertion point\n    struct Node* prev = head;\n    int count = 1;\n    while (count < pos - 1 && prev != NULL) {\n        prev = prev->next;\n        count++;\n    }\n\n    // If position is greater than the number of nodes\n    if (prev == NULL) {\n        printf(\"Invalid position!\\n\");\n        return head;\n    }\n\n    // Insert the new node at the specified position\n    struct Node* temp = getNode(data);\n    temp->next = prev->next;\n    prev->next = temp;\n\n    return head;\n}\n\n````\n\nJava\n````\npublic static Node insertPos(Node head, int pos, int data)\n{\n    if (pos < 1) {\n        System.out.println(\"Invalid position!\");\n        return head;\n    }\n\n    // Special case for inserting at the head\n    if (pos == 1) {\n        Node temp = new Node(data);\n        temp.next = head;\n        return temp;\n    }\n\n    // Traverse the list to find the node before the\n    // insertion point\n    Node prev = head;\n    int count = 1;\n    while (count < pos - 1 && prev != null) {\n        prev = prev.next;\n        count++;\n    }\n\n    // If position is greater than the number of nodes\n    if (prev == null) {\n        System.out.println(\"Invalid position!\");\n        return head;\n    }\n\n    // Insert the new node at the specified position\n    Node temp = new Node(data);\n    temp.next = prev.next;\n    prev.next = temp;\n\n    return head;\n}\n\n````\n\nPython\n````\n# Function to insert a node at a specified position\ndef insertPos(head, pos, data):\n    if pos < 1:\n        print(\"Invalid position!\")\n        return head\n\n    # Special case for inserting at the head\n    if pos == 1:\n        new_node = Node(data)\n        new_node.next = head\n        return new_node\n\n    # Traverse the list to find the node before\n    # the insertion point\n    prev = head\n    count = 1\n    while count < pos - 1 and prev is not None:\n        prev = prev.next\n        count += 1\n\n    # If position is greater than the number of nodes\n    if prev is None:\n        print(\"Invalid position!\")\n        return head\n\n    # Insert the new node at the specified position\n    new_node = Node(data)\n    new_node.next = prev.next\n    prev.next = new_node\n\n    return head\n\n````\n\nJavaScript\n````\n// Function to insert a node at a specified position\nfunction insertPos(head, pos, data) {\n    if (pos < 1) {\n        console.log(\"Invalid position!\");\n        return head;\n    }\n\n    // Special case for inserting at the head\n    if (pos === 1) {\n        const newNode = new Node(data);\n        newNode.next = head;\n        return newNode;\n    }\n\n    // Traverse the list to find the node\n    // before the insertion point\n    let prev = head;\n    let count = 1;\n    while (count < pos - 1 && prev !== null) {\n        prev = prev.next;\n        count++;\n    }\n\n    // If position is greater than the number of nodes\n    if (prev === null) {\n        console.log(\"Invalid position!\");\n        return head;\n    }\n\n    // Insert the new node at the specified position\n    const newNode = new Node(data);\n    newNode.next = prev.next;\n    prev.next = newNode;\n\n    return head;\n}\n\n````\n\n\n\n\n\n\n\n\n[Deletion in Singly Linked List](https://www.geeksforgeeks.org/deletion-in-linked-list)\n---------------------------------------------------------------------------------------\n\nDeletion involves removing a node from the linked list. Similar to\ninsertion, there are different scenarios for deletion:\n\n### a. [****Deletion at the Beginning of**** Singly Linked List****:****](https://www.geeksforgeeks.org/remove-first-node-of-the-linked-list)\n\nTo delete the first node, update the head to point to the second node\nin the list.\n\n![Deletion-at-beginning-](https://media.geeksforgeeks.org/wp-content/uploads/20241022163937663413/Deletion-at-beginning-.webp)\n\nDeletion at beginning in a Linked List\n\n\nSteps-by-step approach:\n\n* Check if the head is ****NULL****.\n  + If it is, return ****NULL**** (the list is empty).\n* Store the current head node in a temporary variable ****temp****.\n* Move the head pointer to the next node.\n* Delete the temporary node.\n* Return the new head of the linked list.\n\nBelow is the function for deletion at the beginning of singly linked\nlist:\n\nC++\n````\n// C++ Function to remove the first node of the linked\n// list\nNode* removeFirstNode(Node* head)\n{\n    if (head == nullptr)\n        return nullptr;\n\n    // Move the head pointer to the next node\n    Node* temp = head;\n    head = head->next;\n\n    delete temp;\n\n    return head;\n}\n\n````\n\nC\n````\n// Function to remove the first node of the linked list\nstruct Node* removeFirstNode(struct Node* head)\n{\n    if (head == NULL)\n        return NULL;\n\n    // Move the head pointer to the next node\n    struct Node* temp = head;\n    head = head->next;\n\n    // Free the memory of the old head\n    free(temp);\n\n    return head;\n}\n\n````\n\nJava\n````\n// Java Function to remove the first node\n// of the linked list\nstatic Node removeFirstNode(Node head)\n{\n    if (head == null)\n        return null;\n\n    // Move the head pointer to the next node\n    Node temp = head;\n    head = head.next;\n\n    return head;\n}\n\n````\n\nPython\n````\n# Python Function to remove the first node\n# of the linked list\ndef removeFirstNode(head):\n    if not head:\n        return None\n    temp = head\n\n    # Move the head pointer to the next node\n    head = head.next\n    temp = None\n    return head\n\n````\n\nJavaScript\n````\n// Javascript Function to remove the first node\n// of the linked list /\nfunction removeFirstNode(head) {\n  if (head == null) return null;\n\n  // Move the head pointer to the next node\n  temp = head;\n  head = head.next;\n\n  return head;\n}\n\n````\n\n\n### b. [Deletion at the End of Singly Linked List:](https://www.geeksforgeeks.org/remove-last-node-of-the-linked-list)\n\nTo delete the last node, traverse the list until the second-to-last\nnode and update its next field to None.\n\n![Deletion-At-End](https://media.geeksforgeeks.org/wp-content/uploads/20241022164030481275/Deletion-At-End.webp)\n\nDeletion at the end of linked list\n\n\nStep-by-step approach:\n\n* Check if the head is ****NULL****.\n  + If it is, return NULL (the list is empty).\n* Check if the head's ****next**** is ****NULL**** (only one node in the list).\n  + If true, delete the head and return ****NULL****.\n* Traverse the list to find the second last node (****second\\_last****).\n* Delete the last node (the node after ****second\\_last****).\n* Set the ****next**** pointer of the second last node to ****NULL****.\n* Return the head of the linked list.\n\nBelow is the function for deletion at the end of singly linked\nlist:\n\nC++\n````\n// C++ Function to remove the last node of the linked list\nNode* removeLastNode(Node* head)\n{\n    if (head == nullptr)\n        return nullptr;\n\n    if (head->next == nullptr) {\n        delete head;\n        return nullptr;\n    }\n\n    // Find the second last node\n    Node* second_last = head;\n    while (second_last->next->next != nullptr)\n        second_last = second_last->next;\n\n    // Delete last node\n    delete (second_last->next);\n\n    // Change next of second last\n    second_last->next = nullptr;\n\n    return head;\n}\n\n````\n\nC\n````\n// Function to remove the last node of the linked list\nstruct Node* removeLastNode(struct Node* head)\n{\n    if (head == NULL)\n        return NULL;\n\n    if (head->next == NULL) {\n        free(head);\n        return NULL;\n    }\n\n    // Find the second last node\n    struct Node* second_last = head;\n    while (second_last->next->next != NULL)\n        second_last = second_last->next;\n\n    // Delete last node\n    free(second_last->next);\n\n    // Change next of second last\n    second_last->next = NULL;\n\n    return head;\n}\n\n````\n\nJava\n````\n// Java Function to remove the last node of the linked list\nNode removeLastNode(Node head)\n{\n    // If the list is empty, return null\n    if (head == null)\n        return null;\n\n    // If the list has only one node, delete it and return\n    // null\n    if (head.next == null) {\n        head = null;\n        return null;\n    }\n\n    // Find the second last node\n    Node second_last = head;\n    while (second_last.next.next != null)\n        second_last = second_last.next;\n\n    // Remove the last node\n    second_last.next = null;\n\n    // Return the modified list\n    return head;\n}\n\n````\n\nPython\n````\n# Python Function to remove the last node of the linked list\ndef removeLastNode(head):\n    # If the list is empty, return None\n    if head is None:\n        return None\n\n    # If the list has only one node, delete it and return None\n    if head.next is None:\n        head = None\n        return None\n\n    # Find the second last node\n    second_last = head\n    while second_last.next.next is not None:\n        second_last = second_last.next\n\n    # Remove the last node\n    second_last.next = None\n\n    # Return the modified list\n    return head\n\n````\n\nJavaScript\n````\n// Javascript Function to remove the last node of the linked list\nfunction removeLastNode(head) {\n    // If the list is empty, return null\n    if (head === null)\n        return null;\n\n    // If the list has only one node, delete it\n    // and return null\n    if (head.next === null) {\n        head = null;\n        return null;\n    }\n\n    // Find the second last node\n    let second_last = head;\n    while (second_last.next.next !== null)\n        second_last = second_last.next;\n\n    // Remove the last node\n    second_last.next = null;\n\n    // Return the modified list\n    return head;\n}\n\n````\n\n\n\n\n### c. [Deletion at a Specific Position of Singly Linked List:](https://www.geeksforgeeks.org/delete-a-linked-list-node-at-a-given-position)\n\nTo delete a node at a specific position, traverse the list to the\ndesired position, update the links to bypass the node to be\ndeleted.\n\n![Deletion-specific-At-End--](https://media.geeksforgeeks.org/wp-content/uploads/20241022164248836160/Deletion-specific-At-End--.webp)\n\nDelete a Linked List node at a given position\n\n\nStep-by-step approach:\n\n* Check if the list is empty or the position is invalid, return if\n  so.\n* If the head needs to be deleted, update the head and delete the\n  node.\n* Traverse to the node before the position to be deleted.\n* If the position is out of range, return.\n* Store the node to be deleted.\n* Update the links to bypass the node.\n* Delete the stored node.\n\nBelow is the function for deletion at a specific position of singly\nlinked list:\n\nC++\n````\n// C++ function to delete a node at a specific position\nNode* deleteAtPosition(Node* head, int position)\n{\n    // If the list is empty or the position is invalid\n    if (head == nullptr || position < 1) {\n        return head;\n    }\n\n    // If the head needs to be deleted\n    if (position == 1) {\n        Node* temp = head;\n        head = head->next;\n        delete temp;\n        return head;\n    }\n\n    // Traverse to the node before the position to be\n    // deleted\n    Node* current = head;\n    for (int i = 1; i < position - 1 && current != nullptr;\n         i++) {\n        current = current->next;\n    }\n\n    // If the position is out of range\n    if (current == NULL || current->next == nullptr) {\n        return;\n    }\n\n    // Store the node to be deleted\n    Node* temp = current->next;\n\n    // Update the links to bypass the node to be deleted\n    current->next = current->next->next;\n\n    // Delete the node\n    delete temp;\n\n    return head;\n}\n\n````\n\nC\n````\n// Function to delete a node at a specific position\nstruct Node* deleteAtPosition(struct Node* head, int position)\n{\n    // If the list is empty or the position is invalid\n    if (head == NULL || position < 1) {\n        return head;\n    }\n\n    // If the head needs to be deleted\n    if (position == 1) {\n        struct Node* temp = head;\n        head = head->next;\n        free(temp);\n        return head;\n    }\n\n    // Traverse to the node before the position to be deleted\n    struct Node* curr = head;\n    for (int i = 1; i < position - 1 && curr != NULL; i++) {\n        curr = curr->next;\n    }\n\n    // If the position is out of range\n    if (curr == NULL || curr->next == NULL) {\n        return head;\n    }\n\n    // Store the node to be deleted\n    struct Node* temp = curr->next;\n\n    // Update the links to bypass the node to be deleted\n    curr->next = curr->next->next;\n\n    // Delete the node\n    free(temp);\n\n    return head;\n}\n\n````\n\nJava\n````\n// Java function to delete a node at a specific position\npublic void deleteAtPosition(Node head, int position)\n{\n    // If the list is empty or the position is invalid\n    if (head == null || position < 1) {\n        return;\n    }\n\n    // If the head needs to be deleted\n    if (position == 1) {\n        Node temp = head;\n        head = head.next;\n        temp = null;\n        return;\n    }\n\n    // Traverse to the node before the position to be\n    // deleted\n    Node current = head;\n    for (int i = 1; i < position - 1 && current != null;\n         i++) {\n        current = current.next;\n    }\n\n    // If the position is out of range\n    if (current == null || current.next == null) {\n        return;\n    }\n\n    // Store the node to be deleted\n    Node temp = current.next;\n\n    // Update the links to bypass the node to be deleted\n    current.next = current.next.next;\n\n    // Delete the node\n    temp = null;\n}\n\n````\n\nPython\n````\n# Python function to delete a node at a specific position\ndef delete_at_position(head, position):\n    # If the list is empty or the position is invalid\n    if head is None or position < 1:\n        return head\n\n    # If the head needs to be deleted\n    if position == 1:\n        temp = head\n        head = head.next\n        temp = None\n        return head\n\n    # Traverse to the node before the position to be deleted\n    current = head\n    for i in range(1, position - 1):\n        if current is not None:\n            current = current.next\n\n    # If the position is out of range\n    if current is None or current.next is None:\n        return head\n\n    # Store the node to be deleted\n    temp = current.next\n\n    # Update the links to bypass the node to be deleted\n    current.next = current.next.next\n\n    # Delete the node\n    temp = None\n    return head\n\n````\n\nJavaScript\n````\n// Javascript function to delete a node at a specific position\nfunction deleteAtPosition(head, position) {\n    // If the list is empty or the position is invalid\n    if (head === null || position < 1) {\n        return head;\n    }\n\n    // If the head needs to be deleted\n    if (position === 1) {\n        let temp = head;\n        head = head.next;\n        temp = null;\n        return head;\n    }\n\n    // Traverse to the node before the position to be deleted\n    let current = head;\n    for (let i = 1; i < position - 1 && current !== null; i++) {\n        current = current.next;\n    }\n\n    // If the position is out of range\n    if (current === null || current.next === null) {\n        return head;\n    }\n\n    // Store the node to be deleted\n    let temp = current.next;\n\n    // Update the links to bypass the node to be deleted\n    current.next = current.next.next;\n\n    // Delete the node\n    temp = null;\n    return head;\n}\n\n````\n\n\n",
        "metadata": {
            "lesson_id": "237c88d5-987b-4fc0-8bd1-d27a07cd1aa9",
            "course_id": "bd157822-862c-4b14-80e0-791fb1f7f1f6",
            "course_name": "Linked List Data Structure Guide",
            "lesson_description": "A singly linked list is a fundamental data structure, it consists of nodes where each node contains a data field and a reference to the next node in the linked list. The next of the last node is null, indicating the end of the list. Linked Lists support efficient insertion and deletion operations.",
            "course_description": "An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving."
        }
    },
    {
        "page_content": "Given two integers ****a**** and ****b**** (b != 0), the task is to return the fraction ****a/b**** in string format. If the fractional part is repeating, enclose the repeating part in parentheses.****Examples:****\n\n\n> ****Input****\n> : a = 1, b = 2\n>\n>\n>\n> ****Output****\n> : \u201c0.5\u201d\n>\n>\n>\n> ****Explanation:****\n> 1/2 = 0.5 with no repeating part.\n>\n>\n>\n>\n>\n> ****Input****\n> : a = 50, b = 22\n>\n>\n>\n> ****Output****\n> : \u201c2.(27)\u201d\n>\n>\n>\n> ****Explanation:****\n> 50/22 = 2.27272727\u2026 Since fractional part (27) is repeating, it is enclosed in parentheses.\n\n****Approach****\n:\n\n\n> The idea is to first calculate the integral quotient (absolute part before decimal point) and then calculate the fractional part. To check if the fractional part is repeating, insert the remainder (a % b) in a\n>\n> [hash map](https://www.geeksforgeeks.org/hashing-data-structure/)\n> with key as remainder and value as the index position at which this remainder occurs. If at any point of time, the remainder becomes zero, then there doesn\u2019t exist a repeating fraction otherwise if the remainder is already found in the map, then there exists a repeating fraction.\n\nC++\n\n````\n// C++ Program to convert fraction to string\n\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nstring calculateFraction(int a, int b) {\n\n    // If the numerator is zero, answer is 0\n    if (a == 0)\n        return \"0\";\n\n    // If exactly one of the numerator or denominator\n    // is negative, then result will be negative\n    string res = (a < 0) ^ (b < 0) ? \"-\" : \"\";\n\n    a = abs(a);\n    b = abs(b);\n\n    // Calculate and Append the part before decimal point\n    res += to_string(a / b);\n\n    int rem = a % b;\n\n    // If completely divisible, return res\n    if (rem == 0)\n        return res;\n\n    res.append(\".\");\n    unordered_map<int, int> mp;\n\n    while (rem > 0) {\n\n        // If this remainder is already seen,\n        // then there exists a repeating fraction.\n        if (mp.find(rem) != mp.end()) {\n\n            res.insert(mp[rem], \"(\");\n            res.append(\")\");\n            break;\n        }\n\n        // If the remainder is seen for the first time,\n        // store its index\n        mp[rem] = res.size();\n\n        rem = rem * 10;\n\n        // Calculate quotient, append it to result and\n        // calculate next remainder\n        res += to_string(rem / b);\n        rem = rem % b;\n    }\n\n    return res;\n}\n\nint main() {\n    int a = 50, b = 22;\n    cout << calculateFraction(a, b) << endl;\n    return 0;\n}\n\n````\n\nJava\n\n````\n// Java Program to convert fraction to string\n\nimport java.util.HashMap;\n\nclass GfG {\n    static String calculateFraction(int a, int b) {\n\n        // If the numerator is zero, answer is \"0\"\n        if (a == 0)\n            return \"0\";\n\n        // If exactly one of the numerator or denominator\n        // is negative, then result will be negative\n        String res = (a < 0) ^ (b < 0) ? \"-\" : \"\";\n\n        a = Math.abs(a);\n        b = Math.abs(b);\n\n        // Calculate and Append the part before decimal point\n        res += Integer.toString(a / b);\n\n        int rem = a % b;\n\n        // If completely divisible, return res\n        if (rem == 0)\n            return res;\n\n        res += \".\";\n        HashMap<Integer, Integer> mp = new HashMap<>();\n\n        while (rem > 0) {\n\n            // If this remainder is already seen,\n            // then there exists a repeating fraction.\n            if (mp.containsKey(rem)) {\n                res = res.substring(0, mp.get(rem)) + \"(\" + res.substring(mp.get(rem)) + \")\";\n                break;\n            }\n\n            // If the remainder is seen for the first time,\n            // store its index\n            mp.put(rem, res.length());\n\n            rem = rem * 10;\n\n            // Calculate quotient, append it to result and\n            // calculate next remainder\n            res += Integer.toString(rem / b);\n            rem = rem % b;\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int a = 50, b = 22;\n        System.out.println(calculateFraction(a, b));\n    }\n}\n\n````\n\nPython\n\n````\n# Python Program to convert fraction to string\n\ndef calculateFraction(a, b):\n\n    # If the numerator is zero, answer is \"0\"\n    if a == 0:\n        return \"0\"\n\n    # If exactly one of the numerator or denominator\n    # is negative, then result will be negative\n    res = \"-\" if (a < 0) ^ (b < 0) else \"\"\n\n    a = abs(a)\n    b = abs(b)\n\n    # Calculate and Append the part before decimal point\n    res += str(a // b)\n\n    rem = a % b\n\n    # If completely divisible, return res\n    if rem == 0:\n        return res\n\n    res += \".\"\n    mp = {}\n\n    while rem > 0:\n\n        # If this remainder is already seen,\n        # then there exists a repeating fraction.\n        if rem in mp:\n            res = res[:mp[rem]] + \"(\" + res[mp[rem]:] + \")\"\n            break\n\n        # If the remainder is seen for the first time,\n        # store its index\n        mp[rem] = len(res)\n\n        rem = rem * 10\n\n        # Calculate quotient, append it to result and\n        # calculate next remainder\n        res += str(rem // b)\n        rem = rem % b\n\n    return res\n\nif __name__ == \"__main__\":\n    a = 50\n    b = 22\n    print(calculateFraction(a, b))\n\n````\n\nC#\n\n````\n// C# Program to convert fraction to string\n\nusing System;\nusing System.Collections.Generic;\n\nclass GfG {\n    static string calculateFraction(int a, int b) {\n\n        // If the numerator is zero, answer is \"0\"\n        if (a == 0)\n            return \"0\";\n\n        // If exactly one of the numerator or denominator\n        // is negative, then result will be negative\n        string res = (a < 0) ^ (b < 0) ? \"-\" : \"\";\n\n        a = Math.Abs(a);\n        b = Math.Abs(b);\n\n        // Calculate and Append the part before decimal point\n        res += a / b;\n\n        int rem = a % b;\n\n        // If completely divisible, return res\n        if (rem == 0)\n            return res;\n\n        res += \".\";\n        Dictionary<int, int> mp = new Dictionary<int, int>();\n\n        while (rem > 0) {\n\n            // If this remainder is already seen,\n            // then there exists a repeating fraction.\n            if (mp.ContainsKey(rem)) {\n                res = res.Insert(mp[rem], \"(\");\n                res += \")\";\n                break;\n            }\n\n            // If the remainder is seen for the first time,\n            // store its index\n            mp[rem] = res.Length;\n\n            rem = rem * 10;\n\n            // Calculate quotient, append it to result and\n            // calculate next remainder\n            res += rem / b;\n            rem = rem % b;\n        }\n\n        return res;\n    }\n\n    static void Main() {\n        int a = 50, b = 22;\n        Console.WriteLine(calculateFraction(a, b));\n    }\n}\n\n````\n\nJavaScript\n\n````\n// JavaScript Program to convert fraction to string\n\nfunction calculateFraction(a, b) {\n\n    // If the numerator is zero, answer is \"0\"\n    if (a === 0) {\n        return \"0\";\n    }\n\n    // If exactly one of the numerator or denominator\n    // is negative, then result will be negative\n    let res = (a < 0) ^ (b < 0) ? \"-\" : \"\";\n\n    a = Math.abs(a);\n    b = Math.abs(b);\n\n    // Calculate and Append the part before decimal point\n    res += Math.floor(a / b);\n\n    let rem = a % b;\n\n    // If completely divisible, return res\n    if (rem === 0) {\n        return res;\n    }\n\n    res += \".\";\n    let mp = new Map();\n\n    while (rem > 0) {\n        // If this remainder is already seen,\n        // then there exists a repeating fraction.\n        if (mp.has(rem)) {\n            let repeatIndex = mp.get(rem);\n            res = res.substring(0, repeatIndex) + \"(\"\n                        + res.substring(repeatIndex) + \")\";\n            break;\n        }\n\n        // If the remainder is seen for the first time,\n        // store its index\n        mp.set(rem, res.length);\n\n        rem = rem * 10;\n\n        // Calculate quotient, append it to result and\n        // calculate next remainder\n        res += Math.floor(rem / b);\n        rem = rem % b;\n    }\n\n    return res;\n}\n\n// Driver Code\nlet a = 50, b = 22;\nconsole.log(calculateFraction(a, b));\n\n````\n**Output**\n```\n2.(27)\n\n```\n\n****Time Complexity****\n: O(max(log10(a), log10(b))), we can make any number of recurring digits in the fraction. For example:\n\n\n* 2/9 = 0.22222..\n* 21/99 = 0.212121\u2026\n* 213/999 = 0.213213\u2026\n* 2134/9999 = 0.21342134\u2026\n* 21345/99999 = 0.2134521345\u2026 and so on.\n\n****Auxiliary Space****\n: O(max(log10(a), log10(b))), to store the result.\n\n",
        "metadata": {
            "lesson_id": "e9c94003-0430-44e0-ac55-fda3101baf00",
            "course_id": "598d78e5-c34f-437f-88fb-31557168c07b",
            "course_name": "The Logic Building Problems",
            "lesson_description": "",
            "course_description": "Logical thinking and problem-solving skills through practical programming exercises. You\u2019ll learn how to analyze problems, design algorithms, and optimize solutions. By the end of the course, you\u2019ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications."
        }
    },
    {
        "page_content": "Let\u2019s take a look a simple example to demonstrate the use of vector\ncontainer:\n\n\nC++\n````\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\n      // Creating a vector of 5 elements\n      vector<int> v = {1, 4, 2, 3, 5};\n\n      for (int i = 0; i < v.size(); i++) {\n        cout << v[i] << \" \";\n    }\n      return 0;\n}\n\n````\n\n**Output**\n```\n1 4 2 3 5\n```\n\nTable of Content\n\n* [Syntax of Vector](#create-a-vector)\n* [Declaration and Initialization](#initialize-a-vector)\n* [Basic Vector Operations](#basic-vector-operations)\n\n+ [Accessing Elements](#accessing-elements)\n+ [Updating Elements](#updating-elements)\n+ [Traversing Vector](#traversal)\n+ [Inserting Elements](#insert)\n+ [Deleting Elements](#delete)\n\n* [Other Common Operations on Vector](#common-examples-of-vector-in-c)\n* [Passing Vector to Functions](#passing-vector-to-functions)\n* [Internal Working of Vector](#internal-working-of-vector)\n* [2D Vectors](#2d-vectors)\n* [All Member Functions of Vector](#all-member-functions-of-stdvector)\n\nSyntax of Vector\n----------------\n\nVector is defined as the ****std::vector****\nclass template which contains its implementation and some useful member\nfunctions. It is defined inside the ****<vector>**** header file.\n\n> ****vector****<**T**> vec\\_name;\n\nwhere,\n\n* ****T:**** Type of elements in the vector.\n* ****vec\\_name:**** Name assigned to the vector.\n\nTo master vectors and other STL components, check out our [****Complete C++ Course****](https://gfgcdn.com/tu/T5Y/), which covers the ins and outs of C++ STL with real-world examples and\nhands-on projects.\n\n\nDeclaration and Initialization\n------------------------------\n\nDeclaration and initialization are the process of creating an instance\nof std::vector class and assigning it some initial value. In C++,\nvectors can be declared and initialized in multiple ways as shown\nbelow:\n\n****1. Default Initialization****\n\nAn empty vector can be created using the below declaration. This vector\ncan be filled later on in the program.\n\n> ****vector****<T> vec\\_name;\n\n****2. Initialization with Size and Default Value****\n\nA vector of a specific size can also be declared and initialized to the\ngiven value as default value.\n\n> ****vector****<T> vec\\_name(size, value);\n\n****3. Initialization Using Initializer List****\n\nVector can also be initialized using a list of values enclosed in ****{} braces**** separated by comma.\n\n> ****vector****<T> vec\\_name = { v1, v2, v3\u2026.};\n> ****vector****<T> vec\\_name ({ v1, v2, v3\u2026.});\n\nLet\u2019s take a look at an example that shows implements the above\nmethods:\n\nC++\n````\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid printV(vector<int> &v) {\n    for (int i = 0; i < v.size(); i++) {\n        cout << v[i] << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n\n    // Creating an empty vector\n    vector<int> v1;\n\n    // Creating a vector of 5 elements from\n    // initializer list\n    vector<int> v2 = {1, 4, 2, 3, 5};\n\n    // Creating a vector of 5 elements with\n    // default value\n    vector<int> v3(5, 9);\n\n    printV(v1);\n    printV(v2);\n    printV(v3);\n\n    return 0;\n}\n\n````\n\n\n\n\n\n**Output**\n```\n\n1 4 2 3 5\n9 9 9 9 9\n\n```\n\nMore ways to declare and initialize vectors are discussed in this\narticle \u2013 [8 Ways to Initialize Vector in C++](https://www.geeksforgeeks.org/initialize-a-vector-in-cpp-different-ways/)\n\nBasic Vector Operations\n-----------------------\n\nThe basic operations of vector are shown below:\n\n### 1. Accessing Elements\n\nJust like arrays, vector elements can be accessed using their index\ninside the [****[] subscript operator****](https://www.geeksforgeeks.org/vectoroperator-vectoroperator-c-stl/). This method is fast but doesn\u2019t check whether the given index exists\nin the vector or not. So, there is another member method [****vector at()****](https://www.geeksforgeeks.org/vector-at-in-cpp-stl/) for safely accessing elements:\n\nThe below example illustrates how to access the vector elements:\n\nC++\n````\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<char> v = {'a', 'c', 'f', 'd', 'z'};\n\n    // Accessing and printing values using indexes\n      cout << v[3] << endl;\n      cout << v.at(2);\n\n    return 0;\n}\n\n````\n\n**Output**\n```\nd\nf\n```\n\nTo know more about accessing vector elements, refer to the article \u2013 [How to Access an Element in a Vector in C++?](https://www.geeksforgeeks.org/how-to-access-element-in-vector-using-index-in-cpp/)\n\n### 2. Updating Elements\n\nUpdating elements is very similar to the accessing except that we use\nan additional assignment operator to assign a new value to a particular\nelement. It uses the same methods: [] subscript operator and vector\nat().\n\nThe below example illustrates how to update vector elements:\n\nC++\n````\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<char> v = {'a', 'c', 'f', 'd', 'z'};\n\n    // Updating values using indexes 3 and 2\n      v[3] = 'D';\n      v.at(2) = 'F';\n\n      cout << v[3] << endl;\n      cout << v.at(2);\n\n    return 0;\n}\n\n````\n\n**Output**\n```\n\nD\nF\n```\n\nMore methods to update vector elements are discussed in this article \u2013 [How to Update Vector Elements in C++?](https://www.geeksforgeeks.org/change-an-element-by-index-in-vector-in-cpp/)\n\n### 3. Traversing Vector\n\nVector in C++ can be traversed using indexes in a loop. The indexes\nstart from 0 and go up to vector size \u2013 1. To iterate through this\nrange, we can use a loop and determine the size of the vector using the [vector size()](https://www.geeksforgeeks.org/vectorempty-vectorsize-c-stl/) method.\n\nC++\n````\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<char> v = {'a', 'c', 'f', 'd', 'z'};\n\n    // Traversing vector using vector size()\n      for (int i = 0; i < v.size(); i++) {\n        cout << v[i] << \" \";\n    }\n    return 0;\n}\n\n````\n\n**Output**\n```\n\na c f d z\na c f d z\n```\n\nMore ways to traverse vectors are discussed in this article \u2013 [How to Iterate Through a Vector in C++?](https://www.geeksforgeeks.org/how-to-iterate-through-a-vector-in-cpp/)\n\n### 4. Inserting Elements\n\nAn element can be inserted into a vector using [****vector insert()****](https://www.geeksforgeeks.org/vector-insert-function-in-cpp-stl)\nmethod which takes linear time. But for the insertion at the end, the [****vector push\\_back()****](https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/)\nmethod can be used. It is much faster, taking only constant time.\n\nThe below example illustrates how to insert elements in the\nvector:\n\nC++\n````\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<char> v = {'a', 'f', 'd'};\n\n      // Inserting 'z' at the back\n      v.push_back('z');\n\n      // Inserting 'c' at index 1\n      v.insert(v.begin() + 1, 'c');\n\n      for (int i = 0; i < v.size(); i++) {\n        cout << v[i] << \" \";\n    }\n    return 0;\n}\n\n````\n\nMore ways to insert an element in the vector are discussed in this\narticle \u2013 [How to Add Elements in a Vector in C++?](https://www.geeksforgeeks.org/how-to-add-elements-in-a-vector-in-cpp/)\n\n### 5. Deleting Elements\n\nAn element can be deleted from a vector using [****vector erase()****](https://www.geeksforgeeks.org/vector-erase-and-clear-in-cpp/)\nbut this method needs iterator to the element to be deleted. If only the\nvalue of the element is known, then find() function is used to find the\nposition of this element.\n\nFor the deletion at the end, the [****vector pop\\_back()****](https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/)\nmethod can be used, and it is much faster, taking only constant\ntime.\n\nThe below example demonstrates how to delete an element from the\nvector:\n\nC++\n````\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<char> v = {'a', 'c', 'f', 'd', 'z'};\n\n    // Deleting last element 'z'\n      v.pop_back();\n      for (int i = 0; i < v.size(); i++) {\n        cout << v[i] << \" \";\n    }\n    cout << endl;\n\n      // Deleting element 'f'\n      v.erase(find(v.begin(), v.end(), 'f'));\n      for (int i = 0; i < v.size(); i++) {\n        cout << v[i] << \" \";\n    }\n    return 0;\n}\n\n````\n\n**Output**\n```\n\na c f d\na c d\n```\n\nTo know more about the deletion of an element in the vector, refer to\nthis article \u2013 [How to Remove an Element from Vector in C++?](https://www.geeksforgeeks.org/how-to-remove-an-element-from-vector-in-cpp/)\n\nOther Common Operations on Vector\n---------------------------------\n\nVector is one of the most frequently used containers in C++. It is used\nin many situations for different purposes. The following examples aim to\nhelp you master vector operations beyond the basics.",
        "metadata": {
            "lesson_id": "864de22e-8f8d-4d5d-93ff-2bb5714cc2f5",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "Array in C is one of the most used data structures in C programming. It is a\nsimple and fast way of storing multiple values under a single name. In\nthis article, we will study the different aspects of array in C language\nsuch as array declaration, definition, initialization, types of arrays,\narray syntax, advantages and disadvantages, and many more.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "**Types of Queues:**\n\nThere are **five different types of queues** that are used in\ndifferent scenarios. They are:\n\n1. Input Restricted Queue (this is a Simple Queue)\n2. Output Restricted Queue (this is also a Simple Queue)\n3. Circular Queue\n4. Double Ended Queue (Deque)\n5. Priority Queue\n   * Ascending Priority Queue\n   * Descending Priority Queue\n\n![Types of Queues](https://media.geeksforgeeks.org/wp-content/uploads/20220623134709/typesofqueues.jpg)\n\nTypes of Queues\n\n**1.** [**Circular Queue**](https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/)**:** Circular Queue is a linear data structure in which the\noperations are performed based on FIFO (First In First Out) principle and\nthe last position is connected back to the first position to make a\ncircle. It is also called **\u2018Ring Buffer\u2019**. This queue is\nprimarily used in the following cases:\n\n1. **Memory Management:** The unused memory locations in the\n   case of ordinary queues can be utilized in circular queues.\n2. **Traffic system:** In a computer-controlled traffic\n   system, circular queues are used to switch on the traffic lights one by\n   one repeatedly as per the time set.\n3. **CPU Scheduling:** Operating systems often maintain a\n   queue of processes that are ready to execute or that are waiting for a\n   particular event to occur.\n\nThe time complexity for the circular Queue is O(1).\n\n**2. Input restricted Queue:** In this type of Queue, the\ninput can be taken from one side only(rear) and deletion of elements can\nbe done from both sides(front and rear). This kind of Queue does not\nfollow FIFO(first in first out).  This queue is used in cases where\nthe consumption of the data needs to be in FIFO order but if there is a\nneed to remove the recently inserted data for some reason and one such\ncase can be irrelevant data, performance issue, etc.\n\n\n\n![Input Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131417/inputrestrictedqueue.jpg)\n\nInput Restricted Queue\n\n**Advantages of Input restricted Queue:**\n\n* Prevents overflow and overloading of the queue by limiting the number of\n  items added\n* Helps maintain stability and predictable performance of the system\n\n**Disadvantages of Input restricted Queue:**\n\n* May lead to resource wastage if the restriction is set too low and items\n  are frequently discarded\n* May lead to waiting or blocking if the restriction is set too high and\n  the queue is full, preventing new items from being added.\n\n**3. Output restricted Queue:** In this type of Queue, the\ninput can be taken from both sides(rear and front) and the deletion of the\nelement can be done from only one side(front).  This queue is used in\nthe case where the inputs have some priority order to be executed and the\ninput can be placed even in the first place so that it is executed\nfirst.\n\n![Output Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131455/outputrestrictedqueue.jpg)\n\nOutput Restricted Queue\n\n**4.** [**Double ended Queue**](https://www.geeksforgeeks.org/deque-set-1-introduction-applications/)**:** Double Ended Queue is also a Queue data structure in\nwhich the insertion and deletion operations are performed at both the ends\n(front and rear). That means, we can insert at both front and rear\npositions and can delete from both front and rear positions.  Since\nDeque supports both stack and queue operations, it can be used as both.\nThe Deque data structure supports clockwise and anticlockwise rotations in\nO(1) time which can be useful in certain applications. Also, the problems\nwhere elements need to be removed and or added both ends can be\nefficiently solved using Deque.\n\n![Double Ended Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131811/doubleended.jpg)\n\nDouble Ended Queue\n\n**5.** [**Priority Queue**](https://www.geeksforgeeks.org/priority-queue-set-1-introduction/)**:** A priority queue is a special type of queue in which\neach element is associated with a priority and is served according to its\npriority. There are two types of Priority Queues. They are:\n\n1. **Ascending Priority Queue:** Element can be inserted\n   arbitrarily but only smallest element can be removed. For example,\n   suppose there is an array having elements 4, 2, 8 in the same order. So,\n   while inserting the elements, the insertion will be in the same sequence\n   but while deleting, the order will be 2, 4, 8.\n2. **Descending priority Queue:** Element can be inserted\n   arbitrarily but only the largest element can be removed first from the\n   given Queue. For example, suppose there is an array having elements 4,\n   2, 8 in the same order. So, while inserting the elements, the insertion\n   will be in the same sequence but while deleting, the order will be 8, 4, 2.\n\nThe time complexity of the Priority Queue is O(logn).\n\n[**Applications of a Queue:**](https://www.geeksforgeeks.org/applications-of-queue-data-structure/)\n\nThe [queue](https://www.geeksforgeeks.org/queue-set-1introduction-and-array-implementation is used when things don\u2019t have to be processed immediately, but have to be processed in First In First Out order like [Breadth First Search](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/). This property of Queue makes it also useful in the following kind of scenarios.\n\n1. When a resource is shared among multiple consumers. Examples include   [CPU scheduling](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/),   [Disk Scheduling](https://www.geeksforgeeks.org/disk-scheduling-algorithms/).\n2. When data is transferred asynchronously (data not necessarily received\n   at the same rate as sent) between two processes. Examples include IO\n   Buffers, [pipes](https://www.geeksforgeeks.org/piping-in-unix-or-linux/), file IO, etc.\n3. Linear Queue: A linear queue is a type of queue where data elements are\n   added to the end of the queue and removed from the front of the queue.\n   Linear queues are used in applications where data elements need to be\n   processed in the order in which they are received. Examples include\n   printer queues and message queues.\n4. Circular Queue: A circular queue is similar to a linear queue, but the\n   end of the queue is connected to the front of the queue. This allows for\n   efficient use of space in memory and can improve performance. Circular\n   queues are used in applications where the data elements need to be\n   processed in a circular fashion. Examples include CPU scheduling and\n   memory management.\n5. Priority Queue: A priority queue is a type of queue where each element\n   is assigned a priority level. Elements with higher priority levels are\n   processed before elements with lower priority levels. Priority queues\n   are used in applications where certain tasks or data elements need to be\n   processed with higher priority. Examples include operating system task\n   scheduling and network packet scheduling.\n6. Double-ended Queue: A double-ended queue, also known as a deque, is a\n   type of queue where elements can be added or removed from either end of\n   the queue. This allows for more flexibility in data processing and can\n   be used in applications where elements need to be processed in multiple\n   directions. Examples include job scheduling and searching algorithms.\n7. Concurrent Queue: A concurrent queue is a type of queue that is designed\n   to handle multiple threads accessing the queue simultaneously.\n   Concurrent queues are used in multi-threaded applications where data\n   needs to be shared between threads in a thread-safe manner. Examples\n   include database transactions and web server requests.\n\n**Issues of Queue :**\n\nSome common issues that can arise when using queues:\n\n1. Queue overflow: Queue overflow occurs when the queue reaches its maximum\n   capacity and is unable to accept any more elements. This can cause data\n   loss and can lead to application crashes.\n2. Queue underflow: Queue underflow occurs when an attempt is made to\n   remove an element from an empty queue. This can cause errors and\n   application crashes.\n3. Priority inversion: Priority inversion occurs in priority queues when a\n   low-priority task holds a resource that a high-priority task needs. This\n   can cause delays in processing and can impact system performance.\n4. Deadlocks: Deadlocks occur when multiple threads or processes are\n   waiting for each other to release resources, resulting in a situation\n   where none of the threads can proceed. This can happen when using\n   concurrent queues and can lead to system crashes.\n5. Performance issues: Queue performance can be impacted by various\n   factors, such as the size of the queue, the frequency of access, and the\n   type of operations performed on the queue. Poor queue performance can\n   lead to slower system performance and reduced user experience.\n6. Synchronization issues: Synchronization issues can arise when multiple\n   threads are accessing the same queue simultaneously. This can result in\n   data corruption, race conditions, and other errors.\n7. Memory management issues: Queues can use up significant amounts of\n   memory, especially when processing large data sets. Memory leaks and\n   other memory management issues can occur, leading to system crashes and\n   other errors.\n\n**Reference :**\n\nSome references for further reading on queues:\n\n1. \u201cData Structures and Algorithms in Java\u201d by Robert Lafore \u2013 This book\n   provides an in-depth explanation of different types of queues and their\n   implementations in Java.\n2. \u201cIntroduction to Algorithms\u201d by Thomas H. Cormen et al. \u2013 This textbook\n   covers the basic concepts of data structures and algorithms, including\n   queues and their various applications.\n3. \u201cConcurrency in C# Cookbook\u201d by Stephen Cleary \u2013 This book provides\n   practical examples of how to use concurrent queues in C# programming.\n4. \u201cQueue (abstract data type)\u201d on Wikipedia \u2013 This article provides an\n   overview of queues and their properties, as well as examples of their\n   applications.\n5. \u201cThe Art of Computer Programming, Volume 1: Fundamental Algorithms\u201d by\n   Donald E. Knuth \u2013 This book includes a detailed analysis of different\n   queue algorithms and their performance.\n6. \u201cQueues and the Producer-Consumer Problem\u201d by Douglas C. Schmidt \u2013 This\n   paper discusses how queues can be used to solve the producer-consumer\n   problem in concurrent programming.",
        "metadata": {
            "lesson_id": "ff4db851-5e60-40f5-9ff9-ab98645fc05c",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "Queue is a linear structure that follows a particular order in which the\noperations are performed. The order is First In First Out (FIFO). A good\nexample of a queue is any queue of consumers for a resource where the\nconsumer that came first is served first. In this article, the different\ntypes of queues are discussed.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "**Basic Operations on Queue:**\n------------------------------\n\nSome of the basic operations for Queue in Data Structure are:\n\n* **enqueue() \u2013** Insertion of elements to the queue.\n* **dequeue() \u2013** Removal of elements from the queue.\n* **peek() or front()-** Acquires the data element available\n  at the front node of the queue without deleting it.\n* **rear() \u2013** This operation returns the element at the rear\n  end without removing it.\n* **isFull() \u2013** Validates if the queue is full.\n* **isEmpty() \u2013** Checks if the queue is empty.\n* **size():** This operation returns the size of the queue\n  i.e. the total number of elements it contains.\n\n![](https://media.geeksforgeeks.org/wp-content/uploads/20221209094646/Queue-768.png)\n\nQueue Data Structure\n\n### **Operation 1: enqueue()**\n\nInserts an element at the end of the queue i.e. at the rear end.\n\nThe following steps should be taken to enqueue (insert) data into a queue:\n\n* Check if the queue is full.\n* If the queue is full, return overflow error and exit.\n* If the queue is not full, increment the rear pointer to point to the\n  next empty space.\n* Add the data element to the queue location, where the rear is pointing.\n* return success.\n\n![Enqueue representation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122158/fifo1-660x371.png)\n\nEnqueue representation\n\nBelow is the Implementation of the above approach:\n\n* C++\n\n\nC++\n```\nvoid queueEnqueue(int data)\n{  // Check queue is full or not\n    if (capacity == rear) {\n        printf(\"\\nQueue is full\\n\");\n        return;  }\n    // Insert element at the rear\n    else {  queue[rear] = data;  rear++;  }\n        return;  }\n```\n\n\n\n\n\n\n\n\n**Complexity Analysis:**\n**Time Complexity:** O(1)\n**Space Complexity:** O(N)\n\n### **Operation 2: dequeue()**\n\nThis operation removes and returns an element that is at the front end of\nthe queue.\n\nThe following steps are taken to perform the dequeue operation:\n\n* Check if the queue is empty.\n* If the queue is empty, return the underflow error and exit.\n* If the queue is not empty, access the data where the front is pointing.\n* Increment the front pointer to point to the next available data element.\n* The Return success.\n\n![Dequeue operation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122625/fifo2-660x371.png)\n\nDequeue operation\n\nBelow is the Implementation of above approach:\n\n* C++\nC++\n```\n void queueDequeue()  {\n     // If queue is empty\n     if (front == rear) {\n        printf(\"\\nQueue is empty\\n\");\n         return;  }\n     // Shift all the elements from index 2\n    // till rear to the left by one\n    else {\n        for (int i = 0; i < rear - 1; i++)\n            {\n                queue[i] = queue[i + 1];\n}\n        // decrement rear  rear--;\n    }\n        return;\n}\n```\n\n**Complexity Analysis:**\n**Time Complexity:** O(1)\n**Space Complexity:** O(N)\n\n### Operation 4 : rear()\n\nThis operation returns the element at the rear end without removing it.\n\nThe following steps are taken to perform the rear operation:\n\n* If the queue is empty return the most minimum value.\n* otherwise, return the rear value.\n\nBelow is the Implementation of the above approach:\n\n* C++\n\nC++\n```\n//Function to get rear of queue\nint rear(Queue* queue)  {\n    if (isEmpty(queue))\n        return INT_MIN;\nreturn queue->arr[queue->rear];\n\n}\n\n```\n\n\n\n**Complexity Analysis:**\n**Time Complexity:** O(1)\n**Space Complexity:** O(N)\n\n### **Operation 5: isEmpty():**\n\nThis operation returns a boolean value that indicates whether the queue is\nempty or not.\n\nThe following steps are taken to perform the Empty operation:\n\n* check if front value is equal to -1 or not, if yes then return true\n  means queue is empty.\n* Otherwise return false, means queue is not empty\n\nBelow is the implementation of the above approach:\n\n* C++\n\n\nC++\n```\n// This function will check whether\n//the queue is empty or not:\n    bool isEmpty() {\n    if (front == -1)\n        return true;\nelse return false;\n}\n```\n\n\n\n**Complexity Analysis:**\n**Time Complexity:** O(1)\n**Space Complexity:** O(N)\n\n### **Operation 6 : isFull()**\n\nThis operation returns a boolean value that indicates whether the queue is\nfull or not.\n\nThe following steps are taken to perform the isFull() operation:\n\n* Check if front value is equal to zero and rear is equal to the capacity\n  of queue if yes then return true.\n* otherwise return false\n\nBelow is the Implementation of the above approach:\n\n* C++\n\n\nC++\n```\n// This function will check\n// whether the queue is full or not.\nbool isFull()  {\n    if (front == 0 && rear == MAX_SIZE - 1) {\n        return true;\n}\n    return false;\n}\n```\n\n**Complexity Analysis:**\n**Time Complexity:** O(1)\n**Space Complexity:** O(N)\n\n### Operation 7: size()\n\nThis operation returns the size of the queue i.e. the total number of\nelements it contains.\n\n```\nqueuename.size()\nParameters :\nNo parameters are passed\nReturns :\nNumber of elements in the container\n```\n\n* C++\n\n\nC++\n```\n// CPP program to illustrate\n// Implementation of size() function\n#include <iostream>\n#include <queue>\nusing namespace std;\nint main()  {\n    int sum = 0;\n    queue<int> myqueue;\n    myqueue.push(1);\n    myqueue.push(8);\n    myqueue.push(3);\n    myqueue.push(6);\n    myqueue.push(2);\n// Queue becomes 1, 8, 3, 6, 2\n    cout << myqueue.size();\nreturn 0;\n\n}\n```\n\n**Complexity Analysis:**\n**Time Complexity:** O(1)\n**Space Complexity:** O(N)\n\n",
        "metadata": {
            "lesson_id": "d6d953c0-ff47-4998-ae93-b22677a0fd02",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Basic Terminologies of Queue\n----------------------------\n\n* ****Front:**** Position of the entry in a queue ready to be served, that is, the\n  first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.\n* ****Rear:****\n  Position of the last entry in the queue, that is, the one most\n  recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.\n* ****Size:**** Size refers to the ****current**** number of elements in the queue.\n* ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.\n\n****Representation of Queue****\n-------------------------------\n\n![Representation-of-Queue-Data-Structure](https://media.geeksforgeeks.org/wp-content/uploads/20241212130245410876/Representation-of-Queue-Data-Structure-768.webp)\n\nOperations on Queue\n-------------------\n\n### ****1. Enqueue:****\n\nEnqueue operation ****adds (or stores) an element to the end of the queue****.\n\n****Steps:****\n\n1. Check if the ****queue is full****. If so, return an ****overflow**** error and exit.\n2. If the queue is ****not full****, increment the ****rear**** pointer to the next available position.\n3. Insert the element at the rear.\n\n\n![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)\n\n\n![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)\n\n\n![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)\n\n\n![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)\n\n\n![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)\n\n\n![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)\n\n\n\nPrevious\n\n\n\n\n\nPause\n\nNext\n\n\n\n\n\n3 / 6\n\n\n\n### ****2. Dequeue:****\n\nDequeue operation removes the element at the front of the queue. The\nfollowing steps are taken to perform the dequeue operation:\n\n\n1. Check if the ****queue is empty****. If so, return an ****underflow**** error.\n2. Remove the element at the ****front****.\n3. ****Increment**** the ****front**** pointer to the next element.\n\n\n![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n\nPrevious\n\n\n\n\n\nPlay\n\nNext\n\n\n\n\n\n1 / 6\n\n\n\n### ****3. Peek or Front Operation:****\n\nThis operation returns the element at the front end without removing\nit.\n\n### 4. Size Operation:\n\nThis operation returns the numbers of elements present in the\nqueue.\n\n### ****5. isEmpty Operation:****\n\nThis operation returns a boolean value that indicates whether the queue\nis empty or not.\n\n### ****6. isFull Operation:****\n\nThis operation returns a boolean value that indicates whether the queue\nis full or not.\n\nImplementation of Queue Data Structure\n--------------------------------------\n\nQueue can be implemented using following data structures:\n\n* [Implementation of Queue using Arrays](https://www.geeksforgeeks.org/introduction-and-array-implementation-of-queue)\n* [Implementation of Queue using Linked List](https://www.geeksforgeeks.org/queue-linked-list-implementation)\n\nComplexity Analysis of Operations on Queue\n------------------------------------------\n\n| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |\n| --- | --- | --- |\n| ****enqueue**** | O(1) | O(1) |\n| ****dequeue**** | O(1) | O(1) |\n| front | O(1) | O(1) |\n| size | O(1) | O(1) |\n| isEmpty | O(1) | O(1) |\n| isFull | O(1) | O(1) |\n\n****Types of Queues****\n-----------------------\n\nQueue data structure can be classified into 4 types:\n\n1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the\n   element from the front of the queue.\n2. [****Double-Ended Queue (Deque)****](https://www.geeksforgeeks.org/deque-set-1-introduction-applications)****:****\n   In a double-ended queue the insertion and deletion operations, both\n   can be performed from both ends. They are of two types:\n   * ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be\n     taken from only one end but deletion can be done from any of the\n     ends.\n   * ****Output Restricted Queue:****\n     This is also a simple queue. In this type of queue, the input can\n     be taken from both ends but deletion can be done from only one\n     end.\n3. [****Circular Queue:****](https://www.geeksforgeeks.org/introduction-to-circular-queue) This is a special type of queue where the last position is connected\n   back to the first position. Here also the operations are performed in\n   FIFO order.\n4. [****Priority Queue****](https://www.geeksforgeeks.org/priority-queue-set-1-introduction)****:****\n   A priority queue is a special queue where the elements are accessed\n   based on the priority assigned to them. They are of two types:\n   * ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in\n     increasing order of their priority values. Element with smallest\n     priority value is popped first.\n   * ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in\n     decreasing order of their priority values. Element with largest\n     priority is popped first.\n\n![Types-of-Queue](https://media.geeksforgeeks.org/wp-content/uploads/20241212125924381216/Types-of-Queue-660.webp)\n\n****Applications of Queue Data Structure****\n--------------------------------------------\n\nApplication of queue is common. In a computer system, there may be\nqueues of tasks waiting for the printer, for access to disk storage, or\neven in a time-sharing system, for use of the CPU. Within a single\nprogram, there may be multiple requests to be kept in a queue, or one\ntask may create other tasks, which must be done in turn by keeping them\nin a queue.\n\n* A Queue is always used as a buffer when we have a speed mismatch\n  between a producer and consumer. For example keyboard and CPU.\n* Queue can be used where we have a single resource and multiple\n  consumers like a single CPU and multiple processes.\n* In a network, a queue is used in devices such as a router/switch and\n  mail queue.\n* Queue can be used in various algorithm techniques like Breadth First\n  Search, Topological Sort, etc.",
        "metadata": {
            "lesson_id": "dfada5ab-a189-4507-8c06-78c269c52440",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "Queue is a linear data structure that follows FIFO (First In First Out) Principle, so the first element inserted is the first to be popped out.\n",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Advantages of Linked Lists (or Most Common Use Cases):\n------------------------------------------------------\n\n* Linked Lists are mostly used because of their effective insertion and\n  deletion.  We only need to change few pointers (or references) to\n  insert (or delete) an item in the middle\n* [Insertion and deletion](https://www.geeksforgeeks.org/insertion-deletion-stl-set-c/) at any point in a linked list take O(1) time. Whereas in an [array](https://www.geeksforgeeks.org/array-data-structure/)\n  data structure, insertion / deletion in the middle takes O(n)\n  time.\n* This data structure is simple and can be also used to implement [a stack](https://www.geeksforgeeks.org/stack-data-structure/), [queues,](https://www.geeksforgeeks.org/queue-data-structure/) and other [abstract data structures](https://www.geeksforgeeks.org/abstract-data-types/).\n* Implementation of Queue and Deque data structures : Simple array\n  implementation is not efficient at all. We must use circular array to\n  efficiently implement which is complex. But with linked list, it is\n  easy and straightforward. That is why most of the language libraries\n  use Linked List internally to implement these data structures..\n* Linked List might turn out to be more space efficient compare to\n  arrays in cases where we cannot guess the number of elements in\n  advance. In case of arrays, the whole memory for items is allocated\n  together. Even with dynamic sized arrays like vector in C++ or list in\n  Python or ArrayList in Java. the internal working involves\n  de-allocation of whole memory and allocation of a bigger chunk when\n  insertions happen beyond the current capacity.\n\nApplications of Linked Lists:\n-----------------------------\n\n* Linked Lists can be used to implement stacks, queue, deque, [sparse matrices](https://www.geeksforgeeks.org/sparse-matrix-representation/) and adjacency list representation of graphs.\n* [Dynamic memory allocation](https://www.geeksforgeeks.org/what-is-dynamic-memory-allocation/)\n  in operating systems and compilers (linked list of free blocks).\n* Manipulation of polynomials\n* Arithmetic operations on long integers.\n* In operating systems, they can be used in Memory management, process\n  scheduling (for example circular linked list for round robin\n  scheduling) and file system.\n* Algorithms that need to frequently insert or delete items from large\n  collections of data.\n* LRU cache, which uses a doubly linked list to keep track of the most\n  recently used items in a cache.\n\nApplications of Linked Lists in real world:\n-------------------------------------------\n\n* The list of songs in the music player are linked to the previous and\n  next songs.\n* In a web browser, previous and next web page URLs can be linked\n  through the previous and next buttons (Doubly Linked List)\n* In image viewer, the previous and next images can be linked with the\n  help of the previous and next buttons (Doubly Linked List)\n* Circular Linked Lists can be used to implement things in round manner\n  where we go to every element one by one.\n* Linked List are preferred over arrays for implementations of Queue\n  and Deque data structures because of fast deletions (or insertions)\n  from the front of the linked lists.\n\nDisadvantages of Linked Lists:\n------------------------------\n\nLinked lists are a popular data structure in computer science, but like\nany other data structure, they have certain disadvantages as well. Some\nof the key disadvantages of linked lists are:\n\n* ****Slow Access Time:**** Accessing elements in a linked list can be slow, as you need to\n  traverse the linked list to find the element you are looking for,\n  which is an O(n) operation. This makes linked lists a poor choice for\n  situations where you need to access elements quickly.\n* ****Pointers or References:****\n  Linked lists use pointers or references to access the next node, which\n  can make them more complex to understand and use compared to arrays.\n  This complexity can make linked lists more difficult to debug and\n  maintain.\n* ****Higher overhead:**** Linked lists have a higher overhead compared to arrays, as each node\n  in a linked list requires extra memory to store the reference to the\n  next node.\n* ****Cache Inefficiency:**** Linked lists are cache-inefficient because the memory is not\n  contiguous. This means that when you traverse a linked list, you are\n  not likely to get the data you need in the cache, leading to cache\n  misses and slow performance.\n\nIn conclusion, linked lists are a powerful and flexible data structure,\nbut they have certain disadvantages that need to be taken into\nconsideration when deciding whether to use them or not. For example, if\nyou need fast access time, arrays might be a better choice, but if you\nneed to insert or delete elements frequently, linked lists might be the\nbetter choice.\n",
        "metadata": {
            "lesson_id": "ba83bbd2-32b7-445a-9895-7a9502446497",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "A Linked List is a linear data structure\nthat is used to store a collection of data with the help of nodes.\nPlease remember the following points before moving forward.\n",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Understanding Node Structure\n----------------------------\n\nIn a singly linked list, each node consists of two parts: data and a\npointer to the next node. This structure allows nodes to be dynamically\nlinked together, forming a chain-like sequence.\n\n\n![Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240917161540/Singly-Linked-List.webp)\n\nSingly Linked List\n\n\n\nC++\n````\n// Definition of a Node in a singly linked list\nstruct Node {\n\n    // Data part of the node\n    int data;\n\n    // Pointer to the next node in the list\n    Node* next;\n\n    // Constructor to initialize the node with data\n    Node(int data)\n    {\n        this->data = data;\n        this->next = nullptr;\n    }\n};\n\n````\n\nC\n````\n// Definition of a Node in a singly linked list\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to create a new Node\nstruct Node* newNode(int data) {\n    struct Node* temp =\n      (struct Node*)malloc(sizeof(struct Node));\n    temp->data = data;\n    temp->next = NULL;\n    return temp;\n}\n\n````\n\nJava\n````\n// Definition of a Node in a singly linked list\npublic class Node {\n    int data;\n    Node next;\n\n    // Constructor to initialize the node with data\n    public Node(int data)\n    {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n````\n\nPython\n````\n# Definition of a Node in a singly linked list\nclass Node:\n    def __init__(self, data):\n       # Data part of the node\n        self.data = data\n        self.next = None\n\n````\n\nJavaScript\n````\n// Definition of a Node in a singly linked list\nclass Node {\n    constructor(data) {\n    // Data part of the node\n        this.data = data;\n        this.next = null;\n    }\n}\n\n````\n\n\n\nIn this example, the Node class contains an integer data field (****data****) to store the information and a pointer to another Node (****next****) to establish the link to the next node in the list.\n\nOperations on Singly Linked List\n--------------------------------\n\n* ****Traversal****\n* ****Searching****\n* ****Length****\n* ****Insertion:****\n  + Insert at the beginning\n  + Insert at the end\n  + Insert at a specific position\n* ****Deletion:****\n  + Delete from the beginning\n  + Delete from the end\n  + Delete a specific node\n\nLet's go through each of the operations mentioned above, one by\none.\n\n[****Traversal**** of Singly Linked List](https://www.geeksforgeeks.org/traversal-of-singly-linked-list/)\n---------------------------------------------------------------------------------------------------------\n\nTraversal involves visiting each node in the linked list and performing\nsome operation on the data. A simple traversal function would print or\nprocess the data of each node.\n\nStep-by-step approach:\n\n* Initialize a pointer current to the head of the list.\n* Use a while loop to iterate through the list until the current\n  pointer reaches NULL.\n* Inside the loop, print the data of the current node and move the\n  current pointer to the next node.\n\nBelow is the function for traversal in singly Linked List:\n\nC++\n````\n// C++ Function to traverse and print the elements of the linked\n// list\nvoid traverseLinkedList(Node* head)\n{\n    // Start from the head of the linked list\n    Node* current = head;\n\n    // Traverse the linked list until reaching the end\n    // (nullptr)\n    while (current != nullptr) {\n\n        // Print the data of the current node\n        cout << current->data << \" \";\n\n        // Move to the next node\n        current = current->next;\n    }\n\n    cout << std::endl;\n}\n\n````\n\nC\n````\n// Function to traverse and print the elements\n// of the linked list\nvoid traverseLinkedList(struct Node* head)\n{\n    // Start from the head of the linked list\n    struct Node* current = head;\n\n    // Traverse the linked list until reaching the end (NULL)\n    while (current != NULL) {\n\n        // Print the data of the current node\n        printf(\"%d \", current->data);\n\n        // Move to the next node\n        current = current->next;\n    }\n\n    printf(\"\\n\");\n}\n\n````\n\nJava\n````\n// Java Function to traverse and print the elements of the\n// linked list\npublic static void traverseLinkedList(Node head)\n{\n    // Start from the head of the linked list\n    Node current = head;\n\n    // Traverse the linked list until reaching the end\n    // (null)\n    while (current != null) {\n\n        // Print the data of the current node\n        System.out.print(current.data + \" \");\n\n        // Move to the next node\n        current = current.next;\n    }\n\n    System.out.println();\n}\n\n````\n\nPython\n````\n# Python Function to traverse and print the elements of the linked list\ndef traverse_linked_list(head):\n    # Start from the head of the linked list\n    current = head\n\n    # Traverse the linked list until reaching the end (None)\n    while current is not None:\n\n        # Print the data of the current node followed by a space\n        print(current.data),\n\n        # Move to the next node\n        current = current.next\n\n    print()  # Print a new line after traversing the linked list\n\n````\n\nJavaScript\n````\n// Javascript Function to traverse and print the elements\n// of the linked list\nfunction traverseLinkedList(head) {\n\n    // Start from the head of the linked list\n    let current = head;\n\n    // Traverse the linked list until reaching the\n    // end (null)\n    while (current !== null) {\n\n        // Print the data of the current node\n        console.log(current.data + \" \");\n\n        // Move to the next node\n        current = current.next;\n    }\n\n    console.log();\n}\n\n````\n\n**Output**\n```\n\n1 2 3\n\n```\n\n[Searching in Singly Linked List](https://www.geeksforgeeks.org/search-an-element-in-a-linked-list-iterative-and-recursive/)\n----------------------------------------------------------------------------------------------------------------------------\n\nSearching in a Singly Linked List refers to the process of looking for\na specific element or value within the elements of the linked list.\n\n\nStep-by-step approach:\n\n1. Traverse the Linked List starting from the head.\n2. Check if the current node's data matches the target value.\n   * If a match is found, return ****true****.\n3. Otherwise, Move to the next node and repeat steps 2.\n4. If the end of the list is reached without finding a match, return ****false****.\n\nBelow is the function for searching in singly linked list:\n\nC++\n````\n// Function to search for a value in the Linked List\nbool searchLinkedList(struct Node* head, int target)\n{\n    // Traverse the Linked List\n    while (head != nullptr) {\n\n        // Check if the current node's\n        // data matches the target value\n        if (head->data == target) {\n            return true; // Value found\n        }\n\n        // Move to the next node\n        head = head->next;\n    }\n\n    return false; // Value not found\n}\n\n````\n\nC\n````\n// Function to search for a value in the Linked List\nbool searchLinkedList(struct Node* head, int target)\n{\n    // Traverse the Linked List\n    while (head != NULL) {\n\n        // Check if the current node's\n        // data matches the target value\n        if (head->data == target) {\n            return true; // Value found\n        }\n\n        // Move to the next node\n        head = head->next;\n    }\n\n    return false; // Value not found\n}\n\n````\n\nJava\n````\n// Java function to search for a value in the Linked List\npublic boolean searchLinkedList(Node head, int target)\n{\n    // Traverse the Linked List\n    while (head != null) {\n\n        // Check if the current node's data matches the\n        // target value\n        if (head.data == target) {\n\n            // Value found\n            return true;\n        }\n\n        // Move to the next node\n        head = head.next;\n    }\n\n    // Value not found\n    return false;\n}\n\n````\n\nPython\n````\n# Python function to search for a value in the Linked List\ndef search_linked_list(head, target):\n\n    # Traverse the Linked List\n    while head is not None:\n\n        # Check if the current node's data matches the target value\n        if head.data == target:\n\n            return True  # Value found\n        # Move to the next node\n        head = head.next\n\n    return False  # Value not found\n\n````\n\nJavaScript\n````\n// Javascript function to search for a value in the Linked List\nfunction searchLinkedList(head, target) {\n\n    // Traverse the Linked List\n    while (head !== null) {\n\n        // Check if the current node's data matches the target value\n        if (head.data === target) {\n            return true;  // Value found\n        }\n\n        // Move to the next node\n        head = head.next;\n    }\n\n    return false;  // Value not found\n}\n\n````\n\n\n\n[Length of Singly Linked List](https://www.geeksforgeeks.org/find-length-of-a-linked-list-iterative-and-recursive)\n------------------------------------------------------------------------------------------------------------------\n\nFinding Length in Singly Linked List refers to the process of\ndetermining the total number of nodes in a singly linked list.\n\nStep-by-step approach:\n\n* Initialize a counter ****length**** to 0.\n* Start from the head of the list, assign it to current.\n* Traverse the list:\n  + Increment ****length**** for each node.\n  + Move to the next node (****current = current->next****).\n* Return the final value of ****length****.\n\nBelow is the function for finding length in Singly Linked List:\n\nC++\n````\n// C++ function to find the length of the linked list\nint findLength(Node* head)\n{\n    // Initialize a counter for the length\n    int length = 0;\n\n    // Start from the head of the list\n    Node* current = head;\n\n    // Traverse the list and increment the length for each\n    // node\n    while (current != nullptr) {\n        length++;\n        current = current->next;\n    }\n\n    // Return the final length of the linked list\n    return length;\n}\n\n````\n\nC\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Definition of a Node in a singly linked list\nstruct Node {\n    int data;          // Data part of the node\n    struct Node* next; // Pointer to the next node in the list\n};\n\n// Function to find the length of the linked list\nint findLength(struct Node* head)\n{\n    // Initialize a counter for the length\n    int length = 0;\n\n    // Start from the head of the list\n    struct Node* curr = head;\n\n    // Traverse the list and increment\n    // the length for each node\n    while (curr != NULL) {\n        length++;\n        curr = curr->next;\n    }\n\n    // Return the final length of the linked list\n    return length;\n}\n\n````\n\nJava\n````\n// Java function to find the length of the linked list\npublic int findLength(Node head) {\n\n    // Initialize a counter for the length\n    int length = 0;\n\n    // Start from the head of the list\n    Node current = head;\n\n    // Traverse the list and increment the length for each\n    // node\n    while (current != null) {\n        length++;\n        current = current.next;\n    }\n\n    // Return the final length of the linked list\n    return length;\n}\n\n````\n\nPython\n````\n# Python function to find the length of the linked list\ndef find_length(head):\n\n    # Initialize a counter for the length\n    length = 0\n\n    # Start from the head of the list\n    current = head\n\n    # Traverse the list and increment the length for each\n    # node\n    while current is not None:\n        length += 1\n        current = current.next\n\n    # Return the final length of the linked list\n    return length\n\n````\n\nJavaScript\n````\n// Javascript function to find the length of the linked list\nfunction findLength(head) {\n\n    // Initialize a counter for the length\n    let length = 0;\n\n    // Start from the head of the list\n    let current = head;\n\n    // Traverse the list and increment the length for each\n    // node\n    while (current !== null) {\n        length++;\n        current = current.next;\n    }\n\n    // Return the final length of the linked list\n    return length;\n}\n\n````\n\n\n\n\n[Insertion in Singly Linked List](https://www.geeksforgeeks.org/insertion-in-linked-list)\n-----------------------------------------------------------------------------------------\n\nInsertion is a fundamental operation in linked lists that involves\nadding a new node to the list. There are several scenarios for\ninsertion:\n\n### a. [Insertion at the Beginning of Singly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-front-beginning-of-a-linked-list):\n\n![Insertion-at-the-Beginning-of-Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20241022163445386036/Insertion-at-the-Beginning-of-Singly-Linked-List.webp)\n\n\nInsert a Node at the Front/Beginning of Linked List\n\n\n\nStep-by-step approach:\n\n* Create a new node with the given value.\n* Set the ****next**** pointer of the new node to the current head.\n* Move the head to point to the new node.\n* Return the new head of the linked list.\n\nBelow is the function for insertion at the beginning of singly linked\nlist:\n\nC++\n````\n// C++ function to insert a new node at the beginning of the\n// linked list\nNode* insertAtBeginning(Node* head, int value)\n{\n    // Create a new node with the given value\n    Node* newNode = new Node(value);\n\n    // Set the next pointer of the new node to the current\n    // head\n    newNode->next = head;\n\n    // Move the head to point to the new node\n    head = newNode;\n\n    // Return the new head of the linked list\n    return head;\n}\n\n````\n\nC\n````\n// Function to insert a new node at the beginning of the linked list\nstruct Node* insertAtBeginning(struct Node* head, int value)\n{\n    // Create a new node with the given value\n    struct Node* new_node = newNode(value);\n\n    // Set the next pointer of the new node to the current head\n    new_node->next = head;\n\n    // Move the head to point to the new node\n    head = new_node;\n\n    // Return the new head of the linked list\n    return head;\n}\n\n````\n\nJava\n````\n// Java function to insert a new node at the beginning of the\n// linked list\npublic Node insertAtBeginning(Node head, int value) {\n    // Create a new node with the given value\n    Node newNode = new Node(value);\n\n    // Set the next pointer of the new node to the current\n    // head\n    newNode.next = head;\n\n    // Move the head to point to the new node\n    head = newNode;\n\n    // Return the new head of the linked list\n    return head;\n}\n\n````\n\nPython\n````\n# Python function to insert a new node at the beginning of the\n# linked list\ndef insert_at_beginning(head, value):\n\n    # Create a new node with the given value\n    new_node = Node(value)\n\n    # Set the next pointer of the new node to the current\n    # head\n    new_node.next = head\n\n    # Move the head to point to the new node\n    head = new_node\n\n    # Return the new head of the linked list\n    return head\n\n````\n\nJavaScript\n````\n// Javascript function to insert a new node at the beginning of the\n// linked list\nfunction insertAtBeginning(head, value) {\n\n    // Create a new node with the given value\n    let newNode = new Node(value);\n\n    // Set the next pointer of the new node to the current\n    // head\n    newNode.next = head;\n\n    // Move the head to point to the new node\n    head = newNode;\n\n    // Return the new head of the linked list\n    return head;\n}\n\n````\n\n\n### b. [Insertion at the End of Singly Linked List:](https://www.geeksforgeeks.org/insert-node-at-the-end-of-a-linked-list)\n\nTo insert a node at the end of the list, traverse the list until the\nlast node is reached, and then link the new node to the current last\nnode-\n\n![Insertion-at-the-End-of-Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20241022163601409037/Insertion-at-the-End-of-Singly-Linked-List.webp)\n\nInsertion at end of Linked List\n\n\nStep-by-step approach:\n\n* Create a new node with the given value.\n* Check if the list is empty:\n  + If it is, make the new node the head and return.\n* Traverse the list until the last node is reached.\n* Link the new node to the current last node by setting the last node's\n  next pointer to the new node.\n\nBelow is the function for insertion at the end of singly linked\nlist:\n\nC++\n````\n// C++ Function to insert a node at the end of the linked\n// list\nNode* insertAtEnd(Node* head, int value)\n{\n    // Create a new node with the given value\n    Node* newNode = new Node(value);\n\n    // If the list is empty, make the new node the head\n    if (head == nullptr)\n        return newNode;\n\n    // Traverse the list until the last node is reached\n    Node* curr = head;\n    while (curr->next != nullptr) {\n        curr = curr->next;\n    }\n\n    // Link the new node to the current last node\n    curr->next = newNode;\n    return head;\n}\n\n````\n\nC\n````\n// Function to insert a node at the end of the linked list\nstruct Node* insertAtEnd(struct Node* head, int value)\n{\n    // Create a new node with the given value\n    struct Node* new_node = newNode(value);\n\n    // If the list is empty, make the new node the head\n    if (head == NULL)\n        return new_node;\n\n    // Traverse the list until the last node is reached\n    struct Node* curr = head;\n    while (curr->next != NULL) {\n        curr = curr->next;\n    }\n\n    // Link the new node to the current last node\n    curr->next = new_node;\n\n    return head;\n}\n\n````\n\nJava\n````\n// Function to insert a node at the end of the linked list\npublic static Node insertAtEnd(Node head, int value)\n{\n    // Create a new node with the given value\n    Node newNode = new Node(value);\n\n    // If the list is empty, make the new node the head\n    if (head == null)\n        return newNode;\n\n    // Traverse the list until the last node is reached\n    Node curr = head;\n    while (curr.next != null) {\n        curr = curr.next;\n    }\n\n    // Link the new node to the current last node\n    curr.next = newNode;\n\n    return head;\n}\n\n````\n\nPython\n````\n# Python function to insert a node at the end of the linked\n# list\ndef insert_at_end(head, value):\n\n    # Create a new node with the given value\n    new_node = Node(value)\n\n    # If the list is empty, make the new node the head\n    if head is None:\n        return new_node\n\n    # Traverse the list until the last node is reached\n    current = head\n    while current.next is not None:\n        current = current.next\n\n    # Link the new node to the current last node\n    current.next = new_node\n\n    return head\n\n````\n\nJavaScript\n````\n// Javascript function to insert a node at the end of the linked\n// list\nfunction insertAtEnd(head, value) {\n\n    // Create a new node with the given value\n    let newNode = new Node(value);\n\n    // If the list is empty, make the new node the head\n    if (head === null) {\n        return newNode;\n    }\n\n    // Traverse the list until the last node is reached\n    let current = head;\n    while (current.next !== null) {\n        current = current.next;\n    }\n\n    // Link the new node to the current last node\n    current.next = newNode;\n\n    return head;\n}\n\n````\n\n\n\n\n\n### c. [Insertion at a Specific Position of the Singly Linked List:](https://www.geeksforgeeks.org/insert-a-node-at-a-specific-position-in-a-linked-list)\n\nTo insert a node at a specific position, traverse the list to the\ndesired position, link the new node to the next node, and update the\nlinks accordingly.\n\n![Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy](https://media.geeksforgeeks.org/wp-content/uploads/20241022163649252002/Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy.webp)\n\n\n\n\nWe mainly find the node after which we need to insert the new node. If\nwe encounter a NULL before reaching that node, it means that the given\nposition is invalid.\n\nBelow is the function for insertion at a specific position of the\nsingly linked list:\n\nC++\n````\n// Function to insert a Node at a specified position\n// without using a double pointer\nNode* insertPos(Node* head, int pos, int data)\n{\n    if (pos < 1) {\n        cout << \"Invalid position!\" << endl;\n        return head;\n    }\n\n    // Special case for inserting at the head\n    if (pos == 1) {\n        Node* temp = new Node(data);\n        temp->next = head;\n        return temp;\n    }\n\n    // Traverse the list to find the node\n    // before the insertion point\n    Node* prev = head;\n    int count = 1;\n    while (count < pos - 1 && prev != nullptr) {\n        prev = prev->next;\n        count++;\n    }\n\n    // If position is greater than the number of nodes\n    if (prev == nullptr) {\n        cout << \"Invalid position!\" << endl;\n        return head;\n    }\n\n    // Insert the new node at the specified position\n    Node* temp = new Node(data);\n    temp->next = prev->next;\n    prev->next = temp;\n\n    return head;\n}\n\n````\n\nC\n````\n// Function to insert a node at a specified position\nstruct Node* insertPos(struct Node* head, int pos, int data) {\n    if (pos < 1) {\n        printf(\"Invalid position!\\n\");\n        return head;\n    }\n\n    // Special case for inserting at the head\n    if (pos == 1) {\n        struct Node* temp = getNode(data);\n        temp->next = head;\n        return temp;\n    }\n\n    // Traverse the list to find the node\n    // before the insertion point\n    struct Node* prev = head;\n    int count = 1;\n    while (count < pos - 1 && prev != NULL) {\n        prev = prev->next;\n        count++;\n    }\n\n    // If position is greater than the number of nodes\n    if (prev == NULL) {\n        printf(\"Invalid position!\\n\");\n        return head;\n    }\n\n    // Insert the new node at the specified position\n    struct Node* temp = getNode(data);\n    temp->next = prev->next;\n    prev->next = temp;\n\n    return head;\n}\n\n````\n\nJava\n````\npublic static Node insertPos(Node head, int pos, int data)\n{\n    if (pos < 1) {\n        System.out.println(\"Invalid position!\");\n        return head;\n    }\n\n    // Special case for inserting at the head\n    if (pos == 1) {\n        Node temp = new Node(data);\n        temp.next = head;\n        return temp;\n    }\n\n    // Traverse the list to find the node before the\n    // insertion point\n    Node prev = head;\n    int count = 1;\n    while (count < pos - 1 && prev != null) {\n        prev = prev.next;\n        count++;\n    }\n\n    // If position is greater than the number of nodes\n    if (prev == null) {\n        System.out.println(\"Invalid position!\");\n        return head;\n    }\n\n    // Insert the new node at the specified position\n    Node temp = new Node(data);\n    temp.next = prev.next;\n    prev.next = temp;\n\n    return head;\n}\n\n````\n\nPython\n````\n# Function to insert a node at a specified position\ndef insertPos(head, pos, data):\n    if pos < 1:\n        print(\"Invalid position!\")\n        return head\n\n    # Special case for inserting at the head\n    if pos == 1:\n        new_node = Node(data)\n        new_node.next = head\n        return new_node\n\n    # Traverse the list to find the node before\n    # the insertion point\n    prev = head\n    count = 1\n    while count < pos - 1 and prev is not None:\n        prev = prev.next\n        count += 1\n\n    # If position is greater than the number of nodes\n    if prev is None:\n        print(\"Invalid position!\")\n        return head\n\n    # Insert the new node at the specified position\n    new_node = Node(data)\n    new_node.next = prev.next\n    prev.next = new_node\n\n    return head\n\n````\n\nJavaScript\n````\n// Function to insert a node at a specified position\nfunction insertPos(head, pos, data) {\n    if (pos < 1) {\n        console.log(\"Invalid position!\");\n        return head;\n    }\n\n    // Special case for inserting at the head\n    if (pos === 1) {\n        const newNode = new Node(data);\n        newNode.next = head;\n        return newNode;\n    }\n\n    // Traverse the list to find the node\n    // before the insertion point\n    let prev = head;\n    let count = 1;\n    while (count < pos - 1 && prev !== null) {\n        prev = prev.next;\n        count++;\n    }\n\n    // If position is greater than the number of nodes\n    if (prev === null) {\n        console.log(\"Invalid position!\");\n        return head;\n    }\n\n    // Insert the new node at the specified position\n    const newNode = new Node(data);\n    newNode.next = prev.next;\n    prev.next = newNode;\n\n    return head;\n}\n\n````\n\n\n\n\n\n\n\n\n[Deletion in Singly Linked List](https://www.geeksforgeeks.org/deletion-in-linked-list)\n---------------------------------------------------------------------------------------\n\nDeletion involves removing a node from the linked list. Similar to\ninsertion, there are different scenarios for deletion:\n\n### a. [****Deletion at the Beginning of**** Singly Linked List****:****](https://www.geeksforgeeks.org/remove-first-node-of-the-linked-list)\n\nTo delete the first node, update the head to point to the second node\nin the list.\n\n![Deletion-at-beginning-](https://media.geeksforgeeks.org/wp-content/uploads/20241022163937663413/Deletion-at-beginning-.webp)\n\nDeletion at beginning in a Linked List\n\n\nSteps-by-step approach:\n\n* Check if the head is ****NULL****.\n  + If it is, return ****NULL**** (the list is empty).\n* Store the current head node in a temporary variable ****temp****.\n* Move the head pointer to the next node.\n* Delete the temporary node.\n* Return the new head of the linked list.\n\nBelow is the function for deletion at the beginning of singly linked\nlist:\n\nC++\n````\n// C++ Function to remove the first node of the linked\n// list\nNode* removeFirstNode(Node* head)\n{\n    if (head == nullptr)\n        return nullptr;\n\n    // Move the head pointer to the next node\n    Node* temp = head;\n    head = head->next;\n\n    delete temp;\n\n    return head;\n}\n\n````\n\nC\n````\n// Function to remove the first node of the linked list\nstruct Node* removeFirstNode(struct Node* head)\n{\n    if (head == NULL)\n        return NULL;\n\n    // Move the head pointer to the next node\n    struct Node* temp = head;\n    head = head->next;\n\n    // Free the memory of the old head\n    free(temp);\n\n    return head;\n}\n\n````\n\nJava\n````\n// Java Function to remove the first node\n// of the linked list\nstatic Node removeFirstNode(Node head)\n{\n    if (head == null)\n        return null;\n\n    // Move the head pointer to the next node\n    Node temp = head;\n    head = head.next;\n\n    return head;\n}\n\n````\n\nPython\n````\n# Python Function to remove the first node\n# of the linked list\ndef removeFirstNode(head):\n    if not head:\n        return None\n    temp = head\n\n    # Move the head pointer to the next node\n    head = head.next\n    temp = None\n    return head\n\n````\n\nJavaScript\n````\n// Javascript Function to remove the first node\n// of the linked list /\nfunction removeFirstNode(head) {\n  if (head == null) return null;\n\n  // Move the head pointer to the next node\n  temp = head;\n  head = head.next;\n\n  return head;\n}\n\n````\n\n\n### b. [Deletion at the End of Singly Linked List:](https://www.geeksforgeeks.org/remove-last-node-of-the-linked-list)\n\nTo delete the last node, traverse the list until the second-to-last\nnode and update its next field to None.\n\n![Deletion-At-End](https://media.geeksforgeeks.org/wp-content/uploads/20241022164030481275/Deletion-At-End.webp)\n\nDeletion at the end of linked list\n\n\nStep-by-step approach:\n\n* Check if the head is ****NULL****.\n  + If it is, return NULL (the list is empty).\n* Check if the head's ****next**** is ****NULL**** (only one node in the list).\n  + If true, delete the head and return ****NULL****.\n* Traverse the list to find the second last node (****second\\_last****).\n* Delete the last node (the node after ****second\\_last****).\n* Set the ****next**** pointer of the second last node to ****NULL****.\n* Return the head of the linked list.\n\nBelow is the function for deletion at the end of singly linked\nlist:\n\nC++\n````\n// C++ Function to remove the last node of the linked list\nNode* removeLastNode(Node* head)\n{\n    if (head == nullptr)\n        return nullptr;\n\n    if (head->next == nullptr) {\n        delete head;\n        return nullptr;\n    }\n\n    // Find the second last node\n    Node* second_last = head;\n    while (second_last->next->next != nullptr)\n        second_last = second_last->next;\n\n    // Delete last node\n    delete (second_last->next);\n\n    // Change next of second last\n    second_last->next = nullptr;\n\n    return head;\n}\n\n````\n\nC\n````\n// Function to remove the last node of the linked list\nstruct Node* removeLastNode(struct Node* head)\n{\n    if (head == NULL)\n        return NULL;\n\n    if (head->next == NULL) {\n        free(head);\n        return NULL;\n    }\n\n    // Find the second last node\n    struct Node* second_last = head;\n    while (second_last->next->next != NULL)\n        second_last = second_last->next;\n\n    // Delete last node\n    free(second_last->next);\n\n    // Change next of second last\n    second_last->next = NULL;\n\n    return head;\n}\n\n````\n\nJava\n````\n// Java Function to remove the last node of the linked list\nNode removeLastNode(Node head)\n{\n    // If the list is empty, return null\n    if (head == null)\n        return null;\n\n    // If the list has only one node, delete it and return\n    // null\n    if (head.next == null) {\n        head = null;\n        return null;\n    }\n\n    // Find the second last node\n    Node second_last = head;\n    while (second_last.next.next != null)\n        second_last = second_last.next;\n\n    // Remove the last node\n    second_last.next = null;\n\n    // Return the modified list\n    return head;\n}\n\n````\n\nPython\n````\n# Python Function to remove the last node of the linked list\ndef removeLastNode(head):\n    # If the list is empty, return None\n    if head is None:\n        return None\n\n    # If the list has only one node, delete it and return None\n    if head.next is None:\n        head = None\n        return None\n\n    # Find the second last node\n    second_last = head\n    while second_last.next.next is not None:\n        second_last = second_last.next\n\n    # Remove the last node\n    second_last.next = None\n\n    # Return the modified list\n    return head\n\n````\n\nJavaScript\n````\n// Javascript Function to remove the last node of the linked list\nfunction removeLastNode(head) {\n    // If the list is empty, return null\n    if (head === null)\n        return null;\n\n    // If the list has only one node, delete it\n    // and return null\n    if (head.next === null) {\n        head = null;\n        return null;\n    }\n\n    // Find the second last node\n    let second_last = head;\n    while (second_last.next.next !== null)\n        second_last = second_last.next;\n\n    // Remove the last node\n    second_last.next = null;\n\n    // Return the modified list\n    return head;\n}\n\n````\n\n\n\n\n### c. [Deletion at a Specific Position of Singly Linked List:](https://www.geeksforgeeks.org/delete-a-linked-list-node-at-a-given-position)\n\nTo delete a node at a specific position, traverse the list to the\ndesired position, update the links to bypass the node to be\ndeleted.\n\n![Deletion-specific-At-End--](https://media.geeksforgeeks.org/wp-content/uploads/20241022164248836160/Deletion-specific-At-End--.webp)\n\nDelete a Linked List node at a given position\n\n\nStep-by-step approach:\n\n* Check if the list is empty or the position is invalid, return if\n  so.\n* If the head needs to be deleted, update the head and delete the\n  node.\n* Traverse to the node before the position to be deleted.\n* If the position is out of range, return.\n* Store the node to be deleted.\n* Update the links to bypass the node.\n* Delete the stored node.\n\nBelow is the function for deletion at a specific position of singly\nlinked list:\n\nC++\n````\n// C++ function to delete a node at a specific position\nNode* deleteAtPosition(Node* head, int position)\n{\n    // If the list is empty or the position is invalid\n    if (head == nullptr || position < 1) {\n        return head;\n    }\n\n    // If the head needs to be deleted\n    if (position == 1) {\n        Node* temp = head;\n        head = head->next;\n        delete temp;\n        return head;\n    }\n\n    // Traverse to the node before the position to be\n    // deleted\n    Node* current = head;\n    for (int i = 1; i < position - 1 && current != nullptr;\n         i++) {\n        current = current->next;\n    }\n\n    // If the position is out of range\n    if (current == NULL || current->next == nullptr) {\n        return;\n    }\n\n    // Store the node to be deleted\n    Node* temp = current->next;\n\n    // Update the links to bypass the node to be deleted\n    current->next = current->next->next;\n\n    // Delete the node\n    delete temp;\n\n    return head;\n}\n\n````\n\nC\n````\n// Function to delete a node at a specific position\nstruct Node* deleteAtPosition(struct Node* head, int position)\n{\n    // If the list is empty or the position is invalid\n    if (head == NULL || position < 1) {\n        return head;\n    }\n\n    // If the head needs to be deleted\n    if (position == 1) {\n        struct Node* temp = head;\n        head = head->next;\n        free(temp);\n        return head;\n    }\n\n    // Traverse to the node before the position to be deleted\n    struct Node* curr = head;\n    for (int i = 1; i < position - 1 && curr != NULL; i++) {\n        curr = curr->next;\n    }\n\n    // If the position is out of range\n    if (curr == NULL || curr->next == NULL) {\n        return head;\n    }\n\n    // Store the node to be deleted\n    struct Node* temp = curr->next;\n\n    // Update the links to bypass the node to be deleted\n    curr->next = curr->next->next;\n\n    // Delete the node\n    free(temp);\n\n    return head;\n}\n\n````\n\nJava\n````\n// Java function to delete a node at a specific position\npublic void deleteAtPosition(Node head, int position)\n{\n    // If the list is empty or the position is invalid\n    if (head == null || position < 1) {\n        return;\n    }\n\n    // If the head needs to be deleted\n    if (position == 1) {\n        Node temp = head;\n        head = head.next;\n        temp = null;\n        return;\n    }\n\n    // Traverse to the node before the position to be\n    // deleted\n    Node current = head;\n    for (int i = 1; i < position - 1 && current != null;\n         i++) {\n        current = current.next;\n    }\n\n    // If the position is out of range\n    if (current == null || current.next == null) {\n        return;\n    }\n\n    // Store the node to be deleted\n    Node temp = current.next;\n\n    // Update the links to bypass the node to be deleted\n    current.next = current.next.next;\n\n    // Delete the node\n    temp = null;\n}\n\n````\n\nPython\n````\n# Python function to delete a node at a specific position\ndef delete_at_position(head, position):\n    # If the list is empty or the position is invalid\n    if head is None or position < 1:\n        return head\n\n    # If the head needs to be deleted\n    if position == 1:\n        temp = head\n        head = head.next\n        temp = None\n        return head\n\n    # Traverse to the node before the position to be deleted\n    current = head\n    for i in range(1, position - 1):\n        if current is not None:\n            current = current.next\n\n    # If the position is out of range\n    if current is None or current.next is None:\n        return head\n\n    # Store the node to be deleted\n    temp = current.next\n\n    # Update the links to bypass the node to be deleted\n    current.next = current.next.next\n\n    # Delete the node\n    temp = None\n    return head\n\n````\n\nJavaScript\n````\n// Javascript function to delete a node at a specific position\nfunction deleteAtPosition(head, position) {\n    // If the list is empty or the position is invalid\n    if (head === null || position < 1) {\n        return head;\n    }\n\n    // If the head needs to be deleted\n    if (position === 1) {\n        let temp = head;\n        head = head.next;\n        temp = null;\n        return head;\n    }\n\n    // Traverse to the node before the position to be deleted\n    let current = head;\n    for (let i = 1; i < position - 1 && current !== null; i++) {\n        current = current.next;\n    }\n\n    // If the position is out of range\n    if (current === null || current.next === null) {\n        return head;\n    }\n\n    // Store the node to be deleted\n    let temp = current.next;\n\n    // Update the links to bypass the node to be deleted\n    current.next = current.next.next;\n\n    // Delete the node\n    temp = null;\n    return head;\n}\n\n````\n\n\n",
        "metadata": {
            "lesson_id": "fe47d547-098c-4d93-a52b-09f5533ea97c",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "A singly linked list is a fundamental data structure, it consists of nodes where each node contains a data field and a reference to the next node in the linked list. The next of the last node is null, indicating the end of the list. Linked Lists support efficient\ninsertion and deletion operations.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "What is a Circular Linked List?\n-------------------------------\n\nA ****circular linked list****\nis a special type of linked list where all the nodes are connected to\nform a circle. Unlike a regular linked list, which ends with a node\npointing to ****NULL****, the last node in a circular linked list points back to the first\nnode. This means that you can keep traversing the list without ever\nreaching a ****NULL**** value.\n\nTypes of Circular Linked Lists\n------------------------------\n\nWe can create a circular linked list from both [singly linked lists](https://www.geeksforgeeks.org/introduction-to-singly-linked-list/) and [doubly linked lists](https://www.geeksforgeeks.org/doubly-linked-list-tutorial-2/). So, circular linked list are basically of two types:\n\n### 1. Circular Singly Linked List\n\nIn ****Circular Singly Linked List****, each node has just one pointer called the \u201c****next****\u201d pointer. The next pointer of ****last node**** points back to the ****first node**** and this results in forming a circle. In this type of Linked list we\ncan only move through the list in one direction.\n\n![Representation-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806130914/Representation-of-circular-linked-list.webp)\n\nRepresentation of Circular Singly Linked List\n\n### 2. Circular Doubly Linked List:\n\nIn ****circular doubly linked**** ****list,**** each node has two pointers ****prev**** and ****next,**** similar to doubly linked list. The ****prev**** pointer points to the previous node and the ****next**** points to the next node. Here, in addition to the ****last**** node storing the address of the first node, the ****first node**** will also store the address of the ****last node****.\n\n![Representation-of-circular-doubly-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806145223/Representation-of-circular-doubly-linked-list.webp)\n\nRepresentation of Circular Doubly Linked List\n\n****Note:**** In this article, we will use the circular singly linked list to explain\nthe working of circular linked lists.\n\nRepresentation of a Circular Singly Linked List\n-----------------------------------------------\n\nLet\u2019s take a look on the structure of a circular linked list.\n\n\n\n![Node-structure-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806145414/Node-structure-of-circular-linked-list.webp)\n\nRepresentation of a Circular Singly Linked List\n\n### Create/Declare a Node of Circular Linked List\n\nSyntax to Declare a Circular Linked List in Different Languages:\n\n\nC++\n````\n// Node structure\nstruct Node {\n    int data;\n    Node* next;\n\n    Node(int value){\n        data = value;\n        next = nullptr;\n    }\n};\n\n````\n\nC\n````\n// Node structure\nstruct Node\n{\n    int data;\n    struct Node *next;\n};\n\n// Function to create a new node\nstruct Node *createNode(int value){\n\n    // Allocate memory\n    struct Node *newNode =\n      (struct Node *)malloc(sizeof(struct Node));\n\n    // Set the data\n    newNode->data = value;\n\n    // Initialize next to NULL\n    newNode->next = NULL;\n\n    // Return the new node\n    return newNode;\n}\n\n````\n\nJava\n````\nclass Node {\n    int data;\n    Node next;\n\n    Node(int data)\n    {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n````\n\nPython\n````\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n````\n\nC#\n````\npublic class Node {\n    public int data;\n    public Node next;\n\n    public Node(int data){\n        this.data = data;\n        this.next = null;\n    }\n}\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(data)\n    {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n````\n\n\n\n\n\n\n\nIn the code above, each node has ****data**** and a ****pointer**** to the next node. When we create multiple nodes for a circular linked\nlist, we only need to connect the last node back to the first one.\n\nExample of Creating a Circular Linked List\n------------------------------------------\n\nHere\u2019s an example of creating a circular linked list with three nodes\n(2, 3, 4):\n\n![Circular-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240806111438/Circular-Linked-List.png)\n\nCreated a circular linked list with 3 nodes\n\n\nC++\n````\n// Initilize and allocate memory for nodes\nfirst = new Node(2);\nsecond = new Node(3);\nlast = new Node(4);\n\n// Connect nodes\nfirst->next = second;\nsecond->next = last;\n\n// Connect last node to first node\nlast->next = first;\n\n````\n\nC\n````\n// Allocate memory for nodes\nstruct Node *first =\n  (struct Node *)malloc(sizeof(struct Node));\nstruct Node *second =\n  (struct Node *)malloc(sizeof(struct Node));\nstruct Node *last =\n  (struct Node *)malloc(sizeof(struct Node));\n\n// Initilize nodes\nfirst->data = 2;\nsecond->data = 3;\nlast->data = 4;\n\n// Connect nodes\nfirst->next = second;\nsecond->next = last;\nlast->next = first;\n\n````\n\nJava\n````\n// Initilize and allocate memory for nodes\nNode first = new Node(2);\nNode second = new Node(3);\nNode last = new Node(4);\n\n// Connect nodes\nfirst.next = second;\nsecond.next = last;\nlast.next = first;\n\n````\n\nPython\n````\n# Initilize and allocate memory for nodes\nfirst = Node(2)\nsecond = Node(3)\nlast = Node(4)\n\n# Connect nodes\nfirst.next = second\nsecond.next = last\nlast.next = first\n\n````\n\nC#\n````\n// Initilize and allocate memory for nodes\nNode first = new Node(2);\nNode second = new Node(3);\nNode last = new Node(4);\n\n// Connect nodes\nfirst.next = second;\nsecond.next = last;\nlast.next = first;\n\n````\n\nJavaScript\n````\n// Initilize and allocate memory for nodes\nlet first = new Node(2);\nlet second = new Node(3);\nlet last = new Node(4);\n\n// Connect nodes\nfirst.next = second;\nsecond.next = last;\nlast.next = first;\n\n````\n\n\n\n\n\nIn the above code, we have created three nodes ****first, second,**** and ****last**** having values ****2, 3,**** and ****4**** respectively.\n\n* After creating three nodes, we have connected these node in a\n  series.\n* Connect the first node \u201c****first\u201d**** to \u201c****second\u201d**** node by ****s****toring the address of \u201c****second\u201d**** nodeinto ****first\u2019s**** next\n* Connect the second node \u201c****second\u201d**** to \u201c****second\u201d**** node by ****s****toring the address of \u201c****third****\u201d node into ****second\u2019s**** next\n* After connecting all the nodes, we reach the key characteristic of a\n  circular linked list: linking the last node back to the first node. Therefore, we store the address of the \u201c****first****\u201d node in the \u201c****last****\u201d node.\n\n### Why have we taken a pointer that points to the last node instead of the first node?\n\nFor the insertion of a node at the beginning, we need to traverse the\nwhole list. Also, for insertion at the end, the whole list has to be\ntraversed. If instead of the start pointer, we take a pointer to the\nlast node, then in both cases there won\u2019t be any need to traverse the\nwhole list. So insertion at the beginning or at the end takes constant\ntime, irrespective of the length of the list.\n\nOperations on the Circular Linked list:\n---------------------------------------\n\nWe can do some operations on the circular linked list similar to the\nsingly and doubly linked list which are:\n\n* ****Insertion****\n  + Insertion at the empty list\n  + Insertion at the beginning\n  + Insertion at the end\n  + Insertion at the given position\n* ****Deletion****\n  + Delete the first node\n  + Delete the last node\n  + Delete the node from any position\n* ****Searching****\n\n****Note:**** We will be using the circular singly linked list to represent the\nworking of the circular linked list.\n\n[Insertion in the circular linked list:](https://www.geeksforgeeks.org/circular-singly-linked-list-insertion/)\n--------------------------------------------------------------------------------------------------------------\n\nInsertion is a fundamental operation in linked lists that involves\nadding a new node to the list. The only extra step is connecting the\nlast node to the first one. In the circular linked list mentioned below,\nwe can insert nodes in four ways:\n\n### 1. Insertion in an empty List in the circular linked list\n\n> To insert a node in empty circular linked list, creates a ****new node**** with the given data, sets its next pointer to point to itself, and\n> updates the ****last**** pointer to reference this ****new node****.\n\n![Insertion-in-an-empty-list-in-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806193408/Insertion-in-an-empty-list-in-circular-linked-list.webp)\n\nInsertion in an empty List\n\n\nC++\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node{\n    int data;\n    Node *next;\n    Node(int value){\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to insert a node into an empty circular singly linked list\nNode *insertInEmptyList(Node *last, int data){\n    if (last != nullptr) return last;\n\n    // Create a new node\n    Node *newNode = new Node(data);\n\n    // Point newNode to itself\n    newNode->next = newNode;\n\n    // Update last to point to the new node\n    last = newNode;\n    return last;\n}\n\nvoid printList(Node* last){\n    if(last == NULL) return;\n\n    // Start from the head node\n    Node* head = last->next;\n    while (true) {\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next) break;\n    }\n    cout << endl;\n}\n\nint main(){\n    Node *last = nullptr;\n\n    // Insert a node into the empty list\n    last = insertInEmptyList(last, 1);\n\n    // Print the list\n    cout << \"List after insertion: \";\n    printList(last);\n\n    return 0;\n}\n\n````\n\nC\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the Node structure\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* createNode(int value);\n\n// Function to insert a node into an empty\n// circular singly linked list\nstruct Node* insertInEmptyList(struct Node* last, int data) {\n    if (last != NULL) return last;\n\n    // Create a new node\n    struct Node* newNode = createNode(data);\n\n    // Update last to point to the new node\n    last = newNode;\n    return last;\n}\n\nvoid printList(struct Node* last) {\n    if (last == NULL) return;\n\n    // Start from the head node\n    struct Node* head = last->next;\n    while (1) {\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next) break;\n    }\n    printf(\"\\n\");\n}\n\nstruct Node* createNode(int value) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = newNode;\n    return newNode;\n}\n\nint main() {\n    struct Node* last = NULL;\n\n    // Insert a node into the empty list\n    last = insertInEmptyList(last, 1);\n\n    // Print the list\n    printf(\"List after insertion: \");\n    printList(last);\n\n    return 0;\n}\n\n````\n\nJava\n````\nclass Node {\n    int data;\n    Node next;\n\n    Node(int value) {\n        data = value;\n        next = null;\n    }\n}\n\npublic class Main {\n    // Function to insert a node into an empty\n    // circular singly linked list\n    static Node insertInEmptyList(Node last, int data) {\n        if (last != null) return last;\n\n        // Create a new node\n        Node newNode = new Node(data);\n\n        // Point newNode to itself\n        newNode.next = newNode;\n\n        // Update last to point to the new node\n        last = newNode;\n        return last;\n    }\n\n    // Function to print the list\n    static void printList(Node last) {\n        if (last == null) return;\n\n        // Start from the head node\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next) break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        Node last = null;\n\n        // Insert a node into the empty list\n        last = insertInEmptyList(last, 1);\n\n        // Print the list\n        System.out.print(\"List after insertion: \");\n        printList(last);\n    }\n}\n\n````\n\nPython\n````\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = self  # Point to itself\n\ndef insertInEmptyList(last, data):\n    if last is not None:\n        return last\n\n    # Create a new node\n    new_node = Node(data)\n\n    # Update last to point to the new node\n    last = new_node\n    return last\n\ndef printList(last):\n    if last is None:\n        return\n\n    # Start from the head node\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\nif __name__ == \"__main__\":\n    last = None\n\n    # Insert a node into the empty list\n    last = insertInEmptyList(last, 1)\n\n    # Print the list\n    print(\"List after insertion: \", end=\"\")\n    printList(last)\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(value)\n    {\n        this.data = value;\n        this.next = null;\n    }\n}\n\nfunction insertInEmptyList(last, data)\n{\n    if (last !== null)\n        return last;\n\n    // Create a new node\n    let newNode = new Node(data);\n\n    // Point newNode to itself\n    newNode.next = newNode;\n\n    // Update last to point to the new node\n    last = newNode;\n    return last;\n}\n\nfunction printList(last)\n{\n    if (last === null)\n        return;\n\n    // Start from the head node\n    let head = last.next;\n    while (true) {\n        console.log(head.data);\n        head = head.next;\n        if (head === last.next)\n            break;\n    }\n}\n\n// Main function\n\nlet last = null;\n\n// Insert a node into the empty list\nlast = insertInEmptyList(last, 1);\n\n// Print the list\nconsole.log(\"List after insertion:\");\nprintList(last);\n\n````\n\n\n\n\n**Output**\n```\n\nList after insertion: 1\n\n```\n### 2. Insertion at the beginning in circular linked list\n\n> To insert a new node at the beginning of a circular linked list, we\n> first create the ****new node****\n> and allocate memory for it. If the list is empty (indicated by the\n> last pointer being ****NULL****), we make the ****new node****\n> point to itself. If the list already contains nodes then we set the ****new node\u2019s**** next pointer to point to the ****current head**** of the list (which is ****last->next****), and then update the last node\u2019s next pointer to point to the ****new node****. This maintains the circular structure of the list.\n\n![Insertion-at-the-beginning-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150314/Insertion-at-the-beginning-of-circular-linked-list.webp)\n\nInsertion at the beginning in circular linked list\n\n\nC++\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n\n    Node(int value)\n    {\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to insert a node at the beginning of the\n// circular linked list\nNode* insertAtBeginning(Node* last, int value){\n    // Allocate memory for the new node and set its data\n    Node* newNode = new Node(value);\n\n    // If the list is empty, make the new node point to\n    // itself and set it as last\n    if (last == nullptr) {\n        newNode->next = newNode;\n        return newNode;\n    }\n\n    // Insert the new node at the beginning\n    newNode->next = last->next;\n    last->next = newNode;\n\n    return last;\n}\n\nvoid printList(Node* last){\n  if(last == NULL) return;\n\n    // Start from the head node\n    Node* head = last->next;\n    while (true) {\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next)\n            break;\n    }\n    cout << endl;\n}\n\nint main(){\n\n    // Create circular linked list: 2, 3, 4\n    Node* first = new Node(2);\n    first->next = new Node(3);\n    first->next->next = new Node(4);\n\n    Node* last = first->next->next;\n    last->next = first;\n\n    cout << \"Original list: \";\n    printList(last);\n\n    // Insert 5 at the beginning\n    last = insertAtBeginning(last, 5);\n\n    cout << \"List after inserting 5 at the beginning: \";\n    printList(last);\n\n    return 0;\n}\n\n````\n\nC\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the Node structure\nstruct Node\n{\n    int data;\n    struct Node *next;\n};\n\n// Function to create a new node\nstruct Node *createNode(int value)\n{\n    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// Function to insert a node at the beginning\n// of the circular linked list\nstruct Node *insertAtBeginning(struct Node *last, int value)\n{\n    struct Node *newNode = createNode(value);\n\n    // If the list is empty, make the new node point to itself\n    // and set it as last\n    if (last == NULL)\n    {\n        newNode->next = newNode;\n        return newNode;\n    }\n\n    // Insert the new node at the beginning\n    newNode->next = last->next;\n    last->next = newNode;\n\n    return last;\n}\n\nvoid printList(struct Node *last)\n{\n    if (last == NULL) return;\n\n    struct Node *head = last->next;\n    while (1){\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next)\n            break;\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    // Create circular linked list: 2, 3, 4\n    struct Node *first = createNode(2);\n    first->next = createNode(3);\n    first->next->next = createNode(4);\n    struct Node *last = first->next->next;\n    last->next = first;\n\n    printf(\"Original list: \");\n    printList(last);\n\n    // Insert 5 at the beginning\n    last = insertAtBeginning(last, 5);\n\n    printf(\"List after inserting 5 at the beginning: \");\n    printList(last);\n\n    return 0;\n}\n\n````\n\nJava\n````\nclass Node {\n    int data;\n    Node next;\n\n    Node(int value){\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n\n    // Function to insert a node at the beginning of the\n    // circular linked list\n    public static Node insertAtBeginning(Node last,\n                                         int value){\n        Node newNode = new Node(value);\n\n        // If the list is empty, make the new node point to\n        // itself and set it as last\n        if (last == null) {\n            newNode.next = newNode;\n            return newNode;\n        }\n\n        // Insert the new node at the beginning\n        newNode.next = last.next;\n        last.next = newNode;\n\n        return last;\n    }\n\n    // Function to print the circular linked list\n    public static void printList(Node last){\n        if (last == null)\n            return;\n\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next) break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args){\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n        Node last = first.next.next;\n        last.next = first;\n\n        System.out.print(\"Original list: \");\n        printList(last);\n\n        // Insert 5 at the beginning\n        last = insertAtBeginning(last, 5);\n\n        System.out.print(\n            \"List after inserting 5 at the beginning: \");\n        printList(last);\n    }\n}\n\n````\n\nPython\n````\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n# Function to insert a node at the beginning of the circular linked list\ndef insert_at_beginning(last, value):\n    new_node = Node(value)\n\n    # If the list is empty, make the new node point to itself and set it as last\n    if last is None:\n        new_node.next = new_node\n        return new_node\n\n    # Insert the new node at the beginning\n    new_node.next = last.next\n    last.next = new_node\n\n    return last\n\n# Function to print the circular linked list\ndef print_list(last):\n    if last is None:\n        return\n\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\n# Create circular linked list: 2, 3, 4\nfirst = Node(2)\nfirst.next = Node(3)\nfirst.next.next = Node(4)\nlast = first.next.next\nlast.next = first\n\nprint(\"Original list: \", end=\"\")\nprint_list(last)\n\n# Insert 5 at the beginning\nlast = insert_at_beginning(last, 5)\n\nprint(\"List after inserting 5 at the beginning: \", end=\"\")\nprint_list(last)\n\n````\n\nC#\n````\nusing System;\n\npublic class Node\n{\n    public int data;\n    public Node next;\n\n    public Node(int value)\n    {\n        data = value;\n        next = null;\n    }\n}\n\npublic class CircularLinkedList\n{\n    // Function to insert a node at the beginning of the circular linked list\n    public static Node InsertAtBeginning(Node last, int value)\n    {\n        Node newNode = new Node(value);\n\n        // If the list is empty, make the new node point to itself and set it as last\n        if (last == null)\n        {\n            newNode.next = newNode;\n            return newNode;\n        }\n\n        // Insert the new node at the beginning\n        newNode.next = last.next;\n        last.next = newNode;\n\n        return last;\n    }\n\n    // Function to print the circular linked list\n    public static void PrintList(Node last)\n    {\n        if (last == null)\n            return;\n\n        Node head = last.next;\n        while (true)\n        {\n            Console.Write(head.data + \" \");\n            head = head.next;\n            if (head == last.next)\n                break;\n        }\n        Console.WriteLine();\n    }\n\n    public static void Main(string[] args)\n    {\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n        Node last = first.next.next;\n        last.next = first;\n\n        Console.Write(\"Original list: \");\n        PrintList(last);\n\n        // Insert 5 at the beginning\n        last = InsertAtBeginning(last, 5);\n\n        Console.Write(\"List after inserting 5 at the beginning: \");\n        PrintList(last);\n    }\n}\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(data)\n    {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// Function to insert a node at the beginning of the\n// circular linked list\nfunction insertAtBeginning(last, value)\n{\n    const newNode = new Node(value);\n\n    // If the list is empty, make the new node point to\n    // itself and set it as last\n    if (last === null) {\n        newNode.next = newNode;\n        return newNode;\n    }\n\n    // Insert the new node at the beginning\n    newNode.next = last.next;\n    last.next = newNode;\n\n    return last;\n}\n\n// Function to print the circular linked list\nfunction printList(last)\n{\n    if (last === null)\n        return;\n\n    let head = last.next;\n    while (true) {\n        console.log(head.data + \" \");\n        head = head.next;\n        if (head === last.next)\n            break;\n    }\n    console.log();\n}\n\n// Create circular linked list: 2, 3, 4\nconst first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\nlet last\n    = first.next.next; // Using let to allow reassignment\nlast.next = first;\n\nconsole.log(\"Original list: \");\nprintList(last);\n\n// Insert 5 at the beginning\nlast = insertAtBeginning(last, 5);\n\nconsole.log(\"List after inserting 5 at the beginning: \");\nprintList(last);\n\n````\n\n\n\n\n\n**Output**\n```\n\nOriginal list: 2 3 4\nList after inserting 5 at the beginning: 5 2 3 4\n\n```\n### 3. Insertion at the end in circular linked list\n\n> To insert a new node at the end of a circular linked list, we first\n> create the new node and allocate memory for it. If the list is empty\n> (mean, ****last**** or ****tail**** pointer being ****NULL****), we initialize the list with the ****new node**** and making it point to itself to form a circular structure. If the\n> list already contains nodes then we set the ****new node\u2019s**** next pointer to point to the ****current head**** (which is ****tail->next****), then update the ****current tail\u2019s**** next pointer to point to the ****new node****. Finally, we update the ****tail pointer**** to the ****new node.**** This will ensure that the ****new node**** is now the ****last node**** in the list while maintaining the circular linkage.\n\n![Insertion-at-the-end-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150353/Insertion-at-the-end-of-circular-linked-list.webp)\n\nInsertion at the end in circular linked list\n\n\nC++\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node{\n    int data;\n    Node *next;\n    Node(int value)\n    {\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to insert a node at the end of a circular linked list\nNode *insertEnd(Node *tail, int value)\n{\n    Node *newNode = new Node(value);\n    if (tail == nullptr){\n        // If the list is empty, initialize it with the new node\n        tail = newNode;\n\n        // Point to itself to form a circular structure\n        newNode->next = newNode;\n    }\n    else{\n        // Insert new node after the current tail\n        // and update the tail pointer.\n        // New node points to the head node\n        newNode->next = tail->next;\n\n        // Tail node points to the new node\n        tail->next = newNode;\n\n        // Update tail to be the new node\n        tail = newNode;\n    }\n    return tail;\n}\n\nvoid printList(Node *last){\n  if(last == NULL) return;\n\n    // Start from the head node\n    Node *head = last->next;\n    while (true){\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next)\n            break;\n    }\n    cout << endl;\n}\n\nint main(){\n    // Create circular linked list: 2, 3, 4\n    Node *first = new Node(2);\n    first->next = new Node(3);\n    first->next->next = new Node(4);\n\n    Node *last = first->next->next;\n    last->next = first;\n\n    cout << \"Original list: \";\n    printList(last);\n\n    // Insert elements at the end of the circular linked list\n    last = insertEnd(last, 5);\n    last = insertEnd(last, 6);\n\n    cout << \"List after inserting 5 and 6: \";\n    printList(last);\n\n    return 0;\n}\n\n````\n\nC\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the Node structure\nstruct Node\n{\n    int data;\n    struct Node *next;\n};\n\n// Function to create a new node\nstruct Node *createNode(int value);\n\n// Function to insert a node at the end of a circular linked list\nstruct Node *insertEnd(struct Node *tail, int value)\n{\n    struct Node *newNode = createNode(value);\n    if (tail == NULL)\n    {\n        // If the list is empty, initialize it with the new node\n        tail = newNode;\n        newNode->next = newNode;\n    }\n    else\n    {\n        // Insert new node after the current tail and update the tail pointer\n        newNode->next = tail->next;\n        tail->next = newNode;\n        tail = newNode;\n    }\n    return tail;\n}\n\n// Function to print the circular linked list\nvoid printList(struct Node *last)\n{\n    if (last == NULL)\n        return;\n\n    struct Node *head = last->next;\n    while (1)\n    {\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next)\n            break;\n    }\n    printf(\"\\n\");\n}\n\nstruct Node *createNode(int value)\n{\n    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main()\n{\n    // Create circular linked list: 2, 3, 4\n    struct Node *first = createNode(2);\n    first->next = createNode(3);\n    first->next->next = createNode(4);\n\n    struct Node *last = first->next->next;\n    last->next = first;\n\n    printf(\"Original list: \");\n    printList(last);\n\n    // Insert elements at the end of the circular linked list\n    last = insertEnd(last, 5);\n    last = insertEnd(last, 6);\n\n    printf(\"List after inserting 5 and 6: \");\n    printList(last);\n\n    return 0;\n}\n\n````\n\nJava\n````\nclass Node {\n    int data;\n    Node next;\n\n    Node(int value){\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n\n    // Function to insert a node at the end of a circular\n    // linked list\n    static Node insertEnd(Node tail, int value){\n        Node newNode = new Node(value);\n        if (tail == null) {\n            // If the list is empty, initialize it with the\n            // new node\n            tail = newNode;\n            newNode.next = newNode;\n        }\n        else {\n            // Insert new node after the current tail and\n            // update the tail pointer\n            newNode.next = tail.next;\n            tail.next = newNode;\n            tail = newNode;\n        }\n        return tail;\n    }\n\n    // Function to print the circular linked list\n    static void printList(Node last){\n        if (last == null) return;\n\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next) break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args){\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n\n        Node last = first.next.next;\n        last.next = first;\n\n        System.out.print(\"Original list: \");\n        printList(last);\n\n        // Insert elements at the end of the circular linked\n        // list\n        last = insertEnd(last, 5);\n        last = insertEnd(last, 6);\n\n        System.out.print(\"List after inserting 5 and 6: \");\n        printList(last);\n    }\n}\n\n````\n\nPython\n````\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\n# Function to insert a node at the end of a circular linked list\n\n\ndef insert_end(tail, value):\n    new_node = Node(value)\n    if tail is None:\n        # If the list is empty, initialize\n        # it with the new node\n        tail = new_node\n        new_node.next = new_node\n    else:\n        # Insert new node after the current tail\n        # and update the tail pointer\n        new_node.next = tail.next\n        tail.next = new_node\n        tail = new_node\n    return tail\n\n# Function to print the circular linked list\n\n\ndef print_list(last):\n    if last is None:\n        return\n\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\n\nif __name__ == \"__main__\":\n    # Create circular linked list: 2, 3, 4\n    first = Node(2)\n    first.next = Node(3)\n    first.next.next = Node(4)\n\n    last = first.next.next\n    last.next = first\n\n    print(\"Original list: \", end=\"\")\n    print_list(last)\n\n    # Insert elements at the end of the circular linked list\n    last = insert_end(last, 5)\n    last = insert_end(last, 6)\n\n    print(\"List after inserting 5 and 6: \", end=\"\")\n    print_list(last)\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(value){\n        this.data = value;\n        this.next = null;\n    }\n}\n\n// Function to insert a node at the end of a circular linked\n// list\nfunction insertEnd(tail, value){\n    let newNode = new Node(value);\n    if (tail === null) {\n        // If the list is empty, initialize it with the new\n        // node\n        tail = newNode;\n        newNode.next = newNode;\n    }\n    else {\n        // Insert new node after the current tail and update\n        // the tail pointer\n        newNode.next = tail.next;\n        tail.next = newNode;\n        tail = newNode;\n    }\n    return tail;\n}\n\n// Function to print the circular linked list\nfunction printList(last)\n{\n    if (last === null)\n        return;\n\n    let head = last.next;\n    while (true) {\n        console.log(head.data + \" \");\n        head = head.next;\n        if (head === last.next)\n            break;\n    }\n    console.log();\n}\n\n// Create circular linked list: 2, 3, 4\nlet first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\n\nlet last = first.next.next;\nlast.next = first;\n\nconsole.log(\"Original list: \");\nprintList(last);\n\n// Insert elements at the end of the circular linked\n// list\nlast = insertEnd(last, 5);\nlast = insertEnd(last, 6);\n\nconsole.log(\"List after inserting 5 and 6: \");\nprintList(last);\n\n````\n\n**Output**\n```\n\nOriginal list: 2 3 4\nList after inserting 5 and 6: 2 3 4 5 6\n\n```\n### 4. Insertion at specific position in circular linked list\n\n> To insert a new node at a specific position in a circular linked\n> list, we first check if the list is empty. If it is and the ****position**** is not ****1****\n> then we print an error message because the position doesn\u2019t exist in\n> the list. If the ****position**** is ****1**** then we create the ****new node**** and make it point to itself. If the list is not empty, we create the ****new node**** and traverse the list to find the correct insertion point. If the ****position**** is ****1****, we insert the ****new node****\n> at the beginning by adjusting the pointers accordingly. For other\n> positions, we traverse through the list until we reach the desired\n> position and inserting the ****new node****\n> by updating the pointers. If the new node is inserted at the end, we\n> also update the ****last****\n> pointer to reference the new node, maintaining the circular structure\n> of the list.\n\n![Insertion-at-specific-position-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150431/Insertion-at-specific-position-of-circular-linked-list.webp)\n\nInsertion at specific position in circular linked list\n\n\nC++\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node{\n    int data;\n    Node *next;\n    Node(int value){\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to insert a node at a specific position in a circular linked list\nNode *insertAtPosition(Node *last, int data, int pos){\n    if (last == nullptr){\n        // If the list is empty\n        if (pos != 1){\n            cout << \"Invalid position!\" << endl;\n            return last;\n        }\n        // Create a new node and make it point to itself\n        Node *newNode = new Node(data);\n        last = newNode;\n        last->next = last;\n        return last;\n    }\n\n    // Create a new node with the given data\n    Node *newNode = new Node(data);\n\n    // curr will point to head initially\n    Node *curr = last->next;\n\n    if (pos == 1){\n        // Insert at the beginning\n        newNode->next = curr;\n        last->next = newNode;\n        return last;\n    }\n\n    // Traverse the list to find the insertion point\n    for (int i = 1; i < pos - 1; ++i) {\n        curr = curr->next;\n\n        // If position is out of bounds\n        if (curr == last->next){\n            cout << \"Invalid position!\" << endl;\n            return last;\n        }\n    }\n    // Insert the new node at the desired position\n    newNode->next = curr->next;\n    curr->next = newNode;\n\n    // Update last if the new node is inserted at the end\n    if (curr == last) last = newNode;\n\n    return last;\n}\n\nvoid printList(Node *last){\n    if (last == NULL) return;\n\n    Node *head = last->next;\n    while (true){\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next) break;\n    }\n    cout << endl;\n}\n\nint main(){\n    // Create circular linked list: 2, 3, 4\n    Node *first = new Node(2);\n    first->next = new Node(3);\n    first->next->next = new Node(4);\n\n    Node *last = first->next->next;\n    last->next = first;\n\n    cout << \"Original list: \";\n    printList(last);\n\n    // Insert elements at specific positions\n    int data = 5, pos = 2;\n    last = insertAtPosition(last, data, pos);\n    cout << \"List after insertions: \";\n    printList(last);\n\n    return 0;\n}\n\n````\n\nC\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the Node structure\nstruct Node {\n    int data;\n    struct Node *next;\n};\n\nstruct Node* createNode(int value);\n\n// Function to insert a node at a specific position in a circular linked list\nstruct Node* insertAtPosition(struct Node *last, int data, int pos) {\n    if (last == NULL) {\n        // If the list is empty\n        if (pos != 1) {\n            printf(\"Invalid position!\\n\");\n            return last;\n        }\n        // Create a new node and make it point to itself\n        struct Node *newNode = createNode(data);\n        last = newNode;\n        last->next = last;\n        return last;\n    }\n\n    // Create a new node with the given data\n    struct Node *newNode = createNode(data);\n\n    // curr will point to head initially\n    struct Node *curr = last->next;\n\n    if (pos == 1) {\n        // Insert at the beginning\n        newNode->next = curr;\n        last->next = newNode;\n        return last;\n    }\n\n    // Traverse the list to find the insertion point\n    for (int i = 1; i < pos - 1; ++i) {\n        curr = curr->next;\n\n        // If position is out of bounds\n        if (curr == last->next) {\n            printf(\"Invalid position!\\n\");\n            return last;\n        }\n    }\n\n    // Insert the new node at the desired position\n    newNode->next = curr->next;\n    curr->next = newNode;\n\n    // Update last if the new node is inserted at the end\n    if (curr == last) last = newNode;\n\n    return last;\n}\n\n// Function to print the circular linked list\nvoid printList(struct Node *last) {\n    if (last == NULL) return;\n\n    struct Node *head = last->next;\n    while (1) {\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next) break;\n    }\n    printf(\"\\n\");\n}\n\n// Function to create a new node\nstruct Node* createNode(int value) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    // Create circular linked list: 2, 3, 4\n    struct Node *first = createNode(2);\n    first->next = createNode(3);\n    first->next->next = createNode(4);\n\n    struct Node *last = first->next->next;\n    last->next = first;\n\n    printf(\"Original list: \");\n    printList(last);\n\n    // Insert elements at specific positions\n    int data = 5, pos = 2;\n    last = insertAtPosition(last, data, pos);\n    printf(\"List after insertions: \");\n    printList(last);\n\n    return 0;\n}\n\n````\n\nJava\n````\nclass Node {\n    int data;\n    Node next;\n\n    Node(int value){\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n\n    // Function to insert a node at a specific position in a\n    // circular linked list\n    static Node insertAtPosition(Node last, int data,\n                                 int pos){\n        if (last == null) {\n            // If the list is empty\n            if (pos != 1) {\n                System.out.println(\"Invalid position!\");\n                return last;\n            }\n            // Create a new node and make it point to itself\n            Node newNode = new Node(data);\n            last = newNode;\n            last.next = last;\n            return last;\n        }\n\n        // Create a new node with the given data\n        Node newNode = new Node(data);\n\n        // curr will point to head initially\n        Node curr = last.next;\n\n        if (pos == 1) {\n            // Insert at the beginning\n            newNode.next = curr;\n            last.next = newNode;\n            return last;\n        }\n\n        // Traverse the list to find the insertion point\n        for (int i = 1; i < pos - 1; ++i) {\n            curr = curr.next;\n\n            // If position is out of bounds\n            if (curr == last.next) {\n                System.out.println(\"Invalid position!\");\n                return last;\n            }\n        }\n\n        // Insert the new node at the desired position\n        newNode.next = curr.next;\n        curr.next = newNode;\n\n        // Update last if the new node is inserted at the\n        // end\n        if (curr == last)\n            last = newNode;\n\n        return last;\n    }\n\n    static void printList(Node last){\n        if (last == null)\n            return;\n\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next)\n                break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args)\n    {\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n\n        Node last = first.next.next;\n        last.next = first;\n\n        System.out.print(\"Original list: \");\n        printList(last);\n\n        // Insert elements at specific positions\n        int data = 5, pos = 2;\n        last = insertAtPosition(last, data, pos);\n        System.out.print(\"List after insertions: \");\n        printList(last);\n    }\n}\n\n````\n\nPython\n````\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\n# Function to insert a node at a specific position in a circular linked list\ndef insertAtPosition(last, data, pos):\n    if last is None:\n        # If the list is empty\n        if pos != 1:\n            print(\"Invalid position!\")\n            return last\n        # Create a new node and make it point to itself\n        new_node = Node(data)\n        last = new_node\n        last.next = last\n        return last\n\n    # Create a new node with the given data\n    new_node = Node(data)\n\n    # curr will point to head initially\n    curr = last.next\n\n    if pos == 1:\n        # Insert at the beginning\n        new_node.next = curr\n        last.next = new_node\n        return last\n\n    # Traverse the list to find the insertion point\n    for i in range(1, pos - 1):\n        curr = curr.next\n\n        # If position is out of bounds\n        if curr == last.next:\n            print(\"Invalid position!\")\n            return last\n\n    # Insert the new node at the desired position\n    new_node.next = curr.next\n    curr.next = new_node\n\n    # Update last if the new node is inserted at the end\n    if curr == last:\n        last = new_node\n\n    return last\n\n# Function to print the circular linked list\ndef print_list(last):\n    if last is None:\n        return\n\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\nif __name__ == \"__main__\":\n    # Create circular linked list: 2, 3, 4\n    first = Node(2)\n    first.next = Node(3)\n    first.next.next = Node(4)\n\n    last = first.next.next\n    last.next = first\n\n    print(\"Original list: \", end=\"\")\n    print_list(last)\n\n    # Insert elements at specific positions\n    data = 5\n    pos = 2\n    last = insertAtPosition(last, data, pos)\n    print(\"List after insertions: \", end=\"\")\n    print_list(last)\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(value){\n        this.data = value;\n        this.next = null;\n    }\n}\n\n// Function to insert a node at a specific position in a\n// circular linked list\nfunction insertAtPosition(last, data, pos)\n{\n    if (last === null) {\n        // If the list is empty\n        if (pos !== 1) {\n            console.log(\"Invalid position!\");\n            return last;\n        }\n        // Create a new node and make it point to itself\n        let newNode = new Node(data);\n        last = newNode;\n        last.next = last;\n        return last;\n    }\n\n    // Create a new node with the given data\n    let newNode = new Node(data);\n\n    // curr will point to head initially\n    let curr = last.next;\n\n    if (pos === 1) {\n        // Insert at the beginning\n        newNode.next = curr;\n        last.next = newNode;\n        return last;\n    }\n\n    // Traverse the list to find the insertion point\n    for (let i = 1; i < pos - 1; ++i) {\n        curr = curr.next;\n\n        // If position is out of bounds\n        if (curr === last.next) {\n            console.log(\"Invalid position!\");\n            return last;\n        }\n    }\n\n    // Insert the new node at the desired position\n    newNode.next = curr.next;\n    curr.next = newNode;\n\n    // Update last if the new node is inserted at the end\n    if (curr === last)\n        last = newNode;\n\n    return last;\n}\n\n// Function to print the circular linked list\nfunction printList(last){\n    if (last === null)\n        return;\n\n    let head = last.next;\n    while (true) {\n        console.log(head.data + \" \");\n        head = head.next;\n        if (head === last.next)\n            break;\n    }\n    console.log();\n}\n\n// Create circular linked list: 2, 3, 4\nlet first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\n\nlet last = first.next.next;\nlast.next = first;\n\nconsole.log(\"Original list: \");\nprintList(last);\n\n// Insert elements at specific positions\nlet data = 5;\nlet pos = 2;\nlast = insertAtPosition(last, data, pos);\nconsole.log(\"List after insertions: \");\nprintList(last);\n\n````\n\n\n**Output**\n```\n\nOriginal list: 2 3 4\nList after insertions: 2 5 3 4\n\n```\n\n[Deletion from a Circular Linked List](https://www.geeksforgeeks.org/deletion-circular-linked-list/?ref=ml_lbp)\n---------------------------------------------------------------------------------------------------------------\n\nDeletion involves removing a node from the linked list. The main\ndifference is that we need to ensure the list remains circular after the\ndeletion. We can delete a node in a circular linked list in three\nways:\n\n### 1. Delete the first node in circular linked list\n\n> To delete the first node of a circular linked list, we first check if\n> the list is empty. If it is then we print a message and return ****NULL****. If the list contains only one node (the ****head**** is the same as the ****last****) then we delete that node and set the ****last**** pointer to ****NULL****. If there are multiple nodes then we update the ****last->next**** pointer to skip the ****head**** node and effectively removing it from the list. We then delete the ****head**** node to free the allocated memory. Finally, we return the updated ****last**** pointer, which still points to the ****last**** node in the list.\n\n![Deletion-from-the-beginning-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150500/Deletion-from-the-beginning-of-circular-linked-list.webp)\n\nDelete the first node in circular linked list\n\n\nC++\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int value) {\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to delete the first node of the circular linked list\nNode* deleteFirstNode(Node* last) {\n    if (last == nullptr) {\n        // If the list is empty\n        cout << \"List is empty\" << endl;\n        return nullptr;\n    }\n\n    Node* head = last->next;\n\n    if (head == last) {\n        // If there is only one node in the list\n        delete head;\n        last = nullptr;\n    } else {\n        // More than one node in the list\n        last->next = head->next;\n        delete head;\n    }\n\n    return last;\n}\n\nvoid printList(Node* last) {\n    if(last == NULL) return ;\n\n    Node *head = last->next;\n    while (true){\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next) break;\n    }\n    cout << endl;\n}\n\nint main() {\n    // Create circular linked list: 2, 3, 4\n    Node* first = new Node(2);\n    first->next = new Node(3);\n    first->next->next = new Node(4);\n\n    Node* last = first->next->next;\n    last->next = first;\n\n    cout << \"Original list: \";\n    printList(last);\n\n    // Delete the first node\n    last = deleteFirstNode(last);\n\n    cout << \"List after deleting first node: \";\n    printList(last);\n\n    return 0;\n}\n\n````\n\nC\n````\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Node* deleteFirstNode(struct Node* last) {\n    if (last == NULL) {\n        // If the list is empty\n        printf(\"List is empty\\n\");\n        return NULL;\n    }\n\n    struct Node* head = last->next;\n\n    if (head == last) {\n        // If there is only one node in the list\n        free(head);\n        last = NULL;\n    } else {\n        // More than one node in the list\n        last->next = head->next;\n        free(head);\n    }\n\n    return last;\n}\n\nvoid printList(struct Node* last) {\n    if (last == NULL) return;\n\n    struct Node* head = last->next;\n    while (1) {\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next) break;\n    }\n    printf(\"\\n\");\n}\n\nstruct Node* createNode(int value) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    struct Node* first = createNode(2);\n    first->next = createNode(3);\n    first->next->next = createNode(4);\n\n    struct Node* last = first->next->next;\n    last->next = first;\n\n    printf(\"Original list: \");\n    printList(last);\n\n    last = deleteFirstNode(last);\n\n    printf(\"List after deleting first node: \");\n    printList(last);\n\n    return 0;\n}\n\n````\n\nJava\n````\nclass Node {\n    int data;\n    Node next;\n\n    Node(int value) {\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n    public static Node deleteFirstNode(Node last) {\n        if (last == null) {\n            // If the list is empty\n            System.out.println(\"List is empty\");\n            return null;\n        }\n\n        Node head = last.next;\n\n        if (head == last) {\n            // If there is only one node in the list\n            last = null;\n        } else {\n            // More than one node in the list\n            last.next = head.next;\n        }\n\n        return last;\n    }\n\n    public static void printList(Node last) {\n        if (last == null) return;\n\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next) break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n\n        Node last = first.next.next;\n        last.next = first;\n\n        System.out.print(\"Original list: \");\n        printList(last);\n\n        // Delete the first node\n        last = deleteFirstNode(last);\n\n        System.out.print(\"List after deleting first node: \");\n        printList(last);\n    }\n}\n\n````\n\nPython\n````\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef deleteFirstNode(last):\n    if last is None:\n        # If the list is empty\n        print(\"List is empty\")\n        return None\n\n    head = last.next\n\n    if head == last:\n        # If there is only one node in the list\n        last = None\n    else:\n        # More than one node in the list\n        last.next = head.next\n\n    return last\n\ndef print_list(last):\n    if last is None:\n        return\n\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\n# Create circular linked list: 2, 3, 4\nfirst = Node(2)\nfirst.next = Node(3)\nfirst.next.next = Node(4)\n\nlast = first.next.next\nlast.next = first\n\nprint(\"Original list: \", end=\"\")\nprint_list(last)\n\n# Delete the first node\nlast = deleteFirstNode(last)\n\nprint(\"List after deleting first node: \", end=\"\")\nprint_list(last)\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nfunction deleteFirstNode(last) {\n    if (last === null) {\n        // If the list is empty\n        console.log(\"List is empty\");\n        return null;\n    }\n\n    let head = last.next;\n\n    if (head === last) {\n        // If there is only one node in the list\n        last = null;\n    } else {\n        // More than one node in the list\n        last.next = head.next;\n    }\n\n    return last;\n}\n\nfunction printList(last) {\n    if (last === null) return;\n\n    let head = last.next;\n    while (true) {\n        console.log(head.data + \" \");\n        head = head.next;\n        if (head === last.next) break;\n    }\n    console.log();\n}\n\n// Create circular linked list: 2, 3, 4\nlet first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\n\nlet last = first.next.next;\nlast.next = first;\n\nconsole.log(\"Original list: \");\nprintList(last);\n\n// Delete the first node\nlast = deleteFirstNode(last);\n\nconsole.log(\"List after deleting first node: \");\nprintList(last);\n\n````\n\n\n\n\n**Output**\n```\n\nOriginal list: 2 3 4\nList after deleting first node: 3 4\n\n```\n### 2. Delete a specific node in circular linked list\n\n> To delete a specific node from a circular linked list, we first check\n> if the list is empty. If it is then we print a message and return ****nullptr****. If the list contains only one node and it matches the ****key**** then we delete that node and set ****last**** to ****nullptr****. If the node to be deleted is the first node then we update\n> the ****next**** pointer of the ****last**** node to skip the ****head**** node and delete the ****head****. For other nodes, we traverse the list using two pointers: ****curr**** (to find the node) and ****prev****\n> (to keep track of the previous node). If we find the node with the\n> matching key then we update the next pointer of ****prev**** to skip the ****curr****\n> node and delete it. If the node is found and it is the last node, we\n> update the ****last****\n> pointer accordingly. If the node is not found then do nothing and ****tail**** or ****last**** as it is. Finally, we return the updated ****last**** pointer.\n\n![Delete-a-specific-node-in-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150531/Delete-a-specific-node-in-circular-linked-list.webp)\n\nDelete a specific node in circular linked list\n\n\nC++\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int value) {\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to delete a specific node in the circular linked list\nNode* deleteSpecificNode(Node* last, int key) {\n    if (last == nullptr) {\n        // If the list is empty\n        cout << \"List is empty, nothing to delete.\" << endl;\n        return nullptr;\n    }\n\n    Node* curr = last->next;\n    Node* prev = last;\n\n    // If the node to be deleted is the only node in the list\n    if (curr == last && curr->data == key) {\n        delete curr;\n        last = nullptr;\n        return last;\n    }\n\n    // If the node to be deleted is the first node\n    if (curr->data == key) {\n        last->next = curr->next;\n        delete curr;\n        return last;\n    }\n\n    // Traverse the list to find the node to be deleted\n    while (curr != last && curr->data != key) {\n        prev = curr;\n        curr = curr->next;\n    }\n\n    // If the node to be deleted is found\n    if (curr->data == key) {\n        prev->next = curr->next;\n        if (curr == last) {\n            last = prev;\n        }\n        delete curr;\n    } else {\n        // If the node to be deleted is not found\n        cout << \"Node with data \" << key\n          << \" not found.\" << endl;\n    }\n\n    return last;\n}\n\n// Function to print the circular linked list\nvoid printList(Node* last) {\n     if (last == NULL){\n        cout << \"List is Empty\";\n        return;\n    }\n\n    Node *head = last->next;\n    while (true){\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next) break;\n    }\n    cout << endl;\n}\n\nint main() {\n    // Create circular linked list: 2, 3, 4\n    Node* first = new Node(2);\n    first->next = new Node(3);\n    first->next->next = new Node(4);\n\n    Node* last = first->next->next;\n    last->next = first;\n\n    cout << \"Original list: \";\n    printList(last);\n\n    // Delete a specific node\n    int key = 3;\n    last = deleteSpecificNode(last, key);\n\n    cout << \"List after deleting node \" << key << \": \";\n    printList(last);\n\n    return 0;\n}\n\n````\n\nC\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the structure for a node in the circular linked list\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to delete a specific node in the circular linked list\nstruct Node* deleteSpecificNode(struct Node* last, int key) {\n    if (last == NULL) {\n        // If the list is empty\n        printf(\"List is empty, nothing to delete.\\n\");\n        return NULL;\n    }\n\n    struct Node* curr = last->next;\n    struct Node* prev = last;\n\n    // If the node to be deleted is the only node in the list\n    if (curr == last && curr->data == key) {\n        free(curr);\n        last = NULL;\n        return last;\n    }\n\n    // If the node to be deleted is the first node\n    if (curr->data == key) {\n        last->next = curr->next;\n        free(curr);\n        return last;\n    }\n\n    // Traverse the list to find the node to be deleted\n    while (curr != last && curr->data != key) {\n        prev = curr;\n        curr = curr->next;\n    }\n\n    // If the node to be deleted is found\n    if (curr->data == key) {\n        prev->next = curr->next;\n        if (curr == last) {\n            last = prev;\n        }\n        free(curr);\n    } else {\n        // If the node to be deleted is not found\n        printf(\"Node with data %d not found.\\n\", key);\n    }\n\n    return last;\n}\n\nvoid printList(struct Node* last) {\n    if (last == NULL) {\n        printf(\"List is Empty\");\n        return;\n    }\n\n    struct Node* head = last->next;\n    while (1) {\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next) break;\n    }\n    printf(\"\\n\");\n}\n\nstruct Node* createNode(int value) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    // Create circular linked list: 2, 3, 4\n    struct Node* first = createNode(2);\n    first->next = createNode(3);\n    first->next->next = createNode(4);\n\n    struct Node* last = first->next->next;\n    last->next = first;\n\n    printf(\"Original list: \");\n    printList(last);\n\n    // Delete a specific node\n    int key = 3;\n    last = deleteSpecificNode(last, key);\n\n    printf(\"List after deleting node %d: \", key);\n    printList(last);\n\n    return 0;\n}\n\n````\n\nJava\n````\nclass Node {\n    int data;\n    Node next;\n    Node(int value){\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n    public static Node deleteSpecificNode(Node last,\n                                          int key){\n        if (last == null) {\n            // If the list is empty\n            System.out.println(\n                \"List is empty, nothing to delete.\");\n            return null;\n        }\n        Node curr = last.next;\n        Node prev = last;\n\n        // If the node to be deleted is the only node in the\n        // list\n        if (curr == last && curr.data == key) {\n            last = null;\n            return last;\n        }\n\n        // If the node to be deleted is the first node\n        if (curr.data == key) {\n            last.next = curr.next;\n            return last;\n        }\n\n        // Traverse the list to find the node to be deleted\n        while (curr != last && curr.data != key) {\n            prev = curr;\n            curr = curr.next;\n        }\n\n        // If the node to be deleted is found\n        if (curr.data == key) {\n            prev.next = curr.next;\n            if (curr == last) {\n                last = prev;\n            }\n        }\n        else {\n            // If the node to be deleted is not found\n            System.out.println(\"Node with data \" + key\n                               + \" not found.\");\n        }\n        return last;\n    }\n\n    public static void printList(Node last){\n        if (last == null) {\n            System.out.println(\"List is Empty\");\n            return;\n        }\n\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next)\n                break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args){\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n\n        Node last = first.next.next;\n        last.next = first;\n\n        System.out.print(\"Original list: \");\n        printList(last);\n\n        // Delete a specific node\n        int key = 3;\n        last = deleteSpecificNode(last, key);\n\n        System.out.print(\"List after deleting node \" + key\n                         + \": \");\n        printList(last);\n    }\n}\n\n````\n\nPython\n````\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef deleteSpecificNode(last, key):\n    if last is None:\n        # If the list is empty\n        print(\"List is empty, nothing to delete.\")\n        return None\n\n    curr = last.next\n    prev = last\n\n    # If the node to be deleted is the only node in the list\n    if curr == last and curr.data == key:\n        last = None\n        return last\n\n    # If the node to be deleted is the first node\n    if curr.data == key:\n        last.next = curr.next\n        return last\n\n    # Traverse the list to find the node to be deleted\n    while curr != last and curr.data != key:\n        prev = curr\n        curr = curr.next\n\n    # If the node to be deleted is found\n    if curr.data == key:\n        prev.next = curr.next\n        if curr == last:\n            last = prev\n    else:\n        # If the node to be deleted is not found\n        print(f\"Node with data {key} not found.\")\n\n    return last\n\ndef printList(last):\n    if last is None:\n        print(\"List is Empty\")\n        return\n\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\n# Create circular linked list: 2, 3, 4\nfirst = Node(2)\nfirst.next = Node(3)\nfirst.next.next = Node(4)\n\nlast = first.next.next\nlast.next = first\n\nprint(\"Original list: \", end=\"\")\nprintList(last)\n\n# Delete a specific node\nkey = 3\nlast = deleteSpecificNode(last, key)\n\nprint(f\"List after deleting node {key}: \", end=\"\")\nprintList(last)\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nfunction deleteSpecificNode(last, key) {\n    if (last === null) {\n        // If the list is empty\n        console.log(\"List is empty, nothing to delete.\");\n        return null;\n    }\n\n    let curr = last.next;\n    let prev = last;\n\n    // If the node to be deleted is the only node in the list\n    if (curr === last && curr.data === key) {\n        last = null;\n        return last;\n    }\n\n    // If the node to be deleted is the first node\n    if (curr.data === key) {\n        last.next = curr.next;\n        return last;\n    }\n\n    // Traverse the list to find the node to be deleted\n    while (curr !== last && curr.data !== key) {\n        prev = curr;\n        curr = curr.next;\n    }\n\n    // If the node to be deleted is found\n    if (curr.data === key) {\n        prev.next = curr.next;\n        if (curr === last) {\n            last = prev;\n        }\n    } else {\n        // If the node to be deleted is not found\n        console.log(\"Node with data \" + key + \" not found.\");\n    }\n\n    return last;\n}\n\nfunction printList(last) {\n    if (last === null) {\n        console.log(\"List is Empty\");\n        return;\n    }\n\n    let head = last.next;\n    while (true) {\n        console.log(head.data + \" \");\n        head = head.next;\n        if (head === last.next) break;\n    }\n    console.log();\n}\n\n// Create circular linked list: 2, 3, 4\nlet first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\n\nlet last = first.next.next;\nlast.next = first;\n\nconsole.log(\"Original list: \");\nprintList(last);\n\n// Delete a specific node\nlet key = 3;\nlast = deleteSpecificNode(last, key);\n\nconsole.log(\"List after deleting node \" + key + \": \");\nprintList(last);\n\n````\n\n\n\n**Output**\n```\n\nOriginal list: 2 3 4\nList after deleting node 3: 2 4\n\n```\n### 3. Deletion at the end of Circular linked list\n\n> To delete the last node in a circular linked list, we first check if\n> the list is empty. If it is, we print a message and return ****nullptr****. If the list contains only one node (where the ****head**** is the same as the ****last****), we delete that node and set ****last**** to ****nullptr****. For lists with multiple nodes, we need to traverse the list to find\n> the ****second last node****. We do this by starting from the ****head**** and moving through the list until we reach the node whose next\n> pointer points to ****last****. Once we find the ****second last**** node then we update its next pointer to point back to the ****head,****\n> this effectively removing the last node from the list. We then delete\n> the last node to free up memory and return the updated ****last**** pointer, which now points to the last node.\n\n![Deletion-at-the-end-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150601/Deletion-at-the-end-of-circular-linked-list.webp)\n\nDeletion at the end of Circular linked list\n\n\nC++\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int value) {\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to delete the last node in the circular linked list\nNode* deleteLastNode(Node* last) {\n    if (last == nullptr) {\n        // If the list is empty\n        cout << \"List is empty, nothing to delete.\" << endl;\n        return nullptr;\n    }\n    Node* head = last->next;\n\n    // If there is only one node in the list\n    if (head == last) {\n        delete last;\n        last = nullptr;\n        return last;\n    }\n    // Traverse the list to find the second last node\n    Node* curr = head;\n    while (curr->next != last) {\n        curr = curr->next;\n    }\n    // Update the second last node's next pointer\n    // to point to head\n    curr->next = head;\ndelete last;\nlast = curr;\n\n    return last;\n}\n\nvoid printList(Node* last) {\n   if(last == NULL) return;\n\n    Node *head = last->next;\n    while (true){\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next) break;\n}\n    cout << endl;\n}\n\nint main() {\n    // Create circular linked list: 2, 3, 4\n    Node* first = new Node(2);\nfirst->next = new Node(3);\nfirst->next->next = new Node(4);\n\n    Node* last = first->next->next;\nlast->next = first;\n\n    cout << \"Original list: \";\n    printList(last);\n\n// Delete the last node\n    last = deleteLastNode(last);\n\n    cout << \"List after deleting last node: \";\n    printList(last);\n\nreturn 0;\n}\n\n````\n\nC\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the structure for a node in the circular linked list\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\n// Function to delete the last node in the circular linked list\nstruct Node* deleteLastNode(struct Node* last) {\n    if (last == NULL) {\n        // If the list is empty\n        printf(\"List is empty, nothing to delete.\\n\");\nreturn NULL;\n}\n    struct Node* head = last->next;\n\n// If there is only one node in the list\n    if (head == last) {\n        free(last);\nlast = NULL;\n        return last;\n}\n    // Traverse the list to find the second last node\n    struct Node* curr = head;\n    while (curr->next != last) {\n        curr = curr->next;\n}\n    // Update the second last node's next pointer to point to head\n    curr->next = head;\n    free(last);\n    last = curr;\n\n    return last;\n}\n\nvoid printList(struct Node* last) {\n    if (last == NULL) return;\n\n    struct Node* head = last->next;\n    while (1) {\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next) break;\n    }\n    printf(\"\\n\");\n}\n\nstruct Node* createNode(int value) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n    // Create circular linked list: 2, 3, 4\n    struct Node* first = createNode(2);\n    first->next = createNode(3);\n    first->next->next = createNode(4);\n\n    struct Node* last = first->next->next;\n    last->next = first;\n\n    printf(\"Original list: \");\n    printList(last);\n\n    // Delete the last node\n    last = deleteLastNode(last);\n\n    printf(\"List after deleting last node: \");\n    printList(last);\n\n    return 0;\n}\n\n````\n\nJava\n````\nclass Node {\n    int data;\n    Node next;\n\n    Node(int value){\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n    public static Node deleteLastNode(Node last){\n        if (last == null) {\n            // If the list is empty\n            System.out.println(\n                \"List is empty, nothing to delete.\");\n            return null;\n        }\n        Node head = last.next;\n\n        // If there is only one node in the list\n        if (head == last) {\n            last = null;\n            return last;\n        }\n        // Traverse the list to find the second last node\n        Node curr = head;\n        while (curr.next != last) {\n            curr = curr.next;\n        }\n        // Update the second last node's next pointer to\n           // point to head\n           curr.next = head;\nlast = curr;\n\n        return last;\n}\n\n    public static void printList(Node last){\n        if (last == null)\n            return;\n\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next)\n                break;\n}\n        System.out.println();\n}\n\n    public static void main(String[] args){\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\n\n        Node last = first.next.next;\nlast.next = first;\n\n        System.out.print(\"Original list: \");\n        printList(last);\n\n// Delete the last node\n        last = deleteLastNode(last);\n\n        System.out.print(\"List after deleting last node: \");\n        printList(last);\n}\n}\n\n````\n\nPython\n````\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef deleteLastNode(last):\n    if last is None:\n        # If the list is empty\n        print(\"List is empty, nothing to delete.\")\n        return None\n\n    head = last.next\n\n    # If there is only one node in the list\n    if head == last:\n        last = None\n        return last\n\n    # Traverse the list to find the second last node\n    curr = head\n    while curr.next != last:\n        curr = curr.next\n\n    # Update the second last node's next pointer to point to head\n    curr.next = head\n    last = curr\n\n    return last\n\ndef printList(last):\n    if last is None:\n        return\n\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\n# Create circular linked list: 2, 3, 4\nfirst = Node(2)\nfirst.next = Node(3)\nfirst.next.next = Node(4)\n\nlast = first.next.next\nlast.next = first\n\nprint(\"Original list: \", end=\"\")\nprintList(last)\n\n# Delete the last node\nlast = deleteLastNode(last)\n\nprint(\"List after deleting last node: \", end=\"\")\nprintList(last)\n\n````\n\nC#\n````\nusing System;\n\npublic class Node {\n    public int data;\n    public Node next;\n\n    public Node(int value)\n    {\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n    // Function to delete the last node in the circular\n    // linked list\n    public static Node deleteLastNode(Node last)\n    {\n        if (last == null) {\n            // If the list is empty\n            Console.WriteLine(\n                \"List is empty, nothing to delete.\");\n            return null;\n        }\n        Node head = last.next;\n\n        // If there is only one node in the list\n        if (head == last) {\n            last = null;\n            return last;\n        }\n        // Traverse the list to find the second last node\n        Node curr = head;\n        while (curr.next != last) {\n            curr = curr.next;\n        }\n        // Update the second last node's next pointer\n          // to point to head\n          curr.next = head;\nlast = curr;\n\n        return last;\n}\n\n    // Function to print the circular linked list\n    public static void printList(Node last)\n    {\n        if (last == null) {\n            Console.WriteLine(\"List is Empty\");\n            return;\n}\n\n        Node head = last.next;\n        while (true) {\n            Console.Write(head.data + \" \");\n            head = head.next;\n            if (head == last.next)\n                break;\n}\n        Console.WriteLine();\n}\n\n    public static void Main(string[] args)\n    {\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\n\n        Node last = first.next.next;\nlast.next = first;\n\n        Console.Write(\"Original list: \");\n        printList(last);\n\n// Delete the last node\n        last = deleteLastNode(last);\n\n        Console.Write(\"List after deleting last node: \");\n        printList(last);\n}\n}\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n}\n}\n\nfunction deleteLastNode(last) {\n    if (last === null) {\n        // If the list is empty\n        console.log(\"List is empty, nothing to delete.\");\nreturn null;\n}\n    let head = last.next;\n\n// If there is only one node in the list\n    if (head === last) {\n        last = null;\n        return last;\n}\n    // Traverse the list to find the second last node\n    let curr = head;\n    while (curr.next !== last) {\n        curr = curr.next;\n}\n    // Update the second last node's next pointer to point to head\n    curr.next = head;\n    last = curr;\n\n    return last;\n}\n\nfunction printList(last) {\n    if (last === null) return;\n\n    let head = last.next;\n    while (true) {\n        process.stdout.write(head.data + \" \");\n        head = head.next;\n        if (head === last.next) break;\n    }\n    console.log();\n}\n\n// Create circular linked list: 2, 3, 4\nlet first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\n\nlet last = first.next.next;\nlast.next = first;\n\nconsole.log(\"Original list: \");\nprintList(last);\n\n// Delete the last node\nlast = deleteLastNode(last);\n\nconsole.log(\"List after deleting last node: \");\nprintList(last);\n\n````\n\n**Output**\n```\n\nOriginal list: 2 3 4\nList after deleting last node: 2 3\n\n```\n\n[Searching in Circular Linked list](https://www.geeksforgeeks.org/searching-in-circular-linked-list/?ref=ml_lbp)\n----------------------------------------------------------------------------------------------------------------\n\nSearching in a circular linked list is similar to searching in a\nregular linked list. We start at a given node and traverse the list\nuntil you either find the target value or return to the starting node.\nSince the list is circular, make sure to keep track of where you started\nto avoid an infinite loop.\n\n> To search for a specific value in a circular linked list, we first\n> check if the list is empty. If it is then we return ****false****. If the list contains nodes then we start from the ****head**** node (which is the ****last->next****) and traverse the list. We use a pointer ****curr**** to iterate through the nodes until we reach back to the ****head****. During traversal, if we find a node whose ****data**** matches the given ****key**** then we return ****true**** to indicating that the value was found. After the loop, we also check\n> the last node to ensure we don\u2019t miss it. If the ****key**** is not found after traversing the entire list then we return ****false****.\n\nC++\n````\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int value) {\n        data = value;\n        next = nullptr;\n    }\n};\n\n// Function to search for a specific value in the\n// circular linked list\nbool search(Node* last, int key) {\n    if (last == nullptr) {\n        // If the list is empty\n        return false;\n    }\n\n    Node* head = last->next;\n    Node* curr = head;\n\n    // Traverse the list to find the key\n    while (curr != last) {\n        if (curr->data == key) {\n          // Key found\n            return true;\n        }\n        curr = curr->next;\n    }\n\n    // Check the last node\n    if (last->data == key) {\n      // Key found\n        return true;\n    }\n    // Key not found\n    return false;\n}\n\nvoid printList(Node* last) {\n   if(last == NULL) return;\n\n    Node *head = last->next;\n    while (true){\n        cout << head->data << \" \";\n        head = head->next;\n        if (head == last->next) break;\n    }\n    cout << endl;\n}\n\nint main() {\n    // Create circular linked list: 2, 3, 4\n    Node* first = new Node(2);\n    first->next = new Node(3);\n    first->next->next = new Node(4);\n\n    Node* last = first->next->next;\n    last->next = first;\n\n    cout << \"Original list: \";\n    printList(last);\n\n    // Search for a specific value\n    int key = 3;\n    bool found = search(last, key);\n    if (found) {\n        cout << \"Value \" << key << \" found in the list.\" << endl;\n    } else {\n        cout << \"Value \" << key << \" not found in the list.\" << endl;\n    }\n\n    return 0;\n}\n\n````\n\nC\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Definition of the Node structure\nstruct Node{\n    int data;\n    struct Node *next;\n};\n\n// Function to search for a specific value in the circular linked list\nint search(struct Node *last, int key){\n    if (last == NULL){\n        // If the list is empty\n        return 0;\n    }\n\n    struct Node *head = last->next;\n    struct Node *curr = head;\n\n    // Traverse the list to find the key\n    while (curr != last){\n        if (curr->data == key){\n            // Key found\n            return 1;\n        }\n        curr = curr->next;\n    }\n\n    // Check the last node\n    if (last->data == key){\n        // Key found\n        return 1;\n    }\n    // Key not found\n    return 0;\n}\n\n// Function to print the circular linked list\nvoid printList(struct Node *last){\n    if (last == NULL) return;\n\n    struct Node *head = last->next;\n    while (1){\n        printf(\"%d \", head->data);\n        head = head->next;\n        if (head == last->next)\n            break;\n    }\n    printf(\"\\n\");\n}\n// Function to create a new node\nstruct Node *createNode(int value){\n    struct Node *temp = (struct Node *)malloc(sizeof(struct Node));\n    temp->data = value;\n    temp->next = NULL;\n    return temp;\n}\n\nint main(){\n    // Create circular linked list: 2, 3, 4\n    struct Node *first = createNode(2);\n    first->next = createNode(3);\n    first->next->next = createNode(4);\n\n    struct Node *last = first->next->next;\n    last->next = first;\n\n    printf(\"Original list: \");\n    printList(last);\n\n    // Search for a specific value\n    int key = 3;\n    int found = search(last, key);\n    if (found){\n        printf(\"Value %d found in the list.\\n\", key);\n    }\n    else{\n        printf(\"Value %d not found in the list.\\n\", key);\n    }\n\n    return 0;\n}\n\n````\n\nJava\n````\nclass Node {\n    int data;\n    Node next;\n    Node(int value) {\n        data = value;\n        next = null;\n    }\n}\n\npublic class CircularLinkedList {\n    // Function to search for a specific value\n    // in the circular linked list\n    static boolean search(Node last, int key) {\n        if (last == null) {\n            // If the list is empty\n            return false;\n        }\n\n        Node head = last.next;\n        Node curr = head;\n\n        // Traverse the list to find the key\n        while (curr != last) {\n            if (curr.data == key) {\n                // Key found\n                return true;\n            }\n            curr = curr.next;\n        }\n\n        // Check the last node\n        if (last.data == key) {\n            // Key found\n            return true;\n        }\n        // Key not found\n        return false;\n    }\n\n    static void printList(Node last) {\n        if (last == null) return;\n\n        Node head = last.next;\n        while (true) {\n            System.out.print(head.data + \" \");\n            head = head.next;\n            if (head == last.next) break;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n\n        Node last = first.next.next;\n        last.next = first;\n\n        System.out.print(\"Original list: \");\n        printList(last);\n\n        // Search for a specific value\n        int key = 3;\n        boolean found = search(last, key);\n        if (found) {\n            System.out.println(\"Value \" + key\n                               + \" found in the list.\");\n        } else {\n            System.out.println(\"Value \" + key +\n                               \" not found in the list.\");\n        }\n    }\n}\n\n````\n\nPython\n````\nclass Node:\n    def __init__(self, value):\n        self.data = value\n        self.next = None\n\ndef search(last, key):\n    if last is None:\n        # If the list is empty\n        return False\n\n    head = last.next\n    curr = head\n\n    # Traverse the list to find the key\n    while curr != last:\n        if curr.data == key:\n            # Key found\n            return True\n        curr = curr.next\n\n    # Check the last node\n    if last.data == key:\n        # Key found\n        return True\n    # Key not found\n    return False\n\ndef print_list(last):\n    if last is None:\n        return\n\n    head = last.next\n    while True:\n        print(head.data, end=\" \")\n        head = head.next\n        if head == last.next:\n            break\n    print()\n\nif __name__ == \"__main__\":\n    # Create circular linked list: 2, 3, 4\n    first = Node(2)\n    first.next = Node(3)\n    first.next.next = Node(4)\n\n    last = first.next.next\n    last.next = first\n\n    print(\"Original list:\", end=\" \")\n    print_list(last)\n\n    # Search for a specific value\n    key = 3\n    found = search(last, key)\n    if found:\n        print(f\"Value {key} found in the list.\")\n    else:\n        print(f\"Value {key} not found in the list.\")\n\n````\n\nC#\n````\nusing System;\n\npublic class Node {\n    public int data;\n    public Node next;\n    public Node(int value){\n        data = value;\n        next = null;\n    }\n}\n\npublic class GFG {\n    // Function to search for a specific value in the\n    // circular linked list\n    public static bool Search(Node last, int key){\n        if (last == null) {\n            // If the list is empty\n            return false;\n        }\n\n        Node head = last.next;\n        Node curr = head;\n\n        // Traverse the list to find the key\n        while (curr != last) {\n            if (curr.data == key) {\n                // Key found\n                return true;\n            }\n            curr = curr.next;\n        }\n\n        // Check the last node\n        if (last.data == key) {\n            // Key found\n            return true;\n        }\n        // Key not found\n        return false;\n    }\n\n    public static void PrintList(Node last){\n        if (last == null)\n            return;\n\n        Node head = last.next;\n        while (true) {\n            Console.Write(head.data + \" \");\n            head = head.next;\n            if (head == last.next)\n                break;\n        }\n        Console.WriteLine();\n    }\n\n    public static void Main(string[] args){\n        // Create circular linked list: 2, 3, 4\n        Node first = new Node(2);\n        first.next = new Node(3);\n        first.next.next = new Node(4);\n\n        Node last = first.next.next;\n        last.next = first;\n\n        Console.Write(\"Original list: \");\n        PrintList(last);\n\n        // Search for a specific value\n        int key = 3;\n        bool found = Search(last, key);\n        if (found) {\n            Console.WriteLine(\"Value \" + key\n                              + \" found in the list.\");\n        }\n        else {\n            Console.WriteLine(\"Value \" + key\n                              + \" not found in the list.\");\n        }\n    }\n}\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(value){\n        this.data = value;\n        this.next = null;\n    }\n}\n\nfunction search(last, key){\n    if (last === null) {\n        // If the list is empty\n        return false;\n    }\n\n    let head = last.next;\n    let curr = head;\n\n    // Traverse the list to find the key\n    while (curr !== last) {\n        if (curr.data === key) {\n            // Key found\n            return true;\n        }\n        curr = curr.next;\n    }\n\n    // Check the last node\n    if (last.data === key) {\n        // Key found\n        return true;\n    }\n    // Key not found\n    return false;\n}\n\nfunction printList(last){\n    if (last === null)\n        return;\n\n    let head = last.next;\n    while (true) {\n        process.stdout.write(head.data + \" \");\n        head = head.next;\n        if (head === last.next)\n            break;\n    }\n    console.log();\n}\n\n// Create circular linked list: 2, 3, 4\nlet first = new Node(2);\nfirst.next = new Node(3);\nfirst.next.next = new Node(4);\n\nlet last = first.next.next;\nlast.next = first;\n\nconsole.log(\"Original list:\");\nprintList(last);\n\n// Search for a specific value\nlet key = 3;\nlet found = search(last, key);\nif (found) {\n    console.log(`Value ${key} found in the list.`);\n}\nelse {\n    console.log(`Value ${key} not found in the list.`);\n}\n\n````\n\n\n\n\n**Output**\n```\n\nOriginal list: 2 3 4\nValue 3 found in the list.\n\n```\n\nAdvantages of Circular Linked Lists\n-----------------------------------\n\n* In circular linked list, the last node points to the first node.\n  There are no null references, making traversal easier and reducing the\n  chances of encountering null pointer exceptions.\n* We can traverse the list from any node and return to it without\n  needing to restart from the head, which is useful in applications\n  requiring a circular iteration.\n* Circular linked lists can easily implement circular queues, where the\n  last element connects back to the first, allowing for efficient\n  resource management.\n* In a circular linked list, each node has a reference to the next node\n  in the sequence. Although it doesn\u2019t have a direct reference to the\n  previous node like a doubly linked list, we can still find the\n  previous node by traversing the list.\n\nDisadvantages of Circular Linked Lists\n--------------------------------------\n\n* Circular linked lists are more complex to implement than singly\n  linked lists.\n* Traversing a circular linked list without a clear stopping condition\n  can lead to infinite loops if not handled carefully.\n* Debugging can be more challenging due to the circular nature, as\n  traditional methods of traversing linked lists may not apply.\n\nApplications of Circular Linked Lists\n-------------------------------------\n\n* It is used for time-sharing among different users, typically through\n  a ****Round-Robin scheduling mechanism.****\n* In multiplayer games, a circular linked list can be used to switch\n  between players. After the last player\u2019s turn, the list cycles back to\n  the first player.\n* Circular linked lists are often used in buffering applications, such\n  as streaming data, where data is continuously produced and\n  consumed.\n* In media players, circular linked lists can manage playlists, this\n  allowing users to loop through songs continuously.\n* Browsers use circular linked lists to manage the cache. This allows\n  you to navigate back through your browsing history efficiently by\n  pressing the BACK button.",
        "metadata": {
            "lesson_id": "2220549e-2da8-4f0c-9d38-2495ce6b234e",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "A circular linked list is a data structure where the last node connects back to the first,\nforming a loop. This structure allows for continuous traversal without\nany interruptions. Circular linked lists are especially helpful for\ntasks like scheduling and managing playlists, this allowing for smooth navigation. In this tutorial, we\u2019ll cover the\nbasics of circular linked lists, how to work with them, their advantages\nand disadvantages, and their applications.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Representation of Stack Data Structure:\n---------------------------------------\n\nStack follows LIFO (Last In First Out) Principle so the element which\nis pushed last is popped first.\n\n\n![Stack-representation-in-Data-Structures-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180735/Stack-representation-in-Data-Structures-(1).webp)\n\n****Types of Stack:****\n-----------------------\n\n* ****Fixed Size Stack****\n  : As the name suggests, a fixed size stack has a fixed size and cannot\n  grow or shrink dynamically. If the stack is full and an attempt is\n  made to add an element to it, an overflow error occurs. If the stack\n  is empty and an attempt is made to remove an element from it, an\n  underflow error occurs.\n* ****Dynamic Size Stack****\n  : A dynamic size stack can grow or shrink dynamically. When the stack\n  is full, it automatically increases its size to accommodate the new\n  element, and when the stack is empty, it decreases its size. This type\n  of stack is implemented using a linked list, as it allows for easy\n  resizing of the stack.\n\nBasic Operations on Stack:\n--------------------------\n\nIn order to make manipulations in a stack, there are certain operations\nprovided to us.\n\n\n* ****push()****  to insert an element into the stack\n* ****pop()****  to remove an element from the stack\n* ****top()****  Returns the top element of the stack.\n* ****isEmpty()****  returns true if stack is empty else false.\n* ****isFull()****  returns true if the stack is full else false.\n\nTo implement stack, we need to maintain reference to the top\nitem.\n\n### ****Push Operation on Stack****\n\nAdds an item to the stack. If the stack is full, then it is said to be\nan  ****Overflow condition.****\n\n ****Algorithm for Push Operation:****\n\n* Before pushing the element to the stack, we check if the stack is  ****full****  .\n* If the stack is full  ****(top == capacity-1)****  , then  ****Stack Overflows****  and we cannot insert the element to the stack.\n* Otherwise, we increment the value of top by 1  ****(top = top + 1)****  and the new value is inserted at  ****top position****  .\n* The elements can be pushed into the stack till we reach the  ****capacity****  of the stack.\n\n![Push-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180844/Push-Operation-in-Stack-(1).webp)\n### ****Pop Operation in Stack****\n\nRemoves an item from the stack. The items are popped in the reversed\norder in which they are pushed. If the stack is empty, then it is said\nto be an  ****Underflow condition.****\n\n****Algorithm for Pop Operation:****\n\n* Before popping the element from the stack, we check if the stack is  ****empty****  .\n* If the stack is empty (top == -1), then  ****Stack Underflows****  and we cannot remove any element from the stack.\n* Otherwise, we store the value at top, decrement the value of top by 1  ****(top = top \u2013 1)****  and return the stored top value.\n\n![Pop-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180943/Pop-Operation-in-Stack-(1).webp)\n### ****Top or Peek Operation on Stack****\n\nReturns the top element of the stack.\n\n****Algorithm for Top Operation:****\n\n* Before returning the top element from the stack, we check if the\n  stack is empty.\n* If the stack is empty (top == -1), we simply print \u201cStack is empty\u201d.\n* Otherwise, we return the element stored at  ****index = top****  .\n\n![Top-or-Peek-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181023/Top-or-Peek-Operation-in-Stack-(1).webp)\n### ****isEmpty Operation in Stack Data Structure:****\n\nReturns true if the stack is empty, else false.\n\n****Algorithm for isEmpty Operation****:\n\n* Check for the value of  ****top****  in stack.\n* If  ****(top == -1)****, then the stack is  ****empty****  so return  ****true****  .\n* Otherwise, the stack is not empty so return  ****false****  .\n\n![isEmpty-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181101/isEmpty-Operation-in-Stack-(1).webp)\n### isFull ****Operation in Stack**** ****Data Structure****:\n\nReturns true if the stack is full, else false.\n\n****Algorithm for isFull Operation:****\n\n* Check for the value of  ****top****  in stack.\n* If  ****(top == capacity-1),****  then the stack is  ****full****  so return  ****true****.\n* Otherwise, the stack is not full so return  ****false****.\n\n![isFull-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181147/isFull-Operation-in-Stack-(1).webp)\n\nImplementation of Stack\n-----------------------\n\n\nThe basic operations that can be performed on a stack include push, pop,\nand peek. There are two ways to implement a stack \u2013\n\n\n* [****Implementation of Stack using Array****](https://www.geeksforgeeks.org/implement-stack-using-array/)\n* [****Implementation of Stack using Linked List****](https://www.geeksforgeeks.org/implement-a-stack-using-singly-linked-list/)\n\n****Complexity Analysis of Operations on Stack Data Structure:****\n------------------------------------------------------------------\n\n| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |\n| --- | --- | --- |\n| ****push()**** | O(1) | O(1) |\n| ****pop()**** | O(1) | O(1) |\n| top() or  ****pee****k() | O(1) | O(1) |\n| isEmpty() | O(1) | O(1) |\n| isFull() | O(1) | O(1) |",
        "metadata": {
            "lesson_id": "039efe3e-47d0-410e-b3db-a9e64d9bedd7",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "Stack is a linear data structure that follows LIFO (Last In First Out) Principle, the last element inserted is the first to be popped out. It means\nboth insertion and deletion operations happen at one end only.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Implement Stack using Array:\n----------------------------\n\n> To implement a stack using an array, initialize an array and treat\n> its end as the stack\u2019s top. Implement ****push**** (add to end), ****pop**** (remove from end), and ****peek**** (check end) operations, handling cases for an ****empty**** or f****ull stack****.\n\n****Step-by-step approach:****\n\n1. ****Initialize an array**** to represent the stack.\n2. Use the ****end of the array**** to represent the ****top of the stack****.\n3. Implement ****push**** (add to end), ****pop**** (remove from the end), and ****peek**** (check end) operations, ensuring to handle empty and full stack\n   conditions.\n\nImplement Stack Operations using Array:\n---------------------------------------\n\n\nHere are the following operations of implement stack using array:\n\n### ****Push Operation in Stack:****\n\nAdds an item to the stack. If the stack is full, then it is said to be\nan ****Overflow condition.****\n\n****Algorithm for Push Operation:****\n\n> * Before pushing the element to the stack, we check if the stack\n>   is ****full****.\n> * If the stack is full ****(top == capacity-1)**** , then ****Stack Overflows****and we cannot insert the element to the stack.\n> * Otherwise, we increment the value of top by 1 ****(top = top + 1)**** and the new value is inserted at ****top position****.\n> * The elements can be pushed into the stack till we reach\n>   the ****capacity**** of the stack.\n\n![push-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114219/push-operation-in-stack-1.webp)![push-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114219/push-operation-in-stack-1.webp)\n\n\n![push-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114220/push-operation-in-stack-2.webp)![push-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114220/push-operation-in-stack-2.webp)\n\n\n![push-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114221/push-operation-in-stack-3.webp)![push-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114221/push-operation-in-stack-3.webp)\n\n\n![push-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-4.webp)![push-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-4.webp)\n\n\n![push-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-5.webp)![push-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-5.webp)\n\n\n![push-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114223/push-operation-in-stack-6.webp)![push-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114223/push-operation-in-stack-6.webp)\n\n\n\nPrevious\n\n\n\n\n\nPause\n\nNext\n\n\n\n\n\n5 / 6\n\n### ****Pop Operation in Stack:****\n\nRemoves an item from the stack. The items are popped in the reversed\norder in which they are pushed. If the stack is empty, then it is said\nto be an ****Underflow condition.****\n\n****Algorithm for Pop Operation:****\n\n> * Before popping the element from the stack, we check if the stack\n>   is ****empty****.\n> * If the stack is empty (top == -1), then ****Stack Underflows**** and we cannot remove any element from the stack.\n> * Otherwise, we store the value at top, decrement the value of top by\n>   1 ****(top = top \u2013 1)**** and return the stored top value.\n\n![pop-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)\n\n\n![pop-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)\n\n\n![pop-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)\n\n\n![pop-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)\n\n\n![pop-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)\n\n\n![pop-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)\n\n\n\nPrevious\n\n\n\n\n\nPlay\n\nNext\n\n\n\n\n\n1 / 6\n\n\n\n\n### ****Top or Peek Operation in Stack:****\n\nReturns the top element of the stack.\n\n****Algorithm for Top Operation:****\n\n> * Before returning the top element from the stack, we check if the\n>   stack is empty.\n> * If the stack is empty (top == -1), we simply print \u201cStack is\n>   empty\u201d.\n> * Otherwise, we return the element stored at ****index = top****.\n\n### ****isEmpty Operation in Stack:****\n\nReturns true if the stack is empty, else false.\n\n****Algorithm for isEmpty Operation****:\n\n> * Check for the value of ****top**** in stack.\n> * If ****(top == -1)**** , then the stack is ****empty****so return ****true****.\n> * Otherwise, the stack is not empty so return ****false****.\n\n### isFull ****Operation in Stack****:\n\nReturns true if the stack is full, else false.\n\n****Algorithm for isFull Operation:****\n\n> * Check for the value of ****top**** in stack.\n> * If ****(top == capacity-1),**** then the stack is ****full**** so return ****true****.\n> * Otherwise, the stack is not full so return ****false.****\n\nBelow is the implementation of the above approach:\n\nC++\n````\n/* C++ program to implement basic stack\noperations */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1000\n\nclass Stack {\n    int top;\n\npublic:\n    int a[MAX]; // Maximum size of Stack\n\n    Stack() { top = -1; }\n    bool push(int x);\n    int pop();\n    int peek();\n    bool isEmpty();\n};\n\nbool Stack::push(int x)\n{\n    if (top >= (MAX - 1)) {\n        cout << \"Stack Overflow\";\n        return false;\n    }\n    else {\n        a[++top] = x;\n        cout << x << \" pushed into stack\\n\";\n        return true;\n    }\n}\n\nint Stack::pop()\n{\n    if (top < 0) {\n        cout << \"Stack Underflow\";\n        return 0;\n    }\n    else {\n        int x = a[top--];\n        return x;\n    }\n}\nint Stack::peek()\n{\n    if (top < 0) {\n        cout << \"Stack is Empty\";\n        return 0;\n    }\n    else {\n        int x = a[top];\n        return x;\n    }\n}\n\nbool Stack::isEmpty()\n{\n    return (top < 0);\n}\n\n// Driver program to test above functions\nint main()\n{\n    class Stack s;\n    s.push(10);\n    s.push(20);\n    s.push(30);\n    cout << s.pop() << \" Popped from stack\\n\";\n\n    //print top element of stack after popping\n    cout << \"Top element is : \" << s.peek() << endl;\n\n    //print all elements in stack :\n    cout <<\"Elements present in stack : \";\n    while(!s.isEmpty())\n    {\n        // print top element in stack\n        cout << s.peek() <<\" \";\n        // remove top element in stack\n        s.pop();\n    }\n\n    return 0;\n}\n\n````\n\nC\n````\n// C program for array implementation of stack\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// A structure to represent a stack\nstruct Stack {\n    int top;\n    unsigned capacity;\n    int* array;\n};\n\n// function to create a stack of given capacity. It initializes size of\n// stack as 0\nstruct Stack* createStack(unsigned capacity)\n{\n    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));\n    stack->capacity = capacity;\n    stack->top = -1;\n    stack->array = (int*)malloc(stack->capacity * sizeof(int));\n    return stack;\n}\n\n// Stack is full when top is equal to the last index\nint isFull(struct Stack* stack)\n{\n    return stack->top == stack->capacity - 1;\n}\n\n// Stack is empty when top is equal to -1\nint isEmpty(struct Stack* stack)\n{\n    return stack->top == -1;\n}\n\n// Function to add an item to stack. It increases top by 1\nvoid push(struct Stack* stack, int item)\n{\n    if (isFull(stack))\n        return;\n    stack->array[++stack->top] = item;\n    printf(\"%d pushed to stack\\n\", item);\n}\n\n// Function to remove an item from stack. It decreases top by 1\nint pop(struct Stack* stack)\n{\n    if (isEmpty(stack))\n        return INT_MIN;\n    return stack->array[stack->top--];\n}\n\n// Function to return the top from stack without removing it\nint peek(struct Stack* stack)\n{\n    if (isEmpty(stack))\n        return INT_MIN;\n    return stack->array[stack->top];\n}\n\n// Driver program to test above functions\nint main()\n{\n    struct Stack* stack = createStack(100);\n\n    push(stack, 10);\n    push(stack, 20);\n    push(stack, 30);\n\n    printf(\"%d popped from stack\\n\", pop(stack));\n\n    return 0;\n}\n\n````\n\nJava\n````\n/* Java program to implement basic stack\noperations */\nclass Stack {\n    static final int MAX = 1000;\n    int top;\n    int a[] = new int[MAX]; // Maximum size of Stack\n\n    boolean isEmpty()\n    {\n        return (top < 0);\n    }\n    Stack()\n    {\n        top = -1;\n    }\n\n    boolean push(int x)\n    {\n        if (top >= (MAX - 1)) {\n            System.out.println(\"Stack Overflow\");\n            return false;\n        }\n        else {\n            a[++top] = x;\n            System.out.println(x + \" pushed into stack\");\n            return true;\n        }\n    }\n\n    int pop()\n    {\n        if (top < 0) {\n            System.out.println(\"Stack Underflow\");\n            return 0;\n        }\n        else {\n            int x = a[top--];\n            return x;\n        }\n    }\n\n    int peek()\n    {\n        if (top < 0) {\n            System.out.println(\"Stack Underflow\");\n            return 0;\n        }\n        else {\n            int x = a[top];\n            return x;\n        }\n    }\n\n    void print(){\n    for(int i = top;i>-1;i--){\n    System.out.print(\" \"+ a[i]);\n    }\n}\n}\n\n// Driver code\nclass Main {\n    public static void main(String args[])\n    {\n        Stack s = new Stack();\n        s.push(10);\n        s.push(20);\n        s.push(30);\n        System.out.println(s.pop() + \" Popped from stack\");\n        System.out.println(\"Top element is :\" + s.peek());\n        System.out.print(\"Elements present in stack :\");\n        s.print();\n    }\n}\n\n````\n\nPython3\n````\n# Python program for implementation of stack\n\n# import maxsize from sys module\n# Used to return -infinite when stack is empty\nfrom sys import maxsize\n\n# Function to create a stack. It initializes size of stack as 0\ndef createStack():\n    stack = []\n    return stack\n\n# Stack is empty when stack size is 0\ndef isEmpty(stack):\n    return len(stack) == 0\n\n# Function to add an item to stack. It increases size by 1\ndef push(stack, item):\n    stack.append(item)\n    print(item + \" pushed to stack \")\n\n# Function to remove an item from stack. It decreases size by 1\ndef pop(stack):\n    if (isEmpty(stack)):\n        return str(-maxsize -1) # return minus infinite\n\n    return stack.pop()\n\n# Function to return the top from stack without removing it\ndef peek(stack):\n    if (isEmpty(stack)):\n        return str(-maxsize -1) # return minus infinite\n    return stack[len(stack) - 1]\n\n# Driver program to test above functions\nstack = createStack()\npush(stack, str(10))\npush(stack, str(20))\npush(stack, str(30))\nprint(pop(stack) + \" popped from stack\")\n\n````\n\nC#\n````\n// C# program to implement basic stack\n// operations\nusing System;\n\nnamespace ImplementStack {\nclass Stack {\n    private int[] ele;\n    private int top;\n    private int max;\n    public Stack(int size)\n    {\n        ele = new int[size]; // Maximum size of Stack\n        top = -1;\n        max = size;\n    }\n\n    public void push(int item)\n    {\n        if (top == max - 1) {\n            Console.WriteLine(\"Stack Overflow\");\n            return;\n        }\n        else {\n            ele[++top] = item;\n        }\n    }\n\n    public int pop()\n    {\n        if (top == -1) {\n            Console.WriteLine(\"Stack is Empty\");\n            return -1;\n        }\n        else {\n            Console.WriteLine(\"{0} popped from stack \", ele[top]);\n            return ele[top--];\n        }\n    }\n\n    public int peek()\n    {\n        if (top == -1) {\n            Console.WriteLine(\"Stack is Empty\");\n            return -1;\n        }\n        else {\n            Console.WriteLine(\"{0} popped from stack \", ele[top]);\n            return ele[top];\n        }\n    }\n\n    public void printStack()\n    {\n        if (top == -1) {\n            Console.WriteLine(\"Stack is Empty\");\n            return;\n        }\n        else {\n            for (int i = 0; i <= top; i++) {\n                Console.WriteLine(\"{0} pushed into stack\", ele[i]);\n            }\n        }\n    }\n}\n\n// Driver program to test above functions\nclass Program {\n    static void Main()\n    {\n        Stack p = new Stack(5);\n\n        p.push(10);\n        p.push(20);\n        p.push(30);\n        p.printStack();\n        p.pop();\n    }\n}\n}\n\n````\n\nJavaScript\n````\n/* javascript program to implement basic stack\noperations\n*/\nvar t = -1;\n    var MAX = 1000;\n    var a = Array(MAX).fill(0); // Maximum size of Stack\n\n    function isEmpty() {\n        return (t < 0);\n    }\n\n    function push(x) {\n        if (t >= (MAX - 1)) {\n            console.log(\"Stack Overflow\");\n            return false;\n        } else {\n        t+=1;\n            a[t] = x;\n\n            console.log(x + \" pushed into stack<br/>\");\n            return true;\n        }\n    }\n\n    function pop() {\n        if (t < 0) {\n            console.log(\"Stack Underflow\");\n            return 0;\n        } else {\n            var x = a[t];\n            t-=1;\n            return x;\n        }\n    }\n\n    function peek() {\n        if (t < 0) {\n            console.log(\"Stack Underflow\");\n            return 0;\n        } else {\n            var x = a[t];\n            return x;\n        }\n    }\n\n    function print() {\n        for (i = t; i > -1; i--) {\n            console.log(\" \" + a[i]);\n        }\n    }\n\n        push(10);\n        push(20);\n        push(30);\n        console.log(pop() + \" Popped from stack\");\n        console.log(\"<br/>Top element is :\" + peek());\n        console.log(\"<br/>Elements present in stack : \");\n        print();\n\n````\n\n**Output**\n```\n\n10 pushed into stack\n20 pushed into stack\n30 pushed into stack\n30 Popped from stack\nTop element is : 20\nElements present in stack : 20 10\n```\n### Complexity Analysis:\n\n* ****Time Complexity****:\n  + `push`: O(1)\n  + `pop`: O(1)\n  + `peek`: O(1)\n  + `is_empty`: O(1)\n  + is\\_full: O(1)\n* ****Auxiliary Space****: O(n), where n is the number of items in the stack.\n\nAdvantages of Array Implementation:\n-----------------------------------\n\n* Easy to implement.\n* Memory is saved as pointers are not involved.\n\nDisadvantages of Array Implementation:\n--------------------------------------\n\n* It is not dynamic i.e., it doesn\u2019t grow and shrink depending on needs\n  at runtime. [But in case of dynamic sized arrays like vector in C++,\n  list in Python, ArrayList in Java, stacks can grow and shrink with\n  array implementation as well].\n* The total size of the stack must be defined beforehand.\n",
        "metadata": {
            "lesson_id": "2b55a666-302b-4c46-8d3a-3fdaefcca1e7",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "Stack is a linear data structurewhich follows LIFO principle. In this article, we will learn how to implement Stack using\nArrays. In Array-based approach, all stack-related operations are\nexecuted using arrays. Let\u2019s see how we can implement each operation on\nthe stack utilizing the Array Data Structure.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Applications of Stacks:\n-----------------------\n\n* ****Function calls:****\n  Stacks are used to keep track of the return addresses of function\n  calls, allowing the program to return to the correct location after a\n  function has finished executing.\n* ****Recursion:**** Stacks are used to store the local variables and return addresses of\n  recursive function calls, allowing the program to keep track of the\n  current state of the recursion.\n* ****Expression evaluation:**** Stacks are used to evaluate expressions in postfix notation (Reverse\n  Polish Notation).\n* ****Syntax parsing:**** Stacks are used to check the validity of syntax in programming\n  languages and other formal languages.\n* ****Memory management:**** Stacks are used to allocate and manage memory in some operating\n  systems and programming languages.\n* Used to solve popular problems like [Next Greater](https://www.geeksforgeeks.org/next-greater-element/), [Previous Greater](https://www.geeksforgeeks.org/previous-greater-element/), [Next Smaller](https://www.geeksforgeeks.org/next-smaller-element/), [Previous Smaller](https://www.geeksforgeeks.org/find-the-nearest-smaller-numbers-on-left-side-in-an-array/), [Largest Area in a Histogram](https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-using-stack/) and [Stock Span Problems](https://www.geeksforgeeks.org/the-stock-span-problem/).\n\nAdvantages of Stacks:\n---------------------\n\n* ****Simplicity:**** Stacks are a simple and easy-to-understand data structure, making\n  them suitable for a wide range of applications.\n* ****Efficiency:**** Push and pop operations on a stack can be performed in constant time ****(O(1))****, providing efficient access to data.\n* ****Last-in, First-out (LIFO):****\n  Stacks follow the LIFO principle, ensuring that the last element added\n  to the stack is the first one removed. This behavior is useful in many\n  scenarios, such as function calls and expression evaluation.\n* ****Limited memory usage:**** Stacks only need to store the elements that have been pushed onto\n  them, making them memory-efficient compared to other data\n  structures.\n\nDisadvantages of Stacks:\n------------------------\n\n* ****Limited access:****\n  Elements in a stack can only be accessed from the top, making it\n  difficult to retrieve or modify elements in the middle of the\n  stack.\n* ****Potential for overflow:**** If more elements are pushed onto a stack than it can hold, an\n  overflow error will occur, resulting in a loss of data.\n* ****Not suitable for random access:**** Stacks do not allow for random access to elements, making them\n  unsuitable for applications where elements need to be accessed in a\n  specific order.\n* ****Limited capacity:****\n  Stacks have a fixed capacity, which can be a limitation if the number\n  of elements that need to be stored is unknown or highly\n  variable.\n",
        "metadata": {
            "lesson_id": "b41b7e34-c749-4217-b0f3-6b496b632261",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "A stack is a linear data structure\nin which the insertion of a new element and removal of an existing\nelement takes place at the same end represented as the top of the stack.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "What is a Doubly Linked List?\n-----------------------------\n\nA ****doubly linked list****\nis a data structure that consists of a set of nodes, each of which\ncontains a ****value**** and ****two pointers****, one pointing to the ****previous node**** in the list and one pointing to the ****next node****\nin the list. This allows for efficient traversal of the list in ****both directions****, making it suitable for applications where frequent ****insertions**** and ****deletions**** are required.\n\n![Insertion-at-the-End-in-Doubly-Linked-List-copy](https://media.geeksforgeeks.org/wp-content/uploads/20240809123741/Insertion-at-the-End-in-Doubly-Linked-List-copy.webp)\n\nDoubly Linked List\n\n\nRepresentation of Doubly Linked List in Data Structure\n------------------------------------------------------\n\nIn a data structure, a doubly linked list is represented using nodes\nthat have three fields:\n\n1. Data\n2. A pointer to the next node (****next****)\n3. A pointer to the previous node (****prev****)\n\n![Node-Structure-of-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124907/Node-Structure-of-Doubly-Linked-List.webp)\n\nNode Structure of Doubly Linked List\n\n\nNode Definition\n---------------\n\nHere is how a node in a Doubly Linked List is typically\nrepresented:\n\n[Try it on GfG Practice\n![redirect icon](https://media.geeksforgeeks.org/auth-dashboard-uploads/Group-arrow.svg)](https://www.geeksforgeeks.org/problems/display-doubly-linked-list--154650/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=practice_card)\nC++\n````\nstruct Node {\n\n    // To store the Value or data.\n    int data;\n\n    // Pointer to point the Previous Element\n    Node* prev;\n\n    // Pointer to point the Next Element\n    Node* next;\n\n    // Constructor\n    Node(int d) {\n       data = d;\n       prev = next = nullptr;\n    }\n};\n\n````\n\nC\n````\nstruct Node {\n\n    // To store the Value or data.\n    int data;\n\n    // Pointer to point the Previous Element\n    Node* prev;\n\n    // Pointer to point the Next Element\n    Node* next;\n};\n\n// Function to create a new node\nstruct Node *createNode(int new_data) {\n    struct Node *new_node = (struct Node *)\n    malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    new_node->prev = NULL;\n    return new_node;\n}\n\n````\n\nJava\n````\nclass Node {\n\n    // To store the Value or data.\n    int data;\n\n    // Reference to the Previous Node\n    Node prev;\n\n    // Reference to the next Node\n    Node next;\n\n    // Constructor\n    Node(int d) {\n       data = d;\n       prev = next = null;\n    }\n};\n\n````\n\nPython\n````\nclass Node:\n\n    def __init__(self, data):\n        # To store the value or data.\n        self.data = data\n\n        # Reference to the previous node\n        self.prev = None\n\n        # Reference to the next node\n        self.next = None\n\n````\n\nC#\n````\nclass Node\n{\n  \t// To store the value or data\n    public int Data;\n\n  \t// Pointer to the next node\n    public Node Next;\n\n  \t// Pointer to the previous node\n    public Node Prev;\n\n    // Constructor\n    public Node(int d)\n    {\n        Data = d;\n        Prev = Next = null;\n    }\n}\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(data)\n    {\n        // To store the value or data.\n        this.data = data;\n\n        // Reference to the previous node\n        this.prev = null;\n\n        // Reference to the next node\n        this.next = null;\n    }\n}\n\n````\n\nEach node in a ****Doubly Linked List**** contains the ****data**** it holds, a pointer to the ****next**** node in the list, and a pointer to the ****previous****\nnode in the list. By linking these nodes together through the ****next**** and ****prev****\npointers, we can traverse the list in both directions (forward and\nbackward), which is a key feature of a Doubly Linked List.\n\n[Operations on Doubly Linked List](https://www.geeksforgeeks.org/doubly-linked-list-tutorial)\n---------------------------------------------------------------------------------------------\n\n* ****Traversal in Doubly Linked List****\n* ****Searching in Doubly Linked List****\n* ****Finding Length of Doubly Linked List****\n* [****Insertion in Doubly Linked List****:](https://www.geeksforgeeks.org/introduction-and-insertion-in-a-doubly-linked-list)\n  + Insertion at the beginning of Doubly Linked List\n  + Insertion at the end of the Doubly Linked List\n  + Insertion at a specific position in Doubly Linked List\n* [****Deletion in Doubly Linked List****:](https://www.geeksforgeeks.org/delete-a-node-in-a-doubly-linked-list)\n  + Deletion of a node at the beginning of Doubly Linked List\n  + Deletion of a node at the end of Doubly Linked List\n  + Deletion of a node at a specific position in Doubly Linked\n    List\n\nLet's go through each of the operations mentioned above, one by\none.\n\n[Traversal in Doubly Linked List](https://www.geeksforgeeks.org/traversal-in-doubly-linked-list/)\n-------------------------------------------------------------------------------------------------\n\nTo Traverse the doubly list, we can use the following steps:\n\n****a. Forward Traversal:****\n\n* Initialize a pointer to the head of the linked list.\n* While the pointer is not null:\n  + Visit the data at the current node.\n  + Move the pointer to the next node.\n\n****b. Backward Traversal:****\n\n* Initialize a pointer to the tail of the linked list.\n* While the pointer is not null:\n  + Visit the data at the current node.\n  + Move the pointer to the previous node.\n\nBelow are the implementation of the above approach:\n\nC++\n````\n#include <iostream>\nusing namespace std;\n\n// Define the Node structure\nstruct Node {\n    int data;\n    Node* next;\n    Node* prev;\n\n// Constructor to initialize Node with data\n    Node(int data) : data(data), next(nullptr),\n  \tprev(nullptr) {}\n};\n\n// Function to traverse the doubly linked list\n// in forward direction\nvoid forwardTraversal(Node* head) {\n\n    // Start traversal from the head of the list\n    Node* curr = head;\n\n// Continue until current node is not null\n    // (end of list)\n    while (curr != nullptr) {\n\n        // Output data of the current node\n        cout << curr->data << \" \";\n\n// Move to the next node\n        curr = curr->next;\n}\n\n    // Print newline after traversal\n    cout << endl;\n}\n\n// Function to traverse the doubly linked list\n// in backward direction\nvoid backwardTraversal(Node* tail) {\n\n    // Start traversal from the tail of the list\n    Node* curr = tail;\n\n// Continue until current node is not null\n    // (end of list)\n    while (curr != nullptr) {\n\n        // Output data of the current node\n        cout << curr->data << \" \";\n\n// Move to the previous node\n        curr = curr->prev;\n}\n\n    // Print newline after traversal\n    cout << endl;\n}\n\nint main() {\n\n    // Sample usage of the doubly linked list and\n    // traversal functions\n    Node* head = new Node(1);\n    Node* second = new Node(2);\n    Node* third = new Node(3);\n\n    head->next = second;\nsecond->prev = head;\nsecond->next = third;\n    third->prev = second;\n\n    cout << \"Forward Traversal:\" << endl;\n    forwardTraversal(head);\n\n    cout << \"Backward Traversal:\" << endl;\n    backwardTraversal(third);\n\nreturn 0;\n}\n\n````\n\nC\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Define the Node structure\nstruct Node {\n    int data; // Data stored in the node\n    struct Node* next; // Pointer to the next node\n    struct Node* prev; // Pointer to the previous node\n};\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node* newNode =\n      (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->next = NULL;\n    newNode->prev = NULL;\nreturn newNode;\n}\n\n// Function to traverse the doubly linked list\n// in forward direction\nvoid forwardTraversal(struct Node* head) {\n\n    // Start traversal from the head of the list\n    struct Node* curr = head;\n\n// Continue until the current node is not\n    // null (end of list)\n    while (curr != NULL) {\n\n        // Output data of the current node\n        printf(\"%d \", curr->data);\n\n// Move to the next node\n        curr = curr->next;\n}\n\n    // Print newline after traversal\n    printf(\"\\n\");\n}\n\n// Function to traverse the doubly linked list\n// in backward direction\nvoid backwardTraversal(struct Node* tail) {\n\n    // Start traversal from the tail of the list\n    struct Node* curr = tail;\n\n// Continue until the current node is not\n    // null (end of list)\n    while (curr != NULL) {\n\n        // Output data of the current node\n        printf(\"%d \", curr->data);\n\n// Move to the previous node\n        curr = curr->prev;\n}\n\n    // Print newline after traversal\n    printf(\"\\n\");\n}\n\nint main() {\n\n    // Sample usage of the doubly linked list and\n    // traversal functions\n    struct Node* head = createNode(1);\n    struct Node* second = createNode(2);\n    struct Node* third = createNode(3);\n\n    head->next = second;\nsecond->prev = head;\nsecond->next = third;\n    third->prev = second;\n\n    printf(\"Forward Traversal:\\n\");\n    forwardTraversal(head);\n\n    printf(\"Backward Traversal:\\n\");\n    backwardTraversal(third);\n\n// Free memory allocated for nodes\n    free(head);\n    free(second);\n    free(third);\n\nreturn 0;\n}\n\n````\n\nJava\n````\n// Define the Node class\nclass Node {\n    int data; // Data stored in the node\n    Node next; // Pointer to the next node\n    Node prev; // Pointer to the previous node\n\n    // Constructor to initialize the node with data\n    public Node(int data) {\n        this.data = data;\n        this.next = null;\n        this.prev = null;\n}\n}\n\n// Class to manage the doubly linked list\nclass GfG {\n\n    // Function to traverse the doubly linked list\n    // in forward direction\n    static void forwardTraversal(Node head) {\n\n        // Start traversal from the head of the list\n        Node curr = head;\n\n// Continue until the current node is\n        // null (end of the list)\n        while (curr != null) {\n\n            // Output data of the current node\n            System.out.print(curr.data + \" \");\n\n// Move to the next node\n            curr = curr.next;\n}\n\n        // Print newline after traversal\n        System.out.println();\n}\n\n    // Function to traverse the doubly linked list\n  \t//in backward direction\n    static void backwardTraversal(Node tail) {\n\n        // Start traversal from the tail of the list\n        Node curr = tail;\n\n// Continue until the current node is\n        // null (end of the list)\n        while (curr != null) {\n\n            // Output data of the current node\n            System.out.print(curr.data + \" \");\n\n// Move to the previous node\n            curr = curr.prev;\n}\n\n        // Print newline after traversal\n        System.out.println();\n}\n\n    public static void main(String[] args) {\n\n        // Sample usage of the doubly linked\n        // list and traversal functions\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.next = second;\nsecond.prev = head;\nsecond.next = third;\n        third.prev = second;\n\n        System.out.println(\"Forward Traversal:\");\n        forwardTraversal(head);\n\n        System.out.println(\"Backward Traversal:\");\n        backwardTraversal(third);\n}\n}\n\n````\n\nPython\n````\n# Define the Node class\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n# Function to traverse the doubly linked list\n# in forward direction\ndef forward_traversal(head):\n\n    # Start traversal from the head of the list\n    curr = head\n\n    # Continue until the current node is\n    # null (end of the list)\n    while curr is not None:\n\n        # Output data of the current node\n        print(curr.data, end=\" \")\n\n        # Move to the next node\n        curr = curr.next\n\n    # Print newline after traversal\n    print()\n\n# Function to traverse the doubly linked\n# list in backward direction\ndef backward_traversal(tail):\n\n    # Start traversal from the tail of the list\n    curr = tail\n\n    # Continue until the current node\n    # is null (end of the list)\n    while curr is not None:\n\n        # Output data of the current node\n        print(curr.data, end=\" \")\n\n        # Move to the previous node\n        curr = curr.prev\n\n    # Print newline after traversal\n    print()\n\n# Sample usage of the doubly linked list\n# and traversal functions\nif __name__ == \"__main__\":\n\n    # Create a doubly linked list with 3 nodes\n    head = Node(1)\n    second = Node(2)\n    third = Node(3)\n\n    head.next = second\n    second.prev = head\n    second.next = third\n    third.prev = second\n\n    print(\"Forward Traversal:\")\n    forward_traversal(head)\n\n    print(\"Backward Traversal:\")\n    backward_traversal(third)\n\n````\n\nC#\n````\nusing System;\n\n// Define the Node class\nclass Node\n{\n    public int Data; // Data stored in the node\n    public Node Next; // Pointer to the next node\n    public Node Prev; // Pointer to the previous node\n\n    // Constructor to initialize the node with data\n    public Node(int data)\n    {\n        Data = data;\nNext = null;\n        Prev = null;\n}\n}\n\n// Class to manage the doubly linked list\nclass GfG\n{\n    // Function to traverse the doubly linked list\n  \t//in forward direction\n    static void ForwardTraversal(Node head)\n    {\n        // Start traversal from the head of the list\n        Node curr = head;\n\n// Continue until the current node is null\n      \t//(end of the list)\n        while (curr != null)\n        {\n            // Output data of the current node\n            Console.Write(curr.Data + \" \");\n\n// Move to the next node\n            curr = curr.Next;\n}\n\n        // Print newline after traversal\n        Console.WriteLine();\n}\n\n    // Function to traverse the doubly linked list\n  \t//in backward direction\n    static void BackwardTraversal(Node tail)\n    {\n        // Start traversal from the tail of the list\n        Node curr = tail;\n\n// Continue until the current node is null\n      \t//(end of the list)\n        while (curr != null)\n        {\n            // Output data of the current node\n            Console.Write(curr.Data + \" \");\n\n// Move to the previous node\n            curr = curr.Prev;\n}\n\n        // Print newline after traversal\n        Console.WriteLine();\n}\n\n    public static void Main()\n    {\n        // Sample usage of the doubly linked list\n      \t//and traversal functions\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.Next = second;\nsecond.Prev = head;\nsecond.Next = third;\n        third.Prev = second;\n\n        Console.WriteLine(\"Forward Traversal:\");\n        ForwardTraversal(head);\n\n        Console.WriteLine(\"Backward Traversal:\");\n        BackwardTraversal(third);\n}\n}\n\n````\n\nJavaScript\n````\n// Define the Node class\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n}\n}\n\n// Function to traverse the doubly linked list\n// in forward direction\nfunction forwardTraversal(head) {\n\n    // Start traversal from the head of the list\n    let curr = head;\n\n// Continue until the current node is null\n    // (end of the list)\n    while (curr !== null) {\n\n        // Output data of the current node\n        console.log(curr.data + \" \");\n\n// Move to the next node\n        curr = curr.next;\n}\n\n    // Print newline after traversal\n    console.log();\n}\n\n// Function to traverse the doubly linked list\n// in backward direction\nfunction backwardTraversal(tail) {\n\n    // Start traversal from the tail of the list\n    let curr = tail;\n\n// Continue until the current node is null\n    // (end of the list)\n    while (curr !== null) {\n\n        // Output data of the current node\n        console.log(curr.data + \" \");\n\n// Move to the previous node\n        curr = curr.prev;\n}\n\n    // Print newline after traversal\n    console.log();\n}\n\n// Sample usage of the doubly linked list\n//and traversal functions\n// Create a doubly linked list with 3 nodes\nconst head = new Node(1);\nconst second = new Node(2);\nconst third = new Node(3);\n\nhead.next = second;\nsecond.prev = head;\nsecond.next = third;\nthird.prev = second;\n\nconsole.log(\"Forward Traversal:\");\nforwardTraversal(head);\n\nconsole.log(\"Backward Traversal:\");\nbackwardTraversal(third);\n\n````\n\n\n\n**Output**\n```\n\nForward Traversal:\n1 2 3\nBackward Traversal:\n3 2 1\n\n```\n\n[Finding Length of Doubly Linked List](https://www.geeksforgeeks.org/program-find-size-doubly-linked-list/)\n-----------------------------------------------------------------------------------------------------------\n\nTo find the length of doubly list, we can use the following\nsteps:\n\n* Start at the head of the list.\n* Traverse through the list, counting each node visited.\n* Return the total count of nodes as the length of the list.\n\nBelow are the implementation of the above approach:\n\nC++\n````\n#include <iostream>\n\nusing namespace std;\n\n// Node structure for doubly linked list\nstruct Node {\n    int data;\n    Node * prev;\n    Node * next;\n\n    Node(int val) {\n        data = val;\n        prev = next = nullptr;\n}\n};\n\n// Function to find the length of a doubly\n//linked list\nint findLength(Node * head) {\n    int count = 0;\nfor (Node * cur = head; cur != nullptr; cur = cur -> next)\n        count++;\nreturn count;\n}\n\nint main() {\n\n    // Create a DLL with 3 nodes\n    Node * head = new Node(1);\n    Node * second = new Node(2);\n    Node * third = new Node(3);\n    head -> next = second;\nsecond -> prev = head;\nsecond -> next = third;\n    third -> prev = second;\n\n    cout << \"Length of the doubly linked list: \" <<\n        findLength(head) << endl;\n\nreturn 0;\n}\n\n````\n\nC\n````\n#include <stdio.h>\n#include <stdlib.h>\n\n// Node structure for doubly linked list\nstruct Node {\n    int data; // Data stored in the node\n    struct Node* prev; // Pointer to the previous node\n    struct Node* next; // Pointer to the next node\n};\n\n// Constructor function to create a new node\nstruct Node* createNode(int val) {\n    struct Node* newNode =\n         (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = val;\n    newNode->prev = NULL;\n    newNode->next = NULL;\nreturn newNode;\n}\n\n// Function to find the length of a doubly linked list\nint findLength(struct Node* head) {\n    int count = 0;\nfor (struct Node* cur = head; cur != NULL; cur = cur->next)\n        count++;\nreturn count;\n}\n\nint main() {\n    // Create a DLL with 3 nodes\n    struct Node* head = createNode(1);\n    struct Node* second = createNode(2);\n    struct Node* third = createNode(3);\n\n    head->next = second;\nsecond->prev = head;\nsecond->next = third;\n    third->prev = second;\n\n    printf(\"Length of the doubly linked list: %d\\n\",\n           findLength(head));\n\nreturn 0;\n}\n\n````\n\nJava\n````\nclass Node {\n    int data;\n    Node prev;\n    Node next;\n\n// Constructor\n    public Node(int val) {\n        data = val;\n        prev = null;\nnext = null;\n}\n}\n\nclass GfG {\n\n    // Function to find the length of\n    // a doubly linked list\n    static int FindLength(Node head) {\n        int count = 0;\nfor (Node cur = head; cur != null; cur = cur.next)\n            count++;\nreturn count;\n}\n\n    // Driver code\n    public static void main(String[] args) {\n\n        // Create a doubly linked list\n        // with 3 nodes\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.next = second;\nsecond.prev = head;\nsecond.next = third;\n        third.prev = second;\n\n        System.out.println(\"Length of doubly linked list: \"\n                           + FindLength(head));\n}\n}\n\n````\n\nPython\n````\nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.prev = None\n        self.next = None\n\n# Function to find the length of\n# a doubly linked list\ndef find_length(head):\n    count = 0\n    cur = head\n    while cur is not None:\n        count += 1\n        cur = cur.next\n    return count\n\n# Driver code\nif __name__ == \"__main__\":\n\n    # Create a doubly linked list\n    # with 3 nodes\n    head = Node(1)\n    second = Node(2)\n    third = Node(3)\n\n    head.next = second\n    second.prev = head\n    second.next = third\n    third.prev = second\n\n    print(\"Length of the doubly linked list: \" +\n          str(find_length(head)))\n\n````\n\nC#\n````\nusing System;\n\nclass Node {\n    public int data;\npublic Node prev;\npublic Node next;\n\n// Constructor\n    public Node(int val) {\n        data = val;\n        prev = null;\nnext = null;\n}\n}\n\npublic class GfG {\n\n    // Function to find the length of\n    // a doubly linked list\n    static int FindLength(Node head) {\n        int count = 0;\nfor (Node cur = head; cur != null; cur = cur.next)\n            count++;\nreturn count;\n}\n\n    // Driver code\n    public static void Main(string[] args) {\n\n        // Create a doubly linked list\n        // with 3 nodes\n        Node head = new Node(1);\n        Node second = new Node(2);\n        Node third = new Node(3);\n\n        head.next = second;\nsecond.prev = head;\nsecond.next = third;\n        third.prev = second;\n\n        Console.WriteLine(\"Length of doubly linked list: \"\n                                 + FindLength(head));\n}\n}\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(val) {\n        this.data = val;\n        this.prev = null;\n        this.next = null;\n}\n}\n\n// Function to find the length of\n// a doubly linked list\nfunction findLength(head) {\n    let count = 0;\n    let cur = head;\n    while (cur !== null) {\n        count++;\n        cur = cur.next;\n}\n    return count;\n}\n\n// Create a doubly linked list with 3 nodes\nconst head = new Node(1);\nconst second = new Node(2);\nconst third = new Node(3);\n\nhead.next = second;\nsecond.prev = head;\nsecond.next = third;\nthird.prev = second;\n\nconsole.log(\"Length of the doubly linked list: \" +\n            findLength(head));\n\n````\n\n\n\n\n\n**Output**\n```\n\nLength of the doubly linked list: 3\n\n```\n\n[Insertion at the Beginning in Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-frontbeginning-of-doubly-linked-list/)\n----------------------------------------------------------------------------------------------------------------------------------------\n\n![Insertion-at-the-Beginning-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809123903/Insertion-at-the-Beginning-in-Doubly-Linked-List.webp)\n\nInsertion at the Beginning in Doubly Linked List\n\n\nTo insert a new node at the beginning of the doubly list, we can use\nthe following steps:\n\n* Create a new node, say ****new\\_node****with the given data and set its previous pointer to null, ****new\\_node->prev =**** ****NULL****.\n* Set the next pointer of new\\_node to current head, ****new\\_node->next = head.****\n* If the linked list is not empty, update the previous pointer of the\n                                                                                                                                                                                                                current head to new\\_node, ****head->prev = new\\_node****.\n                                                                                                                                                                                                                * Return new\\_node as the head of the updated linked list.\n\n                                                                                                                                                                                                                Below are the implementation of the above approach:\n\n                                                                                                                                                                                                                C++\n                                                                                                                                                                                                                ````\n                                                                                                                                                                                                                // C++ Program to insert a new node at the\n                                   // beginning of doubly linked list\n\n                                   #include <iostream>\n                                   using namespace std;\n\n// Node structure for the doubly linked list\nstruct Node {\n    int data;\n    Node* prev;\n    Node* next;\n\n    Node(int d) {\n      data = d;\n      prev = next = NULL;\n}\n};\n\n// Insert a node at the beginning\nNode* insertBegin(Node* head, int data) {\n\n    // Create a new node\n    Node* new_node = new Node(data);\n\n// Make next of it as head\n    new_node->next = head;\n\n// Set previous of head as new node\n    if (head != NULL) {\n        head->prev = new_node;\n}\n\n    // Return new node as new head\n    return new_node;\n}\n\nvoid printList(Node* head) {\n    Node* curr = head;\n    while (curr != NULL) {\n        cout << curr->data << \" \";\n        curr = curr->next;\n}\n  \tcout << \"\\n\";\n}\n\nint main() {\n\n    // Create a hardcoded linked list:\n  \t// 2 <-> 3 <-> 4\n    Node* head = new Node(2);\n    Node* temp1 = new Node(3);\n    Node* temp2 = new Node(4);\n    head->next = temp1;\n    temp1->prev = head;\n    temp1->next = temp2;\n    temp2->prev = temp1;\n\n// Print the original list\n    cout << \"Original Linked List: \";\n    printList(head);\n\n// Insert a new node at the front of the list\n    head = insertBegin(head, 1);\n\n// Print the updated list\n  \tcout << \"After inserting Node 1 at the front: \";\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nC\n````\n// C Program to insert a node at the beginning\n//of doubly linked list\n\n\n#include <stdio.h>\n\n// Node structure for the doubly linked list\nstruct Node {\n    int data;\n    struct Node* prev;\n    struct Node* next;\n};\n\n// Create a new node\nstruct Node* createNode(int data) {\n    struct Node* new_node =\n      (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = data;\n    new_node->prev = NULL;\n    new_node->next = NULL;\nreturn new_node;\n}\n\n// Insert a node at the beginning\nstruct Node* insertBegin(struct Node* head, int data) {\n\n    // Create a new node\n    struct Node* new_node = createNode(data);\n\n// Make next of it as head\n    new_node->next = head;\n\n// Set previous of head as new node\n    if (head != NULL) {\n        head->prev = new_node;\n}\n\n    // Return new node as new head\n    return new_node;\n}\n\n// Print the doubly linked list\nvoid printList(struct Node* head) {\n    struct Node* curr = head;\n    while (curr != NULL) {\n        printf(\"%d \", curr->data);\n        curr = curr->next;\n}\n  \tprintf(\"\\n\");\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 2 <-> 3 <-> 4\n    struct Node *head = createNode(2);\n    head->next = createNode(3);\n    head->next->prev = head;\n    head->next->next = createNode(4);\n    head->next->next->prev = head->next;\n\n// Print the original list\n    printf(\"Original Linked List: \");\n    printList(head);\n\n// Insert a new node at the front of the list\n    head = insertBegin(head, 1);\n\n// Print the updated list\n  \tprintf(\"After inserting Node 1 at the front: \");\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nJava\n````\n// Java Program to insert a node at the beginning of a\n// doubly linked list\n\nclass Node {\n    int data;\n    Node prev, next;\n\n// Node structure for the doubly linked list\n    Node(int d) {\n        data = d;\n        prev = null;\nnext = null;\n}\n}\n\nclass GfG {\n\n    // Insert a node at the beginning\n    static Node insertBegin(Node head, int data) {\n\n        // Create a new node\n        Node new_node = new Node(data);\n\n// Make next of it as head\n        new_node.next = head;\n\n// Set previous of head as new node\n        if (head != null) {\n            head.prev = new_node;\n}\n\n        // Return new node as new head\n        return new_node;\n}\n\n    // Print the doubly linked list\n    static void printList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            System.out.print(curr.data + \" \");\n            curr = curr.next;\n}\n      \tSystem.out.println();\n}\n\n    public static void main(String[] args) {\n\n        // Create a hardcoded doubly linked list:\n        // 2 <-> 3 <-> 4\n        Node head = new Node(2);\n        head.next = new Node(3);\n        head.next.prev = head;\n        head.next.next = new Node(4);\n        head.next.next.prev = head.next;\n\n// Print the original list\n        System.out.print(\"Original Linked List: \");\n        printList(head);\n\n// Insert a new node at the front of the list\n        head = insertBegin(head, 1);\n\n// Print the updated list\n      \tSystem.out.print(\n            \"After inserting Node 1 at the front: \");\n        printList(head);\n}\n}\n\n````\n\nPython\n````\n# Python Program to insert a node at the beginning\n#of doubly linked list\n\n# Node structure for the doubly linked list\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n# Insert a node at the beginning\ndef insertBegin(head, data):\n\n    # Create a new node\n    new_node = Node(data)\n\n    # Make next of it as head\n    new_node.next = head\n\n    # Set previous of head as new node\n    if head is not None:\n        head.prev = new_node\n\n    # Return new node as new head\n    return new_node\n\n# Print the doubly linked list\ndef printList(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\" \")\n        curr = curr.next\n    print()\n\nif __name__ == \"__main__\":\n\n    # Create a hardcoded doubly linked list:\n    # 2 <-> 3 <-> 4\n    head = Node(2)\n    head.next = Node(3)\n    head.next.prev = head\n    head.next.next = Node(4)\n    head.next.next.prev = head.next\n\n    # Print the original list\n    print(\"Original Linked List:\", end=' ')\n    printList(head)\n\n    # Insert a new node at the front of the list\n    head = insertBegin(head, 1)\n\n    # Print the updated list\n    print(\"After inserting Node 1 at the front:\", end=' ')\n    printList(head)\n\n````\n\nC#\n````\n// C# Program to insert a node at the beginning of a\n// doubly linked list\n\nusing System;\n\n// Node structure for the doubly linked list\nclass Node {\n    public int data;\npublic Node prev, next;\n\n// Constructor for creating a new node\n    public Node(int d) {\n        data = d;\n        prev = null;\nnext = null;\n}\n}\n\nclass GfG {\n\n    // Insert a node at the beginning\n    public static\n    Node insertBegin(Node head, int data) {\n\n        // Create a new node\n        Node new_node = new Node(data);\n\n// Make next of it as head\n        new_node.next = head;\n\n// Set previous of head as new node\n        if (head != null) {\n            head.prev = new_node;\n}\n\n        // Return new node as new head\n        return new_node;\n}\n\n    // Print the doubly linked list\n    public static void printList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            Console.Write(curr.data + \" \");\n            curr = curr.next;\n}\n      \tConsole.WriteLine();\n}\n\n    public static void Main(string[] args) {\n\n        // Create a hardcoded doubly linked list:\n        // 2 <-> 3 <-> 4\n        Node head = new Node(2);\n        head.next = new Node(3);\n        head.next.prev = head;\n        head.next.next = new Node(4);\n        head.next.next.prev = head.next;\n\n// Print the original list\n        Console.Write(\"Original Linked List: \");\n        printList(head);\n\n// Insert a new node at the front of the list\n        head = insertBegin(head, 1);\n\n// Print the updated list\n      \tConsole.Write\n        (\"After inserting Node 1 at the front: \");\n        printList(head);\n}\n}\n\n````\n\nJavaScript\n````\n// JavaScript Program to insert a node at the\n//beginning of doubly linked list\n\n// Node structure for the doubly linked list\nfunction Node(data) {\n    this.data = data;\n    this.prev = null;\n    this.next = null;\n}\n\n// Insert a node at the beginning\nfunction insertBegin(head, data) {\n\n    // Create a new node\n    const new_node = new Node(data);\n\n// Make next of it as head\n    new_node.next = head;\n\n// Set previous of head as new node\n    if (head !== null) {\n        head.prev = new_node;\n}\n\n    // Return new node as new head\n    return new_node;\n}\n\n// Print the doubly linked list\nfunction printList(head) {\n    let curr = head;\n    while (curr !== null) {\n        console.log(curr.data);\n        curr = curr.next;\n}\n}\n\n// Create a hardcoded doubly linked list:\n// 2 <-> 3 <-> 4\nlet head = new Node(2);\nhead.next = new Node(3);\nhead.next.prev = head;\nhead.next.next = new Node(4);\nhead.next.next.prev = head.next;\n\n// Print the original list\nconsole.log(\"Original Linked List:\");\nprintList(head);\n\n// Insert a new node at the front of the list\nconsole.log\n(\"After inserting Node 1 at the front:\");\nlet data = 1;\nhead = insertBegin(head, data);\n\n// Print the updated list\nprintList(head);\n\n````\n\n\n\n\n\n\n\n\n**Output**\n```\n\nOriginal Linked List: 2 3 4\nAfter inserting Node 1 at the front: 1 2 3 4\n\n```\n\n[Insertion at the End of Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-the-end-of-doubly-linked-list/)\n---------------------------------------------------------------------------------------------------------------------------\n\n![Insertion-at-the-End-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809123955/Insertion-at-the-End-in-Doubly-Linked-List.webp)\n\nInsertion at the End in the Doubly Linked List\n\n\nTo insert a new node at the end of the doubly linked list, we can use\nthe following steps:\n\n* Allocate memory for a new node and assign the provided value to its\n  data field.\n* Initialize the next pointer of the new node to nullptr.\n* If the list is empty:\n  + Set the previous pointer of the new node to nullptr.\n  + Update the head pointer to point to the new node.\n                                                                                          * If the list is not empty:\n                                                                                          + Traverse the list starting from the head to reach the last\n                                                                                          node.\n                                                                                          + Set the next pointer of the last node to point to the new\n                                                                                          node.\n                                                                                          + Set the previous pointer of the new node to point to the last\n                                                                                          node.\n\n                                                                                          Below are the implementation of the above approach:\n\n                                                                                          C++\n                                                                                          ````\n                                                                                          // C++ Program to insert a node at the end of\n//doubly linked list\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node *next, *prev;\n\n    Node(int new_data) {\n        data = new_data;\nnext = prev = nullptr;\n}\n};\n\n// Function to insert a new node at the end of\n//doubly linked list\nNode *insertEnd(Node *head, int new_data) {\n\n    // Create a new node\n    Node *new_node = new Node(new_data);\n\n// If the linked list is empty, set the new\n  \t//node as the head of linked list\n    if (head == NULL) {\n        head = new_node;\n}\n    else {\n          Node *curr = head;\n        while (curr->next != NULL) {\n            curr = curr->next;\n}\n\n        // Set the next of last node to new node\n        curr->next = new_node;\n\n// Set prev of new node to last node\n        new_node->prev = curr;\n}\n\n    // Return the head of the doubly linked list\n    return head;\n}\n\nvoid printList(Node *head) {\n    Node *curr = head;\n    while (curr != NULL) {\n        cout << curr->data << \" \";\n        curr = curr->next;\n}\n    cout << endl;\n}\n\nint main() {\n\n    // Create a harcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->prev = head;\n    head->next->next = new Node(3);\n    head->next->next->prev = head->next;\n\n// Print the original list\n    cout << \"Original Linked List: \";\n    printList(head);\n\n// Insert a new node with data 4 at the end\n    cout << \"Inserting Node with data 4 at the end: \";\nint data = 4;\n    head = insertEnd(head, data);\n\n// Print the updated list\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nC\n````\n// C Program to insert a node at the end of\n//doubly linked list\n\n#include <stdio.h>\n\nstruct Node {\n    int data;\n    struct Node *next;\n    struct Node *prev;\n};\n\n// Function to create a new node with the given data\nstruct Node *createNode(int new_data) {\n    struct Node *new_node =\n    (struct Node *)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\nreturn new_node;\n}\n\n// Function to insert a new node at the end of the\n//doubly linked list\nstruct Node* insertEnd(struct Node *head, int new_data) {\n    struct Node *new_node = createNode(new_data);\n\n// If the linked list is empty, set the\n \t//new node as the head\n    if (head == NULL) {\n        head = new_node;\n} else {\n        struct Node *curr = head;\n        while (curr->next != NULL) {\n            curr = curr->next;\n}\n\n        // Set the next of last node to new node\n        curr->next = new_node;\n// Set prev of new node to last node\n        new_node->prev = curr;\n}\n\n    return head;\n}\n\nvoid printList(struct Node *head) {\n    struct Node *curr = head;\n    while (curr != NULL) {\n        printf(\"%d \", curr->data);\n        curr = curr->next;\n}\n    printf(\"\\n\");\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->prev = head;\n    head->next->next = createNode(3);\n    head->next->next->prev = head->next;\n\n// Print the original list\n    printf(\"Original Linked List: \");\n    printList(head);\n\n// Insert a new node with data 4 at the end\n    printf(\"Inserting Node with data 4 at the end: \");\n    head = insertEnd(head, 4);\n\n// Print the updated list\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nJava\n````\n// Java Program to insert a node at the end of\n// doubly linked list\n\nclass Node {\n    int data;\n    Node next, prev;\n\n    Node(int newData) {\n        data = newData;\nnext = prev = null;\n}\n}\n\nclass GFG {\n\n    // Function to insert a new node at the end of the\n    // doubly linked list\n    public static Node insertEnd(Node head, int newData) {\n\n        // Create a new node\n        Node newNode = new Node(newData);\n\n// If the linked list is empty, set the new node as\n        // the head\n        if (head == null) {\n            head = newNode;\n}\n        else {\n            Node curr = head;\n            while (curr.next != null) {\n                curr = curr.next;\n}\n\n            // Set the next of last node to the new node\n            curr.next = newNode;\n\n// Set the prev of new node to the last node\n            newNode.prev = curr;\n}\n\n        return head;\n}\n\n    // Function to print the doubly linked list\n    public static void printList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            System.out.print(curr.data + \" \");\n            curr = curr.next;\n}\n        System.out.println();\n}\n\n    public static void main(String[] args) {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.prev = head;\n        head.next.next = new Node(3);\n        head.next.next.prev = head.next;\n\n// Print the original list\n        System.out.println(\"Original Linked List: \");\n        printList(head);\n\n// Insert a new node with data 4 at the end\n        System.out.println(\n            \"Inserting Node with data 4 at the end: \");\nint data = 4;\n        head = insertEnd(head, data);\n\n// Print the updated list\n        printList(head);\n}\n}\n\n````\n\nPython\n````\n# Python Program to insert a node at the end of\n#doubly linked list\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\n# Function to insert a new node at the end of the\n#doubly linked list\ndef insert_end(head, new_data):\n\n    # Create a new node\n    new_node = Node(new_data)\n\n    # If the linked list is empty, set the new node\n    #as the head\n    if head is None:\n        head = new_node\n    else:\n        curr = head\n        while curr.next is not None:\n            curr = curr.next\n\n        # Set the next of the last node to the new node\n        curr.next = new_node\n\n        # Set the prev of the new node to the last node\n        new_node.prev = curr\n\n    return head\n\ndef print_list(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\" \")\n        curr = curr.next\n    print()\n\nif __name__ == \"__main__\":\n\n    # Create a hardcoded doubly linked list:\n    # 1 <-> 2 <-> 3\n    head = Node(1)\n    head.next = Node(2)\n    head.next.prev = head\n    head.next.next = Node(3)\n    head.next.next.prev = head.next\n\n    # Print the original list\n    print(\"Original Linked List: \", end=\"\")\n    print_list(head)\n\n    # Insert a new node with data 4 at the end\n    print(\"Inserting Node with data 4 at the end: \", end=\"\")\n    data = 4\n    head = insert_end(head, data)\n\n    # Print the updated list\n    print_list(head)\n\n````\n\nC#\n````\n// C# Program to insert a node at the end of\n//doubly linked list\n\nusing System;\n\nclass Node {\n    public int Data;\npublic Node Next;\npublic Node Prev;\n\npublic Node(int data) {\n        Data = data;\nNext = null;\n        Prev = null;\n}\n}\n\nclass GFG {\n\n    // Function to insert a new node at the end\n  \t//of the doubly linked list\n    public static Node InsertEnd(Node head, int newData) {\n\n          // Create a new node\n        Node newNode = new Node(newData);\n\n// If the linked list is empty, set the\n      \t//new node as the head\n        if (head == null) {\n            head = newNode;\n}\n        else {\n            Node curr = head;\n            while (curr.Next != null) {\n                curr = curr.Next;\n}\n\n            // Set the next of the last node to\n          \t//the new node\n            curr.Next = newNode;\n\n// Set the prev of the new node to\n          \t//the last node\n            newNode.Prev = curr;\n}\n\n        return head;\n}\n\n    // Function to print the doubly linked list\n    public static void PrintList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            Console.Write(curr.Data + \" \");\n            curr = curr.Next;\n}\n        Console.WriteLine();\n}\n\n    static void Main() {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.Next = new Node(2);\n        head.Next.Prev = head;\n        head.Next.Next = new Node(3);\n        head.Next.Next.Prev = head.Next;\n\n// Print the original list\n        Console.Write(\"Original Linked List: \");\n        PrintList(head);\n\n// Insert a new node with data 4 at the end\n        Console.Write(\"Inserting Node with data 4 at the end: \");\nint data = 4;\n        head = InsertEnd(head, data);\n\n// Print the updated list\n        PrintList(head);\n}\n}\n\n````\n\nJavaScript\n````\n// Javascript Program to insert a node at the end of\n//doublylinked list\n\nclass Node {\n    constructor(data)\n    {\n        this.data = data;\n        this.next = null;\n        this.prev = null;\n}\n}\n\nfunction insertEnd(head, newData) {\n\n    // Create a new node\n    const newNode = new Node(newData);\n\n// If the linked list is empty, set the\n    //new node as the head\n    if (head === null) {\n        head = newNode;\n}\n    else {\n        let curr = head;\n        while (curr.next !== null) {\n            curr = curr.next;\n}\n\n        // Set the next of the last node to the\n        //new node\n        curr.next = newNode;\n\n// Set the prev of the new node to the\n        //last node\n        newNode.prev = curr;\n}\n\n    return head;\n}\n\nfunction printList(head)\n{\n    let curr = head;\n    let result = \"\";\n    while (curr !== null) {\n        result += curr.data + \" \";\n        curr = curr.next;\n}\n    console.log(result.trim());\n}\n\n// Create a hardcoded doubly linked list:\n// 1 <-> 2 <-> 3\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.prev = head;\nhead.next.next = new Node(3);\nhead.next.next.prev = head.next;\n\n// Print the original list\nconsole.log(\"Original Linked List: \");\nprintList(head);\n\n// Insert a new node with data 4 at the end\nconsole.log(\"Inserting Node with data 4 at the end: \");\nconst data = 4;\nhead = insertEnd(head, data);\n\n// Print the updated list\nprintList(head);\n\n````\n\n\n\n\n**Output**\n```\n\nOriginal Linked List: 1 2 3\nInserting Node with data 4 at the end: 1 2 3 4\n\n```\n\n[Insertion at a Specific Position in Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-a-specific-position-in-doubly-linked-list/)\n---------------------------------------------------------------------------------------------------------------------------------------------------\n\nTo insert a node at a specific Position in doubly linked list, we can\nuse the following steps:\n\n![Insertion-at-a-Specific-Position-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124039/Insertion-at-a-Specific-Position-in-Doubly-Linked-List.webp)\n\n\nInsertion at a Specific Position in Doubly Linked List\n\n\n\nTo insert a new node at a specific position,\n\n* If position = 1, create a new node and make it the head of the linked\n  list and return it.\n* Otherwise, traverse the list to reach the node at position \u2013 1,\n  say ****curr****.\n* If the position is valid, create a new node with given data,\n  say ****new\\_node****.\n* Update the next pointer of new node to the next\n                                                                                                                                             of current node and prev pointer of new node to current\n                                                                                                                                             node, ****new\\_node->next = curr->next****and ****new\\_node->prev = curr.****\n                                                                                                                                             * Similarly, update next pointer of current node to\n                                                                                                                                                              thenew node, ****curr->next = new\\_node****.\n                                                                                                                                                              * If the new node is not the last node, update prev pointer of new\n                                                                                                                                                                                                          node\u2019s next to the new node, ****new\\_node->next->prev = new\\_node.****\n\n                                                                                                                                                                                                          Below is the implementation of the above approach:\n\n                                                                                                                                                                                                          C++\n                                                                                                                                                                                                          ````\n                                                                                                                                                                                                          // C++ Program to insert a node at a given position\n\n                                                                                                                                                                                                      #include <bits/stdc++.h>\n                                                                                                                                                                                                      using namespace std;\n\nstruct Node {\n    int data;\n    Node *next, *prev;\n\n    Node(int new_data) {\n        data = new_data;\nnext = prev = nullptr;\n}\n};\n\n// Function to insert a new node at a given position\nNode *insertAtPosition(Node *head, int pos, int new_data) {\n\n    // Create a new node\n    Node *new_node = new Node(new_data);\n\n// Insertion at the beginning\n    if (pos == 1) {\n        new_node->next = head;\n\n// If the linked list is not empty, set the prev\n      \t//of head to new node\n        if (head != NULL)\n            head->prev = new_node;\n\n// Set the new node as the head of linked list\n        head = new_node;\nreturn head;\n}\n\n    Node *curr = head;\n// Traverse the list to find the node before the\n    // insertion point\n    for (int i = 1; i < pos - 1 && curr != NULL; ++i) {\n        curr = curr->next;\n}\n\n    // If the position is out of bounds\n    if (curr == NULL) {\n        cout << \"Position is out of bounds.\" << endl;\n        delete new_node;\nreturn head;\n}\n\n    // Set the prev of new node to curr\n    new_node->prev = curr;\n\n// Set the new of new node to next of curr\n    new_node->next = curr->next;\n\n// Update the next of current node to new node\n       curr->next = new_node;\n\n// If the new node is not the last node, update prev\n                                             //of next node to new node\n                                             if (new_node->next != NULL)\n                                             new_node->next->prev = new_node;\n\n// Return the head of the doubly linked list\n    return head;\n}\n\nvoid printList(Node *head) {\n    Node *curr = head;\n    while (curr != NULL) {\n        cout << curr->data << \" \";\n        curr = curr->next;\n}\n    cout << endl;\n}\n\nint main() {\n\n    // Create a harcoded doubly linked list:\n    // 1 <-> 2 <-> 4\n    Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->prev = head;\n    head->next->next = new Node(4);\n    head->next->next->prev = head->next;\n\n// Print the original list\n    cout << \"Original Linked List: \";\n    printList(head);\n\n// Insert new node with data 3 at position 3\n    cout << \"Inserting Node with data 3 at position 3: \";\nint data = 3;\nint pos = 3;\n    head = insertAtPosition(head, pos, data);\n\n// Print the updated list\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nC\n````\n// C Program to insert a node at a given position\n\n#include <stdio.h>\n\nstruct Node {\n    int data;\n    struct Node * next;\n    struct Node * prev;\n};\n\n// Function to create a new node with the given data\nstruct Node * createNode(int new_data) {\n    struct Node * new_node =\n        (struct Node * ) malloc(sizeof(struct Node));\n    new_node -> data = new_data;\n    new_node -> next = NULL;\nreturn new_node;\n}\n\n// Function to insert a new node at a given position\nstruct Node * insertAtPosition(struct Node * head, int pos, int new_data) {\n    // Create a new node\n    struct Node * new_node = createNode(new_data);\n\n// Insertion at the beginning\n    if (pos == 1) {\n        new_node -> next = head;\n\n// If the linked list is not empty, set the\n      //prev of head to new node\n        if (head != NULL) {\n            head -> prev = new_node;\n}\n\n        // Set the new node as the head of linked list\n        head = new_node;\nreturn head;\n}\n\n    struct Node * curr = head;\n\n// Traverse the list to find the node before the insertion point\n    for (int i = 1; i < pos - 1 && curr != NULL; ++i) {\n        curr = curr -> next;\n}\n\n    // If the position is out of bounds\n    if (curr == NULL) {\n        printf(\"Position is out of bounds.\\n\");\n        free(new_node);\nreturn head;\n}\n\n    // Set the prev of new node to curr\n    new_node -> prev = curr;\n\n// Set the next of new node to next of curr\n    new_node -> next = curr -> next;\n\n// Update the next of current node to new node\n       curr -> next = new_node;\n\n// If the new node is not the last node, update\n                                             //the prev of next node to new node\n                                             if (new_node -> next != NULL) {\n                                             new_node -> next -> prev = new_node;\n}\n\n    // Return the head of the doubly linked list\n    return head;\n}\n\n// Function to print the linked list\nvoid printList(struct Node * head) {\n    struct Node * curr = head;\n    while (curr != NULL) {\n        printf(\"%d \", curr -> data);\n        curr = curr -> next;\n}\n    printf(\"\\n\");\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 4\n    struct Node * head = createNode(1);\n    head -> next = createNode(2);\n    head -> next -> prev = head;\n    head -> next -> next = createNode(4);\n    head -> next -> next -> prev = head -> next;\n\n// Print the original list\n    printf(\"Original Linked List: \");\n    printList(head);\n\n// Insert new node with data 3 at position 3\n    printf(\"Inserting Node with data 3 at position 3: \");\nint data = 3;\nint pos = 3;\n    head = insertAtPosition(head, pos, data);\n\n// Print the updated list\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nJava\n````\n// Java Program to insert a node at a given position\n\nclass Node {\n    int data;\n    Node next;\n    Node prev;\n\n    Node(int new_data) {\n        data = new_data;\nnext = prev = null;\n}\n}\n\nclass GFG {\n\n    // Function to insert a new node at a given position\n    public static Node insertAtPosition(Node head, int pos, int new_data) {\n        // Create a new node\n        Node new_node = new Node(new_data);\n\n// Insertion at the beginning\n        if (pos == 1) {\n            new_node.next = head;\n\n// If the linked list is not empty, set\n          \t//the prev of head to new node\n            if (head != null) {\n                head.prev = new_node;\n}\n\n            // Set the new node as the head of linked list\n            head = new_node;\nreturn head;\n}\n\n        Node curr = head;\n\n// Traverse the list to find the node before\n      \t//the insertion point\n        for (int i = 1; i < pos - 1 && curr != null; ++i) {\n            curr = curr.next;\n}\n\n        // If the position is out of bounds\n        if (curr == null) {\n            System.out.println(\"Position is out of bounds.\");\nreturn head;\n}\n\n        // Set the prev of new node to curr\n        new_node.prev = curr;\n\n// Set the next of new node to next of curr\n        new_node.next = curr.next;\n\n// Update the next of current node to new node\n       curr.next = new_node;\n\n// If the new node is not the last node, update\n                                             //prev of next node to new node\n                                             if (new_node.next != null) {\n                                             new_node.next.prev = new_node;\n}\n\n        // Return the head of the doubly linked list\n        return head;\n}\n\n    // Function to print the linked list\n    public static void printList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            System.out.print(curr.data + \" \");\n            curr = curr.next;\n}\n        System.out.println();\n}\n\n    public static void main(String[] args) {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 4\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.prev = head;\n        head.next.next = new Node(4);\n        head.next.next.prev = head.next;\n\n// Print the original list\n        System.out.print(\"Original Linked List: \");\n        printList(head);\n\n// Insert new node with data 3 at position 3\n        System.out.print(\"Inserting Node with data 3 at position 3: \");\nint data = 3;\nint pos = 3;\n        head = insertAtPosition(head, pos, data);\n\n// Print the updated list\n        printList(head);\n}\n}\n\n````\n\nPython\n````\n# Python Program to insert a node at a given position\n\nclass Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n        self.prev = None\n\ndef insert_at_position(head, pos, new_data):\n\n    # Create a new node\n    new_node = Node(new_data)\n\n    # Insertion at the beginning\n    if pos == 1:\n        new_node.next = head\n\n        # If the linked list is not empty, set the\n        #prev of head to new node\n        if head is not None:\n            head.prev = new_node\n\n        # Set the new node as the head of the linked list\n        head = new_node\n        return head\n\n    curr = head\n\n    # Traverse the list to find the node before the\n    #insertion point\n    for _ in range(1, pos - 1):\n        if curr is None:\n            print(\"Position is out of bounds.\")\n            return head\n        curr = curr.next\n\n    # If the position is out of bounds\n    if curr is None:\n        print(\"Position is out of bounds.\")\n        return head\n\n    # Set the prev of new node to curr\n    new_node.prev = curr\n\n    # Set the next of new node to next of curr\n    new_node.next = curr.next\n\n    # Update the next of current node to new node\n                       curr.next = new_node\n\n                       # If the new node is not the last node, update\n                                                                   #prev of next node to new node\n                                                                   if new_node.next is not None:\n                                                                   new_node.next.prev = new_node\n\n                                                                   return head\n\n                                                                   def print_list(head):\n                                                                   curr = head\n                                                                   while curr is not None:\n                                                                   print(curr.data, end=\" \")\n                                                                   curr = curr.next\n                                                                   print()\n\n                                                                   if __name__ == \"__main__\":\n\n                                                                   # Create a hardcoded doubly linked list:\n    # 1 <-> 2 <-> 4\n    head = Node(1)\n    head.next = Node(2)\n    head.next.prev = head\n    head.next.next = Node(4)\n    head.next.next.prev = head.next\n\n    # Print the original list\n    print(\"Original Linked List: \", end=\"\")\n    print_list(head)\n\n    # Insert new node with data 3 at position 3\n    print(\"Inserting Node with data 3 at position 3: \", end=\"\")\n    data = 3\n    pos = 3\n    head = insert_at_position(head, pos, data)\n\n    # Print the updated list\n    print_list(head)\n\n````\n\nC#\n````\n// C# Program to insert a node at a given position\n\nusing System;\n\nclass Node {\n    public int Data;\npublic Node Next;\npublic Node Prev;\n\npublic Node(int data) {\n        Data = data;\nNext = null;\n        Prev = null;\n}\n}\n\nclass GFG {\n\n    // Function to insert a new node at a given position\n    static Node InsertAtPosition(Node head, int pos, int newData) {\n\n        // Create a new node\n        Node newNode = new Node(newData);\n\n// Insertion at the beginning\n        if (pos == 1) {\n            newNode.Next = head;\n            if (head != null)\n                head.Prev = newNode;\n            head = newNode;\nreturn head;\n}\n\n        Node curr = head;\n\n// Traverse the list to find the node\n      \t //before the insertion point\n        for (int i = 1; i < pos - 1 && curr != null; ++i) {\n            curr = curr.Next;\n}\n\n        // If the position is out of bounds\n        if (curr == null) {\n            Console.WriteLine(\"Position is out of bounds.\");\nreturn head;\n}\n\n        // Set the prev of new node to curr\n        newNode.Prev = curr;\n\n// Set the next of new node to the next of curr\n        newNode.Next = curr.Next;\n\n// Update the next of current node to new node\n       curr.Next = newNode;\n\n// If the new node is not the last node, update\n                                             //prev of next node to new node\n                                             if (newNode.Next != null)\n                                             newNode.Next.Prev = newNode;\n\nreturn head;\n}\n\n    // Function to print the list\n    static void PrintList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            Console.Write(curr.Data + \" \");\n            curr = curr.Next;\n}\n        Console.WriteLine();\n}\n\n    static void Main() {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 4\n        Node head = new Node(1);\n        head.Next = new Node(2);\n        head.Next.Prev = head;\n        head.Next.Next = new Node(4);\n        head.Next.Next.Prev = head.Next;\n\n// Print the original list\n        Console.WriteLine(\"Original Linked List: \");\n        PrintList(head);\n\n// Insert new node with data 3 at position 3\n        Console.WriteLine(\"Inserting Node with data 3 at position 3: \");\n        head = InsertAtPosition(head, 3, 3);\n\n// Print the updated list\n        PrintList(head);\n}\n}\n\n````\n\nJavaScript\n````\n// Javascript Program to insert a node at a given position\n\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n        this.prev = null;\n}\n}\n\n// Function to insert a new node at a given position\nfunction insertAtPosition(head, pos, newData) {\n\n    // Create a new node\n    let newNode = new Node(newData);\n\n// Insertion at the beginning\n    if (pos === 1) {\n        newNode.next = head;\n        if (head !== null) {\n            head.prev = newNode;\n}\n        head = newNode;\nreturn head;\n}\n\n    let curr = head;\n\n// Traverse the list to find the node\n    //before the insertion point\n    for (let i = 1; i < pos - 1 && curr !== null; ++i) {\n        curr = curr.next;\n}\n\n    // If the position is out of bounds\n    if (curr === null) {\n        console.log(\"Position is out of bounds.\");\nreturn head;\n}\n\n    // Set the prev of new node to curr\n    newNode.prev = curr;\n\n// Set the next of new node to the next of curr\n    newNode.next = curr.next;\n\n// Update the next of current node to new node\n       curr.next = newNode;\n\n// If the new node is not the last node,\n    // update prev of next node to new node\n           if (newNode.next !== null) {\n           newNode.next.prev = newNode;\n}\n\n    return head;\n}\n\n// Function to print the list\nfunction printList(head) {\n    let curr = head;\n    while (curr !== null) {\n        console.log(curr.data + \" \");\n        curr = curr.next;\n}\n    console.log();\n}\n\n// Create a hardcoded doubly linked list:\n// 1 <-> 2 <-> 4\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.prev = head;\nhead.next.next = new Node(4);\nhead.next.next.prev = head.next;\n\n// Print the original list\nconsole.log(\"Original Linked List:\");\nprintList(head);\n\n// Insert new node with data 3 at position 3\nconsole.log(\"Inserting Node with data 3 at position 3:\");\nhead = insertAtPosition(head, 3, 3);\n\n// Print the updated list\nprintList(head);\n\n````\n\n\n\n\n\n**Output**\n```\n\nOriginal Linked List: 1 2 4\nInserting Node with data 3 at position 3: 1 2 3 4\n\n```\n\n[Deletion at the Beginning of Doubly Linked List](https://www.geeksforgeeks.org/deletion-at-beginning-removal-of-first-node-in-a-doubly-linked-list/)\n-----------------------------------------------------------------------------------------------------------------------------------------------------\n\n![Deletion-at-the-Beginning-of-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124112/Deletion-at-the-Beginning-of-Doubly-Linked-List.webp)\n\nDeletion at the Beginning of Doubly Linked List\n\n\nTo delete a node at the beginning in doubly linked list, we can use the\nfollowing steps:\n\n* Check if the list is empty, there is nothing to delete. Return.\n* Store the head pointer in a variable, say ****temp****.\n* Update the head of linked list to the node next to the current head, ****head = head->next****.\n                                                                        * If the new head is not NULL, update the previous pointer of new head\n                                                                                                           to NULL, ****head->prev = NULL****.\n\n                                                                                                           Below is the implementation of the above approach:\n\n                                                                                                           C++\n                                                                                                           ````\n                                                                                                           // C++ Program to delete a node from the\n// beginning of Doubly Linked List\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node{\n    int data;\n    Node *prev;\n    Node *next;\n    Node(int d) {\n      \tdata = d;\n      \tprev = next = nullptr;\n}\n};\n\n// Deletes the first node (head) of the list\n// and returns the second node as new head\nNode *delHead(Node *head) {\n\n    // If empty, return\n    if (head == nullptr)\n        return nullptr;\n\n// Store in temp for deletion later\n    Node *temp = head;\n\n// Move head to the next node\n    head = head->next;\n\n// Set prev of the new head\n    if (head != nullptr)\n        head->prev = nullptr;\n\n// Free memory and return new head\n    delete temp;\nreturn head;\n}\n\nvoid printList(Node *head) {\n    for (Node *curr = head; curr != nullptr; curr = curr->next)\n        cout << curr->data << \" \";\n    cout << endl;\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    struct Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->prev = head;\n    head->next->next = new Node(3);\n    head->next->next->prev = head->next;\n\n    printf(\"Original Linked List: \");\n    printList(head);\n\n    printf(\"After Deletion at the beginning: \");\n    head = delHead(head);\n\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nC\n````\n// C Program to delete a node from the\n// beginning of Doubly Linked List\n\n#include <stdio.h>\n\nstruct Node {\n    int data;\n    struct Node *prev;\n    struct Node *next;\n};\n\n// Function to create a new node\nstruct Node *createNode(int data) {\n    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->prev = NULL;\n    newNode->next = NULL;\nreturn newNode;\n}\n\n// Function to delete the first node (head) of the list\n// and return the second node as the new head\nstruct Node *delHead(struct Node *head) {\n    // If empty, return NULL\n    if (head == NULL)\n        return NULL;\n\n// Store in temp for deletion later\n    struct Node *temp = head;\n\n// Move head to the next node\n    head = head->next;\n\n// Set prev of the new head\n    if (head != NULL)\n        head->prev = NULL;\n\n// Free memory and return new head\n    free(temp);\nreturn head;\n}\n\nvoid printList(struct Node *head) {\n    struct Node *curr = head;\n    while (curr != NULL) {\n        printf(\"%d \", curr->data);\n        curr = curr->next;\n}\n    printf(\"\\n\");\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->prev = head;\n    head->next->next = createNode(3);\n    head->next->next->prev = head->next;\n\n    printf(\"Original Linked List: \");\n    printList(head);\n\n    printf(\"After Deletion at the beginning: \");\n    head = delHead(head);\n\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nJava\n````\n// Java Program to delete a node from the\n// beginning of Doubly Linked List\n\nclass Node {\n    int data;\n    Node prev;\n    Node next;\n\n    Node(int data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n}\n}\n\nclass GFG {\n\n    // Function to delete the first node (head) of the list\n    // and return the second node as the new head\n    public static Node delHead(Node head) {\n        // If empty, return null\n        if (head == null) {\n            return null;\n}\n\n        // Store in temp for deletion later\n        Node temp = head;\n\n// Move head to the next node\n        head = head.next;\n\n// Set prev of the new head\n        if (head != null) {\n            head.prev = null;\n}\n\n        // Return new head\n        return head;\n}\n\n    public static void printList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            System.out.print(curr.data + \" \");\n            curr = curr.next;\n}\n        System.out.println();\n}\n\n    public static void main(String[] args) {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.prev = head;\n        head.next.next = new Node(3);\n        head.next.next.prev = head.next;\n\n        System.out.print(\"Original Linked List: \");\n        printList(head);\n\n        System.out.print(\"After Deletion at the beginning: \");\n        head = delHead(head);\n\n        printList(head);\n}\n}\n\n````\n\nPython\n````\n# Python Program to delete a node from the\n# beginning of Doubly Linked List\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n# Function to delete the first node (head) of the list\n# and return the second node as the new head\ndef del_head(head):\n\n    # If empty, return None\n    if head is None:\n        return None\n\n    # Store in temp for deletion later\n    temp = head\n\n    # Move head to the next node\n    head = head.next\n\n    # Set prev of the new head\n    if head is not None:\n        head.prev = None\n\n    # Return new head\n    return head\n\ndef print_list(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\" \")\n        curr = curr.next\n    print()\n\n\nif __name__ == \"__main__\":\n\n\t# Create a hardcoded doubly linked list:\n    # 1 <-> 2 <-> 3\n    head = Node(1)\n    head.next = Node(2)\n    head.next.prev = head\n    head.next.next = Node(3)\n    head.next.next.prev = head.next\n\n    print(\"Original Linked List: \", end=\"\")\n    print_list(head)\n\n    print(\"After Deletion at the beginning: \", end=\"\")\n    head = del_head(head)\n\n    print_list(head)\n\n````\n\nC#\n````\n// C# Program to delete a node from the\n// beginning of Doubly Linked List\n\nusing System;\n\nclass Node {\n    public int Data;\npublic Node Prev;\npublic Node Next;\n\npublic Node(int data) {\n        Data = data;\n        Prev = null;\nNext = null;\n}\n}\n\nclass GFG {\n\n    // Deletes the first node (head) of the list\n    // and returns the second node as the new head\n    public static Node DelHead(Node head) {\n\n        // If empty, return null\n        if (head == null)\n            return null;\n\n// Move head to the next node\n        head = head.Next;\n\n// Set prev of the new head\n        if (head != null)\n            head.Prev = null;\n\n// Return new head\n        return head;\n}\n\n    public static void PrintList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            Console.Write(curr.Data + \" \");\n            curr = curr.Next;\n}\n        Console.WriteLine();\n}\n\n    static void Main() {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.Next = new Node(2);\n        head.Next.Prev = head;\n        head.Next.Next = new Node(3);\n        head.Next.Next.Prev = head.Next;\n\n        Console.Write(\"Original Linked List: \");\n        PrintList(head);\n\n        Console.Write(\"After Deletion at the beginning: \");\n        head = DelHead(head);\n\n        PrintList(head);\n}\n}\n\n````\n\nJavaScript\n````\n// JavaScript Program to delete a node from the\n// beginning of Doubly Linked List\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n}\n}\n\n// Deletes the first node (head) of the list and returns the second node as the new head\nfunction delHead(head) {\n    // If empty, return null\n    if (head === null) {\n        return null;\n}\n\n    // Store in temp for deletion later\n    let temp = head;\n\n// Move head to the next node\n    head = head.next;\n\n// Set prev of the new head\n    if (head !== null) {\n        head.prev = null;\n}\n\n    // Return new head\n    return head;\n}\n\n// Function to print the list\nfunction printList(head) {\n    let curr = head;\n    let output = '';\n    while (curr !== null) {\n        output += curr.data + ' ';\n        curr = curr.next;\n}\n    console.log(output.trim());\n}\n\n// Create a hardcoded doubly linked list:\n// 1 <-> 2 <-> 3\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.prev = head;\nhead.next.next = new Node(3);\nhead.next.next.prev = head.next;\n\nconsole.log(\"Original Linked List: \");\nprintList(head);\n\nconsole.log(\"After Deletion at the beginning: \");\nhead = delHead(head);\n\nprintList(head);\n\n````\n\n\n\n**Output**\n```\n\nOriginal Linked List: 1 2 3\nAfter Deletion at the beginning: 2 3\n\n```\n\n[Deletion at the End of Doubly Linked List](https://www.geeksforgeeks.org/deletion-at-end-removal-of-last-node-in-a-doubly-linked-list/)\n----------------------------------------------------------------------------------------------------------------------------------------\n\n![Deletion-at-the-End-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124140/Deletion-at-the-End-in-Doubly-Linked-List.webp)\n\nDeletion at the End in Doubly Linked List\n\n\nTo delete a node at the end in doubly linked list, we can use the\nfollowing steps:\n\n* Check if the doubly linked list is empty. If it is empty, then there\n  is nothing to delete.\n* If the list is not empty, then move to the last node of the doubly\n  linked list, say ****curr****.\n* Update the second-to-last node's next pointer to NULL, ****curr->prev->next = NULL****.\n* Free the memory allocated for the node that was deleted.\n\nBelow is the implementation of the above approach:\n\nC++\n````\n// C++ Program to delete a node from the end of\n//Doubly Linked List\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node *prev;\n    Node *next;\n    Node(int d) {\n        data = d;\n        prev = NULL;\n        next = NULL;\n    }\n};\n\n// Function to delete the last node of the doubly\n// linked list\nNode *delLast(Node *head) {\n\n    // Corner cases\n    if (head == NULL)\n        return NULL;\n    if (head->next == NULL) {\n        delete head;\n        return NULL;\n    }\n\n    // Traverse to the last node\n    Node *curr = head;\n    while (curr->next != NULL)\n        curr = curr->next;\n\n    // Update the previous node's next pointer\n                                                                                         curr->prev->next = NULL;\n\n// Delete the last node\n    delete curr;\n\n// Return the updated head\n    return head;\n}\n\nvoid printList(Node *head) {\n    Node *curr = head;\n    while (curr != NULL) {\n        cout << curr->data << \" \";\n        curr = curr->next;\n}\n    cout << endl;\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    struct Node *head = new Node(1);\n    head->next = new Node(2);\n    head->next->prev = head;\n    head->next->next = new Node(3);\n    head->next->next->prev = head->next;\n\n    printf(\"Original Linked List: \");\n    printList(head);\n\n    printf(\"After Deletion at the end: \");\n    head = delLast(head);\n\n    printList(head);\n\nreturn 0;\n}\n\n````\n\nC\n````\n// C Program to delete a node from the end of\n//Doubly Linked List\n\n#include <stdio.h>\n\nstruct Node {\n    int data;\n    struct Node* prev;\n    struct Node* next;\n};\n\n// Function to delete the last node of the\n//doubly linked list\nstruct Node* delLast(struct Node *head) {\n\n    // Corner cases\n    if (head == NULL)\n        return NULL;\n    if (head->next == NULL) {\n        free(head);\nreturn NULL;\n}\n\n    // Traverse to the last node\n    struct Node *curr = head;\n    while (curr->next != NULL)\n        curr = curr->next;\n\n// Update the previous node's next pointer\n    curr->prev->next = NULL;\n\n    // Delete the last node\n    free(curr);\n\n    // Return the updated head\n    return head;\n}\n\n// Function to print the list\nvoid printList(struct Node *head) {\n    struct Node *curr = head;\n    while (curr != NULL) {\n        printf(\"%d \", curr->data);\n        curr = curr->next;\n    }\n    printf(\"\\n\");\n}\n\n// Function to create a new node\nstruct Node* createNode(int data) {\n    struct Node *newNode =\n      (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = data;\n    newNode->prev = NULL;\n    newNode->next = NULL;\n    return newNode;\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    struct Node *head = createNode(1);\n    head->next = createNode(2);\n    head->next->prev = head;\n    head->next->next = createNode(3);\n    head->next->next->prev = head->next;\n\n    printf(\"Original Linked List: \");\n    printList(head);\n\n    printf(\"After Deletion at the end: \");\n    head = delLast(head);\n\n    printList(head);\n\n    return 0;\n}\n\n````\n\nJava\n````\n// Java Program to delete a node from the end of\n//Doubly Linked List\n\nclass Node {\n    int data;\n    Node prev;\n    Node next;\n\n    Node(int data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n    }\n}\n\nclass GFG {\n\n    // Function to delete the last node of the\n  \t//doubly linked list\n    public static Node delLast(Node head) {\n\n        // Corner cases\n        if (head == null) {\n            return null;\n        }\n        if (head.next == null) {\n            return null;\n        }\n\n        // Traverse to the last node\n        Node curr = head;\n        while (curr.next != null) {\n            curr = curr.next;\n        }\n\n        // Update the previous node's next pointer\n       if (curr.prev != null) {\n       curr.prev.next = null;\n}\n\n        // Return the updated head\n        return head;\n}\n\n    // Function to print the list\n    public static void printList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            System.out.print(curr.data + \" \");\n            curr = curr.next;\n}\n        System.out.println();\n}\n\n    public static void main(String[] args) {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.prev = head;\n        head.next.next = new Node(3);\n        head.next.next.prev = head.next;\n\n        System.out.print(\"Original Linked List: \");\n        printList(head);\n\n        System.out.print(\"After Deletion at the end: \");\n        head = delLast(head);\n\n        printList(head);\n}\n}\n\n````\n\nPython\n````\n# Python Program to delete a node from the end of\n#Doubly Linked List\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\ndef del_last(head):\n\n    # Corner cases\n    if head is None:\n        return None\n    if head.next is None:\n        return None\n\n    # Traverse to the last node\n    curr = head\n    while curr.next is not None:\n        curr = curr.next\n\n    # Update the previous node's next pointer\n    if curr.prev is not None:\n        curr.prev.next = None\n\n    # Return the updated head\n    return head\n\ndef print_list(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\" \")\n        curr = curr.next\n    print()\n\nif __name__ == \"__main__\":\n\n    # Create a hardcoded doubly linked list:\n    # 1 <-> 2 <-> 3\n    head = Node(1)\n    head.next = Node(2)\n    head.next.prev = head\n    head.next.next = Node(3)\n    head.next.next.prev = head.next\n\n    print(\"Original Linked List: \", end=\"\")\n    print_list(head)\n\n    print(\"After Deletion at the end: \", end=\"\")\n    head = del_last(head)\n\n    print_list(head)\n\n````\n\nC#\n````\n// C# Program to delete a node from the end of\n//Doubly Linked List\n\nusing System;\n\nclass Node {\n    public int Data;\n    public Node Prev;\n    public Node Next;\n\n    public Node(int data) {\n        Data = data;\n        Prev = null;\n        Next = null;\n    }\n}\n\nclass GFG {\n\n    // Function to delete the last node of the\n  \t//doubly linked list\n    static Node DelLast(Node head) {\n\n      \t// Corner cases\n        if (head == null)\n            return null;\n        if (head.Next == null) {\n            return null;\n        }\n\n        // Traverse to the last node\n        Node curr = head;\n        while (curr.Next != null)\n            curr = curr.Next;\n\n        // Update the previous node's next pointer\n                                     if (curr.Prev != null)\n                                     curr.Prev.Next = null;\n\n// Delete the last node\n        curr = null;\n\n// Return the updated head\n        return head;\n}\n\n    // Function to print the list\n    static void PrintList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            Console.Write(curr.Data + \" \");\n            curr = curr.Next;\n}\n        Console.WriteLine();\n}\n\n    static void Main() {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.Next = new Node(2);\n        head.Next.Prev = head;\n        head.Next.Next = new Node(3);\n        head.Next.Next.Prev = head.Next;\n\n        Console.Write(\"Original Linked List: \");\n        PrintList(head);\n\n        Console.Write(\"After Deletion at the end: \");\n        head = DelLast(head);\n\n        PrintList(head);\n}\n}\n\n````\n\nJavaScript\n````\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n}\n}\n\n// Function to delete the last node of the\n//doubly linked list\nfunction delLast(head) {\n    // Corner cases\n    if (head === null) return null;\n    if (head.next === null) {\n        // Only one node in the list\n        return null;\n}\n\n    // Traverse to the last node\n    let curr = head;\n    while (curr.next !== null) {\n        curr = curr.next;\n}\n\n    // Update the previous node's next pointer\n    if (curr.prev !== null) {\n        curr.prev.next = null;\n    }\n\n    // Node curr is now deleted (garbage collected in JS)\n    return head;\n}\n\n// Function to print the list\nfunction printList(head) {\n    let curr = head;\n    while (curr !== null) {\n        console.log(curr.data + \" \");\n        curr = curr.next;\n    }\n}\n\n// Create a hardcoded doubly linked list:\n// 1 <-> 2 <-> 3\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.prev = head;\nhead.next.next = new Node(3);\nhead.next.next.prev = head.next;\n\nconsole.log(\"Original Linked List:\");\nprintList(head);\n\nconsole.log(\"After Deletion at the end:\");\nhead = delLast(head);\n\nprintList(head);\n\n````\n\n\n\n\n**Output**\n```\n\nOriginal Linked List: 1 2 3\nAfter Deletion at the end: 1 2\n\n```\n\n[Deletion at a Specific Position in Doubly Linked List](https://www.geeksforgeeks.org/delete-doubly-linked-list-node-given-position)\n------------------------------------------------------------------------------------------------------------------------------------\n\n![Deletion-at-a-Specific-Position-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124205/Deletion-at-a-Specific-Position-in-Doubly-Linked-List.webp)\n\n\nDeletion at a Specific Position in Doubly Linked List\n\n\n\nTo delete a node at a specific position in doubly linked list, we can\nuse the following steps:\n\n* Traverse to the node at the specified position, say ****curr****.\n* If the position is valid, adjust the pointers to skip the node to be\n  deleted.\n  + If curr is not the head of the linked list, update the next\n    pointer of the node before curr to point to the node after curr, ****curr->prev->next = curr-next****.\n  + If curr is not the last node of the linked list, update the\n    previous pointer of the node after curr to the node before curr, ****curr->next->prev = curr->prev****.\n* Free the memory allocated for the deleted node.\n\nBelow is the implementation of the above approach:\n\nC++\n````\n// C++ Program to delete node at a specific position\n// in Doubly Linked List\n\n#include <iostream>\n\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node * prev;\n    Node * next;\n    Node(int d) {\n        data = d;\n        prev = next = NULL;\n    }\n};\n\n// Function to delete a node at a specific position\n// in the doubly linked list\nNode * delPos(Node * head, int pos) {\n\n    // If the list is empty\n    if (!head)\n        return head;\n\n    Node * curr = head;\n\n    // Traverse to the node at the given position\n    for (int i = 1; curr && i < pos; ++i) {\n        curr = curr -> next;\n    }\n\n    // If the position is out of range\n    if (!curr)\n        return head;\n\n    // Update the previous node's next pointer\n           if (curr -> prev)\n           curr -> prev -> next = curr -> next;\n\n// Update the next node's prev pointer\n    if (curr -> next)\n        curr -> next -> prev = curr -> prev;\n\n    // If the node to be deleted is the head node\n    if (head == curr)\n        head = curr -> next;\n\n    // Deallocate memory for the deleted node\n    delete curr;\n    return head;\n}\n\n// Function to print the doubly linked list\nvoid printList(Node * head) {\n    Node * curr = head;\n    while (curr != nullptr) {\n        cout << curr -> data << \" \";\n        curr = curr -> next;\n    }\n    cout << endl;\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    struct Node * head = new Node(1);\n    head -> next = new Node(2);\n    head -> next -> prev = head;\n    head -> next -> next = new Node(3);\n    head -> next -> next -> prev = head -> next;\n\n    cout << \"Original Linked List: \";\n    printList(head);\n\n    cout << \"After Deletion at the position 2: \";\n    head = delPos(head, 2);\n\n    printList(head);\n\n    return 0;\n}\n\n````\n\nC\n````\n// C Program to delete node at a specific position\n//in Doubly Linked List\n\n#include <stdio.h>\n\nstruct Node {\n    int data;\n    struct Node * prev;\n    struct Node * next;\n};\n\nstruct Node * createNode(int data) {\n    struct Node * newNode = (struct Node * )\n    malloc(sizeof(struct Node));\n    newNode -> data = data;\n    newNode -> prev = NULL;\n    newNode -> next = NULL;\n    return newNode;\n}\n\n// Function to delete a node at a specific\n//position in the doubly linked list\nstruct Node * delPos(struct Node * head, int pos) {\n\n    // If the list is empty\n    if (head == NULL)\n        return head;\n\n    struct Node * curr = head;\n\n    // Traverse to the node at the given position\n    for (int i = 1; curr && i < pos; ++i) {\n        curr = curr -> next;\n    }\n\n    // If the position is out of range\n    if (curr == NULL)\n        return head;\n\n    // Update the previous node's next pointer\n       if (curr -> prev)\n       curr -> prev -> next = curr -> next;\n\n// Update the next node's prev pointer\n    if (curr -> next)\n        curr -> next -> prev = curr -> prev;\n\n    // If the node to be deleted is the head node\n    if (head == curr)\n        head = curr -> next;\n\n    // Deallocate memory for the deleted node\n    free(curr);\n    return head;\n}\n\n// Function to print the doubly linked list\nvoid printList(struct Node * head) {\n    struct Node * curr = head;\n    while (curr != NULL) {\n        printf(\"%d \", curr -> data);\n        curr = curr -> next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n\n    // Create a hardcoded doubly linked list:\n    // 1 <-> 2 <-> 3\n    struct Node * head = createNode(1);\n    struct Node * temp1 = createNode(2);\n    struct Node * temp2 = createNode(3);\n\n    // Link the nodes together\n    head -> next = temp1;\n    temp1 -> prev = head;\n    temp1 -> next = temp2;\n    temp2 -> prev = temp1;\n\n    printf(\"Original Linked List: \");\n    printList(head);\n\n    // Delete node at position 2\n    head = delPos(head, 2);\n\n    printf(\"After Deletion at position 2: \");\n    printList(head);\n\n    return 0;\n}\n\n````\n\nJava\n````\n// Java Program to delete node at a specific position in Doubly Linked List\n\nclass Node {\n    int data;\n    Node prev;\n    Node next;\n\n    Node(int d) {\n        data = d;\n        prev = null;\n        next = null;\n    }\n}\n\nclass GFG {\n\n    // Function to delete a node at a\n  \t//specific position in the doubly linked list\n    public static Node delPos(Node head, int pos) {\n\n        // If the list is empty\n        if (head == null) {\n            return head;\n        }\n\n        Node curr = head;\n\n        // Traverse to the node at the given position\n        for (int i = 1; curr != null && i < pos; ++i) {\n            curr = curr.next;\n        }\n\n        // If the position is out of range\n        if (curr == null) {\n            return head;\n        }\n\n        // Update the previous node's next pointer\n       if (curr.prev != null) {\n       curr.prev.next = curr.next;\n}\n\n        // Update the next node's prev pointer\n        if (curr.next != null) {\n            curr.next.prev = curr.prev;\n        }\n\n        // If the node to be deleted is the head node\n        if (head == curr) {\n            head = curr.next;\n        }\n\n        // Return the updated head\n        return head;\n    }\n\n    // Function to print the doubly linked list\n    public static void printList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            System.out.print(curr.data + \" \");\n            curr = curr.next;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.prev = head;\n        head.next.next = new Node(3);\n        head.next.next.prev = head.next;\n\n        System.out.print(\"Original Linked List: \");\n        printList(head);\n\n        System.out.print(\"After Deletion at position 2: \");\n        head = delPos(head, 2);\n\n        printList(head);\n    }\n}\n\n````\n\nPython\n````\n# Python Program to delete node at a specific position\n#in Doubly Linked List\n\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\n\n# Function to delete a node at a specific position\n#in the doubly linked list\ndef del_pos(head, pos):\n    # If the list is empty\n    if head is None:\n        return head\n\n    curr = head\n\n    # Traverse to the node at the given position\n    for i in range(1, pos):\n        if curr is None:\n            return head\n        curr = curr.next\n\n    # If the position is out of range\n    if curr is None:\n        return head\n\n    # Update the previous node's next pointer\n               if curr.prev is not None:\n               curr.prev.next = curr.next\n\n               # Update the next node's prev pointer\n    if curr.next is not None:\n        curr.next.prev = curr.prev\n\n    # If the node to be deleted is the head node\n    if head == curr:\n        head = curr.next\n\n    # Return the updated head\n    return head\n\n\ndef print_list(head):\n    curr = head\n    while curr is not None:\n        print(curr.data, end=\" \")\n        curr = curr.next\n    print()\n\n\nif __name__ == \"__main__\":\n\n    # Create a hardcoded doubly linked list:\n    # 1 <-> 2 <-> 3\n    head = Node(1)\n    head.next = Node(2)\n    head.next.prev = head\n    head.next.next = Node(3)\n    head.next.next.prev = head.next\n\n    print(\"Original Linked List: \", end=\"\")\n    print_list(head)\n\n    print(\"After Deletion at the position 2: \", end=\"\")\n    head = del_pos(head, 2)\n\n    print_list(head)\n\n````\n\nC#\n````\n// C# Program to delete node at a specific position\n//in Doubly Linked List\n\nusing System;\n\nclass Node {\n    public int Data;\n    public Node Prev;\n    public Node Next;\n\n    public Node(int data) {\n        Data = data;\n        Prev = null;\n        Next = null;\n    }\n}\n\nclass Program {\n    // Function to delete a node at a specific position\n    // in the doubly linked list\n    static Node DelPos(Node head, int pos) {\n        // If the list is empty\n        if (head == null)\n            return head;\n\n        Node curr = head;\n\n        // Traverse to the node at the given position\n        for (int i = 1; curr != null && i < pos; ++i) {\n            curr = curr.Next;\n        }\n\n        // If the position is out of range\n        if (curr == null)\n            return head;\n\n        // Update the previous node's next pointer\n                     if (curr.Prev != null)\n                     curr.Prev.Next = curr.Next;\n\n// Update the next node's prev pointer\n        if (curr.Next != null)\n            curr.Next.Prev = curr.Prev;\n\n        // If the node to be deleted is the head node\n        if (head == curr)\n            head = curr.Next;\n\n        // Deallocate memory for the deleted node\n        // In C#, garbage collection will handle this\n      \t//automatically\n\n        return head;\n    }\n\n    // Function to print the doubly linked list\n    static void PrintList(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            Console.Write(curr.Data + \" \");\n            curr = curr.Next;\n        }\n        Console.WriteLine();\n    }\n\n    static void Main() {\n\n        // Create a hardcoded doubly linked list:\n        // 1 <-> 2 <-> 3\n        Node head = new Node(1);\n        head.Next = new Node(2);\n        head.Next.Prev = head;\n        head.Next.Next = new Node(3);\n        head.Next.Next.Prev = head.Next;\n\n        Console.Write(\"Original Linked List: \");\n        PrintList(head);\n\n        Console.Write(\"After Deletion at position 2: \");\n        head = DelPos(head, 2);\n\n        PrintList(head);\n    }\n}\n\n````\n\nJavaScript\n````\nclass Node {\n\tconstructor(data) {\n\t\tthis.data = data;\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\t}\n}\n\n// Function to delete a node at a specific position\n// in the doubly linked list\nfunction delPos(head, pos) {\n\t// If the list is empty\n\tif (head === null) return head;\n\n\tlet curr = head;\n\n\t// Traverse to the node at the given position\n\tfor (let i = 1; curr && i < pos; ++i) {\n\t\tcurr = curr.next;\n\t}\n\n\t// If the position is out of range\n\tif (curr === null) return head;\n\n\t// Update the previous node's next pointer\n       if (curr.prev) {\n       curr.prev.next = curr.next;\n}\n\n\t// Update the next node's prev pointer\n\tif (curr.next) {\n\t\tcurr.next.prev = curr.prev;\n\t}\n\n\t// If the node to be deleted is the head node\n\tif (head === curr) {\n\t\thead = curr.next;\n\t}\n\n\t// Deallocate memory for the deleted node\n\t// In JavaScript, garbage collection handles\n    //this automatically\n\n\treturn head;\n}\n\n// Function to print the doubly linked list\nfunction printList(head) {\n\tlet curr = head;\n\tlet result = [];\n\twhile (curr !== null) {\n\t\tresult.push(curr.data);\n\t\tcurr = curr.next;\n\t}\n\tconsole.log(result.join(' '));\n}\n\n\n// Create a hardcoded doubly linked list:\n// 1 <-> 2 <-> 3\nlet head = new Node(1);\nhead.next = new Node(2);\nhead.next.prev = head;\nhead.next.next = new Node(3);\nhead.next.next.prev = head.next;\n\nconsole.log(\"Original Linked List:\");\nprintList(head);\n\nconsole.log(\"After Deletion at the position 2:\");\nhead = delPos(head, 2);\n\nprintList(head);\n\n````\n\n\n**Output**\n```\n\nOriginal Linked List: 1 2 3\nAfter Deletion at the position 2: 1 3\n\n```\n\nAdvantages of Doubly Linked List\n--------------------------------\n\n* ****Efficient traversal in both directions:**** Doubly linked lists allow for efficient traversal of the list in both\n  directions, making it suitable for applications where frequent\n  insertions and deletions are required.\n* ****Easy insertion and deletion of nodes:**** The presence of pointers to both the previous and next nodes makes it\n  easy to insert or delete nodes from the list, without having to\n  traverse the entire list.\n* ****Can be used to implement a stack or queue:**** Doubly linked lists can be used to implement both stacks and queues,\n  which are common data structures used in programming.\n\nDisadvantages of Doubly Linked List\n-----------------------------------\n\n* ****More complex than singly linked lists:****\n  Doubly linked lists are more complex than singly linked lists, as they\n  require additional pointers for each node.\n* ****More memory overhead:**** Doubly linked lists require more memory overhead than singly linked\n  lists, as each node stores two pointers instead of one.",
        "metadata": {
            "lesson_id": "9a7d3527-1c48-4e9d-8aac-990f873ca15d",
            "course_id": "dc8c4016-8dba-4baf-afea-ada6f0c21ae4",
            "course_name": "Introduction to DSA I\n",
            "lesson_description": "A doubly linked list\nis a more complex data structure than a singly linked list, but it\noffers several advantages. The main advantage of a doubly linked list is\nthat it allows for efficient traversal of the list in both directions.\nThis is because each node in the list contains a pointer to the previous\nnode and a pointer to the next node. This allows for quick and easy\ninsertion and deletion of nodes from the list, as well as efficient\ntraversal of the list in both directions.",
            "course_description": "A foundational understanding of Data Structures and Algorithms (DSA). You\u2019ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you\u2019ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews."
        }
    },
    {
        "page_content": "Basic Terminologies of Queue\n----------------------------\n\n* ****Front:**** Position of the entry in a queue ready to be served, that is, the\n  first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.\n* ****Rear:****\n  Position of the last entry in the queue, that is, the one most\n  recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.\n* ****Size:**** Size refers to the ****current**** number of elements in the queue.\n* ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.\n\n****Representation of Queue****\n-------------------------------\n\n![Representation-of-Queue-Data-Structure](https://media.geeksforgeeks.org/wp-content/uploads/20241212130245410876/Representation-of-Queue-Data-Structure-768.webp)\n\nOperations on Queue\n-------------------\n\n### ****1. Enqueue:****\n\nEnqueue operation ****adds (or stores) an element to the end of the queue****. \n\n****Steps:****\n\n1. Check if the ****queue is full****. If so, return an ****overflow**** error and exit.\n2. If the queue is ****not full****, increment the ****rear**** pointer to the next available position.\n3. Insert the element at the rear.\n\n\n![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)\n\n\n![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)\n\n\n![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)\n\n\n![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)\n\n\n![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)\n\n\n![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)\n\n\n\nPrevious\n\n\n\n\n\nPause\n\nNext\n\n\n\n\n\n3 / 6\n\n\n\n### ****2. Dequeue:****\n\nDequeue operation removes the element at the front of the queue. The\nfollowing steps are taken to perform the dequeue operation:\n\n\n1. Check if the ****queue is empty****. If so, return an ****underflow**** error.\n2. Remove the element at the ****front****.\n3. ****Increment**** the ****front**** pointer to the next element.\n\n\n![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n\nPrevious\n\n\n\n\n\nPlay\n\nNext\n\n\n\n\n\n1 / 6\n\n\n\n### ****3. Peek or Front Operation:****\n\nThis operation returns the element at the front end without removing\nit.\n\n### 4. Size Operation:\n\nThis operation returns the numbers of elements present in the\nqueue.\n\n### ****5. isEmpty Operation:****\n\nThis operation returns a boolean value that indicates whether the queue\nis empty or not.\n\n### ****6. isFull Operation:****\n\nThis operation returns a boolean value that indicates whether the queue\nis full or not.\n\nImplementation of Queue Data Structure\n--------------------------------------\n\nQueue can be implemented using following data structures:\n\n* [Implementation of Queue using Arrays](https://www.geeksforgeeks.org/introduction-and-array-implementation-of-queue)\n* [Implementation of Queue using Linked List](https://www.geeksforgeeks.org/queue-linked-list-implementation)\n\nComplexity Analysis of Operations on Queue\n------------------------------------------\n\n| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |\n| --- | --- | --- |\n| ****enqueue**** | O(1) | O(1) |\n| ****dequeue**** | O(1) | O(1) |\n| front | O(1) | O(1) |\n| size | O(1) | O(1) |\n| isEmpty | O(1) | O(1) |\n| isFull | O(1) | O(1) |\n\n****Types of Queues****\n-----------------------\n\nQueue data structure can be classified into 4 types:\n\n1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the\n   element from the front of the queue.\n2. [****Double-Ended Queue (Deque)****](https://www.geeksforgeeks.org/deque-set-1-introduction-applications)****:****\n   In a double-ended queue the insertion and deletion operations, both\n   can be performed from both ends. They are of two types:\n   * ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be\n     taken from only one end but deletion can be done from any of the\n     ends.\n   * ****Output Restricted Queue:****\n     This is also a simple queue. In this type of queue, the input can\n     be taken from both ends but deletion can be done from only one\n     end.\n3. [****Circular Queue:****](https://www.geeksforgeeks.org/introduction-to-circular-queue) This is a special type of queue where the last position is connected\n   back to the first position. Here also the operations are performed in\n   FIFO order.\n4. [****Priority Queue****](https://www.geeksforgeeks.org/priority-queue-set-1-introduction)****:****\n   A priority queue is a special queue where the elements are accessed\n   based on the priority assigned to them. They are of two types:\n   * ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in\n     increasing order of their priority values. Element with smallest\n     priority value is popped first.\n   * ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in\n     decreasing order of their priority values. Element with largest\n     priority is popped first.\n\n![Types-of-Queue](https://media.geeksforgeeks.org/wp-content/uploads/20241212125924381216/Types-of-Queue-660.webp)\n\n****Applications of Queue Data Structure****\n--------------------------------------------\n\nApplication of queue is common. In a computer system, there may be\nqueues of tasks waiting for the printer, for access to disk storage, or\neven in a time-sharing system, for use of the CPU. Within a single\nprogram, there may be multiple requests to be kept in a queue, or one\ntask may create other tasks, which must be done in turn by keeping them\nin a queue.\n\n* A Queue is always used as a buffer when we have a speed mismatch\n  between a producer and consumer. For example keyboard and CPU.\n* Queue can be used where we have a single resource and multiple\n  consumers like a single CPU and multiple processes.\n* In a network, a queue is used in devices such as a router/switch and\n  mail queue.\n* Queue can be used in various algorithm techniques like Breadth First\n  Search, Topological Sort, etc.",
        "metadata": {
            "lesson_id": "5579b7b8-f82f-4a7d-9fe5-7ec75bf66434",
            "course_id": "c9b04774-3a81-43ab-ace6-5242360d9e07",
            "course_name": "Queue",
            "lesson_description": "Queue is a linear data structure that follows FIFO (First In First Out) Principle, so the first element inserted is the first to be popped out.\n",
            "course_description": "The Queue lesson series dives into the mechanics of this fundamental data structure, which follows the FIFO (First In, First Out) principle. You\u2019ll learn how to perform operations such as enqueue, dequeue, and peek, while also exploring its variations like Circular Queues and Priority Queues. Practical applications, including task scheduling, buffering, and breadth-first search algorithms, will help solidify your understanding. This series is perfect for beginners and anyone looking to master essential programming concepts."
        }
    },
    {
        "page_content": "**Types of Queues:**\n\nThere are **five different types of queues** that are used in\ndifferent scenarios. They are:\n\n1. Input Restricted Queue (this is a Simple Queue)\n2. Output Restricted Queue (this is also a Simple Queue)\n3. Circular Queue\n4. Double Ended Queue (Deque)\n5. Priority Queue\n   * Ascending Priority Queue\n   * Descending Priority Queue\n\n![Types of Queues](https://media.geeksforgeeks.org/wp-content/uploads/20220623134709/typesofqueues.jpg)\n\nTypes of Queues\n\n**1.** [**Circular Queue**](https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/)**:** Circular Queue is a linear data structure in which the\noperations are performed based on FIFO (First In First Out) principle and\nthe last position is connected back to the first position to make a\ncircle. It is also called **\u2018Ring Buffer\u2019**. This queue is\nprimarily used in the following cases:\n\n1. **Memory Management:** The unused memory locations in the\n   case of ordinary queues can be utilized in circular queues.\n2. **Traffic system:** In a computer-controlled traffic\n   system, circular queues are used to switch on the traffic lights one by\n   one repeatedly as per the time set.\n3. **CPU Scheduling:** Operating systems often maintain a\n   queue of processes that are ready to execute or that are waiting for a\n   particular event to occur.\n\nThe time complexity for the circular Queue is O(1).\n\n**2. Input restricted Queue:** In this type of Queue, the\ninput can be taken from one side only(rear) and deletion of elements can\nbe done from both sides(front and rear). This kind of Queue does not\nfollow FIFO(first in first out).  This queue is used in cases where\nthe consumption of the data needs to be in FIFO order but if there is a\nneed to remove the recently inserted data for some reason and one such\ncase can be irrelevant data, performance issue, etc.\n\n\n\n![Input Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131417/inputrestrictedqueue.jpg)\n\nInput Restricted Queue\n\n**Advantages of Input restricted Queue:**\n\n* Prevents overflow and overloading of the queue by limiting the number of\n  items added\n* Helps maintain stability and predictable performance of the system\n\n**Disadvantages of Input restricted Queue:**\n\n* May lead to resource wastage if the restriction is set too low and items\n  are frequently discarded\n* May lead to waiting or blocking if the restriction is set too high and\n  the queue is full, preventing new items from being added.\n\n**3. Output restricted Queue:** In this type of Queue, the\ninput can be taken from both sides(rear and front) and the deletion of the\nelement can be done from only one side(front).  This queue is used in\nthe case where the inputs have some priority order to be executed and the\ninput can be placed even in the first place so that it is executed\nfirst.\n\n![Output Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131455/outputrestrictedqueue.jpg)\n\nOutput Restricted Queue\n\n**4.** [**Double ended Queue**](https://www.geeksforgeeks.org/deque-set-1-introduction-applications/)**:** Double Ended Queue is also a Queue data structure in\nwhich the insertion and deletion operations are performed at both the ends\n(front and rear). That means, we can insert at both front and rear\npositions and can delete from both front and rear positions.  Since\nDeque supports both stack and queue operations, it can be used as both.\nThe Deque data structure supports clockwise and anticlockwise rotations in\nO(1) time which can be useful in certain applications. Also, the problems\nwhere elements need to be removed and or added both ends can be\nefficiently solved using Deque.\n\n![Double Ended Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131811/doubleended.jpg)\n\nDouble Ended Queue\n\n**5.** [**Priority Queue**](https://www.geeksforgeeks.org/priority-queue-set-1-introduction/)**:** A priority queue is a special type of queue in which\neach element is associated with a priority and is served according to its\npriority. There are two types of Priority Queues. They are:\n\n1. **Ascending Priority Queue:** Element can be inserted\n   arbitrarily but only smallest element can be removed. For example,\n   suppose there is an array having elements 4, 2, 8 in the same order. So,\n   while inserting the elements, the insertion will be in the same sequence\n   but while deleting, the order will be 2, 4, 8.\n2. **Descending priority Queue:** Element can be inserted\n   arbitrarily but only the largest element can be removed first from the\n   given Queue. For example, suppose there is an array having elements 4,\n   2, 8 in the same order. So, while inserting the elements, the insertion\n   will be in the same sequence but while deleting, the order will be 8, 4,\n   2.\n\nThe time complexity of the Priority Queue is O(logn).\n\n[**Applications of a Queue:**](https://www.geeksforgeeks.org/applications-of-queue-data-structure/)\n\nThe\n[queue](https://www.geeksforgeeks.org/queue-set-1introduction-and-array-implementation/)\nis used when things don\u2019t have to be processed immediately, but have to be\nprocessed in First In First Out order like\n[Breadth First Search](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/). This property of Queue makes it also useful in the following kind of\nscenarios.\n\n1. When a resource is shared among multiple consumers. Examples include\n   [CPU scheduling](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/),\n   [Disk Scheduling](https://www.geeksforgeeks.org/disk-scheduling-algorithms/).\n2. When data is transferred asynchronously (data not necessarily received\n   at the same rate as sent) between two processes. Examples include IO\n   Buffers,\n   [pipes](https://www.geeksforgeeks.org/piping-in-unix-or-linux/), file IO, etc.\n3. Linear Queue: A linear queue is a type of queue where data elements are\n   added to the end of the queue and removed from the front of the queue.\n   Linear queues are used in applications where data elements need to be\n   processed in the order in which they are received. Examples include\n   printer queues and message queues.\n4. Circular Queue: A circular queue is similar to a linear queue, but the\n   end of the queue is connected to the front of the queue. This allows for\n   efficient use of space in memory and can improve performance. Circular\n   queues are used in applications where the data elements need to be\n   processed in a circular fashion. Examples include CPU scheduling and\n   memory management.\n5. Priority Queue: A priority queue is a type of queue where each element\n   is assigned a priority level. Elements with higher priority levels are\n   processed before elements with lower priority levels. Priority queues\n   are used in applications where certain tasks or data elements need to be\n   processed with higher priority. Examples include operating system task\n   scheduling and network packet scheduling.\n6. Double-ended Queue: A double-ended queue, also known as a deque, is a\n   type of queue where elements can be added or removed from either end of\n   the queue. This allows for more flexibility in data processing and can\n   be used in applications where elements need to be processed in multiple\n   directions. Examples include job scheduling and searching algorithms.\n7. Concurrent Queue: A concurrent queue is a type of queue that is designed\n   to handle multiple threads accessing the queue simultaneously.\n   Concurrent queues are used in multi-threaded applications where data\n   needs to be shared between threads in a thread-safe manner. Examples\n   include database transactions and web server requests.\n\n**Issues of Queue :**\n\nSome common issues that can arise when using queues:\n\n1. Queue overflow: Queue overflow occurs when the queue reaches its maximum\n   capacity and is unable to accept any more elements. This can cause data\n   loss and can lead to application crashes.\n2. Queue underflow: Queue underflow occurs when an attempt is made to\n   remove an element from an empty queue. This can cause errors and\n   application crashes.\n3. Priority inversion: Priority inversion occurs in priority queues when a\n   low-priority task holds a resource that a high-priority task needs. This\n   can cause delays in processing and can impact system performance.\n4. Deadlocks: Deadlocks occur when multiple threads or processes are\n   waiting for each other to release resources, resulting in a situation\n   where none of the threads can proceed. This can happen when using\n   concurrent queues and can lead to system crashes.\n5. Performance issues: Queue performance can be impacted by various\n   factors, such as the size of the queue, the frequency of access, and the\n   type of operations performed on the queue. Poor queue performance can\n   lead to slower system performance and reduced user experience.\n6. Synchronization issues: Synchronization issues can arise when multiple\n   threads are accessing the same queue simultaneously. This can result in\n   data corruption, race conditions, and other errors.\n7. Memory management issues: Queues can use up significant amounts of\n   memory, especially when processing large data sets. Memory leaks and\n   other memory management issues can occur, leading to system crashes and\n   other errors.\n\n**Reference :**\n\nSome references for further reading on queues:\n\n1. \u201cData Structures and Algorithms in Java\u201d by Robert Lafore \u2013 This book\n   provides an in-depth explanation of different types of queues and their\n   implementations in Java.\n2. \u201cIntroduction to Algorithms\u201d by Thomas H. Cormen et al. \u2013 This textbook\n   covers the basic concepts of data structures and algorithms, including\n   queues and their various applications.\n3. \u201cConcurrency in C# Cookbook\u201d by Stephen Cleary \u2013 This book provides\n   practical examples of how to use concurrent queues in C# programming.\n4. \u201cQueue (abstract data type)\u201d on Wikipedia \u2013 This article provides an\n   overview of queues and their properties, as well as examples of their\n   applications.\n5. \u201cThe Art of Computer Programming, Volume 1: Fundamental Algorithms\u201d by\n   Donald E. Knuth \u2013 This book includes a detailed analysis of different\n   queue algorithms and their performance.\n6. \u201cQueues and the Producer-Consumer Problem\u201d by Douglas C. Schmidt \u2013 This\n   paper discusses how queues can be used to solve the producer-consumer\n   problem in concurrent programming.",
        "metadata": {
            "lesson_id": "2a878929-d192-4a08-a92c-f93b22786c0f",
            "course_id": "c9b04774-3a81-43ab-ace6-5242360d9e07",
            "course_name": "Queue",
            "lesson_description": "Queue is a linear structure that follows a particular order in which the\noperations are performed. The order is First In First Out (FIFO). A good\nexample of a queue is any queue of consumers for a resource where the\nconsumer that came first is served first. In this article, the different\ntypes of queues are discussed.",
            "course_description": "The Queue lesson series dives into the mechanics of this fundamental data structure, which follows the FIFO (First In, First Out) principle. You\u2019ll learn how to perform operations such as enqueue, dequeue, and peek, while also exploring its variations like Circular Queues and Priority Queues. Practical applications, including task scheduling, buffering, and breadth-first search algorithms, will help solidify your understanding. This series is perfect for beginners and anyone looking to master essential programming concepts."
        }
    },
    {
        "page_content": "**Basic Operations on Queue:**\n------------------------------\n\nSome of the basic operations for Queue in Data Structure are:\n\n* **enqueue() \u2013** Insertion of elements to the queue.\n* **dequeue() \u2013** Removal of elements from the queue.\n* **peek() or front()-** Acquires the data element available\n  at the front node of the queue without deleting it.\n* **rear() \u2013** This operation returns the element at the rear\n  end without removing it.\n* **isFull() \u2013** Validates if the queue is full.\n* **isEmpty() \u2013** Checks if the queue is empty.\n* **size():** This operation returns the size of the queue\n  i.e. the total number of elements it contains.\n\n![](https://media.geeksforgeeks.org/wp-content/uploads/20221209094646/Queue-768.png)\n\nQueue Data Structure\n\n### **Operation 1: enqueue()**\n\nInserts an element at the end of the queue i.e. at the rear end.\n\nThe following steps should be taken to enqueue (insert) data into a queue:\n\n* Check if the queue is full.\n* If the queue is full, return overflow error and exit.\n* If the queue is not full, increment the rear pointer to point to the\n  next empty space.\n* Add the data element to the queue location, where the rear is pointing.\n* return success.\n\n![Enqueue representation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122158/fifo1-660x371.png)\n\nEnqueue representation\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n---\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `printf``(``\"\\nQueue is full\\n\"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n----\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `System.out.println(``\"\\nQueue is full\\n\"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n-\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to add an item to the queue.`  `// It changes rear and size`  `void` `enqueue(``struct` `Queue* queue,` `int` `item)`  `{`  `if` `(isFull(queue))`  `return``;`  `queue->rear = (queue->rear + 1) % queue->capacity;`  `queue->array[queue->rear] = item;`  `queue->size = queue->size + 1;`  `printf``(``\"%d enqueued to queue\\n\"``, item);`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n-------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to add an item to the queue.`  `# It changes rear and size`  `def` `EnQueue(``self``, item):`  `if` `self``.isFull():`  `print``(``\"Full\"``)`  `return`  `self``.rear` `=` `(``self``.rear` `+` `1``)` `%` `(``self``.capacity)`  `self``.Q[``self``.rear]` `=` `item`  `self``.size` `=` `self``.size` `+` `1`  `print``(``\"% s enqueued to queue\"` `%` `str``(item))`  `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n--\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `void` `enqueue(``int` `item)`  `{`  `if` `(rear == max - 1) {`  `Console.WriteLine(``\"Queue Overflow\"``);`  `return``;`  `}`  `else` `{`  `ele[++rear] = item;`  `}`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n----------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `enqueue(element){`  `// adding element to the queue`  `this``.items.push(element);`  `}`    `// This code is contributed by Susobhan Akhuli`  `</script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 2: dequeue()**\n\nThis operation removes and returns an element that is at the front end of\nthe queue.\n\nThe following steps are taken to perform the dequeue operation:\n\n* Check if the queue is empty.\n* If the queue is empty, return the underflow error and exit.\n* If the queue is not empty, access the data where the front is pointing.\n* Increment the front pointer to point to the next available data element.\n* The Return success.\n\n![Dequeue operation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122625/fifo2-660x371.png)\n\nDequeue operation\n\nBelow is the Implementation of above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n---\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `printf``(``\"\\nQueue is empty\\n\"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i = 0; i < rear - 1; i++) {`  `queue[i] = queue[i + 1];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n----\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `System.out.println(``\"\\nQueue is empty\\n\"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i =` `0``; i < rear -` `1``; i++) {`  `queue[i] = queue[i +` `1``];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n-\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to remove an item from queue.`  `// It changes front and size`  `int` `dequeue(``struct` `Queue* queue)`  `{`  `if` `(isEmpty(queue)) {`  `printf``(``\"\\nQueue is empty\\n\"``);`  `return``;`  `}`  `int` `item = queue->array[queue->front];`  `queue->front = (queue->front + 1) % queue->capacity;`  `queue->size = queue->size - 1;`  `return` `item;`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n-------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to remove an item from queue.`  `# It changes front and size`      `def` `DeQueue(``self``):`  `if` `self``.isEmpty():`  `print``(``\"Queue is empty\"``)`  `return`    `print``(``\"% s dequeued from queue\"` `%` `str``(``self``.Q[``self``.front]))`  `self``.front` `=` `(``self``.front` `+` `1``)` `%` `(``self``.capacity)`  `self``.size` `=` `self``.size` `-` `1`  `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n--\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to remove an item from queue.`  `// It changes front and size`  `public` `int` `dequeue()`  `{`  `if` `(front == rear + 1) {`  `Console.WriteLine(``\"Queue is Empty\"``);`  `return` `-1;`  `}`  `else` `{`  `int` `p = ele[front++];`  `return` `p;`  `}`  `}`  `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n----------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `dequeue(){`  `// removing element from the queue`  `// returns underflow when called`  `// on empty queue`  `if``(``this``.isEmpty()){`  `document.write(``\"<br>Queue is empty<br>\"``);`  `return` `-1;`  `}`  `return` `this``.items.shift();`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 3: front()**\n\nThis operation returns the element at the front end without removing it.\n\nThe following steps are taken to perform the front operation:\n\n* If the queue is empty return the most minimum value.\n* otherwise, return the front value.\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n---\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}` |\n| --- |\n\n\n\n\n\nJava\n----\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(Queue queue)`  `{`  `if` `(isempty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.front];`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n-\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n-------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to get front of queue`  `def` `que_front(``self``):`  `if` `self``.isempty():`  `return` `\"Queue is empty\"`  `return` `self``.Q[``self``.front]`    `# This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n--\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[front];`  `}`    `// This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n----------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `// Function to get front of queue`  `front(){`  `// returns the Front element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `\"No elements in Queue<br>\"``;`  `return` `this``.items[0];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### Operation 4 : rear()\n\nThis operation returns the element at the rear end without removing it.\n\nThe following steps are taken to perform the rear operation:\n\n* If the queue is empty return the most minimum value.\n* otherwise, return the rear value.\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n---\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get rear of queue`  `int` `rear(Queue* queue)`  `{`  `if` `(isEmpty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}` |\n| --- |\n\n\n\n\n\nJava\n----\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get rear of queue`  `int` `rear(Queue queue)`  `{`  `if` `(isEmpty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.rear];`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n-\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n-------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to get rear of queue`  `def` `que_rear(``self``):`  `if` `self``.isEmpty():`  `return` `\"Queue is empty\"`  `return` `self``.Q[``self``.rear]`    `# This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n--\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[rear];`  `}`    `// This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n----------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `rear(){`  `// returns the Rear element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `\"No elements in Queue<br>\"``;`  `return` `this``.items[``this``.items.length-1];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 5: isEmpty():**\n\nThis operation returns a boolean value that indicates whether the queue is\nempty or not.\n\nThe following steps are taken to perform the Empty operation:\n\n* check if front value is equal to -1 or not, if yes then return true\n  means queue is empty.\n* Otherwise return false, means queue is not empty\n\nBelow is the implementation of the above approach:\n\n* C++\n* Java\n* C#\n* C\n* Python3\n* Javascript\n\nC++\n---\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n----\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check whether`  `// the queue is empty or not:`  `boolean` `isEmpty()`  `{`  `if` `(front == -``1``)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC#\n--\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by lokeshmvs21.` |\n| --- |\n\n\n\n\n\nC\n-\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Queue is empty when size is 0`  `bool` `isEmpty(``struct` `Queue* queue)`  `{`  `return` `(queue->size == 0);`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n-------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Queue is empty when size is 0`  `def` `isEmpty(``self``):`  `return` `self``.size` `=``=` `0`  `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n----------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `</script>`  `isEmpty(){`  `// return true if the queue is empty.`  `return` `this``.items.length == 0;`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 6 : isFull()**\n\nThis operation returns a boolean value that indicates whether the queue is\nfull or not.\n\nThe following steps are taken to perform the isFull() operation:\n\n* Check if front value is equal to zero and rear is equal to the capacity\n  of queue if yes then return true.\n* otherwise return false\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* C#\n* Python3\n* Javascript\n\nC++\n---\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check`  `// whether the queue is full or not.`  `bool` `isFull()`  `{`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n----\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check`  `// whether the queue is full or not.`  `boolean` `isFull()`  `{`  `if` `(front ==` `0` `&& rear == MAX_SIZE -` `1``) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n-\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Queue is full when size becomes`  `// equal to the capacity`  `bool` `isFull(``struct` `Queue* queue)`  `{`  `return` `(queue->size == queue->capacity);`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n--\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `bool` `isFull(``int` `item) {` `return` `(rear == max - 1); }`  `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n-------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Queue is full when size becomes`  `# equal to the capacity`      `def` `isFull(``self``):`  `return` `self``.size` `=``=` `self``.capacity`    `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n----------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `function` `isFull() {`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityamaharshi21.` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### Operation 7: size()\n\nThis operation returns the size of the queue i.e. the total number of\nelements it contains.\n\n```\nqueuename.size()\nParameters :\nNo parameters are passed\nReturns :\nNumber of elements in the container\n```\n\n* C++\n* Java\n* Python\n* C#\n* Javascript\n\nC++\n---\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// CPP program to illustrate`  `// Implementation of size() function`  `#include <iostream>`  `#include <queue>`  `using` `namespace` `std;`    `int` `main()`  `{`  `int` `sum = 0;`  `queue<``int``> myqueue;`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `cout << myqueue.size();`    `return` `0;`  `}` |\n| --- |\n\n\n\n\n\nJava\n----\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Java program to illustrate implementation of size()`  `// function`    `import` `java.util.*;`    `public` `class` `Main {`  `public` `static` `void` `main(String[] args)`  `{`  `int` `sum =` `0``;`  `Queue<Integer> myqueue =` `new` `LinkedList<>();`  `myqueue.add(``1``);`  `myqueue.add(``8``);`  `myqueue.add(``3``);`  `myqueue.add(``6``);`  `myqueue.add(``2``);`    `// Queue becomes 1, 8, 3, 6, 2`    `System.out.println(myqueue.size());`  `}`  `}`    `// This code is contributed by lokesh.` |\n| --- |\n\n\n\n\n\nPython\n------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `from` `collections` `import` `deque`    `def` `main():`  `sum` `=` `0`  `myqueue` `=` `deque()`  `myqueue.append(``1``)`  `myqueue.append(``8``)`  `myqueue.append(``3``)`  `myqueue.append(``6``)`  `myqueue.append(``2``)`    `# Queue becomes 1, 8, 3, 6, 2`    `print``(``len``(myqueue))`    `main()`    `# This code is contributed by aadityamaharshi21.` |\n| --- |\n\n\n\n\n\nC#\n--\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `using` `System;`  `using` `System.Collections.Generic;`    `namespace` `ConsoleApp1 {`  `class` `MainClass {`  `public` `static` `void` `Main(``string``[] args)`  `{`  `int` `sum = 0;`  `Queue<``int``> myqueue =` `new` `Queue<``int``>();`  `myqueue.Enqueue(1);`  `myqueue.Enqueue(8);`  `myqueue.Enqueue(3);`  `myqueue.Enqueue(6);`  `myqueue.Enqueue(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `Console.WriteLine(myqueue.Count);`  `}`  `}`  `}`    `// This code is contributed by adityamaharshi21.` |\n| --- |\n\n\n\n\n\nJavascript\n----------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Javascript code`  `let sum = 0;`  `let myqueue=[];`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `console.log(myqueue.length);` |\n| --- |\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n",
        "metadata": {
            "lesson_id": "562940a2-1089-4c6d-a938-5fe36049bc5f",
            "course_id": "c9b04774-3a81-43ab-ace6-5242360d9e07",
            "course_name": "Queue",
            "lesson_description": "",
            "course_description": "The Queue lesson series dives into the mechanics of this fundamental data structure, which follows the FIFO (First In, First Out) principle. You\u2019ll learn how to perform operations such as enqueue, dequeue, and peek, while also exploring its variations like Circular Queues and Priority Queues. Practical applications, including task scheduling, buffering, and breadth-first search algorithms, will help solidify your understanding. This series is perfect for beginners and anyone looking to master essential programming concepts."
        }
    },
    {
        "page_content": "****Enqueue**** and when an element is deleted from the queue, then the operation is\nknown as ****Dequeue.****It is important to know that we cannot insert an element if the size of\nthe queue is full and cannot delete an element when the queue itself is\nempty. If we try to insert an element even after the queue is full, then\nsuch a condition is known as overflow whereas, if we try to delete an\nelement even after the queue is empty then such a condition is known as\nunderflow.\n\n****Primary Queue Operations:****\n\n* ****void enqueue(int Element):**** When this operation is performed, an element is inserted in the queue\n  at the end i.e. at the rear end. (Where T is Generic i.e we can define\n  Queue of any type of data structure.) This operation take ****constant time i.e O(1).****\n* ****int dequeue():****\n  When this operation is performed, an element is removed from the front\n  end and is returned. This operation take ****constant time i.e O(1).****\n\n****Auxiliary Queue Operations:****\n\n* ****int front():**** This operation will return the element at the front without removing\n  it and it take O(1) time.\n* ****int rear():**** This operation will return the element at the rear without removing\n  it, Its Time Complexity is O(1).\n* ****int isEmpty():**** This operation indicates whether the queue is empty or not. This\n  Operation also done in O(1).\n* ****int size():**** This operation will return the size of the queue i.e. the total\n  number of elements present in the queue and it\u2019s time complexity is\n  O(1).\n\n****Types of Queues:****\n\n* ****Simple Queue:**** Simple queue also known as a linear queue is the most basic version\n  of a queue. Here, insertion of an element i.e. the Enqueue operation\n  takes place at the rear end and removal of an element i.e. the Dequeue\n  operation takes place at the front end.\n* ****Circular Queue:****This is mainly an efficient array implementation of Simple Queue. In\n  a circular queue, the element of the queue act as a circular ring. The\n  working of a circular queue is similar to the linear queue except for\n  the fact that the last element is connected to the first element. Its\n  advantage is that the memory is utilized in a better way. This is\n  because if there is an empty space i.e. if no element is present at a\n  certain position in the queue, then an element can be easily added at\n  that position.\n* ****Priority Queue:**** This queue is a special type of queue. Its specialty is that it\n  arranges the elements in a queue based on some priority. The priority\n  can be something where the element with the highest value has the\n  priority so it creates a queue with decreasing order of values. The\n  priority can also be such that the element with the lowest value gets\n  the highest priority so in turn it creates a queue with increasing\n  order of values.\n* ****Dequeue:**** Dequeue is also known as Double Ended Queue. As the name suggests\n  double ended, it means that an element can be inserted or removed from\n  both the ends of the queue unlike the other queues in which it can be\n  done only from one end. Because of this property it may not obey the\n  First In First Out property.\n\n****Implementation of Queue:****\n\n* ****Sequential allocation:**** A queue can be implemented using an array. It can organize a limited\n  number of elements.\n* ****Linked list allocation:****\n  A queue can be implemented using a linked list. It can organize an\n  unlimited number of elements.\n\n****Applications of Queue:****\n\n* ****Multi programming:**** Multi programming means when multiple programs are running in the\n  main memory. It is essential to organize these multiple programs and\n  these multiple programs are organized as queues.\n* ****Network:**** In a network, a queue is used in devices such as a router or a\n  switch. another application of a queue is a mail queue which is a\n  directory that stores data and controls files for mail messages.\n* ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that\n  are scheduled to be executed one after another. These jobs are\n  assigned to the processor one by one which is organized using a\n  queue.\n* ****Shared resources:**** Queues are used as waiting lists for a single shared resource.\n\n****Real-time application of Queue:****\n\n* Working as a buffer between a slow and a fast device. For example\n  keyboard and CPU, and two devices on network.\n* ATM Booth Line\n* Ticket Counter Line\n* CPU task scheduling\n* Waiting time of each customer at call centers.\n\n****Advantages of Queue:****\n\n* A large amount of data can be managed efficiently with ease.\n* Operations such as insertion and deletion can be performed with ease\n  as it follows the first in first out rule.\n* Queues are useful when a particular service is used by multiple\n  consumers.\n* Queues are fast in speed for data inter-process communication.\n* Queues can be used in the implementation of other data\n  structures.\n\n****Disadvantages of Queue:****\n\n* The operations such as insertion and deletion of elements from the\n  middle are time consuming.\n* In a classical queue, a new element can only be inserted when the\n  existing elements are deleted from the queue.\n* Searching an element takes O(N) time.\n* Maximum size of a queue must be defined prior in case of array\n  implementation.",
        "metadata": {
            "lesson_id": "6c6539f0-a9f9-4639-b197-d3fc89870e6a",
            "course_id": "c9b04774-3a81-43ab-ace6-5242360d9e07",
            "course_name": "Queue",
            "lesson_description": "A Queue\nis a linear data structure. This data structure follows a particular\norder in which the operations are performed. The order is First In First Out (FIFO). It means that the element that is inserted first in the queue will\ncome out first and the element that is inserted last will come out last.",
            "course_description": "The Queue lesson series dives into the mechanics of this fundamental data structure, which follows the FIFO (First In, First Out) principle. You\u2019ll learn how to perform operations such as enqueue, dequeue, and peek, while also exploring its variations like Circular Queues and Priority Queues. Practical applications, including task scheduling, buffering, and breadth-first search algorithms, will help solidify your understanding. This series is perfect for beginners and anyone looking to master essential programming concepts."
        }
    },
    {
        "page_content": "Basic Terminologies of Queue\n----------------------------\n\n* ****Front:**** Position of the entry in a queue ready to be served, that is, the\n  first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.\n* ****Rear:****\n  Position of the last entry in the queue, that is, the one most\n  recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.\n* ****Size:**** Size refers to the ****current**** number of elements in the queue.\n* ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.\n\n****Representation of Queue****\n-------------------------------\n\n![Representation-of-Queue-Data-Structure](https://media.geeksforgeeks.org/wp-content/uploads/20241212130245410876/Representation-of-Queue-Data-Structure-768.webp)\n\nOperations on Queue\n-------------------\n\n### ****1. Enqueue:****\n\nEnqueue operation ****adds (or stores) an element to the end of the queue****. \n\n****Steps:****\n\n1. Check if the ****queue is full****. If so, return an ****overflow**** error and exit.\n2. If the queue is ****not full****, increment the ****rear**** pointer to the next available position.\n3. Insert the element at the rear.\n\n\n![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)\n\n\n![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)\n\n\n![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)\n\n\n![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)\n\n\n![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)\n\n\n![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)\n\n\n\nPrevious\n\n\n\n\n\nPause\n\nNext\n\n\n\n\n\n3 / 6\n\n\n\n### ****2. Dequeue:****\n\nDequeue operation removes the element at the front of the queue. The\nfollowing steps are taken to perform the dequeue operation:\n\n\n1. Check if the ****queue is empty****. If so, return an ****underflow**** error.\n2. Remove the element at the ****front****.\n3. ****Increment**** the ****front**** pointer to the next element.\n\n\n![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)\n\n\n\nPrevious\n\n\n\n\n\nPlay\n\nNext\n\n\n\n\n\n1 / 6\n\n\n\n### ****3. Peek or Front Operation:****\n\nThis operation returns the element at the front end without removing\nit.\n\n### 4. Size Operation:\n\nThis operation returns the numbers of elements present in the\nqueue.\n\n### ****5. isEmpty Operation:****\n\nThis operation returns a boolean value that indicates whether the queue\nis empty or not.\n\n### ****6. isFull Operation:****\n\nThis operation returns a boolean value that indicates whether the queue\nis full or not.\n\nImplementation of Queue Data Structure\n--------------------------------------\n\nQueue can be implemented using following data structures:\n\n* [Implementation of Queue using Arrays](https://www.geeksforgeeks.org/introduction-and-array-implementation-of-queue)\n* [Implementation of Queue using Linked List](https://www.geeksforgeeks.org/queue-linked-list-implementation)\n\nComplexity Analysis of Operations on Queue\n------------------------------------------\n\n| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |\n| --- | --- | --- |\n| ****enqueue**** | O(1) | O(1) |\n| ****dequeue**** | O(1) | O(1) |\n| front | O(1) | O(1) |\n| size | O(1) | O(1) |\n| isEmpty | O(1) | O(1) |\n| isFull | O(1) | O(1) |\n\n****Types of Queues****\n-----------------------\n\nQueue data structure can be classified into 4 types:\n\n1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the\n   element from the front of the queue.\n2. [****Double-Ended Queue (Deque)****](https://www.geeksforgeeks.org/deque-set-1-introduction-applications)****:****\n   In a double-ended queue the insertion and deletion operations, both\n   can be performed from both ends. They are of two types:\n   * ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be\n     taken from only one end but deletion can be done from any of the\n     ends.\n   * ****Output Restricted Queue:****\n     This is also a simple queue. In this type of queue, the input can\n     be taken from both ends but deletion can be done from only one\n     end.\n3. [****Circular Queue:****](https://www.geeksforgeeks.org/introduction-to-circular-queue) This is a special type of queue where the last position is connected\n   back to the first position. Here also the operations are performed in\n   FIFO order.\n4. [****Priority Queue****](https://www.geeksforgeeks.org/priority-queue-set-1-introduction)****:****\n   A priority queue is a special queue where the elements are accessed\n   based on the priority assigned to them. They are of two types:\n   * ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in\n     increasing order of their priority values. Element with smallest\n     priority value is popped first.\n   * ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in\n     decreasing order of their priority values. Element with largest\n     priority is popped first.\n\n![Types-of-Queue](https://media.geeksforgeeks.org/wp-content/uploads/20241212125924381216/Types-of-Queue-660.webp)\n\n****Applications of Queue Data Structure****\n--------------------------------------------\n\nApplication of queue is common. In a computer system, there may be\nqueues of tasks waiting for the printer, for access to disk storage, or\neven in a time-sharing system, for use of the CPU. Within a single\nprogram, there may be multiple requests to be kept in a queue, or one\ntask may create other tasks, which must be done in turn by keeping them\nin a queue.\n\n* A Queue is always used as a buffer when we have a speed mismatch\n  between a producer and consumer. For example keyboard and CPU.\n* Queue can be used where we have a single resource and multiple\n  consumers like a single CPU and multiple processes.\n* In a network, a queue is used in devices such as a router/switch and\n  mail queue.\n* Queue can be used in various algorithm techniques like Breadth First\n  Search, Topological Sort, etc.",
        "metadata": {
            "lesson_id": "3126233c-3e02-455e-8152-6d095b943168",
            "course_id": "c9b04774-3a81-43ab-ace6-5242360d9e07",
            "course_name": "Queue",
            "lesson_description": "Queue is a linear data structure that follows FIFO (First In First Out) Principle, so the first element inserted is the first to be popped out.\n",
            "course_description": "The Queue lesson series dives into the mechanics of this fundamental data structure, which follows the FIFO (First In, First Out) principle. You\u2019ll learn how to perform operations such as enqueue, dequeue, and peek, while also exploring its variations like Circular Queues and Priority Queues. Practical applications, including task scheduling, buffering, and breadth-first search algorithms, will help solidify your understanding. This series is perfect for beginners and anyone looking to master essential programming concepts."
        }
    },
    {
        "page_content": "**Types of Queues:**\n\nThere are **five different types of queues** that are used in\ndifferent scenarios. They are:\n\n1. Input Restricted Queue (this is a Simple Queue)\n2. Output Restricted Queue (this is also a Simple Queue)\n3. Circular Queue\n4. Double Ended Queue (Deque)\n5. Priority Queue\n   * Ascending Priority Queue\n   * Descending Priority Queue\n\n![Types of Queues](https://media.geeksforgeeks.org/wp-content/uploads/20220623134709/typesofqueues.jpg)\n\nTypes of Queues\n\n**1.** [**Circular Queue**](https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/)**:** Circular Queue is a linear data structure in which the\noperations are performed based on FIFO (First In First Out) principle and\nthe last position is connected back to the first position to make a\ncircle. It is also called **\u2018Ring Buffer\u2019**. This queue is\nprimarily used in the following cases:\n\n1. **Memory Management:** The unused memory locations in the\n   case of ordinary queues can be utilized in circular queues.\n2. **Traffic system:** In a computer-controlled traffic\n   system, circular queues are used to switch on the traffic lights one by\n   one repeatedly as per the time set.\n3. **CPU Scheduling:** Operating systems often maintain a\n   queue of processes that are ready to execute or that are waiting for a\n   particular event to occur.\n\nThe time complexity for the circular Queue is O(1).\n\n**2. Input restricted Queue:** In this type of Queue, the\ninput can be taken from one side only(rear) and deletion of elements can\nbe done from both sides(front and rear). This kind of Queue does not\nfollow FIFO(first in first out).  This queue is used in cases where\nthe consumption of the data needs to be in FIFO order but if there is a\nneed to remove the recently inserted data for some reason and one such\ncase can be irrelevant data, performance issue, etc.\n\n\n\n![Input Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131417/inputrestrictedqueue.jpg)\n\nInput Restricted Queue\n\n**Advantages of Input restricted Queue:**\n\n* Prevents overflow and overloading of the queue by limiting the number of\n  items added\n* Helps maintain stability and predictable performance of the system\n\n**Disadvantages of Input restricted Queue:**\n\n* May lead to resource wastage if the restriction is set too low and items\n  are frequently discarded\n* May lead to waiting or blocking if the restriction is set too high and\n  the queue is full, preventing new items from being added.\n\n**3. Output restricted Queue:** In this type of Queue, the\ninput can be taken from both sides(rear and front) and the deletion of the\nelement can be done from only one side(front).  This queue is used in\nthe case where the inputs have some priority order to be executed and the\ninput can be placed even in the first place so that it is executed\nfirst.\n\n![Output Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131455/outputrestrictedqueue.jpg)\n\nOutput Restricted Queue\n\n**4.** [**Double ended Queue**](https://www.geeksforgeeks.org/deque-set-1-introduction-applications/)**:** Double Ended Queue is also a Queue data structure in\nwhich the insertion and deletion operations are performed at both the ends\n(front and rear). That means, we can insert at both front and rear\npositions and can delete from both front and rear positions.  Since\nDeque supports both stack and queue operations, it can be used as both.\nThe Deque data structure supports clockwise and anticlockwise rotations in\nO(1) time which can be useful in certain applications. Also, the problems\nwhere elements need to be removed and or added both ends can be\nefficiently solved using Deque.\n\n![Double Ended Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131811/doubleended.jpg)\n\nDouble Ended Queue\n\n**5.** [**Priority Queue**](https://www.geeksforgeeks.org/priority-queue-set-1-introduction/)**:** A priority queue is a special type of queue in which\neach element is associated with a priority and is served according to its\npriority. There are two types of Priority Queues. They are:\n\n1. **Ascending Priority Queue:** Element can be inserted\n   arbitrarily but only smallest element can be removed. For example,\n   suppose there is an array having elements 4, 2, 8 in the same order. So,\n   while inserting the elements, the insertion will be in the same sequence\n   but while deleting, the order will be 2, 4, 8.\n2. **Descending priority Queue:** Element can be inserted\n   arbitrarily but only the largest element can be removed first from the\n   given Queue. For example, suppose there is an array having elements 4,\n   2, 8 in the same order. So, while inserting the elements, the insertion\n   will be in the same sequence but while deleting, the order will be 8, 4,\n   2.\n\nThe time complexity of the Priority Queue is O(logn).\n\n[**Applications of a Queue:**](https://www.geeksforgeeks.org/applications-of-queue-data-structure/)\n\nThe\n[queue](https://www.geeksforgeeks.org/queue-set-1introduction-and-array-implementation/)\nis used when things don\u2019t have to be processed immediately, but have to be\nprocessed in First In First Out order like\n[Breadth First Search](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/). This property of Queue makes it also useful in the following kind of\nscenarios.\n\n1. When a resource is shared among multiple consumers. Examples include\n   [CPU scheduling](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/),\n   [Disk Scheduling](https://www.geeksforgeeks.org/disk-scheduling-algorithms/).\n2. When data is transferred asynchronously (data not necessarily received\n   at the same rate as sent) between two processes. Examples include IO\n   Buffers,\n   [pipes](https://www.geeksforgeeks.org/piping-in-unix-or-linux/), file IO, etc.\n3. Linear Queue: A linear queue is a type of queue where data elements are\n   added to the end of the queue and removed from the front of the queue.\n   Linear queues are used in applications where data elements need to be\n   processed in the order in which they are received. Examples include\n   printer queues and message queues.\n4. Circular Queue: A circular queue is similar to a linear queue, but the\n   end of the queue is connected to the front of the queue. This allows for\n   efficient use of space in memory and can improve performance. Circular\n   queues are used in applications where the data elements need to be\n   processed in a circular fashion. Examples include CPU scheduling and\n   memory management.\n5. Priority Queue: A priority queue is a type of queue where each element\n   is assigned a priority level. Elements with higher priority levels are\n   processed before elements with lower priority levels. Priority queues\n   are used in applications where certain tasks or data elements need to be\n   processed with higher priority. Examples include operating system task\n   scheduling and network packet scheduling.\n6. Double-ended Queue: A double-ended queue, also known as a deque, is a\n   type of queue where elements can be added or removed from either end of\n   the queue. This allows for more flexibility in data processing and can\n   be used in applications where elements need to be processed in multiple\n   directions. Examples include job scheduling and searching algorithms.\n7. Concurrent Queue: A concurrent queue is a type of queue that is designed\n   to handle multiple threads accessing the queue simultaneously.\n   Concurrent queues are used in multi-threaded applications where data\n   needs to be shared between threads in a thread-safe manner. Examples\n   include database transactions and web server requests.\n\n**Issues of Queue :**\n\nSome common issues that can arise when using queues:\n\n1. Queue overflow: Queue overflow occurs when the queue reaches its maximum\n   capacity and is unable to accept any more elements. This can cause data\n   loss and can lead to application crashes.\n2. Queue underflow: Queue underflow occurs when an attempt is made to\n   remove an element from an empty queue. This can cause errors and\n   application crashes.\n3. Priority inversion: Priority inversion occurs in priority queues when a\n   low-priority task holds a resource that a high-priority task needs. This\n   can cause delays in processing and can impact system performance.\n4. Deadlocks: Deadlocks occur when multiple threads or processes are\n   waiting for each other to release resources, resulting in a situation\n   where none of the threads can proceed. This can happen when using\n   concurrent queues and can lead to system crashes.\n5. Performance issues: Queue performance can be impacted by various\n   factors, such as the size of the queue, the frequency of access, and the\n   type of operations performed on the queue. Poor queue performance can\n   lead to slower system performance and reduced user experience.\n6. Synchronization issues: Synchronization issues can arise when multiple\n   threads are accessing the same queue simultaneously. This can result in\n   data corruption, race conditions, and other errors.\n7. Memory management issues: Queues can use up significant amounts of\n   memory, especially when processing large data sets. Memory leaks and\n   other memory management issues can occur, leading to system crashes and\n   other errors.\n\n**Reference :**\n\nSome references for further reading on queues:\n\n1. \u201cData Structures and Algorithms in Java\u201d by Robert Lafore \u2013 This book\n   provides an in-depth explanation of different types of queues and their\n   implementations in Java.\n2. \u201cIntroduction to Algorithms\u201d by Thomas H. Cormen et al. \u2013 This textbook\n   covers the basic concepts of data structures and algorithms, including\n   queues and their various applications.\n3. \u201cConcurrency in C# Cookbook\u201d by Stephen Cleary \u2013 This book provides\n   practical examples of how to use concurrent queues in C# programming.\n4. \u201cQueue (abstract data type)\u201d on Wikipedia \u2013 This article provides an\n   overview of queues and their properties, as well as examples of their\n   applications.\n5. \u201cThe Art of Computer Programming, Volume 1: Fundamental Algorithms\u201d by\n   Donald E. Knuth \u2013 This book includes a detailed analysis of different\n   queue algorithms and their performance.\n6. \u201cQueues and the Producer-Consumer Problem\u201d by Douglas C. Schmidt \u2013 This\n   paper discusses how queues can be used to solve the producer-consumer\n   problem in concurrent programming.",
        "metadata": {
            "lesson_id": "8d4f2d0d-a9f3-49f5-a13e-9aa4fad99826",
            "course_id": "c9b04774-3a81-43ab-ace6-5242360d9e07",
            "course_name": "Queue",
            "lesson_description": "Queue is a linear structure that follows a particular order in which the\noperations are performed. The order is First In First Out (FIFO). A good\nexample of a queue is any queue of consumers for a resource where the\nconsumer that came first is served first. In this article, the different\ntypes of queues are discussed.",
            "course_description": "The Queue lesson series dives into the mechanics of this fundamental data structure, which follows the FIFO (First In, First Out) principle. You\u2019ll learn how to perform operations such as enqueue, dequeue, and peek, while also exploring its variations like Circular Queues and Priority Queues. Practical applications, including task scheduling, buffering, and breadth-first search algorithms, will help solidify your understanding. This series is perfect for beginners and anyone looking to master essential programming concepts."
        }
    },
    {
        "page_content": "**Basic Operations on Queue:**\n------------------------------\n\nSome of the basic operations for Queue in Data Structure are:\n\n* **enqueue() \u2013** Insertion of elements to the queue.\n* **dequeue() \u2013** Removal of elements from the queue.\n* **peek() or front()-** Acquires the data element available\n  at the front node of the queue without deleting it.\n* **rear() \u2013** This operation returns the element at the rear\n  end without removing it.\n* **isFull() \u2013** Validates if the queue is full.\n* **isEmpty() \u2013** Checks if the queue is empty.\n* **size():** This operation returns the size of the queue\n  i.e. the total number of elements it contains.\n\n![](https://media.geeksforgeeks.org/wp-content/uploads/20221209094646/Queue-768.png)\n\nQueue Data Structure\n\n### **Operation 1: enqueue()**\n\nInserts an element at the end of the queue i.e. at the rear end.\n\nThe following steps should be taken to enqueue (insert) data into a queue:\n\n* Check if the queue is full.\n* If the queue is full, return overflow error and exit.\n* If the queue is not full, increment the rear pointer to point to the\n  next empty space.\n* Add the data element to the queue location, where the rear is pointing.\n* return success.\n\n![Enqueue representation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122158/fifo1-660x371.png)\n\nEnqueue representation\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n---\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `printf``(``\"\\nQueue is full\\n\"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n----\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `System.out.println(``\"\\nQueue is full\\n\"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n-\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to add an item to the queue.`  `// It changes rear and size`  `void` `enqueue(``struct` `Queue* queue,` `int` `item)`  `{`  `if` `(isFull(queue))`  `return``;`  `queue->rear = (queue->rear + 1) % queue->capacity;`  `queue->array[queue->rear] = item;`  `queue->size = queue->size + 1;`  `printf``(``\"%d enqueued to queue\\n\"``, item);`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n-------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to add an item to the queue.`  `# It changes rear and size`  `def` `EnQueue(``self``, item):`  `if` `self``.isFull():`  `print``(``\"Full\"``)`  `return`  `self``.rear` `=` `(``self``.rear` `+` `1``)` `%` `(``self``.capacity)`  `self``.Q[``self``.rear]` `=` `item`  `self``.size` `=` `self``.size` `+` `1`  `print``(``\"% s enqueued to queue\"` `%` `str``(item))`  `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n--\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `void` `enqueue(``int` `item)`  `{`  `if` `(rear == max - 1) {`  `Console.WriteLine(``\"Queue Overflow\"``);`  `return``;`  `}`  `else` `{`  `ele[++rear] = item;`  `}`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n----------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `enqueue(element){`  `// adding element to the queue`  `this``.items.push(element);`  `}`    `// This code is contributed by Susobhan Akhuli`  `</script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 2: dequeue()**\n\nThis operation removes and returns an element that is at the front end of\nthe queue.\n\nThe following steps are taken to perform the dequeue operation:\n\n* Check if the queue is empty.\n* If the queue is empty, return the underflow error and exit.\n* If the queue is not empty, access the data where the front is pointing.\n* Increment the front pointer to point to the next available data element.\n* The Return success.\n\n![Dequeue operation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122625/fifo2-660x371.png)\n\nDequeue operation\n\nBelow is the Implementation of above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n---\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `printf``(``\"\\nQueue is empty\\n\"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i = 0; i < rear - 1; i++) {`  `queue[i] = queue[i + 1];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n----\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `System.out.println(``\"\\nQueue is empty\\n\"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i =` `0``; i < rear -` `1``; i++) {`  `queue[i] = queue[i +` `1``];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n-\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to remove an item from queue.`  `// It changes front and size`  `int` `dequeue(``struct` `Queue* queue)`  `{`  `if` `(isEmpty(queue)) {`  `printf``(``\"\\nQueue is empty\\n\"``);`  `return``;`  `}`  `int` `item = queue->array[queue->front];`  `queue->front = (queue->front + 1) % queue->capacity;`  `queue->size = queue->size - 1;`  `return` `item;`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n-------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to remove an item from queue.`  `# It changes front and size`      `def` `DeQueue(``self``):`  `if` `self``.isEmpty():`  `print``(``\"Queue is empty\"``)`  `return`    `print``(``\"% s dequeued from queue\"` `%` `str``(``self``.Q[``self``.front]))`  `self``.front` `=` `(``self``.front` `+` `1``)` `%` `(``self``.capacity)`  `self``.size` `=` `self``.size` `-` `1`  `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n--\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to remove an item from queue.`  `// It changes front and size`  `public` `int` `dequeue()`  `{`  `if` `(front == rear + 1) {`  `Console.WriteLine(``\"Queue is Empty\"``);`  `return` `-1;`  `}`  `else` `{`  `int` `p = ele[front++];`  `return` `p;`  `}`  `}`  `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n----------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `dequeue(){`  `// removing element from the queue`  `// returns underflow when called`  `// on empty queue`  `if``(``this``.isEmpty()){`  `document.write(``\"<br>Queue is empty<br>\"``);`  `return` `-1;`  `}`  `return` `this``.items.shift();`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 3: front()**\n\nThis operation returns the element at the front end without removing it.\n\nThe following steps are taken to perform the front operation:\n\n* If the queue is empty return the most minimum value.\n* otherwise, return the front value.\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n---\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}` |\n| --- |\n\n\n\n\n\nJava\n----\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(Queue queue)`  `{`  `if` `(isempty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.front];`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n-\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n-------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to get front of queue`  `def` `que_front(``self``):`  `if` `self``.isempty():`  `return` `\"Queue is empty\"`  `return` `self``.Q[``self``.front]`    `# This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n--\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[front];`  `}`    `// This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n----------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `// Function to get front of queue`  `front(){`  `// returns the Front element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `\"No elements in Queue<br>\"``;`  `return` `this``.items[0];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### Operation 4 : rear()\n\nThis operation returns the element at the rear end without removing it.\n\nThe following steps are taken to perform the rear operation:\n\n* If the queue is empty return the most minimum value.\n* otherwise, return the rear value.\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* Python3\n* C#\n* Javascript\n\nC++\n---\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get rear of queue`  `int` `rear(Queue* queue)`  `{`  `if` `(isEmpty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}` |\n| --- |\n\n\n\n\n\nJava\n----\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get rear of queue`  `int` `rear(Queue queue)`  `{`  `if` `(isEmpty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.rear];`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n-\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n-------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Function to get rear of queue`  `def` `que_rear(``self``):`  `if` `self``.isEmpty():`  `return` `\"Queue is empty\"`  `return` `self``.Q[``self``.rear]`    `# This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n--\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[rear];`  `}`    `// This code is contributed By Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n----------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `<script>`  `rear(){`  `// returns the Rear element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `\"No elements in Queue<br>\"``;`  `return` `this``.items[``this``.items.length-1];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 5: isEmpty():**\n\nThis operation returns a boolean value that indicates whether the queue is\nempty or not.\n\nThe following steps are taken to perform the Empty operation:\n\n* check if front value is equal to -1 or not, if yes then return true\n  means queue is empty.\n* Otherwise return false, means queue is not empty\n\nBelow is the implementation of the above approach:\n\n* C++\n* Java\n* C#\n* C\n* Python3\n* Javascript\n\nC++\n---\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n----\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check whether`  `// the queue is empty or not:`  `boolean` `isEmpty()`  `{`  `if` `(front == -``1``)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC#\n--\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by lokeshmvs21.` |\n| --- |\n\n\n\n\n\nC\n-\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Queue is empty when size is 0`  `bool` `isEmpty(``struct` `Queue* queue)`  `{`  `return` `(queue->size == 0);`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n-------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Queue is empty when size is 0`  `def` `isEmpty(``self``):`  `return` `self``.size` `=``=` `0`  `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n----------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `</script>`  `isEmpty(){`  `// return true if the queue is empty.`  `return` `this``.items.length == 0;`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### **Operation 6 : isFull()**\n\nThis operation returns a boolean value that indicates whether the queue is\nfull or not.\n\nThe following steps are taken to perform the isFull() operation:\n\n* Check if front value is equal to zero and rear is equal to the capacity\n  of queue if yes then return true.\n* otherwise return false\n\nBelow is the Implementation of the above approach:\n\n* C++\n* Java\n* C\n* C#\n* Python3\n* Javascript\n\nC++\n---\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check`  `// whether the queue is full or not.`  `bool` `isFull()`  `{`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}` |\n| --- |\n\n\n\n\n\nJava\n----\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// This function will check`  `// whether the queue is full or not.`  `boolean` `isFull()`  `{`  `if` `(front ==` `0` `&& rear == MAX_SIZE -` `1``) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |\n| --- |\n\n\n\n\n\nC\n-\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Queue is full when size becomes`  `// equal to the capacity`  `bool` `isFull(``struct` `Queue* queue)`  `{`  `return` `(queue->size == queue->capacity);`  `}`    `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nC#\n--\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `bool` `isFull(``int` `item) {` `return` `(rear == max - 1); }`  `// This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nPython3\n-------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `# Queue is full when size becomes`  `# equal to the capacity`      `def` `isFull(``self``):`  `return` `self``.size` `=``=` `self``.capacity`    `# This code is contributed by Susobhan Akhuli` |\n| --- |\n\n\n\n\n\nJavascript\n----------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `function` `isFull() {`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityamaharshi21.` |\n| --- |\n\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n### Operation 7: size()\n\nThis operation returns the size of the queue i.e. the total number of\nelements it contains.\n\n```\nqueuename.size()\nParameters :\nNo parameters are passed\nReturns :\nNumber of elements in the container\n```\n\n* C++\n* Java\n* Python\n* C#\n* Javascript\n\nC++\n---\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// CPP program to illustrate`  `// Implementation of size() function`  `#include <iostream>`  `#include <queue>`  `using` `namespace` `std;`    `int` `main()`  `{`  `int` `sum = 0;`  `queue<``int``> myqueue;`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `cout << myqueue.size();`    `return` `0;`  `}` |\n| --- |\n\n\n\n\n\nJava\n----\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Java program to illustrate implementation of size()`  `// function`    `import` `java.util.*;`    `public` `class` `Main {`  `public` `static` `void` `main(String[] args)`  `{`  `int` `sum =` `0``;`  `Queue<Integer> myqueue =` `new` `LinkedList<>();`  `myqueue.add(``1``);`  `myqueue.add(``8``);`  `myqueue.add(``3``);`  `myqueue.add(``6``);`  `myqueue.add(``2``);`    `// Queue becomes 1, 8, 3, 6, 2`    `System.out.println(myqueue.size());`  `}`  `}`    `// This code is contributed by lokesh.` |\n| --- |\n\n\n\n\n\nPython\n------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `from` `collections` `import` `deque`    `def` `main():`  `sum` `=` `0`  `myqueue` `=` `deque()`  `myqueue.append(``1``)`  `myqueue.append(``8``)`  `myqueue.append(``3``)`  `myqueue.append(``6``)`  `myqueue.append(``2``)`    `# Queue becomes 1, 8, 3, 6, 2`    `print``(``len``(myqueue))`    `main()`    `# This code is contributed by aadityamaharshi21.` |\n| --- |\n\n\n\n\n\nC#\n--\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `using` `System;`  `using` `System.Collections.Generic;`    `namespace` `ConsoleApp1 {`  `class` `MainClass {`  `public` `static` `void` `Main(``string``[] args)`  `{`  `int` `sum = 0;`  `Queue<``int``> myqueue =` `new` `Queue<``int``>();`  `myqueue.Enqueue(1);`  `myqueue.Enqueue(8);`  `myqueue.Enqueue(3);`  `myqueue.Enqueue(6);`  `myqueue.Enqueue(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `Console.WriteLine(myqueue.Count);`  `}`  `}`  `}`    `// This code is contributed by adityamaharshi21.` |\n| --- |\n\n\n\n\n\nJavascript\n----------\n\n  \n\n\n\n  \n\n  \n\n\n\n\n| `// Javascript code`  `let sum = 0;`  `let myqueue=[];`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `console.log(myqueue.length);` |\n| --- |\n\n\n\n\n\n\n\n**Complexity Analysis:**  \n**Time Complexity:** O(1)  \n**Space Complexity:** O(N)\n\n",
        "metadata": {
            "lesson_id": "dd501d4c-f5c6-424f-9678-af343551671c",
            "course_id": "c9b04774-3a81-43ab-ace6-5242360d9e07",
            "course_name": "Queue",
            "lesson_description": "",
            "course_description": "The Queue lesson series dives into the mechanics of this fundamental data structure, which follows the FIFO (First In, First Out) principle. You\u2019ll learn how to perform operations such as enqueue, dequeue, and peek, while also exploring its variations like Circular Queues and Priority Queues. Practical applications, including task scheduling, buffering, and breadth-first search algorithms, will help solidify your understanding. This series is perfect for beginners and anyone looking to master essential programming concepts."
        }
    },
    {
        "page_content": "****Enqueue**** and when an element is deleted from the queue, then the operation is\nknown as ****Dequeue.****It is important to know that we cannot insert an element if the size of\nthe queue is full and cannot delete an element when the queue itself is\nempty. If we try to insert an element even after the queue is full, then\nsuch a condition is known as overflow whereas, if we try to delete an\nelement even after the queue is empty then such a condition is known as\nunderflow.\n\n****Primary Queue Operations:****\n\n* ****void enqueue(int Element):**** When this operation is performed, an element is inserted in the queue\n  at the end i.e. at the rear end. (Where T is Generic i.e we can define\n  Queue of any type of data structure.) This operation take ****constant time i.e O(1).****\n* ****int dequeue():****\n  When this operation is performed, an element is removed from the front\n  end and is returned. This operation take ****constant time i.e O(1).****\n\n****Auxiliary Queue Operations:****\n\n* ****int front():**** This operation will return the element at the front without removing\n  it and it take O(1) time.\n* ****int rear():**** This operation will return the element at the rear without removing\n  it, Its Time Complexity is O(1).\n* ****int isEmpty():**** This operation indicates whether the queue is empty or not. This\n  Operation also done in O(1).\n* ****int size():**** This operation will return the size of the queue i.e. the total\n  number of elements present in the queue and it\u2019s time complexity is\n  O(1).\n\n****Types of Queues:****\n\n* ****Simple Queue:**** Simple queue also known as a linear queue is the most basic version\n  of a queue. Here, insertion of an element i.e. the Enqueue operation\n  takes place at the rear end and removal of an element i.e. the Dequeue\n  operation takes place at the front end.\n* ****Circular Queue:****This is mainly an efficient array implementation of Simple Queue. In\n  a circular queue, the element of the queue act as a circular ring. The\n  working of a circular queue is similar to the linear queue except for\n  the fact that the last element is connected to the first element. Its\n  advantage is that the memory is utilized in a better way. This is\n  because if there is an empty space i.e. if no element is present at a\n  certain position in the queue, then an element can be easily added at\n  that position.\n* ****Priority Queue:**** This queue is a special type of queue. Its specialty is that it\n  arranges the elements in a queue based on some priority. The priority\n  can be something where the element with the highest value has the\n  priority so it creates a queue with decreasing order of values. The\n  priority can also be such that the element with the lowest value gets\n  the highest priority so in turn it creates a queue with increasing\n  order of values.\n* ****Dequeue:**** Dequeue is also known as Double Ended Queue. As the name suggests\n  double ended, it means that an element can be inserted or removed from\n  both the ends of the queue unlike the other queues in which it can be\n  done only from one end. Because of this property it may not obey the\n  First In First Out property.\n\n****Implementation of Queue:****\n\n* ****Sequential allocation:**** A queue can be implemented using an array. It can organize a limited\n  number of elements.\n* ****Linked list allocation:****\n  A queue can be implemented using a linked list. It can organize an\n  unlimited number of elements.\n\n****Applications of Queue:****\n\n* ****Multi programming:**** Multi programming means when multiple programs are running in the\n  main memory. It is essential to organize these multiple programs and\n  these multiple programs are organized as queues.\n* ****Network:**** In a network, a queue is used in devices such as a router or a\n  switch. another application of a queue is a mail queue which is a\n  directory that stores data and controls files for mail messages.\n* ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that\n  are scheduled to be executed one after another. These jobs are\n  assigned to the processor one by one which is organized using a\n  queue.\n* ****Shared resources:**** Queues are used as waiting lists for a single shared resource.\n\n****Real-time application of Queue:****\n\n* Working as a buffer between a slow and a fast device. For example\n  keyboard and CPU, and two devices on network.\n* ATM Booth Line\n* Ticket Counter Line\n* CPU task scheduling\n* Waiting time of each customer at call centers.\n\n****Advantages of Queue:****\n\n* A large amount of data can be managed efficiently with ease.\n* Operations such as insertion and deletion can be performed with ease\n  as it follows the first in first out rule.\n* Queues are useful when a particular service is used by multiple\n  consumers.\n* Queues are fast in speed for data inter-process communication.\n* Queues can be used in the implementation of other data\n  structures.\n\n****Disadvantages of Queue:****\n\n* The operations such as insertion and deletion of elements from the\n  middle are time consuming.\n* In a classical queue, a new element can only be inserted when the\n  existing elements are deleted from the queue.\n* Searching an element takes O(N) time.\n* Maximum size of a queue must be defined prior in case of array\n  implementation.",
        "metadata": {
            "lesson_id": "21135289-e645-4045-a26c-697c91f3873f",
            "course_id": "c9b04774-3a81-43ab-ace6-5242360d9e07",
            "course_name": "Queue",
            "lesson_description": "A Queue\nis a linear data structure. This data structure follows a particular\norder in which the operations are performed. The order is First In First Out (FIFO). It means that the element that is inserted first in the queue will\ncome out first and the element that is inserted last will come out last.",
            "course_description": "The Queue lesson series dives into the mechanics of this fundamental data structure, which follows the FIFO (First In, First Out) principle. You\u2019ll learn how to perform operations such as enqueue, dequeue, and peek, while also exploring its variations like Circular Queues and Priority Queues. Practical applications, including task scheduling, buffering, and breadth-first search algorithms, will help solidify your understanding. This series is perfect for beginners and anyone looking to master essential programming concepts."
        }
    },
    {
        "page_content": "Representation of Stack Data Structure:\n---------------------------------------\n\nStack follows LIFO (Last In First Out) Principle so the element which\nis pushed last is popped first.\n\n\n![Stack-representation-in-Data-Structures-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180735/Stack-representation-in-Data-Structures-(1).webp)\n\n****Types of Stack:****\n-----------------------\n\n* ****Fixed Size Stack**** \n  : As the name suggests, a fixed size stack has a fixed size and cannot\n  grow or shrink dynamically. If the stack is full and an attempt is\n  made to add an element to it, an overflow error occurs. If the stack\n  is empty and an attempt is made to remove an element from it, an\n  underflow error occurs.\n* ****Dynamic Size Stack**** \n  : A dynamic size stack can grow or shrink dynamically. When the stack\n  is full, it automatically increases its size to accommodate the new\n  element, and when the stack is empty, it decreases its size. This type\n  of stack is implemented using a linked list, as it allows for easy\n  resizing of the stack.\n\nBasic Operations on Stack:\n--------------------------\n\nIn order to make manipulations in a stack, there are certain operations\nprovided to us.\n\n\n* ****push()****  to insert an element into the stack\n* ****pop()****  to remove an element from the stack\n* ****top()****  Returns the top element of the stack.\n* ****isEmpty()****  returns true if stack is empty else false.\n* ****isFull()****  returns true if the stack is full else false.\n\nTo implement stack, we need to maintain reference to the top\nitem.\n\n### ****Push Operation on Stack****\n\nAdds an item to the stack. If the stack is full, then it is said to be\nan  ****Overflow condition.**** \n\n ****Algorithm for Push Operation:**** \n\n* Before pushing the element to the stack, we check if the stack is  ****full****  .\n* If the stack is full  ****(top == capacity-1)****  , then  ****Stack Overflows****  and we cannot insert the element to the stack.\n* Otherwise, we increment the value of top by 1  ****(top = top + 1)****  and the new value is inserted at  ****top position****  .\n* The elements can be pushed into the stack till we reach the  ****capacity****  of the stack.\n\n![Push-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180844/Push-Operation-in-Stack-(1).webp)\n### ****Pop Operation in Stack****\n\nRemoves an item from the stack. The items are popped in the reversed\norder in which they are pushed. If the stack is empty, then it is said\nto be an  ****Underflow condition.**** \n\n****Algorithm for Pop Operation:**** \n\n* Before popping the element from the stack, we check if the stack is  ****empty****  .\n* If the stack is empty (top == -1), then  ****Stack Underflows****  and we cannot remove any element from the stack.\n* Otherwise, we store the value at top, decrement the value of top by 1  ****(top = top \u2013 1)****  and return the stored top value.\n\n![Pop-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180943/Pop-Operation-in-Stack-(1).webp)\n### ****Top or Peek Operation on Stack****\n\nReturns the top element of the stack. \n\n****Algorithm for Top Operation:**** \n\n* Before returning the top element from the stack, we check if the\n  stack is empty.\n* If the stack is empty (top == -1), we simply print \u201cStack is empty\u201d.\n* Otherwise, we return the element stored at  ****index = top****  .\n\n![Top-or-Peek-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181023/Top-or-Peek-Operation-in-Stack-(1).webp)\n### ****isEmpty Operation in Stack Data Structure:****\n\nReturns true if the stack is empty, else false. \n\n****Algorithm for isEmpty Operation****: \n\n* Check for the value of  ****top****  in stack.\n* If  ****(top == -1)****, then the stack is  ****empty****  so return  ****true****  .\n* Otherwise, the stack is not empty so return  ****false****  .\n\n![isEmpty-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181101/isEmpty-Operation-in-Stack-(1).webp)\n### isFull ****Operation in Stack**** ****Data Structure****:\n\nReturns true if the stack is full, else false. \n\n****Algorithm for isFull Operation:**** \n\n* Check for the value of  ****top****  in stack.\n* If  ****(top == capacity-1),****  then the stack is  ****full****  so return  ****true****.\n* Otherwise, the stack is not full so return  ****false****.\n\n![isFull-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181147/isFull-Operation-in-Stack-(1).webp)\n\nImplementation of Stack\n-----------------------\n\n\nThe basic operations that can be performed on a stack include push, pop,\nand peek. There are two ways to implement a stack \u2013\n\n\n* [****Implementation of Stack using Array****](https://www.geeksforgeeks.org/implement-stack-using-array/)\n* [****Implementation of Stack using Linked List****](https://www.geeksforgeeks.org/implement-a-stack-using-singly-linked-list/)\n\n****Complexity Analysis of Operations on Stack Data Structure:****\n------------------------------------------------------------------\n\n| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |\n| --- | --- | --- |\n| ****push()**** | O(1) | O(1) |\n| ****pop()**** | O(1) | O(1) |\n| top() or  ****pee****k() | O(1) | O(1) |\n| isEmpty() | O(1) | O(1) |\n| isFull() | O(1) | O(1) |",
        "metadata": {
            "lesson_id": "451c319e-a0a3-48e5-baca-ece2737e6010",
            "course_id": "95713603-63d1-4b75-8a89-1acdc0977459",
            "course_name": "Stack",
            "lesson_description": "Stack is a linear data structure that follows LIFO (Last In First Out) Principle, the last element inserted is the first to be popped out. It means\nboth insertion and deletion operations happen at one end only.",
            "course_description": "The Stack lesson series offers a comprehensive introduction to one of the fundamental data structures in programming. You'll explore how a Stack operates based on the LIFO (Last In, First Out) principle, perform core operations such as push, pop, and peek, and apply these concepts to real-world problems like validating parentheses, converting expressions, or building a browser's backtracking system. This series is ideal for beginners and those looking to strengthen their understanding of data structures."
        }
    },
    {
        "page_content": "Implement Stack using Array:\n----------------------------\n\n> To implement a stack using an array, initialize an array and treat\n> its end as the stack\u2019s top. Implement ****push**** (add to end), ****pop**** (remove from end), and ****peek**** (check end) operations, handling cases for an ****empty**** or f****ull stack****.\n\n****Step-by-step approach:****\n\n1. ****Initialize an array**** to represent the stack.\n2. Use the ****end of the array**** to represent the ****top of the stack****.\n3. Implement ****push**** (add to end), ****pop**** (remove from the end), and ****peek**** (check end) operations, ensuring to handle empty and full stack\n   conditions.\n\nImplement Stack Operations using Array:\n---------------------------------------\n\n\nHere are the following operations of implement stack using array:\n\n### ****Push Operation in Stack:****\n\nAdds an item to the stack. If the stack is full, then it is said to be\nan ****Overflow condition.****\n\n****Algorithm for Push Operation:****\n\n> * Before pushing the element to the stack, we check if the stack\n>   is ****full****.\n> * If the stack is full ****(top == capacity-1)****, then ****Stack Overflows****and we cannot insert the element to the stack.\n> * Otherwise, we increment the value of top by 1 ****(top = top + 1)****and the new value is inserted at ****top position****.\n> * The elements can be pushed into the stack till we reach\n>   the ****capacity****of the stack.\n\n![push-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114219/push-operation-in-stack-1.webp)![push-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114219/push-operation-in-stack-1.webp)\n\n\n![push-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114220/push-operation-in-stack-2.webp)![push-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114220/push-operation-in-stack-2.webp)\n\n\n![push-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114221/push-operation-in-stack-3.webp)![push-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114221/push-operation-in-stack-3.webp)\n\n\n![push-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-4.webp)![push-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-4.webp)\n\n\n![push-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-5.webp)![push-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-5.webp)\n\n\n![push-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114223/push-operation-in-stack-6.webp)![push-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114223/push-operation-in-stack-6.webp)\n\n\n\nPrevious\n\n\n\n\n\nPause\n\nNext\n\n\n\n\n\n5 / 6\n\n### ****Pop Operation in Stack:****\n\nRemoves an item from the stack. The items are popped in the reversed\norder in which they are pushed. If the stack is empty, then it is said\nto be an ****Underflow condition.****\n\n****Algorithm for Pop Operation:****\n\n> * Before popping the element from the stack, we check if the stack\n>   is ****empty****.\n> * If the stack is empty (top == -1), then ****Stack Underflows****and we cannot remove any element from the stack.\n> * Otherwise, we store the value at top, decrement the value of top by\n>   1 ****(top = top \u2013 1)****and return the stored top value.\n\n![pop-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)\n\n\n![pop-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)\n\n\n![pop-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)\n\n\n![pop-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)\n\n\n![pop-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)\n\n\n![pop-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)\n\n\n\nPrevious\n\n\n\n\n\nPlay\n\nNext\n\n\n\n\n\n1 / 6\n\n  \n\n\n### ****Top or Peek Operation in Stack:****\n\nReturns the top element of the stack.\n\n****Algorithm for Top Operation:****\n\n> * Before returning the top element from the stack, we check if the\n>   stack is empty.\n> * If the stack is empty (top == -1), we simply print \u201cStack is\n>   empty\u201d.\n> * Otherwise, we return the element stored at ****index = top****.\n\n### ****isEmpty Operation in Stack:****\n\nReturns true if the stack is empty, else false.\n\n****Algorithm for isEmpty Operation****:\n\n> * Check for the value of ****top****in stack.\n> * If ****(top == -1)****, then the stack is ****empty****so return ****true****.\n> * Otherwise, the stack is not empty so return ****false****.\n\n### isFull ****Operation in Stack****:\n\nReturns true if the stack is full, else false.\n\n****Algorithm for isFull Operation:****\n\n> * Check for the value of ****top****in stack.\n> * If ****(top == capacity-1),****then the stack is ****full****so return ****true****.\n> * Otherwise, the stack is not full so return ****false.****\n\nBelow is the implementation of the above approach:\n\nC++\n````\n/* C++ program to implement basic stack \noperations */\n#include <bits/stdc++.h> \n\nusing namespace std; \n\n#define MAX 1000 \n\nclass Stack { \n    int top; \n\npublic: \n    int a[MAX]; // Maximum size of Stack \n\n    Stack() { top = -1; } \n    bool push(int x); \n    int pop(); \n    int peek(); \n    bool isEmpty(); \n}; \n\nbool Stack::push(int x) \n{ \n    if (top >= (MAX - 1)) { \n        cout << \"Stack Overflow\"; \n        return false; \n    } \n    else { \n        a[++top] = x; \n        cout << x << \" pushed into stack\\n\"; \n        return true; \n    } \n} \n\nint Stack::pop() \n{ \n    if (top < 0) { \n        cout << \"Stack Underflow\"; \n        return 0; \n    } \n    else { \n        int x = a[top--]; \n        return x; \n    } \n} \nint Stack::peek() \n{ \n    if (top < 0) { \n        cout << \"Stack is Empty\"; \n        return 0; \n    } \n    else { \n        int x = a[top]; \n        return x; \n    } \n} \n\nbool Stack::isEmpty() \n{ \n    return (top < 0); \n} \n\n// Driver program to test above functions \nint main() \n{ \n    class Stack s; \n    s.push(10); \n    s.push(20); \n    s.push(30); \n    cout << s.pop() << \" Popped from stack\\n\"; \n    \n    //print top element of stack after popping \n    cout << \"Top element is : \" << s.peek() << endl; \n    \n    //print all elements in stack : \n    cout <<\"Elements present in stack : \"; \n    while(!s.isEmpty()) \n    { \n        // print top element in stack \n        cout << s.peek() <<\" \"; \n        // remove top element in stack \n        s.pop(); \n    } \n\n    return 0; \n}\n\n````\n\nC\n````\n// C program for array implementation of stack \n#include <limits.h> \n#include <stdio.h> \n#include <stdlib.h> \n\n// A structure to represent a stack \nstruct Stack { \n    int top; \n    unsigned capacity; \n    int* array; \n}; \n\n// function to create a stack of given capacity. It initializes size of \n// stack as 0 \nstruct Stack* createStack(unsigned capacity) \n{ \n    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack)); \n    stack->capacity = capacity; \n    stack->top = -1; \n    stack->array = (int*)malloc(stack->capacity * sizeof(int)); \n    return stack; \n} \n\n// Stack is full when top is equal to the last index \nint isFull(struct Stack* stack) \n{ \n    return stack->top == stack->capacity - 1; \n} \n\n// Stack is empty when top is equal to -1 \nint isEmpty(struct Stack* stack) \n{ \n    return stack->top == -1; \n} \n\n// Function to add an item to stack. It increases top by 1 \nvoid push(struct Stack* stack, int item) \n{ \n    if (isFull(stack)) \n        return; \n    stack->array[++stack->top] = item; \n    printf(\"%d pushed to stack\\n\", item); \n} \n\n// Function to remove an item from stack. It decreases top by 1 \nint pop(struct Stack* stack) \n{ \n    if (isEmpty(stack)) \n        return INT_MIN; \n    return stack->array[stack->top--]; \n} \n\n// Function to return the top from stack without removing it \nint peek(struct Stack* stack) \n{ \n    if (isEmpty(stack)) \n        return INT_MIN; \n    return stack->array[stack->top]; \n} \n\n// Driver program to test above functions \nint main() \n{ \n    struct Stack* stack = createStack(100); \n\n    push(stack, 10); \n    push(stack, 20); \n    push(stack, 30); \n\n    printf(\"%d popped from stack\\n\", pop(stack)); \n\n    return 0; \n} \n\n````\n\nJava\n````\n/* Java program to implement basic stack \noperations */\nclass Stack { \n    static final int MAX = 1000; \n    int top; \n    int a[] = new int[MAX]; // Maximum size of Stack \n\n    boolean isEmpty() \n    { \n        return (top < 0); \n    } \n    Stack() \n    { \n        top = -1; \n    } \n\n    boolean push(int x) \n    { \n        if (top >= (MAX - 1)) { \n            System.out.println(\"Stack Overflow\"); \n            return false; \n        } \n        else { \n            a[++top] = x; \n            System.out.println(x + \" pushed into stack\"); \n            return true; \n        } \n    } \n\n    int pop() \n    { \n        if (top < 0) { \n            System.out.println(\"Stack Underflow\"); \n            return 0; \n        } \n        else { \n            int x = a[top--]; \n            return x; \n        } \n    } \n\n    int peek() \n    { \n        if (top < 0) { \n            System.out.println(\"Stack Underflow\"); \n            return 0; \n        } \n        else { \n            int x = a[top]; \n            return x; \n        } \n    } \n    \n    void print(){ \n    for(int i = top;i>-1;i--){ \n    System.out.print(\" \"+ a[i]); \n    } \n} \n} \n\n// Driver code \nclass Main { \n    public static void main(String args[]) \n    { \n        Stack s = new Stack(); \n        s.push(10); \n        s.push(20); \n        s.push(30); \n        System.out.println(s.pop() + \" Popped from stack\"); \n        System.out.println(\"Top element is :\" + s.peek()); \n        System.out.print(\"Elements present in stack :\"); \n        s.print(); \n    } \n} \n\n````\n\nPython3\n````\n# Python program for implementation of stack \n\n# import maxsize from sys module \n# Used to return -infinite when stack is empty \nfrom sys import maxsize \n\n# Function to create a stack. It initializes size of stack as 0 \ndef createStack(): \n    stack = [] \n    return stack \n\n# Stack is empty when stack size is 0 \ndef isEmpty(stack): \n    return len(stack) == 0\n\n# Function to add an item to stack. It increases size by 1 \ndef push(stack, item): \n    stack.append(item) \n    print(item + \" pushed to stack \") \n    \n# Function to remove an item from stack. It decreases size by 1 \ndef pop(stack): \n    if (isEmpty(stack)): \n        return str(-maxsize -1) # return minus infinite \n    \n    return stack.pop() \n\n# Function to return the top from stack without removing it \ndef peek(stack): \n    if (isEmpty(stack)): \n        return str(-maxsize -1) # return minus infinite \n    return stack[len(stack) - 1] \n\n# Driver program to test above functions     \nstack = createStack() \npush(stack, str(10)) \npush(stack, str(20)) \npush(stack, str(30)) \nprint(pop(stack) + \" popped from stack\") \n\n````\n\nC#\n````\n// C# program to implement basic stack \n// operations \nusing System; \n\nnamespace ImplementStack { \nclass Stack { \n    private int[] ele; \n    private int top; \n    private int max; \n    public Stack(int size) \n    { \n        ele = new int[size]; // Maximum size of Stack \n        top = -1; \n        max = size; \n    } \n\n    public void push(int item) \n    { \n        if (top == max - 1) { \n            Console.WriteLine(\"Stack Overflow\"); \n            return; \n        } \n        else { \n            ele[++top] = item; \n        } \n    } \n\n    public int pop() \n    { \n        if (top == -1) { \n            Console.WriteLine(\"Stack is Empty\"); \n            return -1; \n        } \n        else { \n            Console.WriteLine(\"{0} popped from stack \", ele[top]); \n            return ele[top--]; \n        } \n    } \n\n    public int peek() \n    { \n        if (top == -1) { \n            Console.WriteLine(\"Stack is Empty\"); \n            return -1; \n        } \n        else { \n            Console.WriteLine(\"{0} popped from stack \", ele[top]); \n            return ele[top]; \n        } \n    } \n\n    public void printStack() \n    { \n        if (top == -1) { \n            Console.WriteLine(\"Stack is Empty\"); \n            return; \n        } \n        else { \n            for (int i = 0; i <= top; i++) { \n                Console.WriteLine(\"{0} pushed into stack\", ele[i]); \n            } \n        } \n    } \n} \n\n// Driver program to test above functions \nclass Program { \n    static void Main() \n    { \n        Stack p = new Stack(5); \n\n        p.push(10); \n        p.push(20); \n        p.push(30); \n        p.printStack(); \n        p.pop(); \n    } \n} \n} \n\n````\n\nJavaScript\n````\n/* javascript program to implement basic stack \noperations \n*/\nvar t = -1; \n    var MAX = 1000; \n    var a = Array(MAX).fill(0); // Maximum size of Stack \n\n    function isEmpty() { \n        return (t < 0); \n    } \n\n    function push(x) { \n        if (t >= (MAX - 1)) { \n            console.log(\"Stack Overflow\"); \n            return false; \n        } else { \n        t+=1; \n            a[t] = x; \n            \n            console.log(x + \" pushed into stack<br/>\"); \n            return true; \n        } \n    } \n\n    function pop() { \n        if (t < 0) { \n            console.log(\"Stack Underflow\"); \n            return 0; \n        } else { \n            var x = a[t]; \n            t-=1; \n            return x; \n        } \n    } \n\n    function peek() { \n        if (t < 0) { \n            console.log(\"Stack Underflow\"); \n            return 0; \n        } else { \n            var x = a[t]; \n            return x; \n        } \n    } \n\n    function print() { \n        for (i = t; i > -1; i--) { \n            console.log(\" \" + a[i]); \n        } \n    } \n\n        push(10); \n        push(20); \n        push(30); \n        console.log(pop() + \" Popped from stack\"); \n        console.log(\"<br/>Top element is :\" + peek()); \n        console.log(\"<br/>Elements present in stack : \"); \n        print(); \n\n````\n\n\n\n\n\n58\n\n\n\n\n\n1\n\n```\n/* javascript program to implement basic stack \n```\n\n2\n\n```\noperations \n```\n\n3\n\n```\n*/\n```\n\n4\n\n```\nvar t = -1; \n```\n\n5\n\n```\n    var MAX = 1000; \n```\n\n6\n\n```\n    var a = Array(MAX).fill(0); // Maximum size of Stack \n```\n\n7\n\n```\n\u200b\n```\n\n8\n\n```\n    function isEmpty() { \n```\n\n9\n\n```\n        return (t < 0); \n```\n\n10\n\n```\n    } \n```\n\n11\n\n```\n\u200b\n```\n\n12\n\n```\n    function push(x) { \n```\n\n13\n\n```\n        if (t >= (MAX - 1)) { \n```\n\n14\n\n```\n            console.log(\"Stack Overflow\"); \n```\n\n15\n\n```\n            return false; \n```\n\n16\n\n```\n        } else { \n```\n\n17\n\n```\n        t+=1; \n```\n\n18\n\n```\n            a[t] = x; \n```\n\n19\n\n```\n            \n```\n\n20\n\n```\n            console.log(x + \" pushed into stack<br/>\"); \n```\n\n21\n\n```\n            return true; \n```\n\n22\n\n```\n        } \n```\n\n23\n\n```\n    } \n```\n\n24\n\n```\n\u200b\n```\n\n25\n\n```\n    function pop() { \n```\n\n26\n\n```\n        if (t < 0) { \n```\n\n27\n\n```\n            console.log(\"Stack Underflow\"); \n```\n\n28\n\n```\n            return 0; \n```\n\n29\n\n```\n        } else { \n```\n\n30\n\n```\n            var x = a[t]; \n```\n\n31\n\n```\n            t-=1; \n```\n\n32\n\n```\n            return x; \n```\n\n33\n\n```\n        } \n```\n\n34\n\n```\n    } \n```\n\n35\n\n```\n\u200b\n```\n\n36\n\n```\n    function peek() { \n```\n\n37\n\n```\n        if (t < 0) { \n```\n\n38\n\n```\n            console.log(\"Stack Underflow\"); \n```\n\n39\n\n```\n            return 0; \n```\n\n40\n\n```\n        } else { \n```\n\n41\n\n```\n            var x = a[t]; \n```\n\n42\n\n```\n            return x; \n```\n\n43\n\n```\n        } \n```\n\n44\n\n```\n    } \n```\n\n45\n\n```\n\u200b\n```\n\n46\n\n```\n    function print() { \n```\n\n47\n\n```\n        for (i = t; i > -1; i--) { \n```\n\n48\n\n```\n            console.log(\" \" + a[i]); \n```\n\n49\n\n```\n        } \n```\n\n50\n\n```\n    } \n```\n\n51\n\n```\n\u200b\n```\n\n52\n\n```\n        push(10); \n```\n\n53\n\n```\n        push(20); \n```\n\n54\n\n```\n        push(30); \n```\n\n55\n\n```\n        console.log(pop() + \" Popped from stack\"); \n```\n\n56\n\n```\n        console.log(\"<br/>Top element is :\" + peek()); \n```\n\n57\n\n```\n        console.log(\"<br/>Elements present in stack : \"); \n```\n\n58\n\n```\n        print();\n```\n\n\n\n\n\n\n\n\n\n  \n**Output**\n```\n\n10 pushed into stack\n20 pushed into stack\n30 pushed into stack\n30 Popped from stack\nTop element is : 20\nElements present in stack : 20 10 \n```\n### Complexity Analysis:\n\n* ****Time Complexity****:\n  + `push`: O(1)\n  + `pop`: O(1)\n  + `peek`: O(1)\n  + `is_empty`: O(1)\n  + is\\_full: O(1)\n* ****Auxiliary Space****: O(n), where n is the number of items in the stack.\n\nAdvantages of Array Implementation:\n-----------------------------------\n\n* Easy to implement.\n* Memory is saved as pointers are not involved.\n\nDisadvantages of Array Implementation:\n--------------------------------------\n\n* It is not dynamic i.e., it doesn\u2019t grow and shrink depending on needs\n  at runtime. [But in case of dynamic sized arrays like vector in C++,\n  list in Python, ArrayList in Java, stacks can grow and shrink with\n  array implementation as well].\n* The total size of the stack must be defined beforehand.",
        "metadata": {
            "lesson_id": "63ddc11b-1888-48d8-afe0-f7153a56cc65",
            "course_id": "95713603-63d1-4b75-8a89-1acdc0977459",
            "course_name": "Stack",
            "lesson_description": "Stack is a linear data structurewhich follows LIFO principle. In this article, we will learn how to implement Stack using\nArrays. In Array-based approach, all stack-related operations are\nexecuted using arrays. Let\u2019s see how we can implement each operation on\nthe stack utilizing the Array Data Structure.",
            "course_description": "The Stack lesson series offers a comprehensive introduction to one of the fundamental data structures in programming. You'll explore how a Stack operates based on the LIFO (Last In, First Out) principle, perform core operations such as push, pop, and peek, and apply these concepts to real-world problems like validating parentheses, converting expressions, or building a browser's backtracking system. This series is ideal for beginners and those looking to strengthen their understanding of data structures."
        }
    },
    {
        "page_content": "****Stack Operations:****\n-------------------------\n\n* [****push()****](https://www.geeksforgeeks.org/stack-push-and-pop-in-c-stl/)****:****\n  Insert a new element into the stack i.e just insert a new element at\n  the beginning of the linked list.\n* [****pop()****](https://www.geeksforgeeks.org/stack-push-and-pop-in-c-stl/)****:****\n  Return the top element of the Stack i.e simply delete the first\n  element from the linked list.\n* [****peek()****](https://www.geeksforgeeks.org/stack-peek-method-in-java/)****:**** Return the top element.\n* ****display():**** Print all elements in Stack.\n\nPush Operation:\n---------------\n\n> * Initialise a node\n> * Update the value of that node by data i.e. ****node->data = data****\n> * Now link this node to the top of the linked list\n> * And update top pointer to the current node\n\nPop Operation:\n--------------\n\n> * First Check whether there is any node present in the linked list or\n>   not, if not then return\n> * Otherwise make pointer let say ****temp**** to the top node and move forward the top node by 1 step\n> * Now free this temp node\n\nPeek Operation:\n---------------\n\n> * Check if there is any node present or not, if not then\n>   return.\n> * Otherwise return the value of top node of the linked list\n\nDisplay Operation:\n------------------\n\n> * Take a ****temp**** node and initialize it with top pointer\n> * Now start traversing temp till it encounters NULL\n> * Simultaneously print the value of the temp node\n\n \n\nBelow is the implementation of the above operations \n\nC++\n````\n// C++ program to implement a stack using singly linked list\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Class representing a node in the linked list\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node(int new_data) {\n        this->data = new_data;\n        this->next = nullptr;\n    }\n};\n\n// Class to implement stack using a singly linked list\nclass Stack {\n\n    // head of the linked list\n    Node* head;\n\npublic:\n    // Constructor to initialize the stack\n    Stack() { this->head = nullptr; }\n\n    // Function to check if the stack is empty\n    bool isEmpty() {\n      \n        // If head is nullptr, the stack is empty\n        return head == nullptr;\n    }\n\n    // Function to push an element onto the stack\n    void push(int new_data) {\n      \n        // Create a new node with given data\n        Node* new_node = new Node(new_data);\n\n        // Check if memory allocation for the new node\n        // failed\n        if (!new_node) {\n            cout << \"\\nStack Overflow\";\n        }\n\n        // Link the new node to the current top node\n        new_node->next = head;\n\n        // Update the top to the new node\n        head = new_node;\n    }\n\n    // Function to remove the top element from the stack\n    void pop() {\n\n        // Check for stack underflow\n        if (this->isEmpty()) {\n            cout << \"\\nStack Underflow\" << endl;\n        }\n        else {\n            // Assign the current top to a temporary\n            // variable\n            Node* temp = head;\n\n            // Update the top to the next node\n            head = head->next;\n\n            // Deallocate the memory of the old top node\n            delete temp;\n        }\n    }\n\n    // Function to return the top element of the stack\n    int peek() {\n\n        // If stack is not empty, return the top element\n        if (!isEmpty())\n            return head->data;\n        else {\n            cout << \"\\nStack is empty\";\n            return INT_MIN;\n        }\n    }\n};\n\n// Driver program to test the stack implementation\nint main() {\n    // Creating a stack\n    Stack st;\n\n    // Push elements onto the stack\n    st.push(11);\n    st.push(22);\n    st.push(33);\n    st.push(44);\n\n    // Print top element of the stack\n    cout << \"Top element is \" << st.peek() << endl;\n\n    // removing two elemements from the top\n      cout << \"Removing two elements...\" << endl;\n    st.pop();\n    st.pop();\n\n    // Print top element of the stack\n    cout << \"Top element is \" << st.peek() << endl;\n\n    return 0;\n}\n\n````\n\nC\n````\n// C program to implement a stack using singly linked list\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// Struct representing a node in the linked list\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\nNode* createNode(int new_data) {\n    Node* new_node = (Node*)malloc(sizeof(Node));\n    new_node->data = new_data;\n    new_node->next = NULL;\n    return new_node;\n}\n\n// Struct to implement stack using a singly linked list\ntypedef struct Stack {\n    Node* head;\n} Stack;\n\n// Constructor to initialize the stack\nvoid initializeStack(Stack* stack) { stack->head = NULL; }\n\n// Function to check if the stack is empty\nint isEmpty(Stack* stack) {\n  \n    // If head is NULL, the stack is empty\n    return stack->head == NULL;\n}\n\n// Function to push an element onto the stack\nvoid push(Stack* stack, int new_data) {\n  \n    // Create a new node with given data\n    Node* new_node = createNode(new_data);\n\n    // Check if memory allocation for the new node failed\n    if (!new_node) {\n        printf(\"\\nStack Overflow\");\n        return;\n    }\n\n    // Link the new node to the current top node\n    new_node->next = stack->head;\n\n    // Update the top to the new node\n    stack->head = new_node;\n}\n\n// Function to remove the top element from the stack\nvoid pop(Stack* stack) {\n  \n    // Check for stack underflow\n    if (isEmpty(stack)) {\n        printf(\"\\nStack Underflow\\n\");\n        return;\n    }\n    else {\n      \n        // Assign the current top to a temporary variable\n        Node* temp = stack->head;\n\n        // Update the top to the next node\n        stack->head = stack->head->next;\n\n        // Deallocate the memory of the old top node\n        free(temp);\n    }\n}\n\n// Function to return the top element of the stack\nint peek(Stack* stack) {\n  \n    // If stack is not empty, return the top element\n    if (!isEmpty(stack))\n        return stack->head->data;\n    else {\n        printf(\"\\nStack is empty\");\n        return INT_MIN;\n    }\n}\n\n// Driver program to test the stack implementation\nint main() {\n  \n    // Creating a stack\n    Stack stack;\n    initializeStack(&stack);\n\n    // Push elements onto the stack\n    push(&stack, 11);\n    push(&stack, 22);\n    push(&stack, 33);\n    push(&stack, 44);\n\n    // Print top element of the stack\n    printf(\"Top element is %d\\n\", peek(&stack));\n\n  \n      // removing two elemements from the top\n      printf(\"Removing two elements...\\n\");\n    pop(&stack);\n    pop(&stack);\n\n    // Print top element of the stack\n    printf(\"Top element is %d\\n\", peek(&stack));\n\n    return 0;\n}\n\n````\n\nJava\n````\n// Java program to implement a stack using singly linked\n// list\n\n// Class representing a node in the linked list\nclass Node {\n    int data;\n    Node next;\n    Node(int new_data) {\n        this.data = new_data;\n        this.next = null;\n    }\n}\n\n// Class to implement stack using a singly linked list\nclass Stack {\n\n    // Head of the linked list\n    Node head;\n\n    // Constructor to initialize the stack\n    Stack() { this.head = null; }\n\n    // Function to check if the stack is empty\n    boolean isEmpty() {\n      \n        // If head is null, the stack is empty\n        return head == null;\n    }\n\n    // Function to push an element onto the stack\n    void push(int new_data) {\n      \n        // Create a new node with given data\n        Node new_node = new Node(new_data);\n\n        // Check if memory allocation for the new node\n        // failed\n        if (new_node == null) {\n            System.out.println(\"\\nStack Overflow\");\n            return;\n        }\n\n        // Link the new node to the current top node\n        new_node.next = head;\n\n        // Update the top to the new node\n        head = new_node;\n    }\n\n    // Function to remove the top element from the stack\n    void pop() {\n      \n        // Check for stack underflow\n        if (isEmpty()) {\n            System.out.println(\"\\nStack Underflow\");\n            return;\n        }\n        else {\n          \n            // Assign the current top to a temporary\n            // variable\n            Node temp = head;\n\n            // Update the top to the next node\n            head = head.next;\n\n            // Deallocate the memory of the old top node\n            temp = null;\n        }\n    }\n\n    // Function to return the top element of the stack\n    int peek() {\n      \n        // If stack is not empty, return the top element\n        if (!isEmpty())\n            return head.data;\n        else {\n            System.out.println(\"\\nStack is empty\");\n            return Integer.MIN_VALUE;\n        }\n    }\n}\n\n// Driver code\npublic class Main {\n    public static void main(String[] args)\n    {\n        // Creating a stack\n        Stack st = new Stack();\n\n        // Push elements onto the stack\n        st.push(11);\n        st.push(22);\n        st.push(33);\n        st.push(44);\n\n        // Print top element of the stack\n        System.out.println(\"Top element is \" + st.peek());\n\n        // removing two elemements from the top\n          System.out.println(\"Removing two elements...\");\n        st.pop();\n        st.pop();\n\n        // Print top element of the stack\n        System.out.println(\"Top element is \" + st.peek());\n    }\n}\n\n````\n\nPython\n````\n# Java program to implement a stack using singly linked\n# list\n\n# Class representing a node in the linked list\nclass Node:\n    def __init__(self, new_data):\n        self.data = new_data\n        self.next = None\n\n# Class to implement stack using a singly linked list\nclass Stack:\n    def __init__(self):\n\n        # head of the linked list\n        self.head = None\n\n    # Function to check if the stack is empty\n    def is_empty(self):\n\n        # If head is None, the stack is empty\n        return self.head is None\n\n    # Function to push an element onto the stack\n    def push(self, new_data):\n\n        # Create a new node with given data\n        new_node = Node(new_data)\n\n        # Check if memory allocation for the new node failed\n        if not new_node:\n            print(\"\\nStack Overflow\")\n            return\n\n        # Link the new node to the current top node\n        new_node.next = self.head\n\n        # Update the top to the new node\n        self.head = new_node\n\n    # Function to remove the top element from the stack\n    def pop(self):\n\n        # Check for stack underflow\n        if self.is_empty():\n            print(\"\\nStack Underflow\")\n        else:\n\n            # Assign the current top to a temporary variable\n            temp = self.head\n\n            # Update the top to the next node\n            self.head = self.head.next\n\n            # Deallocate the memory of the old top node\n            del temp\n\n    # Function to return the top element of the stack\n    def peek(self):\n\n        # If stack is not empty, return the top element\n        if not self.is_empty():\n            return self.head.data\n        else:\n            print(\"\\nStack is empty\")\n            return float('-inf')\n\n\n# Creating a stack\nst = Stack()\n\n# Push elements onto the stack\nst.push(11)\nst.push(22)\nst.push(33)\nst.push(44)\n\n# Print top element of the stack\nprint(\"Top element is\", st.peek())\n\n# removing two elemements from the top\nprint(\"Removing two elements...\");\nst.pop()\nst.pop()\n\n# Print top element of the stack\nprint(\"Top element is\", st.peek())\n\n````\n\nC#\n````\n// C# program to implement a stack using singly linked list\nusing System;\n\n// Class representing a node in the linked list\nclass Node {\n    public int data;\n    public Node next;\n    public Node(int new_data)\n    {\n        this.data = new_data;\n        this.next = null;\n    }\n}\n\n// Class to implement stack using a singly linked list\nclass Stack {\n\n    // head of the linked list\n    private Node head;\n\n    // Constructor to initialize the stack\n    public Stack() { this.head = null; }\n\n    // Function to check if the stack is empty\n    public bool isEmpty()\n    {\n\n        // If head is null, the stack is empty\n        return head == null;\n    }\n\n    // Function to push an element onto the stack\n    public void push(int new_data)\n    {\n\n        // Create a new node with given data\n        Node new_node = new Node(new_data);\n\n        // Check if memory allocation for the new node\n        // failed\n        if (new_node == null) {\n            Console.WriteLine(\"\\nStack Overflow\");\n            return;\n        }\n\n        // Link the new node to the current top node\n        new_node.next = head;\n\n        // Update the top to the new node\n        head = new_node;\n    }\n\n    // Function to remove the top element from the stack\n    public void pop()\n    {\n\n        // Check for stack underflow\n        if (this.isEmpty()) {\n            Console.WriteLine(\"\\nStack Underflow\");\n        }\n        else {\n\n            // Update the top to the next node\n            head = head.next;\n            /* No need to manually free the memory of the\n             * old head in C# */\n        }\n    }\n\n    // Function to return the top element of the stack\n    public int peek()\n    {\n\n        // If stack is not empty, return the top element\n        if (!isEmpty())\n            return head.data;\n        else {\n            Console.WriteLine(\"\\nStack is empty\");\n            return int.MinValue;\n        }\n    }\n}\n\n// Driver program to test the stack implementation\nclass GfG {\n    static void Main(string[] args)\n    {\n\n        // Creating a stack\n        Stack st = new Stack();\n\n        // Push elements onto the stack\n        st.push(11);\n        st.push(22);\n        st.push(33);\n        st.push(44);\n\n        // Print top element of the stack\n        Console.WriteLine(\"Top element is \" + st.peek());\n\n        // removing two elemements from the top\n          Console.WriteLine(\"Removing two elements...\");\n        st.pop();\n        st.pop();\n\n        // Print top element of the stack\n        Console.WriteLine(\"Top element is \" + st.peek());\n    }\n}\n\n````\n\nJavaScript\n````\n// Javascript program to implement a stack using singly\n// linked list\n\n// Class representing a node in the linked list\nclass Node {\n    constructor(new_data) {\n        this.data = new_data;\n        this.next = null;\n    }\n}\n\n// Class to implement stack using a singly linked list\nclass Stack {\n\n    // Constructor to initialize the stack\n    constructor() { this.head = null; }\n\n    // Function to check if the stack is empty\n    isEmpty() {\n    \n        // If head is null, the stack is empty\n        return this.head === null;\n    }\n\n    // Function to push an element onto the stack\n    push(new_data) {\n    \n        // Create a new node with given data\n        const new_node = new Node(new_data);\n\n        // Check if memory allocation for the new node\n        // failed\n        if (!new_node) {\n            console.log(\"\\nStack Overflow\");\n            return;\n        }\n\n        // Link the new node to the current top node\n        new_node.next = this.head;\n\n        // Update the top to the new node\n        this.head = new_node;\n    }\n\n    // Function to remove the top element from the stack\n    pop() {\n    \n        // Check for stack underflow\n        if (this.isEmpty()) {\n            console.log(\"\\nStack Underflow\");\n        }\n        else {\n        \n            // Assign the current top to a temporary\n            // variable\n            let temp = this.head;\n\n            // Update the top to the next node\n            this.head = this.head.next;\n\n            // Deallocate the memory of the old top node\n            temp = null;\n        }\n    }\n\n    // Function to return the top element of the stack\n    peek() {\n    \n        // If stack is not empty, return the top element\n        if (!this.isEmpty())\n            return this.head.data;\n        else {\n            console.log(\"\\nStack is empty\");\n            return Number.MIN_VALUE;\n        }\n    }\n}\n\n// Driver program to test the stack implementation\nconst st = new Stack();\n\n// Push elements onto the stack\nst.push(11);\nst.push(22);\nst.push(33);\nst.push(44);\n\n// Print top element of the stack\nconsole.log(\"Top element is \" + st.peek());\n\n// removing two elemements from the top\nconsole.log(\"Removing two elements...\");\nst.pop();\nst.pop();\n\n// Print top element of the stack\nconsole.log(\"Top element is \" + st.peek());\n\n````\n\n  \n**Output**\n```\n\nTop element is 44\nTop element is 22\n\n```\n\n****Time Complexity:****\nO(1), for all push(), pop(), and peek(), as we are not performing any\nkind of traversal over the list. We perform all the operations through\nthe current pointer only.  \n****Auxiliary Space:**** O(N), where N is the size of the stack\n\n\nIn this implementation, we define a Node class that represents a node\nin the linked list, and a Stack class that uses this node class to\nimplement the stack. The head attribute of the Stack class points to the\ntop of the stack (i.e., the first node in the linked list).\n\nTo push an item onto the stack, we create a new node with the given\nitem and set its next pointer to the current head of the stack. We then\nset the head of the stack to the new node, effectively making it the new\ntop of the stack.\n\nTo pop an item from the stack, we simply remove the first node from the\nlinked list by setting the head of the stack to the next node in the\nlist (i.e., the node pointed to by the next pointer of the current\nhead). We return the data stored in the original head node, which is the\nitem that was removed from the top of the stack.\n\n### Benefits of implementing a stack using a singly linked list include:\n\n****Dynamic memory allocation****: The size of the stack can be increased or decreased dynamically by\nadding or removing nodes from the linked list, without the need to\nallocate a fixed amount of memory for the stack upfront.\n\n****Efficient memory usage:**** Since nodes in a singly linked list only have a next pointer and not a\nprev pointer, they use less memory than nodes in a doubly linked\nlist.\n\n****Easy implementation****: Implementing a stack using a singly linked list is straightforward\nand can be done using just a few lines of code.\n\n****Versatile****: Singly linked lists can be used to implement other data structures\nsuch as queues, linked lists, and trees.\n\nIn summary, implementing a stack using a singly linked list is a simple\nand efficient way to create a dynamic stack data structure in\nPython.\n\n### Real time examples of stack:\n\nStacks are used in various real-world scenarios where a last-in,\nfirst-out (LIFO) data structure is required. Here are some examples of\nreal-time applications of stacks:\n\n****Function call stack****: When a function is called in a program, the return address and all\nthe function parameters are pushed onto the function call stack. The\nstack allows the function to execute and return to the caller function\nin the reverse order in which they were called.\n\n****Undo/Redo operations:****\nIn many applications, such as text editors, image editors, or web\nbrowsers, the undo and redo functionalities are implemented using a\nstack. Every time an action is performed, it is pushed onto the stack.\nWhen the user wants to undo the last action, the top element of the\nstack is popped and the action is reversed.\n\n****Browser history:**** Web browsers use stacks to keep track of the pages visited by the user.\nEvery time a new page is visited, its URL is pushed onto the stack. When\nthe user clicks the \u201cBack\u201d button, the last visited URL is popped from\nthe stack and the user is directed to the previous page.\n\n****Expression evaluation****: Stacks are used in compilers and interpreters to evaluate\nexpressions. When an expression is parsed, it is converted into postfix\nnotation and pushed onto a stack. The postfix expression is then\nevaluated using the stack.\n\n****Call stack in recursion:****\nWhen a recursive function is called, its call is pushed onto the stack.\nThe function executes and calls itself, and each subsequent call is\npushed onto the stack. When the recursion ends, the stack is popped, and\nthe program returns to the previous function call.\n\nIn summary, stacks are widely used in many applications where LIFO\nfunctionality is required, such as function calls, undo/redo operations,\nbrowser history, expression evaluation, and recursive function\ncalls.\n",
        "metadata": {
            "lesson_id": "cf945f38-3396-48d8-815b-81e37df21182",
            "course_id": "95713603-63d1-4b75-8a89-1acdc0977459",
            "course_name": "Stack",
            "lesson_description": "To implement a stack using the singly linked list concept, all the singly linked list operations should be performed based on Stack operations LIFO(last in first out) and with the help of that knowledge, we are going to implement a stack using a singly linked list.",
            "course_description": "The Stack lesson series offers a comprehensive introduction to one of the fundamental data structures in programming. You'll explore how a Stack operates based on the LIFO (Last In, First Out) principle, perform core operations such as push, pop, and peek, and apply these concepts to real-world problems like validating parentheses, converting expressions, or building a browser's backtracking system. This series is ideal for beginners and those looking to strengthen their understanding of data structures."
        }
    },
    {
        "page_content": "Applications of Stacks:\n-----------------------\n\n* ****Function calls:****\n  Stacks are used to keep track of the return addresses of function\n  calls, allowing the program to return to the correct location after a\n  function has finished executing.\n* ****Recursion:**** Stacks are used to store the local variables and return addresses of\n  recursive function calls, allowing the program to keep track of the\n  current state of the recursion.\n* ****Expression evaluation:**** Stacks are used to evaluate expressions in postfix notation (Reverse\n  Polish Notation).\n* ****Syntax parsing:**** Stacks are used to check the validity of syntax in programming\n  languages and other formal languages.\n* ****Memory management:**** Stacks are used to allocate and manage memory in some operating\n  systems and programming languages.\n* Used to solve popular problems like [Next Greater](https://www.geeksforgeeks.org/next-greater-element/), [Previous Greater](https://www.geeksforgeeks.org/previous-greater-element/), [Next Smaller](https://www.geeksforgeeks.org/next-smaller-element/), [Previous Smaller](https://www.geeksforgeeks.org/find-the-nearest-smaller-numbers-on-left-side-in-an-array/), [Largest Area in a Histogram](https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-using-stack/) and [Stock Span Problems](https://www.geeksforgeeks.org/the-stock-span-problem/).\n\nAdvantages of Stacks:\n---------------------\n\n* ****Simplicity:**** Stacks are a simple and easy-to-understand data structure, making\n  them suitable for a wide range of applications.\n* ****Efficiency:**** Push and pop operations on a stack can be performed in constant time ****(O(1))****, providing efficient access to data.\n* ****Last-in, First-out (LIFO):****\n  Stacks follow the LIFO principle, ensuring that the last element added\n  to the stack is the first one removed. This behavior is useful in many\n  scenarios, such as function calls and expression evaluation.\n* ****Limited memory usage:**** Stacks only need to store the elements that have been pushed onto\n  them, making them memory-efficient compared to other data\n  structures.\n\nDisadvantages of Stacks:\n------------------------\n\n* ****Limited access:****\n  Elements in a stack can only be accessed from the top, making it\n  difficult to retrieve or modify elements in the middle of the\n  stack.\n* ****Potential for overflow:**** If more elements are pushed onto a stack than it can hold, an\n  overflow error will occur, resulting in a loss of data.\n* ****Not suitable for random access:**** Stacks do not allow for random access to elements, making them\n  unsuitable for applications where elements need to be accessed in a\n  specific order.\n* ****Limited capacity:****\n  Stacks have a fixed capacity, which can be a limitation if the number\n  of elements that need to be stored is unknown or highly\n  variable.\n",
        "metadata": {
            "lesson_id": "a3e9b26a-8405-4132-a638-8fa5b1a3731e",
            "course_id": "95713603-63d1-4b75-8a89-1acdc0977459",
            "course_name": "Stack",
            "lesson_description": "A stack is a linear data structure\nin which the insertion of a new element and removal of an existing\nelement takes place at the same end represented as the top of the stack.",
            "course_description": "The Stack lesson series offers a comprehensive introduction to one of the fundamental data structures in programming. You'll explore how a Stack operates based on the LIFO (Last In, First Out) principle, perform core operations such as push, pop, and peek, and apply these concepts to real-world problems like validating parentheses, converting expressions, or building a browser's backtracking system. This series is ideal for beginners and those looking to strengthen their understanding of data structures."
        }
    }
]